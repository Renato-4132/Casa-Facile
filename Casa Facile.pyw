#!/usr/bin/env python3

import os
import re
import sys
import csv
import json
import html
import math
import time
import uuid
import email
import base64
import random
import socket
import ctypes
import shutil
import secrets
import hashlib
import imaplib
import logging
import zipfile
import platform
import calendar
import datetime
import tempfile
import threading
import subprocess
import webbrowser
import importlib.util

import urllib.parse
import urllib.request
from urllib.parse import urlparse, parse_qs
from decimal import Decimal, InvalidOperation
from http.server import BaseHTTPRequestHandler, HTTPServer
from collections import defaultdict
import tkinter as tk
from tkinter import ttk, messagebox, filedialog, Toplevel, Label, Button, TclError
import html as html_escape

EMAIL_USER = ""
APP_PASSWORD = "" 
PAROLE_CHIAVE = ["no-reply-ML@aceaenergia.it, no-reply.acque@acque.net, contotelefonico@fatturazione.windtre.it"]
SYNC_INT_MIN = 720
API_KEY =  ""

PATH_LOCALE = os.path.dirname(os.path.abspath(__file__))

def leggi_configurazione_globale():
    p_locale = os.path.dirname(os.path.abspath(__file__))
    c_file = os.path.join(p_locale, "db", "config.json")
    try:
        if os.path.exists(c_file):
            with open(c_file, 'r', encoding='utf-8') as f:
                return json.load(f)
    except:
        pass
    return {}
    
app_config_globale = leggi_configurazione_globale()

DB_CONDIVISO = app_config_globale.get("shared_db", False)
PATH_RETE = app_config_globale.get("shared_db_path", PATH_LOCALE)

# Decidi BASE_DIR
if DB_CONDIVISO and os.path.exists(PATH_RETE):
    BASE_DIR = PATH_RETE
    print("üì° Modalit√† Rete Attiva")
else:
    BASE_DIR = PATH_LOCALE
    print("üè† Modalit√† Locale Attiva")
    
URL_PDF = "https://raw.githubusercontent.com/Renato-4132/Casa-Facile/refs/heads/main/Casa%20Facile.pdf"
URL_PDF_CONSUMI = "https://raw.githubusercontent.com/Renato-4132/Casa-Facile/main/Tabella%20Contatori.pdf"
GITHUB_FILE_URL = "https://raw.githubusercontent.com/Renato-4132/Casa-Facile/refs/heads/main/Casa%20Facile.pyw"
GITHUB_SUPERMARKET = "https://raw.githubusercontent.com/Renato-4132/Casa-Facile/main/supermarket.pyw"
NOME_EDITOR_LOCALE = "supermarket.pyw"
ICON_URL = "https://github.com/Renato-4132/Casa-Facile/blob/main/casa-facile.png?raw=true"
NOME_FILE = "Casa Facile.pyw" 
REPO_OWNER = "Renato-4132"
REPO_NAME = "Casa-Facile"
NAME = "Casa Facile"
EXPORTDB_DIR = "export"
EXPORT_DIR = os.path.join(BASE_DIR, "export")
DB_DIR = os.path.join(BASE_DIR, "db")
DB_FILE = os.path.join(DB_DIR, "spese_db.json")
DATI_FILE = os.path.join(DB_DIR,"rubrica.json")
UTENZE_DB = os.path.join(DB_DIR, "utenze_db.json")
DOC_DIR = os.path.join(DB_DIR, "documenti")
REGISTRY_FILE = os.path.join(DB_DIR, "documenti_archiviati.json")
SALDO_FILE = os.path.join(DB_DIR, "saldo_db.json")
SUPERMERCATI_DB = os.path.join(DB_DIR, "supermercati.json")
EXPORT_FILES = os.path.join(BASE_DIR, "export")
EXP_DB = os.path.join(DB_DIR, EXPORTDB_DIR)
PW_FILE = os.path.join(DB_DIR, "password.json")
MEM_CAT = os.path.join(DB_DIR, "memoria_categorie.json")
CONFIG_FILE = os.path.join(DB_DIR, "config.json")
RIMANDA_FILE = os.path.join(DB_DIR, "update.json")
PROMEMORIA_FILE = os.path.join(DB_DIR, "promemoria.json")
ICON_NAME = "casa-facile.png"
DEFAULT_API = os.path.join(DB_DIR, "api.json")
CONTROLLO_F_M = os.path.join(DB_DIR, "controllo_fm.json")
APRI_BROWSER = False
URL_QST = "https://forms.gle/VidTCh7ySkWHCAE6A"
CONTROLLO_CHANGELOG = os.path.join(DB_DIR, "changelog_hash.json")
LINK_BANCA = ""
LOGIN_WEB = os.path.join(DB_DIR, "login_web.json")
LOGIN_LCL = os.path.join(DB_DIR, "login_lcl.json")

# Imposta timeout Messaggi Popup (millisecondi)
WARN_TIMEOUT = 20000

# Imposta a True se vuoi chiusura con conferma self.show_custom_warning
# Imposta a False per forzare timeout chiusura  self.show_custom_warning
USE_WAIT_WINDOW = False

# Imposta working directory (Dove risiede lo script)
os.chdir(os.path.dirname(os.path.abspath(sys.argv[0])))

# Nome della cartella corrente in cui si trova lo script in esecuzione
current_folder = os.path.basename(os.getcwd())

#Tolleranza Movimenti simili (SmartCat)
toll = 30 #Euro

#Versione
VERSION = "9.6"

# Attiva/disattiva Timer Minimizza
ICONIZZA_INATTIVITA = True

# 20 minuti in millisecondi Timer Minimizza
TIMEOUT_INATTIVITA_MS = 1200000

# Numero di anni che l'applicazione conserver√† nel db
ANNI_DA_MANTENERE = 10

# Salva la posizione della gui
SALVA_GEOMETRIA_INIZIALE = False

# Set data quando iconizza o deiconizza
ICO_SET_DATE = True

#Riconoscimento automatico categorie
SMARTCAT = True

# Set check categorie mancanti a termine mese
CHECK_MESE = True
#Avviso gg prima del termine mese
SOGLIA_GIORNI_RICORRENTI = 5

# Copie backup da conservare
MAX_BACKUP=5

# Rotazione automatica e ciclica dei contenuti visuali (come i grafici)
CAROSELLO = True

# Abilita Tooltips su Calendario
CAL_TOOLTIPS = False

# Abilita sync dati esterni
SYNC_DATI = False

# Default thema avvio
THEMA = "OBSIDIAN"

DEFAULT_CONFIG = {
    "enable_auto_login_flow": False,
    "webserver_enabled": True,
    "iconizza_inattivita": True,
    "inactivity_timeout_ms": 1200000,
    "webserver_port": 8080,
    "load_saved_geometry": False,
    "anni_da_mantenere": 10,
    "ico_set_date": True,
    "enable_recurring_reminder": True,
    "soglia_giorni_ricorrenti": 5,
    "max_backup": 5,
    "smartcat_enabled": True,
    "use_wait_window": False,
    "warn_timeout_ms": 20000,
    "bank_link": "",
    "thema": "OBSIDIAN",
    "carosello_enabled": True,
    "carosello_intervallo": 10000,
    "cal_tooltips_enabled": False,
    "shared_db": False,
    "shared_db_path": PATH_LOCALE,
    "udp_port_1": 5555,
    "udp_port_2": 5556,
    "target_mese": 0,
    "target_anno": 0,
    "sync_dati_enabled": False,
    "email_user": "",
    "app_password": "",
    "parole_chiave": ["no-reply-ML@aceaenergia.it, no-reply.acque@acque.net, contotelefonico@fatturazione.windtre.it"],
    "gemini_api_key": "",
    "sync_intervallo_min": 720,
}

CATEGORIE_PREDEFINITE = [
    "Affettati",
    "Acqua",
    "Animali Domestici",
    "Articoli Bimbi",
    "Assorbenza",
    "Auto e Elettronica",
    "Birre",
    "Biscotti",
    "Bucato",
    "Caff√® e Bevande",
    "Cancelleria/Party",
    "Carne",
    "Carta Casa/Igiene",
    "Carta e Alluminio",
    "Casalinghi/Tessile",
    "Cereali Colazione",
    "Cibi Etnici",
    "Cioccolato",
    "Conserve Pesce",
    "Cosmetici",
    "Cura dei Capelli",
    "Cura del Corpo",
    "Dolciumi e Caramelle",
    "Farine e Lieviti",
    "Formaggi Freschi",
    "Formaggi Stagionati",
    "Frutta Fresca",
    "Gastronomia",
    "Gelati",
    "Giardino e Fai da",
    "Igiene Persona",
    "Insalate Pronte",
    "Integratori/Sanitari",
    "Latte e Burro",
    "Latticini e Yogurt",
    "Legumi Secchi/Scatole",
    "Liquori e Distillati",
    "Marmellate/Creme",
    "Merende e Snack",
    "Molluschi/Crostacei",
    "Olio",
    "Ortaggi e Tuberi",
    "Pane e Panini",
    "Pasta Fresca",
    "Pasta Secca",
    "Pesce",
    "Piatti Pronti",
    "Pizze Surgelate",
    "Pollame",
    "Prodotti Bio",
    "Prodotti Dietetici",
    "Prodotti Veg/Vegan",
    "Pulizia Casa",
    "Riso",
    "Salumi",
    "Salse e Condimenti",
    "Snack Panetteria",
    "Snack Salati",
    "Sottoli/Sottaceti",
    "Spugne e Guanti",
    "Succhi/Bibite",
    "Surgelati Pesce",
    "Surgelati Vari",
    "Surgelati Verdura",
    "Sushi e Tartare",
    "Uova",
    "Varie",
    "Verdura Fresca",
    "Vini e Spumanti",
]

class CasaFacileWebHandler(BaseHTTPRequestHandler):

    def log_message(self, format, *args):
        #Silenzia i log del server in console
        pass
        
    def invia_html(self, html, code=200):
        try:
            self.send_response(code)
            self.send_header("Content-type", "text/html; charset=utf-8")
            self.send_header("Connection", "close")
            self.send_header("Cache-Control", "no-cache, no-store, must-revalidate")
            self.end_headers()
            self.wfile.write(html.encode("utf-8"))
        except (ConnectionResetError, BrokenPipeError):
            pass

    def do_GET(self):
        try:
            parsed = urlparse(self.path)
            path = parsed.path
            ora_attuale = time.time()
            expected_token = self.server.app.web_token
            last_activity = self.server.app.ultimo_accesso_web
            timeout = self.server.app.timeout_sessione
            token_valido = f"session_id={expected_token}" in self.headers.get("Cookie", "")
            non_scaduto = (ora_attuale - last_activity) < timeout
            is_logged = token_valido and non_scaduto
            if is_logged:
                self.server.app.ultimo_accesso_web = ora_attuale
            if path == "/login":
                return self.invia_html(self.server.app.html_login(self.path))
            if path == "/logoff":
                self.send_response(303)
                self.send_header("Set-Cookie", "session_id=; Path=/; Max-Age=0") 
                self.send_header("Location", "/login")
                self.send_header("Connection", "close")
                return self.end_headers()
            if not is_logged:
                self.send_response(303)
                self.send_header("Location", "/login")
                self.send_header("Connection", "close")
                return self.end_headers()
            if path.startswith("/get_pdf"):
                q = parse_qs(parsed.query)
                nome_file = q.get("file", [None])[0]
                if nome_file:
                    file_path = os.path.join("db", "documenti", nome_file)
                    if os.path.exists(file_path):
                        self.send_response(200)
                        self.send_header("Content-type", "application/pdf")
                        self.send_header("Content-Disposition", f'inline; filename="{nome_file}"')
                        self.end_headers()
                        with open(file_path, 'rb') as f:
                            self.wfile.write(f.read())
                        return
                return self.send_error(404, "File non trovato")
            if path == "/info_sys_web":
                content = self.server.app.html_info_sys() 
                self.send_response(200)
                self.send_header("Content-type", "text/html; charset=utf-8")
                resp = content.encode('utf-8')
                self.send_header("Content-Length", len(resp))
                self.end_headers()
                self.wfile.write(resp)
                return
            if path == "/": html = self.server.app.html_form()
            elif path == "/gestione_categorie": html = self.server.app.html_gestione_categorie()
            elif path.startswith("/stats"): html = self.server.app.stats_mensili_html()
            elif path.startswith("/lista"): html = self.server.app.html_lista_spese_mensili()
            elif path.startswith("/utenze"):
                q = parse_qs(parsed.query)
                anno = q.get("anno", [str(datetime.datetime.now().year)])[0]
                html = self.server.app.genera_html_utenze(UTENZE_DB, anno)
            elif path.startswith("/cerca_avanzata"): html = self.server.app.pagina_risultati_avanzati(parse_qs(parsed.query))
            elif path.startswith("/modifica"): html = self.server.app.modifica_voce_form(parse_qs(parsed.query))
            elif path.startswith("/grafici_web"): html = self.server.app.pagina_grafici_web()
            elif path.startswith("/report_annuo"): html = self.server.app.pagina_statistiche_annuali_web()
            elif path.startswith("/consultazione_supermercati"): html = self.server.app.genera_html_consultazione()
            elif path.startswith("/documenti_pdf_web"): html = self.server.app.documenti_pdf_web()
            elif path.startswith("/menu_esplora"): html = self.server.app.pagina_menu_esplora()
            else: return self.send_error(404)
            self.invia_html(html)
        except (ConnectionResetError, BrokenPipeError): pass
        except Exception as e: print(f"‚ùå Errore GET: {e}")
        
    def do_POST(self):
        try:
            ora_attuale = time.time()
            expected_token = self.server.app.web_token
            last_activity = self.server.app.ultimo_accesso_web
            timeout = self.server.app.timeout_sessione
            token_valido = f"session_id={expected_token}" in self.headers.get("Cookie", "")
            non_scaduto = (ora_attuale - last_activity) < timeout
            is_logged = token_valido and non_scaduto
            cl = int(self.headers.get("Content-Length", 0))
            p = parse_qs(self.rfile.read(cl).decode()) if cl > 0 else {}
            if self.path.startswith("/check_login"):
                pwd = p.get("password", [""])[0].strip()
                ok = self.server.app.salva_hash(pwd) or True if not self.server.app.leggi_hash() else self.server.app.verifica_password(pwd)
                if ok:
                    self.server.app.registra_accesso()
                    self.server.app.ultimo_accesso_web = time.time()
                self.send_response(303)
                if ok:
                    self.send_header("Set-Cookie", f"session_id={expected_token}; Path=/; HttpOnly; SameSite=Strict; Max-Age={timeout}")
                    self.send_header("Location", "/")
                else:
                    self.send_header("Set-Cookie", "session_id=; Path=/; Max-Age=0")
                    self.send_header("Location", "/login?error=1")
                self.send_header("Connection", "close")
                self.end_headers()
                return

            if not is_logged:
                self.send_response(303)
                self.send_header("Location", "/login")
                self.send_header("Connection", "close")
                self.end_headers()
                return
            self.server.app.ultimo_accesso_web = ora_attuale

            loc = "/"            
            if self.path == "/":
                d = p.get("data", [""])[0]
                if d:
                    v = {"date": d, "categoria": p.get("categoria", ["Generica"])[0], 
                         "descrizione": p.get("descrizione", [""])[0], 
                         "importo": float(p.get("importo", ["0"])[0].replace(",", ".")), 
                         "tipo": p.get("tipo", ["Uscita"])[0]}
                    self.server.app.aggiungi_voce_web(v)
                    self.server.app.save_db() 
                    loc = "/?salvato=1"
            elif self.path == "/salva_categoria":
                op = p.get("operazione", [""])[0]
                if op == "aggiungi": self.server.app.add_categoria_web(p)
                else: self.server.app.modifica_categoria_web(p)
                self.server.app.save_db()
                loc = "/gestione_categorie?status=success"
            elif self.path == "/cancella_categoria":
                self.server.app.cancella_categoria_web(p)
                self.server.app.save_db()
                loc = "/gestione_categorie?status=deleted"
            elif self.path == "/salva_modifica":
                destinazione = self.server.app.salva_modifica_voce(p)
                self.server.app.save_db()
                self.send_response(303)
                self.send_header('Location', destinazione)
                self.end_headers()
                return
            elif self.path == "/cancella":
                g, i = p.get("data", [""])[0], int(p.get("idx", ["-1"])[0])
                if i != -1 and g: 
                    self.server.app.cancella_voce_web(g, i)
                    self.server.app.save_db()
            if hasattr(self.server.app, 'update_spese_mese_corrente'):
                self.server.app.after(0, self.server.app.update_spese_mese_corrente)
            self.send_response(303)
            self.send_header("Location", loc)
            self.send_header("Connection", "close")
            self.end_headers()
        except (ConnectionResetError, BrokenPipeError):
            print("‚ÑπÔ∏è Info: Connessione interrotta - Richiesta gestita.") 
        except Exception as e: 
            print(f"‚ùå Errore POST: {e}")
            self.send_response(303)
            self.send_header("Location", "/")
            self.end_headers()

class GestioneSpese(tk.Tk):

    CATEGORIA_RIMOSSA = "Categoria Rimossa"
    
    def __init__(self):
        super().__init__()

        self.SESSION_ID = str(random.randint(1000, 9999))

        # Web Token
        self.web_token = secrets.token_hex(16)
        self.ultimo_accesso_web = time.time()
        self.timeout_sessione = 3600 #(1 ora)
        print(f"üîë SESSION TOKEN GENERATO: {self.web_token}")
        
        self.salva_geometria = SALVA_GEOMETRIA_INIZIALE
        self.withdraw()
        self.update_idletasks()
        
        initial_width = 1280
        initial_height = 620
        screen_width = self.winfo_screenwidth()
        screen_height = self.winfo_screenheight()

        self._window_geometry = None
        self.load_window_geometry()

        if self._window_geometry:
            self.geometry(self._window_geometry)
        else:
            x = (screen_width // 2) - (initial_width // 2)
            y = (screen_height // 2) - (initial_height // 2)
            self.geometry(f"{initial_width}x{initial_height}+{x}+{y}")
        
        if not self.gestione_login():
            sys.exit()
            return

        self.resizable(True, True)
        self.minsize(1280, 620)
        self.lift()
        self.focus_force()
        self.after(250, self.deiconify)

        # Carica Icona
        self.set_app_icon()
        
        # Variabili Backup Completo
        self.current_folder = current_folder
        self.backup_formato = 'zip'

        # Variabile Tabella Iniziale
        self.stats_view_mode = tk.StringVar(value="tabella")
        
        # Timer Carosello
        self.chiamato_da_carosello = True
        self.intervallo_scorrimento = 10000  # 10 secondi 
        self.id_scorrimento_automatico = None
        self.intervallo_scorrimento = CAROSELLO_INTERVALLO
        
        # Timer Countdown Minimizza
        self._countdown_delay = 5000 
        self._countdown_splash = None
        self._countdown_timer_id = None

        # Intervallo Lampeggio Cursore
        self.blinking_interval = 500
        
        # Variabili Lampeggio Widget Riepilogo Mese/Anno
        self.blinking_widgets = set()
        self._blink_phase = True
        
        if not os.path.exists(DB_DIR):
            os.makedirs(DB_DIR)
        if not os.path.exists(EXP_DB):
            os.makedirs(EXP_DB)
            
        # Backup Incrementale threading    
        #threading.Thread(target=self._esegui_backup_json, daemon=True).start()
        self.pianifica_backup_orario()
        
        self.aggiorna_titolo_finestra()
        
        self.categoria_bloccata = False
        
        # Sync dati esterni
        if SYNC_DATI:
            self.after(30000, self.pianifica_sincro_web)
            
        # Inizializzazione variabili per il Monitor Sync
        self.operazioni_scaricate_sessione = 0 
        
        # Suggerimento categorie
        self.suggerimenti_attivi = SMARTCAT

        # Timeout Iconizza
        if ICONIZZA_INATTIVITA:
            self._timeout_inattivita = TIMEOUT_INATTIVITA_MS
            self._timer_inattivita = None
            self._attiva_timer_inattivita()
        
        # Check Movimenti mancanti fine mese    
        if CHECK_MESE:
            self._last_dismiss_date = self._carica_dismiss_fm()
            self.after(8000, self.controlla_ricorrenti_a_fine_mese)  
        
        self.categorie = ["Generica", self.CATEGORIA_RIMOSSA]
        self.categorie_tipi = {"Generica": "Uscita", self.CATEGORIA_RIMOSSA: "Uscita"}
        self.spese = {}
        self.ricorrenze = {}  
        self.modifica_idx = None
        self.stats_refdate = datetime.date.today()
        self.load_db()
        self.carica_memoria_descrizioni()
        
        self.budget_mensile = TARGET_MESE
        self.budget_annuale = TARGET_ANNO
        
        self.save_lock = threading.Lock()
       
        # Themi
        if THEMA == "CHIARO":
            style = ttk.Style()
            style.theme_use('default')

            MENU_BG_DARK = "white"              # Sfondo Barra menu superiore
            MENU_FG_LIGHT = "black"             # Colore di primo piano chiaro (bianco)
            MENU_BG = "white"                   # Sfondo dei sottomenu
            MENU_ACT_BG_COLOR = "#00AADD"       # Colore di evidenziazione 
            MENU_ACT_FG_COLOR = "black"         # Nero
 
            COLOR_BACKGROUND = "#FFFFFF"        # Sfondo principale (Bianco Puro)
            COLOR_WIDGET_BG = "white"           # Sfondo widget leggero (Bianco)
            TEXT_COLOR = "black"                # Testo nero
            COLOR_HIGHLIGHT = "#007ACC"         # Blu Windows/VSCode per la selezione
            COLOR_TEXT = "#333333"              # Testo scuro/nero
            COLOR_HEADER = "black"              # Testo scuro per le intestazioni
            COLOR_RED = "red"                   # Rosso standard
            COLOR_GREEN = "green"               # Verde standard
            COLOR_RED_SMOOTH = "red"            # Rosso standard
            COLOR_GREEN_SMOOTH = "green"        # Verde standard
            COLOR_HEADER_BG = "#AAAAAA"         # Grigio medio per sfondo header Treeview
            COLOR_BUTTON_BG = "#DDDDDD"         # Grigio chiaro per bottoni standard
            COLOR_BLINK_OFF = "#333333"         # Il colore "spento" √® Bianco
            COLOR_UPDATE = "#FFFFAA"            # Giallo acceso per l'avviso (come richiesto in precedenza)
            COLOR_BLACK = "black"               # Nero 
            COLOR_YELLOW = "yellow"             # Giallo 
            COLOR_WHITE = "white"               # Bianco 
            COLOR_LIGHTGREEN = "lightgreen"     # LightGreen
            COLOR_LIGHTCORAL = "lightcoral"     # LightCoral
            COLOR_KHAKI = "khaki"               # Khaki
            COLOR_TOOLTIP = "#F9F9F9"           # grigio chiarissimo, quasi bianco.
            COLOR_TEXT_TOOLTIP = "black"        # nero Testo tooltip.

            self.MENU_BG_DARK = MENU_BG_DARK
            self.MENU_FG_LIGHT = MENU_FG_LIGHT
            self.MENU_BG = MENU_BG   
            self.MENU_ACT_BG_COLOR = MENU_ACT_BG_COLOR
            self.MENU_ACT_FG_COLOR = MENU_ACT_FG_COLOR
                        
            self.COLOR_TOPLEVEL = COLOR_WIDGET_BG
            self.TEXT_COLOR = TEXT_COLOR
            self.COLOR_BACKGROUND = COLOR_BACKGROUND
            self.COLOR_WIDGET_BG = COLOR_WIDGET_BG
            self.COLOR_HIGHLIGHT = COLOR_HIGHLIGHT
            self.COLOR_TEXT = COLOR_TEXT
            self.COLOR_HEADER = COLOR_HEADER
            self.COLOR_RED = COLOR_RED
            self.COLOR_GREEN = COLOR_GREEN
            self.COLOR_RED_SMOOTH = COLOR_RED_SMOOTH
            self.COLOR_GREEN_SMOOTH = COLOR_GREEN_SMOOTH
            self.COLOR_HEADER_BG = COLOR_HEADER_BG
            self.COLOR_BUTTON_BG = COLOR_BUTTON_BG
            self.COLOR_BLINK_OFF = COLOR_BLINK_OFF
            self.COLOR_UPDATE = COLOR_UPDATE
            self.COLOR_BLACK = COLOR_BLACK
            self.COLOR_YELLOW = COLOR_YELLOW
            self.COLOR_WHITE = COLOR_WHITE     
            self.COLOR_LIGHTGREEN = COLOR_LIGHTGREEN
            self.COLOR_LIGHTCORAL = COLOR_LIGHTCORAL
            self.COLOR_KHAKI = COLOR_KHAKI
            self.COLOR_TOOLTIP = COLOR_TOOLTIP
            self.COLOR_TEXT_TOOLTIP = COLOR_TEXT_TOOLTIP
            
            try:
                self.option_add('*selectBackground', COLOR_HIGHLIGHT)
                self.option_add('*selectForeground', COLOR_WHITE)
                self.option_add('*Focus.background', COLOR_WIDGET_BG)
                self.option_add('*Focus.relief', 'solid')
                self.option_add('*Focus.borderwidth', 1)
            except Exception:
                pass
                
            self.configure(bg=COLOR_BACKGROUND)                  

            style.configure("TFrame", background=COLOR_WIDGET_BG)
            style.configure("BlackFrame.TFrame", background=COLOR_WIDGET_BG)
            style.configure("TLabelframe", background=COLOR_WIDGET_BG) 
            style.configure("TLabelframe.Label", background=COLOR_WIDGET_BG, foreground=COLOR_HEADER)
            style.configure("RedBold.TLabelframe.Label", foreground=COLOR_RED_SMOOTH, background=COLOR_WIDGET_BG, font=("Arial", 10, "bold"))
            
            style.configure("Rosso.TSeparator", background="red", thickness=2)   
            
            style.configure("Treeview", 
                            background=COLOR_WHITE, 
                            foreground=COLOR_TEXT, 
                            rowheight=25,
                            fieldbackground=COLOR_WHITE, 
                            font=("Arial", 10),
                            borderwidth=0)
            style.configure("Treeview.Heading", 
                            background="#F2F2F2",
                            foreground=COLOR_HEADER, 
                            font=('Arial', 10, 'bold'), 
                            relief="flat",
                            borderwidth=1) 
            style.map('Treeview', 
                      foreground=[('selected', COLOR_WHITE)], 
                      background=[('selected', COLOR_HIGHLIGHT)],
                      fieldbackground=[('!disabled', COLOR_WIDGET_BG)]
            )
            style.map('Treeview.Heading', 
                foreground=[('active', COLOR_HIGHLIGHT), ('pressed', COLOR_HIGHLIGHT)], 
                background=[('active', "#EAEAEA"), ('pressed', "#DDDDDD")] 
            )
            style.configure("TNotebook", background=COLOR_WIDGET_BG, borderwidth=0)

            style.configure("TNotebook.Tab", 
                            background=COLOR_BACKGROUND,
                            foreground=COLOR_TEXT,
                            font=('Arial', 10, 'normal'),
                            padding=[10, 5])
            
            style.map("TNotebook.Tab",
                      background=[('selected', COLOR_HIGHLIGHT)], 
                      foreground=[('selected', COLOR_WHITE)],
                      expand=[('active', [1, 1, 1, 0])])

            style.configure("Custom.TRadiobutton", background=COLOR_WIDGET_BG, foreground=TEXT_COLOR, font=('Arial', 10))

            style.configure('Highlight.TCombobox', 
                fieldbackground=COLOR_WIDGET_BG,
                background=COLOR_BUTTON_BG, 
                foreground=COLOR_RED_SMOOTH,
                relief='solid', 
                arrowsize=8, 
                borderwidth=1)

            style.map('Highlight.TCombobox', 
                arrowcolor=[('!disabled', COLOR_RED_SMOOTH)],
                fieldbackground=[
                    ('readonly', COLOR_WIDGET_BG), 
                    ('focus', COLOR_WIDGET_BG), 
                    ('active', COLOR_WIDGET_BG),
                    ('!disabled', COLOR_WIDGET_BG)
                ],
                foreground=[
                    ('readonly', COLOR_RED_SMOOTH), 
                    ('focus', COLOR_RED_SMOOTH), 
                    ('active', COLOR_RED_SMOOTH),
                    ('!disabled', COLOR_RED_SMOOTH)
                ])
            
            style.configure('Border.TCombobox', 
                fieldbackground=COLOR_WHITE, 
                background=COLOR_YELLOW, 
                foreground=COLOR_BLACK, 
                relief='flat',
                arrowsize=8,
                borderwidth=1)
            style.map('Border.TCombobox', 
                arrowcolor=[('!disabled', COLOR_HIGHLIGHT)],
                fieldbackground=[('readonly', COLOR_WHITE), ('!focus', COLOR_WHITE), ('!disabled', COLOR_WHITE)])
                
            style.configure("TLabel", background=COLOR_WIDGET_BG, foreground=COLOR_TEXT) 
            style.configure("Timer.TLabel", foreground=COLOR_TEXT, background=COLOR_UPDATE, font=("Helvetica", 10, "bold"))
            style.configure("Legend.TLabel", background=COLOR_WIDGET_BG, foreground=COLOR_TEXT, font=("Arial", 10), anchor="w")
            style.configure("White.TLabel", foreground=COLOR_TEXT, background=COLOR_WIDGET_BG, font=("Arial", 11))
            style.configure("WhiteSmall.TLabel", foreground=COLOR_TEXT, background=COLOR_WIDGET_BG, font=("Arial", 10))
            style.configure("Verde.TLabel", foreground=COLOR_GREEN_SMOOTH, background=COLOR_WIDGET_BG, font=("Arial", 10, "bold"), padding=5)

            style.configure("Saldo.TLabel", foreground=COLOR_GREEN_SMOOTH, background=COLOR_WIDGET_BG, font=("Arial", 14, "bold"))
            style.map("Saldo.TLabel", background=[('active', COLOR_WIDGET_BG)], foreground=[('active', COLOR_GREEN_SMOOTH)], relief=[('active', 'flat')])
            style.configure("Doc.TLabel", foreground=COLOR_GREEN_SMOOTH, background=COLOR_WIDGET_BG, font=("Arial", 14, "bold"))
            style.map("Doc.TLabel", background=[('active', COLOR_WIDGET_BG)], foreground=[('active', COLOR_GREEN_SMOOTH)], relief=[('active', 'flat')])
            
            style.configure("GSaldo.TLabel", font=("Arial", 10, "bold"), background=COLOR_WIDGET_BG) 
            style.map("GSaldoPositivo.TLabel", foreground=[('active', COLOR_GREEN_SMOOTH), ('!disabled', COLOR_GREEN_SMOOTH)], parent="GSaldo.TLabel")
            style.map("GSaldoNegativo.TLabel", foreground=[('active', COLOR_RED_SMOOTH), ('!disabled', COLOR_RED_SMOOTH)], parent="GSaldo.TLabel")

            style.configure("BlinkAllarme.TLabel", foreground=COLOR_BLINK_OFF, background=COLOR_WIDGET_BG, font=("Arial", 10, "bold"))
            style.map("BlinkAllarme.TLabel", foreground=[('!disabled', COLOR_RED_SMOOTH)], background=[('!disabled', COLOR_WIDGET_BG), ('disabled', COLOR_WIDGET_BG)])

            SPESSORE_SCROLL = 7
            style.configure("Vertical.TScrollbar", 
                background="#f5f5f5", 
                troughcolor="white",
                arrowcolor=COLOR_HEADER,
                borderwidth=0, 
                relief="flat",
                arrowsize=SPESSORE_SCROLL,
                width=SPESSORE_SCROLL)
            style.configure("Horizontal.TScrollbar", 
                background="#f5f5f5", 
                troughcolor="white",
                arrowcolor=COLOR_HEADER, 
                borderwidth=0, 
                relief="flat",
                arrowsize=SPESSORE_SCROLL,
                width=SPESSORE_SCROLL)
            style.map("Vertical.TScrollbar", background=[('active', COLOR_HIGHLIGHT)])
            style.map("Horizontal.TScrollbar", background=[('active', COLOR_HIGHLIGHT)])

            style.configure("TScale", 
                background=COLOR_WIDGET_BG, 
                foreground=COLOR_HIGHLIGHT,
                troughcolor="#E0E0E0",
                sliderthickness=10,
                troughthickness=2,
                sliderlength=15,
                relief='flat')

            style.map("TScale", 
                background=[('active', COLOR_HIGHLIGHT)],
               troughcolor=[('disabled', COLOR_WIDGET_BG)])

            style.configure("TCheckbutton", background=COLOR_WIDGET_BG, foreground=COLOR_HEADER, font=("Arial", 10))
            style.map("TCheckbutton", background=[('active', COLOR_WIDGET_BG)], foreground=[('active', COLOR_HEADER),('selected', COLOR_HEADER)])

            style.configure("Tooltip.TLabel", background=COLOR_TOOLTIP, foreground=COLOR_BLACK, font=("Arial", 9), borderwidth=1, relief="solid", anchor='w', padding=2)
            
            style.configure("TButton", relief='flat', borderwidth=0, font=("Arial", 9, "bold"), padding=5, background=COLOR_BUTTON_BG, foreground=COLOR_TEXT) 
            style.map("TButton", background=[("active", "#CCCCCC")])

            style.configure("Yellow.TButton", background=COLOR_YELLOW, foreground=COLOR_BLACK, font=("Arial", 8, "bold"), width=2)
            style.map("Yellow.TButton", background=[("active", "#FFE680")])
            style.configure("Giallo.TButton", background=COLOR_YELLOW, foreground=COLOR_BLACK, font=("Arial", 8, "bold"))
            style.map("Giallo.TButton", background=[("active", "#FFE680")])

            style.configure("Verde.TButton", background=COLOR_GREEN_SMOOTH, foreground=COLOR_BLACK, font=("Arial", 8, "bold"))
            style.map("Verde.TButton", background=[('active', '#8AAB6F')], foreground=[('disabled', COLOR_YELLOW)])
            style.configure("Rosso.TButton", background=COLOR_RED_SMOOTH, foreground=COLOR_BLACK, font=("Arial", 8, "bold"))
            style.map("Rosso.TButton", background=[('active', '#C8606B')], foreground=[('disabled', COLOR_YELLOW)])
            style.configure("Arancio.TButton", background="#FFA500", foreground=COLOR_BLACK, font=("Arial", 8, "bold"))
            style.map("Arancio.TButton", background=[("active", "#FFC766")])
            style.configure("Blu.TButton", background=COLOR_HIGHLIGHT, foreground=COLOR_WHITE, font=("Arial", 8, "bold"))
            style.map("Blu.TButton", background=[("active", "#00AADD")])

            style.configure("Verde_Low.TButton", background=COLOR_GREEN_SMOOTH, foreground=COLOR_WHITE, font=("Arial", 8, "bold"), padding=(2, 0))
            style.map("Verde_Low.TButton", background=[('active', '#8AAB6F')], foreground=[('disabled', COLOR_YELLOW)])
            style.configure("Yellow_Low.TButton", background=COLOR_YELLOW, foreground=COLOR_BLACK, font=("Arial", 8, "bold"), width=2, padding=(2, 0))
            style.map("Yellow_Low.TButton", background=[("active", "#FFE680")])

            style.configure("Low.Blu.TButton", background=COLOR_HIGHLIGHT, foreground=COLOR_WHITE, font=("Arial", 6, "bold"), padding=(4, 1))
            style.map("Low.Blu.TButton", background=[("active", "#00AADD")])

            style.configure("Num.TButton", foreground=COLOR_TEXT, background=COLOR_WIDGET_BG, borderwidth=1, relief="raised", font=("Arial", 8, "bold"), padding=6) 
            style.map("Num.TButton", background=[("active", COLOR_HEADER_BG)]) 
            
            style.configure("GreenOutline.TButton", foreground=COLOR_GREEN_SMOOTH, background=COLOR_WIDGET_BG, borderwidth=1, relief="solid", padding=(5, 1), font=("Arial", 10, "bold")) 
            style.map("GreenOutline.TButton", 
                      background=[("active", "#E6FFE6"), ("pressed", "#CCFFCC")],
                      bordercolor=[("!disabled", COLOR_GREEN_SMOOTH)], 
                      foreground=[("!disabled", COLOR_GREEN_SMOOTH)])

            style.configure("RedOutline.TButton", foreground=COLOR_RED_SMOOTH, background=COLOR_WIDGET_BG, borderwidth=1, relief="solid", padding=(5, 1), font=("Arial", 10, "bold")) 
            style.map("RedOutline.TButton", 
                      background=[("active", "#FFEEEE"), ("pressed", "#FFCCCC")],
                      bordercolor=[("!disabled", COLOR_RED_SMOOTH)], 
                      foreground=[("!disabled", COLOR_RED_SMOOTH)])

            style.configure(
                "Backup.Horizontal.TProgressbar",
                troughcolor=self.COLOR_WIDGET_BG,
                background=self.COLOR_HIGHLIGHT,
                thickness=10
            )
                       
            stili_tabella = [
            ("mensile", "#E6FFE6", "#004C00"),
            ("regolare", "#F0FFF0", "#333333"),
            ("bimestrale", "#FFFFE0", "#CC9900"),
            ("trimestrale", "#FFF0E0", "#FF6600"),
            ("irregolare", "#FFEEEE", "#CC0000"),
            ]
        
            for alias, bg, fg in stili_tabella:
                style.configure(
                    f"Legenda.{alias}.TLabel", 
                    background=bg, 
                    foreground=fg, 
                    font=("Arial", 8, "bold"),
                    padding=3
                )
                
            self.cal_bg = COLOR_WIDGET_BG
            self.cal_fg = COLOR_TEXT
            self.cal_weekend_bg = COLOR_WIDGET_BG  
            self.cal_weekend_fg = COLOR_HIGHLIGHT
            self.cal_weekday_bg = COLOR_WIDGET_BG  
            self.cal_weekday_fg = COLOR_HEADER
            self.cal_select_bg = COLOR_HIGHLIGHT 
            self.cal_select_fg = COLOR_BLACK     
            self.cal_header_bg = COLOR_WIDGET_BG   
            self.cal_header_fg = COLOR_HEADER

        if THEMA == "MATERIAL":
            style = ttk.Style()
            style.theme_use('default')
            
            MENU_BG_DARK = "#2A273F"               # Sfondo Barra menu superiore
            MENU_FG_LIGHT = "white"                # Colore di primo piano chiaro (bianco)
            MENU_BG = "#4B4673"                    # Sfondo dei sottomenu
            MENU_ACT_BG_COLOR = "#509FE2"          # Colore di evidenziazione (ciano)
            MENU_ACT_FG_COLOR = "black"            # Nero
            
            COLOR_BACKGROUND = "#20232A"           # Grigio Ardesia Scuro / Quasi Nero (Sfondo Principale)
            COLOR_WIDGET_BG = "#2A273F"            # Blu Violaceo Scuro (Sfondo per Widget/Frame)
            TEXT_COLOR = "white"                   # Bianco Puro (Testo Primario)
            COLOR_HIGHLIGHT = "#61AFEF"            # Azzurro Ciano Brillante (Colore di Enfasi/Selezione Attiva)
            COLOR_TEXT = "#ABB2BF"                 # Grigio Chiaro Freddo (Testo Secondario)
            COLOR_HEADER = "#E0E0E0"               # Grigio Molto Chiaro (Titoli/Intestazioni)
            COLOR_RED = "red"                      # Rosso
            COLOR_GREEN = "green"                  # Verde
            COLOR_RED_SMOOTH = "#E06C75"           # Rosso Salmone Tenue (Avvisi, Negativo/Uscite)
            COLOR_GREEN_SMOOTH = "#98C379"         # Verde Oliva/Salvia (Successo, Positivo/Entrate)
            COLOR_HEADER_BG = "#39355C"            # Viola Scuro Melanzana (Sfondo Intestazioni/Barre Titolo)
            COLOR_BUTTON_BG = "#4B4673"            # Viola Scuro/Indaco (Sfondo Pulsanti)
            COLOR_BLINK_OFF = COLOR_TEXT           # Grigio Chiaro Freddo (Stato di Non Lampeggio)
            COLOR_UPDATE = "#FFFFAA"               # Giallo Molto Chiaro/Crema (Notifiche di Aggiornamento/Blink)
            COLOR_BLACK = "black"                  # Nero (Interni Combobox)
            COLOR_YELLOW = "yellow"                # Giallo (Pulsante combobox)
            COLOR_WHITE = "white"                  # Bianco (Sfondo combobox)
            COLOR_LIGHTGREEN = "lightgreen"        # LightGreen
            COLOR_LIGHTCORAL = "lightcoral"        # LightCoral
            COLOR_KHAKI = "khaki"                  # Khaki
            COLOR_TOOLTIP = "#4B4673"              # Viola Scuro Desaturato (blu-viola scuro)
            COLOR_TEXT_TOOLTIP = "white"           # Bianco (Sfondo Tooltip)

            self.MENU_BG_DARK = MENU_BG_DARK
            self.MENU_FG_LIGHT = MENU_FG_LIGHT
            self.MENU_BG = MENU_BG   
            self.MENU_ACT_BG_COLOR = MENU_ACT_BG_COLOR
            self.MENU_ACT_FG_COLOR = MENU_ACT_FG_COLOR
                        
            self.COLOR_TOPLEVEL = COLOR_WIDGET_BG
            self.TEXT_COLOR = TEXT_COLOR
            self.COLOR_BACKGROUND = COLOR_BACKGROUND
            self.COLOR_WIDGET_BG = COLOR_WIDGET_BG
            self.COLOR_HIGHLIGHT = COLOR_HIGHLIGHT
            self.COLOR_TEXT = COLOR_TEXT
            self.COLOR_HEADER = COLOR_HEADER
            self.COLOR_RED = COLOR_RED
            self.COLOR_GREEN = COLOR_GREEN
            self.COLOR_RED_SMOOTH = COLOR_RED_SMOOTH
            self.COLOR_GREEN_SMOOTH = COLOR_GREEN_SMOOTH
            self.COLOR_HEADER_BG = COLOR_HEADER_BG
            self.COLOR_BUTTON_BG = COLOR_BUTTON_BG
            self.COLOR_BLINK_OFF = COLOR_BLINK_OFF
            self.COLOR_UPDATE = COLOR_UPDATE
            self.COLOR_BLACK = COLOR_BLACK
            self.COLOR_YELLOW = COLOR_YELLOW
            self.COLOR_WHITE = COLOR_WHITE
            self.COLOR_LIGHTGREEN = COLOR_LIGHTGREEN
            self.COLOR_LIGHTCORAL = COLOR_LIGHTCORAL
            self.COLOR_KHAKI = COLOR_KHAKI
            self.COLOR_TOOLTIP = COLOR_TOOLTIP
            self.COLOR_TEXT_TOOLTIP = COLOR_TEXT_TOOLTIP
            
            try:
                self.option_add('*selectBackground', COLOR_HIGHLIGHT)
                self.option_add('*selectForeground', COLOR_WHITE)
                self.option_add('*Focus.background', COLOR_WIDGET_BG)
                self.option_add('*Focus.relief', 'solid')
                self.option_add('*Focus.borderwidth', 1)
                self.option_add('*TCombobox*Listbox.background', COLOR_WIDGET_BG)
                self.option_add('*TCombobox*Listbox.foreground', COLOR_WHITE)
                self.option_add('*TCombobox*Listbox.selectBackground', COLOR_HIGHLIGHT)
                self.option_add('*TCombobox*Listbox.selectForeground', COLOR_BLACK)
                self.option_add('*TCombobox*Listbox.font', ("Arial", 10))
                self.option_add('*TCombobox*Listbox.borderWidth', 0)  
            except Exception:
                pass
                
            self.configure(bg=COLOR_WIDGET_BG)
            
            style.configure("TFrame", background=COLOR_WIDGET_BG)
            style.configure("BlackFrame.TFrame", background=COLOR_WIDGET_BG)
            style.configure("TLabelframe", background=COLOR_WIDGET_BG) 
            style.configure("TLabelframe.Label", background=COLOR_WIDGET_BG, foreground=COLOR_HEADER)
            style.configure("RedBold.TLabelframe.Label", foreground=COLOR_RED_SMOOTH, background=COLOR_WIDGET_BG, font=("Arial", 10, "bold"))
            
            style.configure("Rosso.TSeparator", background="red", thickness=2)   

            style.configure("Treeview", 
                background=COLOR_WIDGET_BG, 
                foreground=COLOR_TEXT, 
                rowheight=25,
                fieldbackground=COLOR_WIDGET_BG, 
                font=("Arial", 10),
                )
            style.configure("Treeview.Heading", 
                background=COLOR_HEADER_BG, 
                foreground=COLOR_HEADER, 
                font=('Arial', 10, 'bold'), 
                relief="flat")
            style.map('Treeview', 
                background=[('selected', COLOR_HIGHLIGHT)], 
                foreground=[('selected', COLOR_WHITE)],
                fieldbackground=[('!disabled', COLOR_WIDGET_BG)]
            )
            style.map('Treeview.Heading', 
                 background=[('active', COLOR_HIGHLIGHT), ('pressed', COLOR_HIGHLIGHT)],
                 foreground=[('active', COLOR_BLACK), ('pressed', COLOR_BLACK)])
        
            style.configure("TNotebook", background=COLOR_WIDGET_BG, borderwidth=0)

            style.configure("TNotebook.Tab", 
                            background=COLOR_BUTTON_BG,
                            foreground=COLOR_TEXT,
                            font=('Arial', 10, 'normal'),
                            padding=[10, 5])
            
            style.map("TNotebook.Tab",
                      background=[('selected', COLOR_HIGHLIGHT)], 
                      foreground=[('selected', COLOR_WHITE)],
                      expand=[('active', [1, 1, 1, 0])])

            style.configure("Custom.TRadiobutton", background=COLOR_WIDGET_BG, foreground=TEXT_COLOR, font=('Arial', 10))
            
            style.configure('Highlight.TCombobox', 
                fieldbackground=COLOR_WIDGET_BG,
                background=COLOR_BUTTON_BG,
                foreground=COLOR_RED_SMOOTH,
                relief='solid',
                arrowsize=8,
                borderwidth=1)

            style.map('Highlight.TCombobox', 
                arrowcolor=[('!disabled', COLOR_RED_SMOOTH)],
                fieldbackground=[
                    ('readonly', COLOR_WIDGET_BG), 
                    ('focus', COLOR_WIDGET_BG), 
                    ('active', COLOR_WIDGET_BG),
                    ('!disabled', COLOR_WIDGET_BG)
                ],
                foreground=[
                    ('readonly', COLOR_RED_SMOOTH), 
                    ('focus', COLOR_RED_SMOOTH), 
                    ('active', COLOR_RED_SMOOTH),
                    ('!disabled', COLOR_RED_SMOOTH)
                ])
          
            style.configure('Border.TCombobox', 
                fieldbackground=COLOR_WIDGET_BG,
                background=COLOR_BUTTON_BG,
                foreground=COLOR_WHITE,
                relief='flat',
                arrowsize=8,
                borderwidth=1)

            style.map('Border.TCombobox', 
                arrowcolor=[('!disabled', COLOR_HIGHLIGHT)],
                fieldbackground=[
                    ('readonly', COLOR_WIDGET_BG), 
                    ('focus', COLOR_WIDGET_BG), 
                    ('active', COLOR_WIDGET_BG),
                    ('!disabled', COLOR_WIDGET_BG)
                ],
                foreground=[
                    ('readonly', COLOR_WHITE), 
                    ('focus', COLOR_WHITE), 
                    ('!disabled', COLOR_WHITE)
                ])

            style.configure("TEntry", 
                            fieldbackground=COLOR_WIDGET_BG, 
                            foreground=COLOR_WHITE, 
                            insertcolor=COLOR_WHITE,
                            borderwidth=1, 
                            relief="flat")
            
            style.map("TEntry", 
                      fieldbackground=[('focus', COLOR_WIDGET_BG), ('readonly', COLOR_WIDGET_BG)],
                      foreground=[('disabled', COLOR_TEXT)])
            
            style.configure("TLabel", background=COLOR_WIDGET_BG, foreground=COLOR_TEXT) 
        
            style.configure("Timer.TLabel", foreground=COLOR_TEXT, background=self.COLOR_UPDATE, font=("Helvetica", 10, "bold"))
            style.configure("Legend.TLabel", background=COLOR_WIDGET_BG, foreground=COLOR_TEXT, font=("Arial", 10), anchor="w")
            style.configure("White.TLabel", foreground=COLOR_HEADER, background=COLOR_WIDGET_BG, font=("Arial", 11))
            style.configure("WhiteSmall.TLabel", foreground=COLOR_HEADER, background=COLOR_WIDGET_BG, font=("Arial", 10))
            style.configure("Verde.TLabel", foreground=COLOR_GREEN_SMOOTH, background=COLOR_WIDGET_BG, font=("Arial", 10, "bold"), padding=5)

            style.configure("Saldo.TLabel", foreground=COLOR_GREEN_SMOOTH, background=COLOR_WIDGET_BG, font=("Arial", 14, "bold"))
            style.map("Saldo.TLabel", background=[('active', COLOR_WIDGET_BG)], foreground=[('active', COLOR_GREEN_SMOOTH)], relief=[('active', 'flat')])
            style.configure("Doc.TLabel", foreground=COLOR_GREEN_SMOOTH, background=COLOR_WIDGET_BG, font=("Arial", 14, "bold"))
            style.map("Doc.TLabel", background=[('active', COLOR_WIDGET_BG)], foreground=[('active', COLOR_GREEN_SMOOTH)], relief=[('active', 'flat')])
        
            style.configure("GSaldo.TLabel", font=("Arial", 10, "bold"), background=COLOR_WIDGET_BG) 
            style.map("GSaldoPositivo.TLabel", foreground=[('active', COLOR_GREEN_SMOOTH), ('!disabled', COLOR_GREEN_SMOOTH)], parent="GSaldo.TLabel")
            style.map("GSaldoNegativo.TLabel", foreground=[('active', COLOR_RED_SMOOTH), ('!disabled', COLOR_RED_SMOOTH)], parent="GSaldo.TLabel")

            style.configure("BlinkAllarme.TLabel", foreground=COLOR_BLINK_OFF, background=COLOR_WIDGET_BG, font=("Arial", 10, "bold"))
            style.map("BlinkAllarme.TLabel", foreground=[('!disabled', COLOR_RED_SMOOTH)], background=[('!disabled', COLOR_WIDGET_BG), ('disabled', COLOR_WIDGET_BG)])
            
            SPESSORE_SCROLL = 7
            style.configure("Vertical.TScrollbar", 
                background=COLOR_BUTTON_BG, 
                troughcolor=COLOR_BACKGROUND, 
                arrowcolor=COLOR_HEADER, 
                relief="flat", 
                borderwidth=0,
                arrowsize=SPESSORE_SCROLL,
                width=SPESSORE_SCROLL)
            style.configure("Horizontal.TScrollbar", 
                background=COLOR_BUTTON_BG, 
                troughcolor=COLOR_BACKGROUND, 
                arrowcolor=COLOR_HEADER, 
                relief="flat", 
                borderwidth=0,
                arrowsize=SPESSORE_SCROLL,
                width=SPESSORE_SCROLL)
            style.map("Vertical.TScrollbar", background=[('active', COLOR_HIGHLIGHT)])
            style.map("Horizontal.TScrollbar", background=[('active', COLOR_HIGHLIGHT)])
            
            style.configure("TScale", 
                background=COLOR_WIDGET_BG, 
                foreground=COLOR_HIGHLIGHT,
                troughcolor="#E0E0E0",
                sliderthickness=10,
                troughthickness=2,
                sliderlength=15,
                relief='flat')

            style.map("TScale", 
                background=[('active', COLOR_HIGHLIGHT)],
               troughcolor=[('disabled', COLOR_WIDGET_BG)])
            
            style.configure("TCheckbutton", background=COLOR_WIDGET_BG, foreground=COLOR_HEADER, font=("Arial", 10))
            style.map("TCheckbutton", background=[('active', COLOR_WIDGET_BG)], foreground=[('active', COLOR_HEADER),('selected', COLOR_HEADER)])
            
            style.configure("Tooltip.TLabel", background=COLOR_TOOLTIP, foreground="#FFFFFF", font=("Arial", 9), borderwidth=1, relief="solid", anchor='w', padding=2)
            
            style.configure("TButton", relief='flat', borderwidth=0, font=("Arial", 9, "bold"), padding=5, background=COLOR_BUTTON_BG, foreground=COLOR_HEADER) 
            style.map("TButton", background=[("active", "#5E598F")]) 
            
            style.configure("Yellow.TButton", background="#E5C07B", foreground=COLOR_BLACK, font=("Arial", 8, "bold"), width=2)
            style.map("Yellow.TButton", background=[("active", "#CFB076")])
            style.configure("Giallo.TButton", background="#E5C07B", foreground=COLOR_BLACK, font=("Arial", 8, "bold"))
            style.map("Giallo.TButton", background=[("active", "#CFB076")])
            style.configure("Verde.TButton", background=COLOR_GREEN_SMOOTH, foreground=COLOR_BLACK, font=("Arial", 8, "bold"))
            style.map("Verde.TButton", background=[('active', '#8AAB6F')], foreground=[('disabled', COLOR_YELLOW)])
            style.configure("Rosso.TButton", background=COLOR_RED_SMOOTH, foreground=COLOR_BLACK, font=("Arial", 8, "bold"))
            style.map("Rosso.TButton", background=[('active', '#C8606B')], foreground=[('disabled', COLOR_YELLOW)])
            style.configure("Arancio.TButton", background="#D19A66", foreground=COLOR_BLACK, font=("Arial", 8, "bold"))
            style.map("Arancio.TButton", background=[("active", "#C18B5C")])
            style.configure("Blu.TButton", background=COLOR_HIGHLIGHT, foreground=COLOR_BLACK, font=("Arial", 8, "bold"))
            style.map("Blu.TButton", background=[("active", "#509FE2")])
            style.configure("Num.TButton", foreground=COLOR_HEADER, background=COLOR_WIDGET_BG, borderwidth=1, relief="raised", font=("Arial", 8, "bold"), padding=6) 
            style.map("Num.TButton", background=[("active", COLOR_HEADER_BG)]) 

            style.configure("Verde_Low.TButton", background=COLOR_GREEN_SMOOTH, foreground=COLOR_BLACK, font=("Arial", 8, "bold"), padding=(2, 0))
            style.map("Verde_Low.TButton", background=[('active', '#8AAB6F')], foreground=[('disabled', COLOR_YELLOW)])
            style.configure("Yellow_Low.TButton", background="#E5C07B", foreground=COLOR_BLACK, font=("Arial", 8, "bold"), width=2, padding=(2, 0))
            style.map("Yellow_Low.TButton", background=[("active", "#CFB076")])
            
            style.configure("Low.Blu.TButton", background=COLOR_HIGHLIGHT, foreground=COLOR_BLACK, font=("Arial", 8, "bold"), padding=(5, 2))
            style.map("Low.Blu.TButton", background=[("active", "#509FE2")])
            
            style.configure("GreenOutline.TButton", 
                            foreground=COLOR_GREEN_SMOOTH, 
                            background=COLOR_WIDGET_BG, 
                            borderwidth=1, 
                            relief="solid", 
                            padding=(5, 1), 
                            font=("Arial", 10, "bold")) 
            style.map("GreenOutline.TButton", 
                      background=[("active", "#1B3D1B"), ("pressed", "#142E14")], 
                      bordercolor=[("!disabled", COLOR_GREEN_SMOOTH)], 
                      foreground=[("!disabled", COLOR_GREEN_SMOOTH)])

            style.configure("RedOutline.TButton", 
                            foreground=COLOR_RED_SMOOTH, 
                            background=COLOR_WIDGET_BG, 
                            borderwidth=1, 
                            relief="solid", 
                            padding=(5, 1), 
                            font=("Arial", 10, "bold")) 
            style.map("RedOutline.TButton", 
                      background=[("active", "#3D1B1B"), ("pressed", "#2E1414")], 
                      bordercolor=[("!disabled", COLOR_RED_SMOOTH)], 
                      foreground=[("!disabled", COLOR_RED_SMOOTH)])
                      
            style.configure(
                "Backup.Horizontal.TProgressbar",
                troughcolor=self.COLOR_WIDGET_BG,
                background=self.COLOR_HIGHLIGHT,
                thickness=10
            )

            stili_tabella = [
            ("mensile", "#E6FFE6", "#004C00"),
            ("regolare", "#F0FFF0", "#333333"),
            ("bimestrale", "#FFFFE0", "#CC9900"),
            ("trimestrale", "#FFF0E0", "#FF6600"),
            ("irregolare", "#FFEEEE", "#CC0000"),
            ]
        
            for alias, bg, fg in stili_tabella:
                style.configure(
                    f"Legenda.{alias}.TLabel", 
                    background=bg, 
                    foreground=fg, 
                    font=("Arial", 8, "bold"),
                    padding=3
                )
 
            self.cal_bg = COLOR_WIDGET_BG
            self.cal_fg = COLOR_TEXT
            self.cal_weekend_bg = COLOR_WIDGET_BG  
            self.cal_weekend_fg = COLOR_HIGHLIGHT
            self.cal_weekday_bg = COLOR_WIDGET_BG  
            self.cal_weekday_fg = COLOR_HEADER
            self.cal_select_bg = COLOR_HIGHLIGHT 
            self.cal_select_fg = COLOR_BLACK     
            self.cal_header_bg = COLOR_WIDGET_BG   
            self.cal_header_fg = COLOR_HEADER

        if THEMA == "BLU":
            style = ttk.Style()
            style.theme_use('default')
            
            MENU_BG_DARK = "#B3E5FC"              # Celeste medio (Barra superiore)
            MENU_FG_LIGHT = "#004B8D"             # Blu scuro per contrasto testo
            MENU_BG = "#E1F5FE"                   # Celeste chiarissimo per i sottomenu
            MENU_ACT_BG_COLOR = "#0288D1"         # Blu brillante in selezione
            MENU_ACT_FG_COLOR = "white"           # Bianco su selezione
            
            COLOR_BACKGROUND = "#B3E5FC"          # SFONDO PRINCIPALE CELESTE
            COLOR_WIDGET_BG = "#B3E5FC"           # Sfondo widget celeste chiaro
            TEXT_COLOR = "#002F6C"                # Testo principale Blu notte
            COLOR_HIGHLIGHT = "#0091EA"           # Blu elettrico per la selezione
            COLOR_TEXT = "#004B8D"                # Testo secondario
            COLOR_HEADER = "#004B8D"              # Testo intestazioni
            COLOR_RED = "red"                     # Rosso standard
            COLOR_GREEN = "#2ed573"               # Verde standard
            COLOR_RED_SMOOTH = "red"              # Rosso standard
            COLOR_GREEN_SMOOTH = "#2ed573"        # Verde smeraldo brillante
            COLOR_HEADER_BG = "#81D4FA"           # Intestazioni coordinate al celeste
            COLOR_BUTTON_BG = "#E1F5FE"           # Bottoni chiari
            COLOR_BLINK_OFF = "#4FC3F7"           # Colore spento azzurro
            COLOR_UPDATE = "#FFF176"              # Giallo avviso solare
            COLOR_BLACK = "black"                 # Nero standard
            COLOR_YELLOW = "#FBC02D"              # Giallo Ambra (Material Design)
            COLOR_WHITE = "white"                 # Bianco puro
            COLOR_LIGHTGREEN = "#7bed9f"          # Verde menta chiaro
            COLOR_LIGHTCORAL = "#ff6b81"          # Corallo pastello
            COLOR_KHAKI = "khaki"                 # Cachi / Sabbia
            COLOR_TOOLTIP = "#E1F5FE"             # Tooltip coerente col tema
            COLOR_TEXT_TOOLTIP = "#004B8D"        # Testo blu scuro

            self.MENU_BG_DARK = MENU_BG_DARK
            self.MENU_FG_LIGHT = MENU_FG_LIGHT
            self.MENU_BG = MENU_BG   
            self.MENU_ACT_BG_COLOR = MENU_ACT_BG_COLOR
            self.MENU_ACT_FG_COLOR = MENU_ACT_FG_COLOR
                        
            self.COLOR_TOPLEVEL = COLOR_WIDGET_BG
            self.TEXT_COLOR = TEXT_COLOR
            self.COLOR_BACKGROUND = COLOR_BACKGROUND
            self.COLOR_WIDGET_BG = COLOR_WIDGET_BG
            self.COLOR_HIGHLIGHT = COLOR_HIGHLIGHT
            self.COLOR_TEXT = COLOR_TEXT
            self.COLOR_HEADER = COLOR_HEADER
            self.COLOR_RED = COLOR_RED
            self.COLOR_GREEN = COLOR_GREEN
            self.COLOR_RED_SMOOTH = COLOR_RED_SMOOTH
            self.COLOR_GREEN_SMOOTH = COLOR_GREEN_SMOOTH
            self.COLOR_HEADER_BG = COLOR_HEADER_BG
            self.COLOR_BUTTON_BG = COLOR_BUTTON_BG
            self.COLOR_BLINK_OFF = COLOR_BLINK_OFF
            self.COLOR_UPDATE = COLOR_UPDATE
            self.COLOR_BLACK = COLOR_BLACK
            self.COLOR_YELLOW = COLOR_YELLOW
            self.COLOR_WHITE = COLOR_WHITE     
            self.COLOR_LIGHTGREEN = COLOR_LIGHTGREEN
            self.COLOR_LIGHTCORAL = COLOR_LIGHTCORAL
            self.COLOR_KHAKI = COLOR_KHAKI
            self.COLOR_TOOLTIP = COLOR_TOOLTIP
            self.COLOR_TEXT_TOOLTIP = COLOR_TEXT_TOOLTIP
            
            try:
                self.option_add('*selectBackground', COLOR_HIGHLIGHT)
                self.option_add('*selectForeground', COLOR_WHITE)
                self.option_add('*Focus.background', COLOR_WIDGET_BG)
                self.option_add('*Focus.relief', 'solid')
                self.option_add('*Focus.borderwidth', 1)
            except Exception:
                pass
                
            self.configure(bg=COLOR_BACKGROUND)                  

            style.configure("TFrame", background=COLOR_WIDGET_BG)
            style.configure("BlackFrame.TFrame", background=COLOR_WIDGET_BG)
            style.configure("TLabelframe", background=COLOR_WIDGET_BG) 
            style.configure("TLabelframe.Label", background=COLOR_WIDGET_BG, foreground=COLOR_HEADER)
            style.configure("RedBold.TLabelframe.Label", foreground=COLOR_RED_SMOOTH, background=COLOR_WIDGET_BG, font=("Arial", 10, "bold"))
            
            style.configure("Rosso.TSeparator", background="red", thickness=2)   
            
            style.configure("Treeview", 
                            background=COLOR_WIDGET_BG, 
                            foreground=COLOR_TEXT, 
                            rowheight=25,
                            fieldbackground=COLOR_WHITE, 
                            font=("Arial", 10),
                            borderwidth=0)
            style.configure("Treeview.Heading", 
                            background="#F2F2F2",
                            foreground=COLOR_HEADER, 
                            font=('Arial', 10, 'bold'), 
                            relief="flat",
                            borderwidth=1) 
            style.map('Treeview', 
                      foreground=[('selected', COLOR_WHITE)], 
                      background=[('selected', COLOR_HIGHLIGHT)],
                      fieldbackground=[('!disabled', COLOR_WIDGET_BG)]
            )
            style.map('Treeview.Heading', 
                foreground=[('active', COLOR_HIGHLIGHT), ('pressed', COLOR_HIGHLIGHT)], 
                background=[('active', "#EAEAEA"), ('pressed', "#DDDDDD")] 
            )
            style.configure("TNotebook", background=COLOR_WIDGET_BG, borderwidth=0)

            style.configure("TNotebook.Tab", 
                            background=COLOR_BACKGROUND,
                            foreground=COLOR_TEXT,
                            font=('Arial', 10, 'normal'),
                            padding=[10, 5])
            
            style.map("TNotebook.Tab",
                      background=[('selected', COLOR_HIGHLIGHT)], 
                      foreground=[('selected', COLOR_WHITE)],
                      expand=[('active', [1, 1, 1, 0])])

            style.configure("Custom.TRadiobutton", background=COLOR_WIDGET_BG, foreground=TEXT_COLOR, font=('Arial', 10))

            style.configure('Highlight.TCombobox', 
                fieldbackground=COLOR_WIDGET_BG,
                background=COLOR_BUTTON_BG, 
                foreground=COLOR_RED_SMOOTH,
                relief='solid', 
                arrowsize=8, 
                borderwidth=1)

            style.map('Highlight.TCombobox', 
                arrowcolor=[('!disabled', COLOR_RED_SMOOTH)],
                fieldbackground=[
                    ('readonly', COLOR_WIDGET_BG), 
                    ('focus', COLOR_WIDGET_BG), 
                    ('active', COLOR_WIDGET_BG),
                    ('!disabled', COLOR_WIDGET_BG)
                ],
                foreground=[
                    ('readonly', COLOR_RED_SMOOTH), 
                    ('focus', COLOR_RED_SMOOTH), 
                    ('active', COLOR_RED_SMOOTH),
                    ('!disabled', COLOR_RED_SMOOTH)
                ])
            
            style.configure('Border.TCombobox', 
                fieldbackground=COLOR_WHITE, 
                background=COLOR_YELLOW, 
                foreground=COLOR_BLACK, 
                relief='flat',
                arrowsize=8,
                borderwidth=1)
            style.map('Border.TCombobox', 
                arrowcolor=[('!disabled', COLOR_HIGHLIGHT)],
                fieldbackground=[('readonly', COLOR_WHITE), ('!focus', COLOR_WHITE), ('!disabled', COLOR_WHITE)])
                
            style.configure("TLabel", background=COLOR_WIDGET_BG, foreground=COLOR_TEXT) 
            style.configure("Timer.TLabel", foreground=COLOR_TEXT, background=COLOR_UPDATE, font=("Helvetica", 10, "bold"))
            style.configure("Legend.TLabel", background=COLOR_WIDGET_BG, foreground=COLOR_TEXT, font=("Arial", 10), anchor="w")
            style.configure("White.TLabel", foreground=COLOR_TEXT, background=COLOR_WIDGET_BG, font=("Arial", 11))
            style.configure("WhiteSmall.TLabel", foreground=COLOR_TEXT, background=COLOR_WIDGET_BG, font=("Arial", 10))
            style.configure("Verde.TLabel", foreground=COLOR_GREEN_SMOOTH, background=COLOR_WIDGET_BG, font=("Arial", 10, "bold"), padding=5)

            style.configure("Saldo.TLabel", foreground=COLOR_GREEN_SMOOTH, background=COLOR_WIDGET_BG, font=("Arial", 14, "bold"))
            style.map("Saldo.TLabel", background=[('active', COLOR_WIDGET_BG)], foreground=[('active', COLOR_GREEN_SMOOTH)], relief=[('active', 'flat')])
            style.configure("Doc.TLabel", foreground=COLOR_GREEN_SMOOTH, background=COLOR_WIDGET_BG, font=("Arial", 14, "bold"))
            style.map("Doc.TLabel", background=[('active', COLOR_WIDGET_BG)], foreground=[('active', COLOR_GREEN_SMOOTH)], relief=[('active', 'flat')])
            
            style.configure("GSaldo.TLabel", font=("Arial", 10, "bold"), background=COLOR_WIDGET_BG) 
            style.map("GSaldoPositivo.TLabel", foreground=[('active', COLOR_GREEN_SMOOTH), ('!disabled', COLOR_GREEN_SMOOTH)], parent="GSaldo.TLabel")
            style.map("GSaldoNegativo.TLabel", foreground=[('active', COLOR_RED_SMOOTH), ('!disabled', COLOR_RED_SMOOTH)], parent="GSaldo.TLabel")

            style.configure("BlinkAllarme.TLabel", foreground=COLOR_BLINK_OFF, background=COLOR_WIDGET_BG, font=("Arial", 10, "bold"))
            style.map("BlinkAllarme.TLabel", foreground=[('!disabled', COLOR_RED_SMOOTH)], background=[('!disabled', COLOR_WIDGET_BG), ('disabled', COLOR_WIDGET_BG)])

            SPESSORE_SCROLL = 7
            style.configure("Vertical.TScrollbar", 
                background="#0288D1", 
                troughcolor="#E1F5FE",
                arrowcolor=COLOR_HEADER,
                borderwidth=0, 
                relief="flat",
                arrowsize=SPESSORE_SCROLL,
                width=SPESSORE_SCROLL)
            style.configure("Horizontal.TScrollbar", 
                background="#0288D1", 
                troughcolor="#E1F5FE",
                arrowcolor=COLOR_HEADER, 
                borderwidth=0, 
                relief="flat",
                arrowsize=SPESSORE_SCROLL,
                width=SPESSORE_SCROLL)
            style.map("Vertical.TScrollbar", background=[('active', COLOR_HIGHLIGHT)])
            style.map("Horizontal.TScrollbar", background=[('active', COLOR_HIGHLIGHT)])

            style.configure("TScale", 
                background=COLOR_WIDGET_BG, 
                foreground=COLOR_HIGHLIGHT,
                troughcolor="#E0E0E0",
                sliderthickness=10,
                troughthickness=2,
                sliderlength=15,
                relief='flat')

            style.map("TScale", 
                background=[('active', COLOR_HIGHLIGHT)],
               troughcolor=[('disabled', COLOR_WIDGET_BG)])

            style.configure("TCheckbutton", background=COLOR_WIDGET_BG, foreground=COLOR_HEADER, font=("Arial", 10))
            style.map("TCheckbutton", background=[('active', COLOR_WIDGET_BG)], foreground=[('active', COLOR_HEADER),('selected', COLOR_HEADER)])

            style.configure("Tooltip.TLabel", background=COLOR_TOOLTIP, foreground=COLOR_BLACK, font=("Arial", 9), borderwidth=1, relief="solid", anchor='w', padding=2)
            
            style.configure("TButton", relief='flat', borderwidth=0, font=("Arial", 9, "bold"), padding=5, background=COLOR_BUTTON_BG, foreground=COLOR_TEXT) 
            style.map("TButton", background=[("active", "#CCCCCC")])

            style.configure("Yellow.TButton", background=COLOR_YELLOW, foreground=COLOR_BLACK, font=("Arial", 8, "bold"), width=2)
            style.map("Yellow.TButton", background=[("active", "#FFE680")])
            style.configure("Giallo.TButton", background=COLOR_YELLOW, foreground=COLOR_BLACK, font=("Arial", 8, "bold"))
            style.map("Giallo.TButton", background=[("active", "#FFE680")])

            style.configure("Verde.TButton", background=COLOR_GREEN_SMOOTH, foreground=COLOR_BLACK, font=("Arial", 8, "bold"))
            style.map("Verde.TButton", background=[('active', '#8AAB6F')], foreground=[('disabled', COLOR_YELLOW)])
            style.configure("Rosso.TButton", background=COLOR_RED_SMOOTH, foreground=COLOR_BLACK, font=("Arial", 8, "bold"))
            style.map("Rosso.TButton", background=[('active', '#C8606B')], foreground=[('disabled', COLOR_YELLOW)])
            style.configure("Arancio.TButton", background="#FFA500", foreground=COLOR_BLACK, font=("Arial", 8, "bold"))
            style.map("Arancio.TButton", background=[("active", "#FFC766")])
            style.configure("Blu.TButton", background=COLOR_HIGHLIGHT, foreground=COLOR_WHITE, font=("Arial", 8, "bold"))
            style.map("Blu.TButton", background=[("active", "#00AADD")])

            style.configure("Verde_Low.TButton", background=COLOR_GREEN_SMOOTH, foreground=COLOR_BLACK, font=("Arial", 8, "bold"), padding=(2, 0))
            style.map("Verde_Low.TButton", background=[('active', '#8AAB6F')], foreground=[('disabled', COLOR_YELLOW)])
            style.configure("Yellow_Low.TButton", background=COLOR_YELLOW, foreground=COLOR_BLACK, font=("Arial", 8, "bold"), width=2, padding=(2, 0))
            style.map("Yellow_Low.TButton", background=[("active", "#FFE680")])

            style.configure("Low.Blu.TButton", background=COLOR_HIGHLIGHT, foreground=COLOR_WHITE, font=("Arial", 6, "bold"), padding=(4, 1))
            style.map("Low.Blu.TButton", background=[("active", "#00AADD")])

            style.configure("Num.TButton", foreground=COLOR_TEXT, background=COLOR_WIDGET_BG, borderwidth=1, relief="raised", font=("Arial", 8, "bold"), padding=6) 
            style.map("Num.TButton", background=[("active", COLOR_HEADER_BG)]) 
            
            style.configure("GreenOutline.TButton", foreground=COLOR_GREEN_SMOOTH, background=COLOR_WIDGET_BG, borderwidth=1, relief="solid", padding=(5, 1), font=("Arial", 10, "bold")) 
            style.map("GreenOutline.TButton", 
                      background=[("active", "#E6FFE6"), ("pressed", "#CCFFCC")],
                      bordercolor=[("!disabled", COLOR_GREEN_SMOOTH)], 
                      foreground=[("!disabled", COLOR_GREEN_SMOOTH)])

            style.configure("RedOutline.TButton", foreground=COLOR_RED_SMOOTH, background=COLOR_WIDGET_BG, borderwidth=1, relief="solid", padding=(5, 1), font=("Arial", 10, "bold")) 
            style.map("RedOutline.TButton", 
                      background=[("active", "#FFEEEE"), ("pressed", "#FFCCCC")],
                      bordercolor=[("!disabled", COLOR_RED_SMOOTH)], 
                      foreground=[("!disabled", COLOR_RED_SMOOTH)])

            style.configure(
                "Backup.Horizontal.TProgressbar",
                troughcolor=self.COLOR_WIDGET_BG,
                background=self.COLOR_HIGHLIGHT,
                thickness=10
            )
                       
            stili_tabella = [
            ("mensile", "#E6FFE6", "#004C00"),
            ("regolare", "#F0FFF0", "#333333"),
            ("bimestrale", "#FFFFE0", "#CC9900"),
            ("trimestrale", "#FFF0E0", "#FF6600"),
            ("irregolare", "#FFEEEE", "#CC0000"),
            ]
        
            for alias, bg, fg in stili_tabella:
                style.configure(
                    f"Legenda.{alias}.TLabel", 
                    background=bg, 
                    foreground=fg, 
                    font=("Arial", 8, "bold"),
                    padding=3
                )
                
            self.cal_bg = COLOR_WIDGET_BG
            self.cal_fg = COLOR_TEXT
            self.cal_weekend_bg = COLOR_WIDGET_BG  
            self.cal_weekend_fg = COLOR_HIGHLIGHT
            self.cal_weekday_bg = COLOR_WIDGET_BG  
            self.cal_weekday_fg = COLOR_HEADER
            self.cal_select_bg = COLOR_HIGHLIGHT 
            self.cal_select_fg = COLOR_BLACK     
            self.cal_header_bg = COLOR_WIDGET_BG   
            self.cal_header_fg = COLOR_HEADER

        if THEMA == "OBSIDIAN":
            style = ttk.Style()
            style.theme_use('default')
            
            COLOR_BACKGROUND = "#000000"            # Nero assoluto per lo sfondo principale
            COLOR_WIDGET_BG = "#000000"             # Sfondo Widget/Frame
            MENU_BG_DARK = "#000000"                # Sfondo Barra menu superiore
            MENU_FG_LIGHT = "white"                 # Bianco
            MENU_BG = "#0A0A0A"                     # Sfondo dei sottomenu
            MENU_ACT_BG_COLOR = "#509FE2"           # Azzurro Ciano
            MENU_ACT_FG_COLOR = "black"             # Nero
            
            TEXT_COLOR = "white"                    # Bianco Puro
            COLOR_HIGHLIGHT = "#61AFEF"             # Azzurro Obsidian
            COLOR_TEXT = "#ABB2BF"                  # Grigio Chiaro Freddo
            COLOR_HEADER = "#E0E0E0"                # Grigio Molto Chiaro
            COLOR_RED = "red"                       # Rosso puro
            COLOR_GREEN = "green"                   # Verde puro
            COLOR_RED_SMOOTH = "#E06C75"            # Rosso Salmone Soft
            COLOR_GREEN_SMOOTH = "#98C379"          # Verde Oliva Soft
            COLOR_HEADER_BG = "#0A0A0A"             # Sfondo Intestazioni
            COLOR_BUTTON_BG = "#2A2A2A"             # Grigio grafite
            COLOR_BLINK_OFF = COLOR_TEXT
            COLOR_UPDATE = "#FFF176"                # Sfondo Blink
            COLOR_BLACK = "black"                   # Riferimento nero standard
            COLOR_YELLOW = "yellow"                 # Riferimento giallo standard
            COLOR_WHITE = "white"                   # Riferimento bianco standard
            COLOR_LIGHTGREEN = "lightgreen"         # Verde chiaro di sistema
            COLOR_LIGHTCORAL = "lightcoral"         # Rosso chiaro di sistema
            COLOR_KHAKI = "khaki"                   # Tonalit√† neutra Sabbia
            COLOR_TOOLTIP = "#1A1A1A"               # Grigio Antracite molto scuro
            COLOR_TEXT_TOOLTIP = "white"            # Testo bianco su tooltip

            self.MENU_BG_DARK = MENU_BG_DARK
            self.MENU_FG_LIGHT = MENU_FG_LIGHT
            self.MENU_BG = MENU_BG   
            self.MENU_ACT_BG_COLOR = MENU_ACT_BG_COLOR
            self.MENU_ACT_FG_COLOR = MENU_ACT_FG_COLOR
                        
            self.COLOR_TOPLEVEL = COLOR_WIDGET_BG
            self.TEXT_COLOR = TEXT_COLOR
            self.COLOR_BACKGROUND = COLOR_BACKGROUND
            self.COLOR_WIDGET_BG = COLOR_WIDGET_BG
            self.COLOR_HIGHLIGHT = COLOR_HIGHLIGHT
            self.COLOR_TEXT = COLOR_TEXT
            self.COLOR_HEADER = COLOR_HEADER
            self.COLOR_RED = COLOR_RED
            self.COLOR_GREEN = COLOR_GREEN
            self.COLOR_RED_SMOOTH = COLOR_RED_SMOOTH
            self.COLOR_GREEN_SMOOTH = COLOR_GREEN_SMOOTH
            self.COLOR_HEADER_BG = COLOR_HEADER_BG
            self.COLOR_BUTTON_BG = COLOR_BUTTON_BG
            self.COLOR_BLINK_OFF = COLOR_BLINK_OFF
            self.COLOR_UPDATE = COLOR_UPDATE
            self.COLOR_BLACK = COLOR_BLACK
            self.COLOR_YELLOW = COLOR_YELLOW
            self.COLOR_WHITE = COLOR_WHITE
            self.COLOR_LIGHTGREEN = COLOR_LIGHTGREEN
            self.COLOR_LIGHTCORAL = COLOR_LIGHTCORAL
            self.COLOR_KHAKI = COLOR_KHAKI
            self.COLOR_TOOLTIP = COLOR_TOOLTIP
            self.COLOR_TEXT_TOOLTIP = COLOR_TEXT_TOOLTIP
            
            try:
                self.option_add('*selectBackground', COLOR_HIGHLIGHT)
                self.option_add('*selectForeground', COLOR_WHITE)
                self.option_add('*Focus.background', COLOR_WIDGET_BG)
                self.option_add('*Focus.relief', 'solid')
                self.option_add('*Focus.borderwidth', 1)
                self.option_add('*TCombobox*Listbox.background', "#0A0A0A")
                self.option_add('*TCombobox*Listbox.foreground', COLOR_WHITE)
                self.option_add('*TCombobox*Listbox.selectBackground', COLOR_HIGHLIGHT)
                self.option_add('*TCombobox*Listbox.selectForeground', COLOR_BLACK)
                self.option_add('*TCombobox*Listbox.font', ("Arial", 10))
                self.option_add('*TCombobox*Listbox.borderWidth', 0)  
            except Exception:
                pass
                
            self.configure(bg=COLOR_WIDGET_BG)
            
            style.configure("TFrame", background=COLOR_WIDGET_BG)
            style.configure("BlackFrame.TFrame", background=COLOR_WIDGET_BG)
            style.configure("TLabelframe", background=COLOR_WIDGET_BG) 
            style.configure("TLabelframe.Label", background=COLOR_WIDGET_BG, foreground=COLOR_HEADER)
            style.configure("RedBold.TLabelframe.Label", foreground=COLOR_RED_SMOOTH, background=COLOR_WIDGET_BG, font=("Arial", 10, "bold"))

            style.configure("Rosso.TSeparator", background="red", thickness=2)   

            style.configure("Treeview", 
                background=COLOR_WIDGET_BG, 
                foreground=COLOR_TEXT, 
                rowheight=25,
                fieldbackground=COLOR_WIDGET_BG, 
                font=("Arial", 10),
                )
            style.configure("Treeview.Heading", 
                background=COLOR_HEADER_BG, 
                foreground=COLOR_HEADER, 
                font=('Arial', 10, 'bold'), 
                relief="flat")
            style.map('Treeview', 
                background=[('selected', COLOR_HIGHLIGHT)], 
                foreground=[('selected', COLOR_WHITE)],
                fieldbackground=[('!disabled', COLOR_WIDGET_BG)]
            )
            style.map('Treeview.Heading', 
                 background=[('active', COLOR_HIGHLIGHT), ('pressed', COLOR_HIGHLIGHT)],
                 foreground=[('active', COLOR_BLACK), ('pressed', COLOR_BLACK)])
        
            style.configure("TNotebook", background=COLOR_WIDGET_BG, borderwidth=0)

            style.configure("TNotebook.Tab", 
                            background=COLOR_BUTTON_BG,
                            foreground=COLOR_TEXT,
                            font=('Arial', 10, 'normal'),
                            padding=[10, 5])
            
            style.map("TNotebook.Tab",
                      background=[('selected', COLOR_HIGHLIGHT)], 
                      foreground=[('selected', COLOR_WHITE)],
                      expand=[('active', [1, 1, 1, 0])])

            style.configure("Custom.TRadiobutton", background=COLOR_WIDGET_BG, foreground=TEXT_COLOR, font=('Arial', 10))
            
            style.configure('Highlight.TCombobox', 
                fieldbackground=COLOR_WIDGET_BG,
                background=COLOR_BUTTON_BG,
                foreground=COLOR_RED_SMOOTH,
                relief='solid',
                arrowsize=8,
                borderwidth=1)

            style.map('Highlight.TCombobox', 
                arrowcolor=[('!disabled', COLOR_RED_SMOOTH)],
                fieldbackground=[
                    ('readonly', COLOR_WIDGET_BG), 
                    ('focus', COLOR_WIDGET_BG), 
                    ('active', COLOR_WIDGET_BG),
                    ('!disabled', COLOR_WIDGET_BG)
                ],
                foreground=[
                    ('readonly', COLOR_RED_SMOOTH), 
                    ('focus', COLOR_RED_SMOOTH), 
                    ('active', COLOR_RED_SMOOTH),
                    ('!disabled', COLOR_RED_SMOOTH)
                ])
          
            style.configure('Border.TCombobox', 
                fieldbackground=COLOR_WIDGET_BG,
                background=COLOR_BUTTON_BG,
                foreground=COLOR_WHITE,
                relief='flat',
                arrowsize=8,
                borderwidth=1)

            style.map('Border.TCombobox', 
                arrowcolor=[('!disabled', COLOR_HIGHLIGHT)],
                fieldbackground=[
                    ('readonly', COLOR_WIDGET_BG), 
                    ('focus', COLOR_WIDGET_BG), 
                    ('active', COLOR_WIDGET_BG),
                    ('!disabled', COLOR_WIDGET_BG)
                ],
                foreground=[
                    ('readonly', COLOR_WHITE), 
                    ('focus', COLOR_WHITE), 
                    ('!disabled', COLOR_WHITE)
                ])

            style.configure("TEntry", 
                            fieldbackground="#0A0A0A", 
                            foreground=COLOR_WHITE, 
                            insertcolor=COLOR_WHITE,
                            borderwidth=1, 
                            relief="flat")
            
            style.map("TEntry", 
                      fieldbackground=[('focus', "#0A0A0A"), ('readonly', "#0A0A0A")],
                      foreground=[('disabled', COLOR_TEXT)])
            
            style.configure("TLabel", background=COLOR_WIDGET_BG, foreground=COLOR_TEXT) 
        
            style.configure("Timer.TLabel", foreground=COLOR_TEXT, background=self.COLOR_UPDATE, font=("Helvetica", 10, "bold"))
            style.configure("Legend.TLabel", background=COLOR_WIDGET_BG, foreground=COLOR_TEXT, font=("Arial", 10), anchor="w")
            style.configure("White.TLabel", foreground=COLOR_HEADER, background=COLOR_WIDGET_BG, font=("Arial", 11))
            style.configure("WhiteSmall.TLabel", foreground=COLOR_HEADER, background=COLOR_WIDGET_BG, font=("Arial", 10))
            style.configure("Verde.TLabel", foreground=COLOR_GREEN_SMOOTH, background=COLOR_WIDGET_BG, font=("Arial", 10, "bold"), padding=5)

            style.configure("Saldo.TLabel", foreground=COLOR_GREEN_SMOOTH, background=COLOR_WIDGET_BG, font=("Arial", 14, "bold"))
            style.map("Saldo.TLabel", background=[('active', COLOR_WIDGET_BG)], foreground=[('active', COLOR_GREEN_SMOOTH)], relief=[('active', 'flat')])
            style.configure("Doc.TLabel", foreground=COLOR_GREEN_SMOOTH, background=COLOR_WIDGET_BG, font=("Arial", 14, "bold"))
            style.map("Doc.TLabel", background=[('active', COLOR_WIDGET_BG)], foreground=[('active', COLOR_GREEN_SMOOTH)], relief=[('active', 'flat')])
        
            style.configure("GSaldo.TLabel", font=("Arial", 10, "bold"), background=COLOR_WIDGET_BG) 
            style.map("GSaldoPositivo.TLabel", foreground=[('active', COLOR_GREEN_SMOOTH), ('!disabled', COLOR_GREEN_SMOOTH)], parent="GSaldo.TLabel")
            style.map("GSaldoNegativo.TLabel", foreground=[('active', COLOR_RED_SMOOTH), ('!disabled', COLOR_RED_SMOOTH)], parent="GSaldo.TLabel")

            style.configure("BlinkAllarme.TLabel", foreground=COLOR_BLINK_OFF, background=COLOR_WIDGET_BG, font=("Arial", 10, "bold"))
            style.map("BlinkAllarme.TLabel", foreground=[('!disabled', COLOR_RED_SMOOTH)], background=[('!disabled', COLOR_WIDGET_BG), ('disabled', COLOR_WIDGET_BG)])
            
            SPESSORE_SCROLL = 7
            style.configure("Vertical.TScrollbar", 
                background=COLOR_BUTTON_BG, 
                troughcolor=COLOR_BACKGROUND, 
                arrowcolor=COLOR_HEADER, 
                relief="flat", 
                borderwidth=0,
                arrowsize=SPESSORE_SCROLL,
                width=SPESSORE_SCROLL)
            style.configure("Horizontal.TScrollbar", 
                background=COLOR_BUTTON_BG, 
                troughcolor=COLOR_BACKGROUND, 
                arrowcolor=COLOR_HEADER, 
                relief="flat", 
                borderwidth=0,
                arrowsize=SPESSORE_SCROLL,
                width=SPESSORE_SCROLL)
            style.map("Vertical.TScrollbar", background=[('active', COLOR_HIGHLIGHT)])
            style.map("Horizontal.TScrollbar", background=[('active', COLOR_HIGHLIGHT)])
            
            style.configure("TScale", 
                background=COLOR_WIDGET_BG, 
                foreground=COLOR_HIGHLIGHT,
                troughcolor="#333333",
                sliderthickness=10,
                troughthickness=2,
                sliderlength=15,
                relief='flat')

            style.map("TScale", 
                background=[('active', COLOR_HIGHLIGHT)],
               troughcolor=[('disabled', COLOR_WIDGET_BG)])
            
            style.configure("TCheckbutton", background=COLOR_WIDGET_BG, foreground=COLOR_HEADER, font=("Arial", 10))
            style.map("TCheckbutton", background=[('active', COLOR_WIDGET_BG)], foreground=[('active', COLOR_HEADER),('selected', COLOR_HEADER)])
            
            style.configure("Tooltip.TLabel", background=COLOR_TOOLTIP, foreground="#FFFFFF", font=("Arial", 9), borderwidth=1, relief="solid", anchor='w', padding=2)
            
            style.configure("TButton", relief='flat', borderwidth=0, font=("Arial", 9, "bold"), padding=5, background=COLOR_BUTTON_BG, foreground=COLOR_HEADER) 
            style.map("TButton", background=[("active", "#1E1E1E")]) 
            
            style.configure("Yellow.TButton", background="#E5C07B", foreground=COLOR_BLACK, font=("Arial", 8, "bold"), width=2)
            style.map("Yellow.TButton", background=[("active", "#CFB076")])
            style.configure("Giallo.TButton", background="#E5C07B", foreground=COLOR_BLACK, font=("Arial", 8, "bold"))
            style.map("Giallo.TButton", background=[("active", "#CFB076")])
            style.configure("Verde.TButton", background=COLOR_GREEN_SMOOTH, foreground=COLOR_BLACK, font=("Arial", 8, "bold"))
            style.map("Verde.TButton", background=[('active', '#8AAB6F')], foreground=[('disabled', COLOR_YELLOW)])
            style.configure("Rosso.TButton", background=COLOR_RED_SMOOTH, foreground=COLOR_BLACK, font=("Arial", 8, "bold"))
            style.map("Rosso.TButton", background=[('active', '#C8606B')], foreground=[('disabled', COLOR_YELLOW)])
            style.configure("Arancio.TButton", background="#D19A66", foreground=COLOR_BLACK, font=("Arial", 8, "bold"))
            style.map("Arancio.TButton", background=[("active", "#C18B5C")])
            style.configure("Blu.TButton", background=COLOR_HIGHLIGHT, foreground=COLOR_BLACK, font=("Arial", 8, "bold"))
            style.map("Blu.TButton", background=[("active", "#509FE2")])
            style.configure("Num.TButton", foreground=COLOR_HEADER, background=COLOR_WIDGET_BG, borderwidth=1, relief="raised", font=("Arial", 8, "bold"), padding=6) 
            style.map("Num.TButton", background=[("active", COLOR_HEADER_BG)]) 
            
            style.configure("Verde_Low.TButton", background=COLOR_GREEN_SMOOTH, foreground=COLOR_BLACK, font=("Arial", 8, "bold"), padding=(2, 0))
            style.map("Verde_Low.TButton", background=[('active', '#8AAB6F')], foreground=[('disabled', COLOR_YELLOW)])
            style.configure("Yellow_Low.TButton", background="#E5C07B", foreground=COLOR_BLACK, font=("Arial", 8, "bold"), width=2, padding=(2, 0))
            style.map("Yellow_Low.TButton", background=[("active", "#CFB076")])
            
            style.configure("Low.Blu.TButton", background=COLOR_HIGHLIGHT, foreground=COLOR_BLACK, font=("Arial", 8, "bold"), padding=(5, 2))
            style.map("Low.Blu.TButton", background=[("active", "#509FE2")])
            
            style.configure("GreenOutline.TButton", 
                            foreground=COLOR_GREEN_SMOOTH, 
                            background=COLOR_WIDGET_BG, 
                            borderwidth=1, 
                            relief="solid", 
                            padding=(5, 1), 
                            font=("Arial", 10, "bold")) 
            style.map("GreenOutline.TButton", 
                      background=[("active", "#1B3D1B"), ("pressed", "#142E14")], 
                      bordercolor=[("!disabled", COLOR_GREEN_SMOOTH)], 
                      foreground=[("!disabled", COLOR_GREEN_SMOOTH)])

            style.configure("RedOutline.TButton", 
                            foreground=COLOR_RED_SMOOTH, 
                            background=COLOR_WIDGET_BG, 
                            borderwidth=1, 
                            relief="solid", 
                            padding=(5, 1), 
                            font=("Arial", 10, "bold")) 
            style.map("RedOutline.TButton", 
                      background=[("active", "#3D1B1B"), ("pressed", "#2E1414")], 
                      bordercolor=[("!disabled", COLOR_RED_SMOOTH)], 
                      foreground=[("!disabled", COLOR_RED_SMOOTH)])
                      
            style.configure(
                "Backup.Horizontal.TProgressbar",
                troughcolor=self.COLOR_WIDGET_BG,
                background=self.COLOR_HIGHLIGHT,
                thickness=10
            )

            stili_tabella = [
            ("mensile", "#E6FFE6", "#004C00"),
            ("regolare", "#F0FFF0", "#333333"),
            ("bimestrale", "#FFFFE0", "#CC9900"),
            ("trimestrale", "#FFF0E0", "#FF6600"),
            ("irregolare", "#FFEEEE", "#CC0000"),
            ]
        
            for alias, bg, fg in stili_tabella:
                style.configure(
                    f"Legenda.{alias}.TLabel", 
                    background=bg, 
                    foreground=fg, 
                    font=("Arial", 8, "bold"),
                    padding=3
                )

            self.cal_bg = COLOR_WIDGET_BG
            self.cal_fg = COLOR_TEXT
            self.cal_weekend_bg = COLOR_WIDGET_BG  
            self.cal_weekend_fg = COLOR_HIGHLIGHT
            self.cal_weekday_bg = COLOR_WIDGET_BG  
            self.cal_weekday_fg = COLOR_HEADER
            self.cal_select_bg = COLOR_HIGHLIGHT 
            self.cal_select_fg = COLOR_BLACK     
            self.cal_header_bg = COLOR_WIDGET_BG   
            self.cal_header_fg = COLOR_HEADER
            
        # Menu Principale
        font_menu = ("Segoe UI", 9)
        barra_menu = tk.Menu(self, background=self.MENU_BG_DARK, foreground=self.MENU_FG_LIGHT, activebackground=self.MENU_ACT_BG_COLOR, activeforeground=self.MENU_ACT_FG_COLOR, font=font_menu, bd=0)
        self.config(menu=barra_menu)
        menu_gestione = tk.Menu(barra_menu, tearoff=0, bg=self.MENU_BG, fg=self.MENU_FG_LIGHT, activebackground=self.MENU_ACT_BG_COLOR, activeforeground=self.MENU_ACT_FG_COLOR, font=font_menu)
        barra_menu.add_cascade(label="üóÇÔ∏è Gestione", menu=menu_gestione)
        menu_gestione.add_command(label="üìã Gestione SuperMarket", command=self.spesa_supermercato)
        menu_gestione.add_command(label="üì§ Gestione Documenti", command=self.gestisci_archivi_pdf)
        menu_gestione.add_command(label="üë• Gestione Utenze", accelerator="Ctrl+U", command=self.utenze)
        menu_gestione.add_command(label="‚ö° Sincronizza Acquisti Email (Gmail)", command=self.avvia_sincronizzazione) # <-- Qui!
        menu_gestione.add_command(label="üìÖ Rubrica", accelerator="Ctrl+R", command=self.rubrica_app)
        menu_gestione.add_command(label="üìã Promemoria", accelerator="Ctrl+Y", command=self.gestisci_promemoria)
        menu_gestione.add_command(label="üìò GCalendar", command=self.launch_qr_svg_generator)
        menu_ricorrenze = tk.Menu(menu_gestione, tearoff=0, bg=self.MENU_BG, fg=self.MENU_FG_LIGHT, activebackground=self.MENU_ACT_BG_COLOR, activeforeground=self.MENU_ACT_FG_COLOR, font=font_menu)
        menu_gestione.add_cascade(label="‚ôªÔ∏è Ricorrenze", menu=menu_ricorrenze)
        menu_ricorrenze.add_command(label="üìã Gestione Ricorrenze", accelerator="Ctrl+T", command=self.mostra_ricorrenza_popup)
        menu_ricorrenze.add_command(label="üìã Lista Ricorrenze", accelerator="Ctrl+L", command=self.mostra_lista_ricorrenze)
        menu_ricorrenze.add_command(label="üìã Scadenze Mese", accelerator="Ctrl+J", command=self.scadenze_mese)
        menu_gestione.add_separator()
        menu_gestione.add_command(label="üìÖ Stampa", accelerator="Ctrl+P", command=self.anteprima_e_stampa_txt)
        menu_gestione.add_command(label="üí∞ Saldo Conto", accelerator="Ctrl+S", command=self.open_saldo_conto)
        menu_gestione.add_command(label="üìã Pannello Controllo", accelerator="Ctrl+Z", command=self.calcola_mancanti)
        menu_gestione.add_command(label="üìã Calcolatrice", accelerator="Ctrl+E", command=self.apri_calcolatrice)
        menu_gestione.add_command(label="üìã Cancella Voci Bulk", command=self.apri_cancella_spese_treeview_unica)
        menu_gestione.add_separator()
        menu_gestione.add_command(label="‚úñÔ∏è Salva e chiudi", accelerator="Ctrl+Q", command=self._on_close)
        menu_gestione.add_command(label="‚úñÔ∏è Riduci a icona", accelerator="Ctrl+X", command=self.iconify)
        menu_analisi = tk.Menu(barra_menu, tearoff=0, bg=self.MENU_BG, fg=self.MENU_FG_LIGHT, activebackground=self.MENU_ACT_BG_COLOR, activeforeground=self.MENU_ACT_FG_COLOR, font=font_menu)
        barra_menu.add_cascade(label="üìä Analisi", menu=menu_analisi)
        menu_analisi.add_command(label="üîç Ricerca Globale", accelerator="Ctrl+F", command=self.cerca_operazioni)
        menu_analisi.add_command(label="üìä Confronta Periodi", accelerator="Ctrl+N", command=self.open_compare_window)
        menu_analisi.add_command(label="üìä Time Machine", accelerator="Ctrl+W", command=self.time_machine)
        menu_analisi.add_command(label="üìÇ Aggrega Categorie", accelerator="Ctrl+G", command=self.gruppo_categorie)
        menu_analisi.add_command(label="üìã Bilancio Annuo", accelerator="Ctrl+A", command=self.calcola_statistiche_annuali)
        menu_analisi.add_command(label="üìã Grafici Interattivi", accelerator="Alt+H", command=self.mostra_analisi_grafici)
        menu_analisi.add_command(label="üåê Report Web Dinamico", accelerator="Alt+R", command=self.genera_report_html)
        menu_finanze = tk.Menu(barra_menu, tearoff=0, bg=self.MENU_BG, fg=self.MENU_FG_LIGHT, activebackground=self.MENU_ACT_BG_COLOR, activeforeground=self.MENU_ACT_FG_COLOR, font=font_menu)
        barra_menu.add_cascade(label="üí∏ Finanze", menu=menu_finanze)
        menu_finanze.add_command(label="üìä Finanziamenti", accelerator="Ctrl+O", command=self.calcolo_mutuo_prestito)
        menu_estrazioni = tk.Menu(menu_finanze, tearoff=0, bg=self.MENU_BG, fg=self.MENU_FG_LIGHT, activebackground=self.MENU_ACT_BG_COLOR, activeforeground=self.MENU_ACT_FG_COLOR, font=font_menu)
        menu_finanze.add_cascade(label="üóÉÔ∏è Estrazioni", menu=menu_estrazioni)
        menu_estrazioni.add_command(label="üìÖ Bilancio Giorno", accelerator="Alt+J", command=self.export_giorno_forzato)
        menu_estrazioni.add_command(label="üìÖ Bilancio Mese", accelerator="Alt+K", command=self.export_month_detail)
        menu_estrazioni.add_command(label="üìä Bilancio Anno", accelerator="Alt+L", command=self.export_anno_dettagliato)
        menu_estrazioni.add_command(label="üìä Bilancio Storico Totale ", accelerator="Alt+G", command=self.export_storico_totale)
        menu_categorie = tk.Menu(barra_menu, tearoff=0, bg=self.MENU_BG, fg=self.MENU_FG_LIGHT, activebackground=self.MENU_ACT_BG_COLOR, activeforeground=self.MENU_ACT_FG_COLOR, font=font_menu)
        barra_menu.add_cascade(label="üìÜ Categorie", menu=menu_categorie)
        menu_categorie.add_command(label="‚è∞ Analisi Categorie", accelerator="Ctrl+K", command=self.open_analisi_categoria)
        menu_categorie.add_command(label="‚è∞ Suggerisci Categorie", accelerator="Ctrl+Shift+K", command=self.apri_categorie_suggerite)
        menu_categorie.add_command(label="‚è∞ Gestione Categorie", accelerator="Ctrl+Shift+T", command=self.mostra_categorie_popup)
        menu_categorie.add_command(label="‚è∞ Gestione Categorie Bulk", accelerator="Ctrl+Shift+S", command=self.apri_cancella_multiplo)
        menu_opzioni = tk.Menu(barra_menu, tearoff=0, bg=self.MENU_BG, fg=self.MENU_FG_LIGHT, activebackground=self.MENU_ACT_BG_COLOR, activeforeground=self.MENU_ACT_FG_COLOR, font=font_menu)
        barra_menu.add_cascade(label="‚öôÔ∏è Opzioni", menu=menu_opzioni)
        menu_opzioni.add_command(label="‚öôÔ∏è Impostazioni App", command=self.gestisci_configurazione)
        menu_db = tk.Menu(menu_opzioni, tearoff=0, bg=self.MENU_BG, fg=self.MENU_FG_LIGHT, activebackground=self.MENU_ACT_BG_COLOR, activeforeground=self.MENU_ACT_FG_COLOR, font=font_menu)
        menu_opzioni.add_cascade(label="üíæ Database", menu=menu_db)
        menu_db.add_command(label="üì§ Esporta DB Transazioni", command=self.export_db)
        menu_db.add_command(label="üì§ Importa DB Transazioni", command=self.import_db)
        menu_db.add_command(label="üì§ Reset DB", command=self.show_reset_dialog)
        menu_db.add_command(label="üì§ Esegui Backup Completo Zip", command=self.esegui_backup_zip)
        menu_opzioni.add_separator()
        menu_opzioni.add_command(label="üîÑ Controlla Aggiornamento Software", command=self.forza_check_aggiornamento_con_api)
        menu_opzioni.add_command(label="üîÑ Forza Aggiornamento Software", command=self.forza_aggiorna)
        menu_opzioni.add_command(label="‚Ü©Ô∏è Annulla Ultimo Aggiornamento", command=self.ripristina_da_backup)
        menu_opzioni.add_command(label="üìÑ Visualizza Storico Aggiornamenti", command=self.visualizza_changelog)
        menu_opzioni.add_separator()
        menu_opzioni.add_command(label="üñ•Ô∏è Visualizza Interfaccia Web Locale", command=self.apri_webserver)
        menu_opzioni.add_command(label="üñ•Ô∏è QRcode Connessioni Gateway Remoti", command=self.genera_qr_web)
        menu_opzioni.add_separator()
        menu_opzioni.add_command(label="üìú Storico Anomalie", command=self.mostra_registro_errori)
        menu_info = tk.Menu(barra_menu, tearoff=0, bg=self.MENU_BG, fg=self.MENU_FG_LIGHT, activebackground=self.MENU_ACT_BG_COLOR, activeforeground=self.MENU_ACT_FG_COLOR, font=font_menu)
        barra_menu.add_cascade(label="üõà Info", menu=menu_info)
        menu_info.add_command(label="üõà Info App", command=self.show_info_app, accelerator="Ctrl+I")
        menu_info.add_command(label="üìò Apri Manuale", command=self.scarica_manuale, accelerator="Ctrl+M")  
        
        self.bind_all("<Control-u>", lambda e: self.utenze())
        self.bind_all("<Control-r>", lambda e: self.rubrica_app())
        self.bind_all("<Control-y>", lambda e: self.gestisci_promemoria())
        self.bind_all("<Control-p>", lambda e: self.anteprima_e_stampa_txt())
        self.bind_all("<Control-s>", lambda e: self.open_saldo_conto())
        self.bind_all("<Control-z>", lambda e: self.calcola_mancanti())
        self.bind_all("<Control-e>", lambda e: self.apri_calcolatrice())
        self.bind_all("<Control-q>", lambda e: self._on_close())
        self.bind_all("<Control-x>", lambda e: self.iconify())
        self.bind_all("<Control-t>", lambda e: self.mostra_ricorrenza_popup())
        self.bind_all("<Control-l>", lambda e: self.mostra_lista_ricorrenze())
        self.bind_all("<Control-j>", lambda e: self.scadenze_mese())
        self.bind_all("<Control-f>", lambda e: self.cerca_operazioni())
        self.bind_all("<Control-n>", lambda e: self.open_compare_window())
        self.bind_all("<Control-w>", lambda e: self.time_machine())
        self.bind_all("<Control-g>", lambda e: self.gruppo_categorie())
        self.bind_all("<Control-a>", lambda e: self.calcola_statistiche_annuali())
        self.bind_all("<Alt-h>", lambda e: self.mostra_analisi_grafici())
        self.bind_all("<Control-o>", lambda e: self.calcolo_mutuo_prestito())
        self.bind_all("<Alt-j>", lambda e: self.export_giorno_forzato())
        self.bind_all("<Alt-k>", lambda e: self.export_month_detail())
        self.bind_all("<Alt-l>", lambda e: self.export_anno_dettagliato())
        self.bind_all("<Alt-g>", lambda e: self.export_storico_totale())
        self.bind_all("<Control-k>", lambda e: self.open_analisi_categoria())
        self.bind_all("<Control-Shift-K>", lambda e: self.apri_categorie_suggerite())
        self.bind_all("<Control-Shift-T>", lambda e: self.mostra_categorie_popup())
        self.bind_all("<Control-Shift-S>", lambda e: self.apri_cancella_multiplo())
        self.bind_all("<Control-i>", lambda e: self.show_info_app())
        self.bind_all("<Control-m>", lambda e: self.scarica_manuale())
               
        main_frame = ttk.Frame(self, style="BlackFrame.TFrame")
        main_frame.pack(fill=tk.BOTH, expand=True, padx=8, pady=4)
        
        cal_frame = ttk.Frame(main_frame, style="BlackFrame.TFrame")
        cal_frame.pack(side=tk.LEFT, fill=tk.Y, padx=(0, 15))
        today = datetime.date.today()
        
        self.cal = Calendar(
            cal_frame,
            selectmode="day",
            year=today.year,
            month=today.month,
            day=today.day,
            locale="it_IT",
            date_pattern="dd-mm-yyyy",
            font=("Arial", 10),
            cursor="hand2",
            background=self.cal_header_bg,
            foreground=self.cal_header_fg,
            headersbackground=self.cal_header_bg,
            headersforeground=self.cal_header_fg,
            normalbackground=self.cal_bg,
            normalforeground=self.cal_fg,
            weekendbackground=self.cal_weekend_bg,
            weekendforeground=self.cal_weekend_fg,
            selectbackground=self.cal_select_bg,
            selectforeground=self.cal_select_fg,
            bordercolor=self.cal_bg,            
            showothermonthdays=False
        )
        self.cal.pack(fill="both", expand=False)
        self.cal.configure(borderwidth=0)

        # Creazione del tooltip Calendario
        self.tooltip_win = tk.Toplevel(self)
        self.tooltip_win.withdraw()
        self.tooltip_win.overrideredirect(True)
        self.tooltip_win.attributes("-topmost", True)
        self.tooltip_timer = None
        # Collega il calendario ai movimenti del mouse
        if CAL_TOOLTIPS:
            self.applica_ricorsivo_tooltip(self.cal)
        # Disattiva Tooltip tkcalendar
        self.cal.configure(tooltipdelay=999999)
        
        legenda = ttk.Frame(cal_frame, style="BlackFrame.TFrame")
        legenda.pack(side=tk.TOP, anchor="n")
        btn_oggi = ttk.Button(legenda, text="üîô Oggi", command=self.goto_today, width=8, style="Giallo.TButton")
        btn_oggi.pack(side="left", padx=3)

        ttk.Label(legenda, text="Entrata", background="lightgreen", foreground="black", width=8, anchor="center", font=("Arial", 10)).pack(side="left", padx=3)
        ttk.Label(legenda, text="Uscita", background="lightcoral", foreground="black", width=8, anchor="center", font=("Arial", 10)).pack(side="left", padx=3)
        ttk.Label(legenda, text="Entrata+Uscita", background="khaki", foreground="black", width=14, anchor="center", font=("Arial", 10)).pack(side="left", padx=3)
        ttk.Label(legenda, text="Weekend", background=self.cal_weekend_bg, foreground=self.cal_weekend_fg, font=("Arial", 10), width=10, anchor="center").pack(side="left", padx=3)
        ttk.Label(legenda, text="Sel.", background="dodgerblue", foreground="white", font=("Arial", 10), width=6, anchor="center").pack(side="left", padx=3)

        oggi = datetime.date.today()
        self.cal.calevent_create(oggi, "Oggi", "today")
        self.cal.tag_config("today", background="gold", foreground="black")

        try:
           self.cal._header_month.config(font=("Arial", 14, "bold"))
           self.cal._header_year.config(font=("Arial", 14, "bold"))
        except:
           pass

        self.cal.tag_config("verde", background=self.COLOR_LIGHTGREEN, foreground=self.COLOR_BLACK)
        self.cal.tag_config("rosso", background=self.COLOR_LIGHTCORAL, foreground=self.COLOR_BLACK)
        self.cal.tag_config("misto", background=self.COLOR_KHAKI, foreground=self.COLOR_BLACK)
        self.cal.tag_config("today", background=self.COLOR_YELLOW, foreground=self.COLOR_BLACK)

        self.cal.bind("<<CalendarSelected>>", self.on_calendar_change)
        self.cal.bind("<<CalendarMonthChanged>>", self.on_month_changed)
        self.colora_giorni_spese()
         
        self.estratto_month_var = tk.StringVar(value=f"{today.month:02d}")
        self.estratto_year_var = tk.StringVar(value=str(today.year))

        current_year = today.year
        self.years = [str(y) for y in range(current_year - 15, current_year + 11)]
        self.months = [
            "01 - Gennaio", "02 - Febbraio", "03 - Marzo", "04 - Aprile", "05 - Maggio", "06 - Giugno",
            "07 - Luglio", "08 - Agosto", "09 - Settembre", "10 - Ottobre", "11 - Novembre", "12 - Dicembre"
        ]

        riepilogo_frame = ttk.Frame(cal_frame)
        riepilogo_frame.pack(fill=tk.X, padx=2, pady=(8, 8))

        self.totalizzatore_mese_frame = ttk.LabelFrame(riepilogo_frame, text="‚öôÔ∏è Riepilogo Mese Attuale", style="RedBold.TLabelframe")
        self.totalizzatore_mese_frame.pack(side="left", fill="both", expand=True, padx=(0, 4))
        self.totalizzatore_mese_frame.grid_columnconfigure(1, weight=1)

        ttk.Label(self.totalizzatore_mese_frame, text="Totale Entrate mese:", foreground="green", font=("Arial", 10, "bold")).grid(row=0, column=0, sticky="w", padx=(6,0), pady=(2, 0))
        self.totalizzatore_mese_entrate_label = ttk.Label(self.totalizzatore_mese_frame, text="0.00 ‚Ç¨", foreground="green", font=("Arial", 10, "bold"))
        self.totalizzatore_mese_entrate_label.grid(row=0, column=1, sticky="e", padx=(0,6), pady=(2, 0))
        
        ttk.Label(self.totalizzatore_mese_frame, text="Totale Uscite mese:", foreground="red", font=("Arial", 10, "bold")).grid(row=1, column=0, sticky="w", padx=(6,0), pady=(2, 0))
        self.totalizzatore_mese_uscite_label = ttk.Label(self.totalizzatore_mese_frame, text="0.00 ‚Ç¨", foreground="red", font=("Arial", 10, "bold"))
        self.totalizzatore_mese_uscite_label.grid(row=1, column=1, sticky="e", padx=(0,6), pady=(2, 0))

        ttk.Label(self.totalizzatore_mese_frame, text="Differenza mese:", foreground="dodgerblue", font=("Arial", 10, "bold")).grid(row=2, column=0, sticky="w", padx=(6,0), pady=(2, 4))
        self.totalizzatore_mese_diff_label = ttk.Label(self.totalizzatore_mese_frame, text="0.00 ‚Ç¨", foreground="dodgerblue", font=("Arial", 10, "bold"))
        self.totalizzatore_mese_diff_label.grid(row=2, column=1, sticky="e", padx=(0,6), pady=(2, 4))

        self.totalizzatore_frame = ttk.LabelFrame(riepilogo_frame, text="‚öôÔ∏è Riepilogo Anno Attuale", style="RedBold.TLabelframe")
        self.totalizzatore_frame.pack(side="left", fill="both", expand=True, padx=(4, 0))
        self.totalizzatore_frame.grid_columnconfigure(1, weight=1)

        ttk.Label(self.totalizzatore_frame, text="Totale Entrate:", foreground="green", font=("Arial", 10, "bold")).grid(row=0, column=0, sticky="w", padx=(6,0), pady=(2, 0))
        self.totalizzatore_entrate_label = ttk.Label(self.totalizzatore_frame, text="0.00 ‚Ç¨", foreground="green", font=("Arial", 10, "bold"))
        self.totalizzatore_entrate_label.grid(row=0, column=1, sticky="e", padx=(0,6), pady=(2, 0))

        ttk.Label(self.totalizzatore_frame, text="Totale Uscite:", foreground="red", font=("Arial", 10, "bold")).grid(row=1, column=0, sticky="w", padx=(6,0), pady=(2, 0))
        self.totalizzatore_uscite_label = ttk.Label(self.totalizzatore_frame, text="0.00 ‚Ç¨", foreground="red", font=("Arial", 10, "bold"))
        self.totalizzatore_uscite_label.grid(row=1, column=1, sticky="e", padx=(0,6), pady=(2, 0))
        
        ttk.Label(self.totalizzatore_frame, text="Differenza:", foreground="dodgerblue", font=("Arial", 10, "bold")).grid(row=2, column=0, sticky="w", padx=(6,0), pady=(2, 4))
        self.totalizzatore_diff_label = ttk.Label(self.totalizzatore_frame, text="0.00 ‚Ç¨", foreground="dodgerblue", font=("Arial", 10, "bold"))
        self.totalizzatore_diff_label.grid(row=2, column=1, sticky="e", padx=(0,6), pady=(2, 4))

        self.lbl_titolo_target_m = ttk.Label(
                self.totalizzatore_mese_frame, 
                text="Target Mese:", 
                font=("Arial", 10, "bold"), 
                foreground=self.COLOR_HEADER
        )
        self.lbl_titolo_target_m.grid(row=3, column=0, sticky="w", padx=(6,0), pady=(2, 2))
        self.lbl_budget_mese = ttk.Label(
                self.totalizzatore_mese_frame, 
                text="0.00 ‚Ç¨", 
                font=("Arial", 10, "bold")
        )
        self.lbl_budget_mese.grid(row=3, column=1, sticky="e", padx=(0,6), pady=(2, 2))
        self.lbl_titolo_target_a = ttk.Label(
                self.totalizzatore_frame, 
                text="Target Anno:", 
                font=("Arial", 10, "bold"), 
                foreground=self.COLOR_HEADER
        )
        self.lbl_titolo_target_a.grid(row=3, column=0, sticky="w", padx=(6,0), pady=(2, 2))
        self.lbl_budget_anno = ttk.Label(
                self.totalizzatore_frame, 
                text="0.00 ‚Ç¨", 
                font=("Arial", 10, "bold")
        )
        self.lbl_budget_anno.grid(row=3, column=1, sticky="e", padx=(0,6), pady=(2, 2))

        self.spese_mese_frame = ttk.LabelFrame(cal_frame, text="Analisi Mese Attuale", style="RedBold.TLabelframe")
        self.spese_mese_frame.pack(fill=tk.BOTH, expand=True, padx=2, pady=(2,4))

        treeview_container = ttk.Frame(self.spese_mese_frame)
        treeview_container.pack(fill=tk.BOTH, expand=True, padx=2, pady=2)
        
        vsb = ttk.Scrollbar(treeview_container, orient="vertical", style="Vertical.TScrollbar")
        
        self.spese_mese_tree = ttk.Treeview(
            treeview_container, 
            columns=("Data", "Categoria", "Descrizione", "Importo", "Tipo"),
            show="headings",
            height=30,
            yscrollcommand=vsb.set 
        )
        
        vsb.config(command=self.spese_mese_tree.yview)

        vsb.pack(side="right", fill="y")
        self.spese_mese_tree.pack(side="left", fill=tk.BOTH, expand=True) 
        
        self.spese_mese_tree.bind("<Double-1>", self.on_spese_mese_tree_double_click) 
        
        self.spese_mese_tree.heading("Data", text="Data")
        self.spese_mese_tree.heading("Categoria", text="Categoria")
        self.spese_mese_tree.heading("Descrizione", text="Descrizione")
        self.spese_mese_tree.heading("Importo", text="Importo (‚Ç¨)")
        self.spese_mese_tree.heading("Tipo", text="Tipo")
        
        self.spese_mese_tree.column("Data", width=80, anchor="center")
        self.spese_mese_tree.column("Categoria", width=125, anchor="center")
        self.spese_mese_tree.column("Descrizione", width=105, anchor="center")
        self.spese_mese_tree.column("Importo", width=80, anchor="e")
        self.spese_mese_tree.column("Tipo", width=50, anchor="center")
        
        self.spese_mese_tree.tag_configure('entrata', foreground='green')
        self.spese_mese_tree.tag_configure('uscita', foreground='red')
        
        for col in self.spese_mese_tree["columns"]:
            self.spese_mese_tree.heading(col, command=lambda _col=col: self.treeview_sort_column(self.spese_mese_tree, _col, False))
            
        right_frame = ttk.Frame(main_frame)
        right_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        stat_frame = ttk.LabelFrame(right_frame, text="‚öôÔ∏è Riepilogo Avanzato", style="RedBold.TLabelframe")
        stat_frame.pack(fill=tk.BOTH, expand=True, padx=2, pady=(8, 8))
        stat_frame.rowconfigure(3, weight=1) 
        stat_frame.columnconfigure(0, weight=1)
        self.stats_frame_ref = stat_frame 
        self.bind("<Escape>", lambda e: self.mostra_treeview_statistiche() if self.stats_view_mode.get() != "tabella" else None)
        self.stats_mode = tk.StringVar(value="giorno")
        
        mode_frame = ttk.Frame(stat_frame)
        mode_frame.grid(row=0, column=0, sticky="ew", padx=6, pady=(4, 0))
        
        self.stats_mode = tk.StringVar(value="giorno")
        self.STATO_CORRENTE = 0
        self.STATI_VISTA = ["tabella", "grafico", "grafico_mensile", "grafico_saldo"]
        self.LABEL_PROSSIMO_STATO = [
            "üìä",
            "üìà",
            "‚öñÔ∏è",
            "üìã"
        ]
        label_iniziale = self.LABEL_PROSSIMO_STATO[ (self.STATO_CORRENTE + 1) % len(self.STATI_VISTA) ]
        
        self.btn_ciclico = ttk.Button(mode_frame, text=label_iniziale, command=self.cicla_visualizzazione_statistiche, width=2, style="Blu.TButton")
        self.btn_ciclico.pack(side=tk.LEFT, padx=(5, 2)) 
        self.bind("<Right>", lambda e: self.cicla_visualizzazione_statistiche())
        self.bind("<Left>", lambda e: self.cicla_indietro())
        
        self.btn_analisi = ttk.Button(mode_frame, text="üîç", command=lambda: self.mostra_analisi_grafici(), width=2, style="Blu.TButton")
        self.btn_analisi.pack(side=tk.LEFT, padx=1) 
        ttk.Button(mode_frame, text="?", command=lambda: self.mostra_help(), width=2, style="Yellow.TButton").pack(side=tk.LEFT, padx=(1, 5))
        
        self.btn_giorno = ttk.Button(mode_frame, text="üìÖ Giorno", command=lambda: self.set_stats_mode("giorno"), width=9, style="Blu.TButton")
        self.btn_giorno.pack(side=tk.LEFT, padx=1)
        self.btn_mese = ttk.Button(mode_frame, text="üìÖ Mese", command=lambda: self.set_stats_mode("mese"), width=9, style="Blu.TButton")
        self.btn_mese.pack(side=tk.LEFT, padx=1)
        self.btn_anno = ttk.Button(mode_frame, text="üìÖ Anno", command=lambda: self.set_stats_mode("anno"), width=9, style="Blu.TButton")
        self.btn_anno.pack(side=tk.LEFT, padx=1)
        self.btn_totali = ttk.Button(mode_frame, text="üìÖ Totali", command=lambda: self.set_stats_mode("totali"), width=9, style="Blu.TButton")
        self.btn_totali.pack(side=tk.LEFT, padx=1)
  
        lbl_saldo_tot = ttk.Label(mode_frame, text="üí∞", style="Saldo.TLabel")
        lbl_saldo_tot.pack(side="right", anchor="e", padx=5)
        lbl_saldo_tot.bind("<Button-1>", lambda e: self.open_saldo_conto())
        lbl_saldo_tot.bind("<Enter>", lambda e: self.show_tooltip_saldo(e))
        lbl_saldo_tot.bind("<Leave>", self.hide_tooltip_saldo)
       
        def add_tt(w, txt):
            def _show(e):
                def _create():
                    self.hide_tooltip()
                    self.tooltip_window = tk.Toplevel(self)
                    self.tooltip_window.withdraw()
                    self.tooltip_window.wm_overrideredirect(True)
                    label = ttk.Label(self.tooltip_window, text=txt, style="Tooltip.TLabel")
                    label.pack()
                    self.tooltip_window.update_idletasks()
                    tw, th = self.tooltip_window.winfo_reqwidth(), self.tooltip_window.winfo_reqheight()
                    x, y = e.x_root - 150, e.y_root - 60
                    if x + tw > self.winfo_screenwidth(): x = e.x_root - tw - 10
                    if y + th > self.winfo_screenheight(): y = e.y_root - th - 10
                    self.tooltip_window.wm_geometry(f"+{int(x)}+{int(y)}")
                    self.tooltip_window.deiconify()
                    self.tooltip_window.attributes("-alpha", 1.0)

                if hasattr(self, 'tooltip_after_id') and self.tooltip_after_id:
                    self.after_cancel(self.tooltip_after_id)
                self.tooltip_after_id = self.after(500, _create)
            
            def _cancel(e):
                if hasattr(self, 'tooltip_after_id') and self.tooltip_after_id:
                    self.after_cancel(self.tooltip_after_id)
                    self.tooltip_after_id = None
                self.hide_tooltip()

            w.bind("<Enter>", _show)
            w.bind("<Leave>", _cancel)
        btn_iconizza = ttk.Label(mode_frame, text="üóó", cursor="hand2", style="Saldo.TLabel")
        btn_iconizza.bind('<Button-1>', lambda e: self.iconify())        
        btn_iconizza.pack(side="right", anchor="e", padx=(0, 5))
        add_tt(btn_iconizza, "Riduci a icona")
        self.btn_report_html = ttk.Button(mode_frame, text="üìä", command=self.genera_report_html, cursor="hand2", style="Doc.TLabel")
        self.btn_report_html.pack(side="right", anchor="e", padx=(0, 5))
        add_tt(self.btn_report_html, "Visualizza Report Grafico Interattivo")
        self.btn_web_qr = ttk.Button(mode_frame, text="üåê", command=lambda: self.genera_qr_web(), cursor="hand2", style="Doc.TLabel")
        self.btn_web_qr.pack(side="right", anchor="e", padx=(0, 5))
        add_tt(self.btn_web_qr, "Genera QR per accesso Web")
        self.btn_promemoria = ttk.Button(mode_frame, text="üìå", command=lambda: self.gestisci_promemoria(), cursor="hand2", style="Doc.TLabel")
        self.btn_promemoria.pack(side="right", anchor="e", padx=(0, 5))
        add_tt(self.btn_promemoria, "Gestione Promemoria")
        self.btn_qr_generator = ttk.Button(mode_frame, text="‚è∞", command=lambda: self.launch_qr_svg_generator(), cursor="hand2", style="Doc.TLabel")
        self.btn_qr_generator.pack(side="right", anchor="e", padx=(0, 5))
        add_tt(self.btn_qr_generator, "Generatore QR e Timer")
        self.btn_controlla_ricorrenze = ttk.Button(mode_frame, text="üì¢", command=lambda: self.controlla_ricorrenti_manual(), cursor="hand2", style="Doc.TLabel")
        self.btn_controlla_ricorrenze.pack(side="right", anchor="e", padx=(0, 5))
        add_tt(self.btn_controlla_ricorrenze, "Controlla scadenze e ricorrenze")
        self.btn_documenti_icona = ttk.Button(mode_frame, text="üìÅ", command=lambda: self.gestisci_archivi_pdf(), cursor="hand2", style="Doc.TLabel")
        self.btn_documenti_icona.pack(side="right", anchor="e", padx=(0, 5))
        add_tt(self.btn_documenti_icona, "Archivio Documenti PDF")
        btn_spesa_super_icon = ttk.Label(mode_frame, text="üõí", cursor="hand2", style="Saldo.TLabel")
        btn_spesa_super_icon.bind('<Button-1>', lambda e: self.spesa_supermercato())
        btn_spesa_super_icon.pack(side="right", anchor="e", padx=(0, 5))
        add_tt(btn_spesa_super_icon, "Gestione Lista della Spesa")
        self.btn_banca_icon = ttk.Button(mode_frame, text="üè¶", command=lambda: self.chiama_banca(), cursor="hand2", style="Doc.TLabel")
        self.btn_banca_icon.pack(side="right", anchor="e", padx=(0, 5))
        add_tt(self.btn_banca_icon, "Accedi ai servizi bancari")
      
        self.stats_label = ttk.Label(stat_frame, text="")
        self.stats_label.grid(row=1, column=0, sticky="w", padx=6, pady=(2, 0))
        
        totali_row = ttk.Frame(stat_frame)
        totali_row.grid(row=2, column=0, sticky="ew", padx=6, pady=(2, 0))
        self.totali_label = ttk.Label(totali_row, text="", font=("Arial", 11))
        
        self.totali_label.pack(side=tk.LEFT)
        self.considera_ricorrenze_var = tk.BooleanVar(value=True)
        
        chk_container_frame = ttk.Frame(totali_row)
        chk_container_frame.pack(side=tk.RIGHT, padx=12)
        
        # Pulsante Carosello
        if CAROSELLO:
            self.var_carosello_enabled = tk.BooleanVar(self, value=True)
            self.btn_ciclico_carosello = ttk.Checkbutton(
                chk_container_frame,
                text="üîÑ",
                variable=self.var_carosello_enabled,
                command=self.toggle_carosello
            )
            self.btn_ciclico_carosello.pack(side=tk.LEFT, padx=0) 
        
        self.chk_ricorrenze = ttk.Checkbutton(
            chk_container_frame,
            text="Includi movimenti futuri nei totali",
            variable=self.considera_ricorrenze_var,
            command=self.refresh_gui
        )
        self.chk_ricorrenze.pack(side=tk.LEFT, padx=0) 
        self.filtri_temporali = [self.btn_giorno, self.btn_mese, self.btn_anno, self.btn_totali, self.chk_ricorrenze]
  
        table_container = ttk.Frame(stat_frame)
        table_container.grid(row=3, column=0, sticky="nsew", padx=4, pady=4)
        self.vsb_stats = ttk.Scrollbar(table_container, orient="vertical")
        self.vsb_stats.pack(side=tk.RIGHT, fill=tk.Y)
        self.hsb_stats = ttk.Scrollbar(table_container, orient="horizontal")
        self.hsb_stats.pack(side=tk.BOTTOM, fill=tk.X)
        self.stats_canvas = tk.Canvas(
            table_container, 
            bg="white", 
            highlightthickness=0
        )
        self.stats_canvas.config(xscrollcommand=self.hsb_stats.set)
        self.hsb_stats.config(command=self.stats_canvas.xview)

        self.stats_table = ttk.Treeview(
            table_container, 
            columns=("A", "B", "C", "D", "E", "F"), 
            show="headings",
            yscrollcommand=self.vsb_stats.set,
            xscrollcommand=self.hsb_stats.set
        )
        self.stats_table.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        self.vsb_stats.config(command=self.stats_table.yview)

        self.stats_text_area = tk.Text(stat_frame, wrap=tk.WORD, state=tk.DISABLED, bg="#F0F0F0")
        
        headers = {
            "A": "Data",
            "B": "Categoria",
            "C": "Descrizione",
            "D": "Importo (‚Ç¨)",
            "E": "Tipo",
            "F": "Modifica"
        }
        for col in ("A", "B", "C", "D", "E", "F"):
            self.stats_table.heading(col, text=headers[col], command=lambda _col=col: self.treeview_sort_column(self.stats_table, _col, False))
            
        self.stats_table.column("A", width=100, anchor="center")
        self.stats_table.column("B", width=150, anchor="center")
        self.stats_table.column("C", width=250, anchor="w")
        self.stats_table.column("D", width=100, anchor="e")
        self.stats_table.column("E", width=80, anchor="center")
        self.stats_table.column("F", width=60, anchor="center")
        
        self.set_stats_mode("giorno")
        self.stats_table.tag_configure("uscita", foreground="red")
        self.stats_table.tag_configure("entrata", foreground="green")
        
        self.stats_table.bind("<Double-1>", self.on_stats_table_double_click)
        self.stats_table.bind("<ButtonRelease-1>", self.on_table_click)
        self.stats_table.bind("<Button-3>", self.on_stats_table_right_click)

        form_frame = ttk.LabelFrame(right_frame, text="‚öôÔ∏è Registra o Modifica Movimento", style="RedBold.TLabelframe")
        form_frame.pack(fill=tk.X, padx=2, pady=(8, 8))
        form_frame.grid_columnconfigure(1, weight=1)
        row = 0
  
        budget_container = tk.Frame(form_frame, bd=2, relief="groove", bg=self.COLOR_WIDGET_BG)
        budget_container.grid(row=0, column=2, rowspan=2, sticky="ne", padx=10, pady=5)
        txt_m = f"Target Mese: ‚Ç¨ {TARGET_MESE:.2f}" if TARGET_MESE > 0 else "Target Mese: N/D"
        txt_a = f"Target Anno: ‚Ç¨ {TARGET_ANNO:.2f}" if TARGET_ANNO > 0 else "Target Anno: N/D"
        self.lbl_budget_mese_widget = ttk.Label(budget_container, text=txt_m, font=("Arial", 8, "bold"), style="TLabel")
        self.lbl_budget_mese_widget.pack(anchor="w", padx=5, pady=2)
        self.lbl_budget_anno_widget = ttk.Label(budget_container, text=txt_a, font=("Arial", 8, "bold"), style="TLabel")
        self.lbl_budget_anno_widget.pack(anchor="w", padx=5, pady=2)
        
        sync_container = tk.Frame(form_frame, bd=1, relief="flat", bg=self.COLOR_WIDGET_BG)
        sync_container.grid(row=2, column=2, sticky="ne", padx=10, pady=(2, 0))
        self.btn_reset_sync = ttk.Button(
                sync_container, 
                text="üîô", 
                width=2,
                cursor="hand2", 
                style="Yellow_Low.TButton", 
                command=self.ricalcola_operazioni_web
        )
        self.btn_reset_sync.pack(side="right", padx=(0, 2), pady=0, expand=False)
        self.lbl_sync_count_widget = ttk.Label(
                sync_container, 
                text=f"üì° Sync: {self.operazioni_scaricate_sessione}", 
                font=("Arial", 9, "bold"),
                foreground=self.TEXT_COLOR,
        )
        self.lbl_sync_count_widget.pack(side="left", anchor="w", padx=2, pady=0, expand=False)
        sync_container.update_idletasks()
        self.btn_avvia_sync = ttk.Button(
            sync_container,
            text="üåê",
            width=2,
            style="Yellow_Low.TButton",
            cursor="hand2", 
            command=lambda: self.avvia_sincronizzazione(manuale=True)
        )
        self.btn_avvia_sync.pack(side="left", padx=(0, 2), pady=0, expand=False)
        self.btn_open_pdf_folder = ttk.Label(
            sync_container, 
            text="üìÅ", 
            width=2, 
            style="Yellow_Low.TButton",  
            cursor="hand2"
        )
        self.btn_open_pdf_folder.pack(side="left", padx=(0, 2))
   
        def apri_cartella():
            path = os.path.join(os.getcwd(), "Fatture_GMail")
            if not os.path.exists(path): 
                os.makedirs(path)
            sistema = platform.system()
            if sistema == "Windows":
                os.startfile(path)
            elif sistema == "Darwin":
                subprocess.Popen(["open", path])
            else: 
                subprocess.Popen(["xdg-open", path])
        self.btn_open_pdf_folder.bind("<Button-1>", lambda e: apri_cartella())
        
        self.label_data_spesa = ttk.Label(
            form_frame, 
            text="üìÖ Data Movimento:", 
            font=("Arial", 10, "bold"),
            style="BlinkAllarme.TLabel" 
        )
        self.label_data_spesa.grid(row=row, column=0, sticky="e", padx=5, pady=5)
        self.data_spesa_var = tk.StringVar(value=today.strftime("%d-%m-%Y"))
        
        data_frame = ttk.Frame(form_frame)
        data_frame.grid(row=row, column=1, columnspan=2, sticky="w")
        
        self.data_spesa_entry = ttk.Entry(
            data_frame,
            width=15,
            font=("Arial", 10, "bold"),
            textvariable=self.data_spesa_var
        )
        self.data_spesa_entry.pack(side="left")

        self.btn_cal_data_spesa = ttk.Button(
            data_frame,
            text="üóìÔ∏è",
            width=2,
            command=lambda: self.mostra_calendario_popup(self.data_spesa_entry, self.data_spesa_var),
            style="Yellow.TButton"
        )
             
        self.btn_cal_data_spesa.pack(side="left", padx=4)

        self.btn_reset_data_spesa = ttk.Button(
            data_frame,
            text="üîô",
            command=self.reset_data_spesa,
            style="Yellow.TButton"
        )
        self.btn_reset_data_spesa.pack(side="left", padx=4)

        self.blocca_data_var = tk.BooleanVar(value=False)
        self.checkbox_blocca_data = ttk.Checkbutton(
            data_frame,
            text="Blocca data",
            variable=self.blocca_data_var,
            command=self.on_blocca_data_changed
        )
        self.checkbox_blocca_data.pack(side="left", padx=4)
        btn_importa_popup = ttk.Button(data_frame, text="üì• Importa", command=self.apri_finestra_importa, style="Blu.TButton")
        btn_importa_popup.pack(side="left", padx=6)
        row += 1
        
        ttk.Label(form_frame, text="üîç Seleziona categoria:").grid(row=row, column=0, sticky="e")
        combo_frame = ttk.Frame(form_frame)
        combo_frame.grid(row=row, column=1, sticky="w", columnspan=2, pady=(4, 4))

        self.cat_sel = tk.StringVar(value=self.categorie[0])
        
        self.cat_menu = ttk.Combobox(combo_frame, textvariable=self.cat_sel, values=sorted(self.categorie), state="readonly", width=25, style="Border.TCombobox",font=("Arial", 10, "bold"))
        self.cat_menu.pack(side="left")
        
        self.label_smartcat = ttk.Label(combo_frame, text="üí° SmartCat attiva", foreground="red", font=("Arial", 9, "bold"))
        self.label_smartcat.pack(side="left", padx=(6, 0))
        self.btn_spese_simili = ttk.Button(combo_frame, text=f"üîç Voci simili ¬± {toll}", style="Low.Blu.TButton", command=self.mostra_spese_simili)
        self.btn_spese_simili.pack(side="left", padx=(6, 0))
        self.btn_spese_simili.pack_forget()

        if not self.suggerimenti_attivi:
            self.label_smartcat.config(text="üõ†Ô∏è SmartCat disattiva", foreground="green")
            self.aggiorna_bottone_spese_simili(visibile=False)
        else:
             self.label_smartcat.config(text="üí° SmartCat attiva", foreground="red")
             
        self.cat_menu.bind("<<ComboboxSelected>>", self.on_categoria_changed)
        row += 1
        
        ttk.Label(form_frame, text="‚ÑπÔ∏è Descrizione:").grid(row=row, column=0, sticky="e", pady=(4, 8))
        def convalida_descrizione(nuovo_valore_1):
         return len(nuovo_valore_1) <= 30

        vdesc = form_frame.register(convalida_descrizione)
        self.desc_entry = ttk.Entry(form_frame, width=30, validate="key", validatecommand=(vdesc, "%P"))
        self.desc_entry.grid(row=row, column=1, sticky="w")
        row += 1
        
        ttk.Label(form_frame, text="üí∞ Importo (‚Ç¨):‚èé").grid(row=row, column=0, sticky="e")
        importo_frame = ttk.Frame(form_frame)

        def convalida_input(nuovo_valore_2):
         if nuovo_valore_2 == "":
              return True  
         import re
         # Imposta massimo
         return len(nuovo_valore_2) <= 8 and re.match(r"^\d*[.,]?\d{0,2}$", nuovo_valore_2) is not None

        vcmd = form_frame.register(convalida_input)       
        self.imp_entry = ttk.Entry(importo_frame, width=12, validate="key", validatecommand=(vcmd, "%P"))  
        self.imp_entry.pack(side=tk.LEFT)      
        self.imp_entry.bind("<KeyRelease>", self.aggiorna_categoria_automatica)
        self.imp_entry.bind("<Return>", lambda event: self.add_spesa()) 
        self.imp_entry.bind("<KP_Enter>", lambda event: self.add_spesa()) 
        
        def start_blinking_callback(event):
            self.start_blinking(self.label_data_spesa)
            if self.STATO_CORRENTE != 0:
                self.mostra_treeview_statistiche()           
        def stop_blinking_callback(event):
            self.stop_blinking(self.label_data_spesa)
        
        self.imp_entry.bind('<FocusIn>', start_blinking_callback)
        self.imp_entry.bind('<FocusOut>', stop_blinking_callback)
        
        self.bind("<Map>", self._gestisci_ripristino_focus)
        
        importo_frame.grid(row=row, column=1, sticky="w")
        if hasattr(self, 'imp_entry'):
            self.after(0, self.imp_entry.focus_set)
        row += 1

        pannello_bottoni = ttk.Frame(form_frame)
        pannello_bottoni.grid(row=row, column=1, columnspan=8, sticky="w", pady=4)
        self.btn_aggiungi = ttk.Button(pannello_bottoni, text="üí∏ Aggiungi Movimento", command=self.add_spesa, cursor="arrow", style="Verde.TButton")
        self.btn_aggiungi.pack(side="left", padx=4)
        self.calc_button = ttk.Button(pannello_bottoni, text="üî¢", style="Yellow.TButton", command=self.apri_calcolatrice)
        self.calc_button.pack(side="left")
        self.btn_reset_form = ttk.Button(pannello_bottoni,text="üîô",width=2,command=self.reset_form, style="Giallo.TButton")
        self.btn_reset_form.pack(side="left", padx=(4, 0))
        self.btn_modifica = ttk.Button(pannello_bottoni, text="üíæ Salva Modifica", command=self.salva_modifica, state=tk.DISABLED, cursor="X_cursor", style="Verde.TButton")
        self.btn_modifica.pack(side="left", padx=4)
        self.btn_cancella = ttk.Button(pannello_bottoni, text="‚ùå Cancella", command=self.cancella_voce, state=tk.DISABLED, cursor="X_cursor", style="Rosso.TButton")
        self.btn_cancella.pack(side="left", padx=4)
        btn_ricorrenze = ttk.Button(pannello_bottoni, text="‚ôªÔ∏è Ricorrenze", command=lambda: self.mostra_ricorrenza_popup(), style="Blu.TButton")
        btn_ricorrenze.pack(side="left", padx=4)
        self.btn_gestisci_categorie = ttk.Button(pannello_bottoni, text="‚úì Categorie", command=lambda: self.mostra_categorie_popup(), style="Blu.TButton")
        self.btn_gestisci_categorie.pack(side="left", padx=4)
        btn_scadenze_mese = ttk.Button(pannello_bottoni, text="‚úì", command=lambda: self.scadenze_mese(), style="Blu.TButton", width=3)
        btn_scadenze_mese.pack(side="left", padx=4)

        row += 1

        cat_default_type = self.categorie_tipi.get(self.cat_sel.get(), "Uscita")
        self.tipo_spesa_var = tk.StringVar(value=cat_default_type)
        btn_style = 'GreenOutline.TButton' if self.tipo_spesa_var.get() == "Entrata" else 'RedOutline.TButton'
        self.btn_tipo_spesa = ttk.Button(
            importo_frame,
            text=self.tipo_spesa_var.get(),
            width=10,
            command=self.toggle_tipo_spesa,
            style=btn_style,
            takefocus=0
        )
        self.btn_tipo_spesa.pack(side=tk.LEFT, padx=8)
        self.metodo_pagamento_var = tk.StringVar(value="") 
        metodi = ["", "üí∞ Contanti", "üîÑ RID/SDD", "üè¶ Bonifico", "üíé C.Credito", "üí≥ C.Debito", ]
        self.metodo_pagamento_combobox = ttk.Combobox(
            importo_frame, 
            textvariable=self.metodo_pagamento_var, 
            values=metodi,
            state="readonly",
            style="Border.TCombobox",
            width=10
        )
        self.metodo_pagamento_combobox.pack(side=tk.LEFT, padx=4) 
        self.metodo_pagamento_combobox.bind("<<ComboboxSelected>>", self.aggiorna_descrizione_con_simbolo)
        row += 1
        self.lbl_tipo_percentuale = ttk.Label(importo_frame, text="", font=("Arial", 9, "bold"))
        self.lbl_tipo_percentuale.pack(side=tk.LEFT, padx=4)
        self.on_categoria_changed(manuale=False)
        self.refresh_gui()
        self.after(1000, self.check_aggiornamento_con_api)
        self.protocol("WM_DELETE_WINDOW", self._on_close)
      
        # Start Carosello
        if CAROSELLO:
            self.after(100, self.riavvia_scorrimento_automatico)
           
    def aggiorna_descrizione_con_simbolo(self, event=None):
        simboli_metodo = {
            "üí∞ Contanti": "üí∞",
            "üîÑ RID/SDD": "üîÑ",
            "üíé C.Credito": "üíé",
            "üí≥ C.Debito": "üí≥",
            "üè¶ Bonifico": "üè¶"
        }
        desc_attuale = self.desc_entry.get().strip()
        metodo_selezionato = self.metodo_pagamento_var.get()
        desc_pulita = desc_attuale
        simboli_possibili = list(simboli_metodo.values()) 
        simbolo_trovato = None
        for simbolo in simboli_possibili:
            if desc_pulita.startswith(simbolo):
                simbolo_trovato = simbolo
                desc_pulita = desc_pulita[len(simbolo_trovato):].lstrip() 
                break 
        nuovo_simbolo = simboli_metodo.get(metodo_selezionato, '')
        
        if not desc_pulita and metodo_selezionato:
            testo_base_da_inserire = metodo_selezionato
        else:
            testo_base_da_inserire = desc_pulita
            
        self.desc_entry.delete(0, tk.END)
        if nuovo_simbolo:
            nuova_desc = f"{nuovo_simbolo} {desc_pulita}".strip()
            self.desc_entry.insert(0, nuova_desc)
        else:
            self.desc_entry.insert(0, desc_pulita)
        self.desc_entry.icursor(tk.END)

    # Cicla
    def mostra_treeview_statistiche(self):
        self.STATO_CORRENTE = 0
        self.toggle_stats_view("tabella")
        self.btn_ciclico.config(text=self.LABEL_PROSSIMO_STATO[1])
    def cicla_visualizzazione_statistiche(self):
        NUOVO_STATO = (self.STATO_CORRENTE + 1) % len(self.STATI_VISTA)
        tipo_vista = self.STATI_VISTA[NUOVO_STATO]
        self.toggle_stats_view(tipo_vista)
        nuova_label = self.LABEL_PROSSIMO_STATO[NUOVO_STATO]
        self.btn_ciclico.config(text=nuova_label)
        self.STATO_CORRENTE = NUOVO_STATO
    def cicla_indietro(self, event=None):
        NUOVO_STATO = (self.STATO_CORRENTE - 1) % len(self.STATI_VISTA)
        tipo_vista = self.STATI_VISTA[NUOVO_STATO]
        self.toggle_stats_view(tipo_vista)
        nuova_label = self.LABEL_PROSSIMO_STATO[(NUOVO_STATO + 1) % len(self.STATI_VISTA)]
        self.btn_ciclico.config(text=nuova_label)
        self.STATO_CORRENTE = NUOVO_STATO
    
    # Start Carosello
    def attiva_binding_stop(self):
        root = self.winfo_toplevel()
        handler = self.handle_stop_carosello
        root.bind('<Motion>', handler)
        root.bind('<Any-KeyPress>', handler)
        root.bind('<Button-1>', handler)
    def disattiva_binding_stop(self):
        root = self.winfo_toplevel()
        try: root.unbind('<Motion>') 
        except: pass
        try: root.unbind('<Any-KeyPress>') 
        except: pass
        try: root.unbind('<Button-1>')
        except: pass
    def esegui_scorrimento_e_riprogramma(self):
        self.chiamato_da_carosello=True
        if not hasattr(self, 'STATI_VISTA'): return
        NUOVO_STATO = (self.STATO_CORRENTE + 1) % len(self.STATI_VISTA)
        tipo_vista = self.STATI_VISTA[NUOVO_STATO]
        self.toggle_stats_view(tipo_vista)   
        nuova_label = self.LABEL_PROSSIMO_STATO[NUOVO_STATO]
        if hasattr(self, 'btn_ciclico_carosello'):
            self.btn_ciclico_carosello.config(text=f"üîÑ{nuova_label}")
        self.STATO_CORRENTE = NUOVO_STATO
        self.id_scorrimento_automatico = self.after(
            self.intervallo_scorrimento, 
            self.esegui_scorrimento_e_riprogramma
        )
    def handle_stop_carosello(self, event=None):
        try:
            self.ferma_scorrimento_automatico()
        except Exception as e:
            pass
    def ferma_scorrimento_automatico(self):
        self.chiamato_da_carosello=False
        self.btn_ciclico_carosello.config(text="üîÑ")
        if hasattr(self, 'id_scorrimento_automatico') and self.id_scorrimento_automatico is not None:
            try:
                self.after_cancel(self.id_scorrimento_automatico) 
            except Exception:
                pass
            self.id_scorrimento_automatico = None
            self.STATO_CORRENTE = 0
            if hasattr(self, 'mostra_treeview_statistiche'):
                try:
                    self.mostra_treeview_statistiche()
                except Exception:
                    pass
            if hasattr(self, 'var_carosello_enabled'):
                self.var_carosello_enabled.set(False)
        self.disattiva_binding_stop()
    def riavvia_scorrimento_automatico(self):
        self.ferma_scorrimento_automatico() 
        self.id_scorrimento_automatico = self.after(
            self.intervallo_scorrimento, 
            self.esegui_scorrimento_e_riprogramma
        )
        self.attiva_binding_stop()
    def riavvia_scorrimento_manuale(self):
        self.ferma_scorrimento_automatico() 
        self.id_scorrimento_automatico = self.after(
            self.intervallo_scorrimento, 
            self.esegui_scorrimento_e_riprogramma
        )
    def toggle_carosello(self):
        if self.var_carosello_enabled.get():
            self.chiamato_da_carosello=True
            self.STATO_CORRENTE = -1 
            self.riavvia_scorrimento_manuale()
        else:
            self.chiamato_da_carosello=False
            self.ferma_scorrimento_automatico()
            if hasattr(self, 'btn_ciclico_carosello'):
                self.btn_ciclico_carosello.config(text="üîÑ")
                
    # Grafici Interni    
    def toggle_stats_view(self, tipo="grafico"):
        parent_frame = None
        try:
            if hasattr(self, 'vsb_stats'): self.vsb_stats.config(command="")
            if hasattr(self, 'hsb_stats'): self.hsb_stats.config(command="")
        except: pass
        if hasattr(self, 'stats_table') and self.stats_table and self.stats_table.winfo_exists():
            parent_frame = self.stats_table.master
            self.stats_table.destroy()
        if hasattr(self, 'stats_canvas') and self.stats_canvas and self.stats_canvas.winfo_exists():
            if parent_frame is None:
                parent_frame = self.stats_canvas.master
            self.stats_canvas.destroy()
        if parent_frame is None and hasattr(self, 'stats_container_frame'):
            parent_frame = self.stats_frame_ref
        for btn in self.filtri_temporali:
            btn.pack_forget()
        if hasattr(self, 'stats_label'):
            self.stats_label.grid_remove()
        if hasattr(self, 'totali_label'):
            self.totali_label.pack_forget()
        if tipo in ("grafico", "grafico_mensile", "grafico_saldo"):
            self.stats_canvas = tk.Canvas(parent_frame, bg="white")
            self.stats_canvas.pack(fill=tk.BOTH, expand=True)
            nomi_mesi_italiano = [
                "", "Gen", "Feb", "Mar", "Apr", "Mag", "Giu", 
                "Lug", "Ago", "Set", "Ott", "Nov", "Dic"
            ]
            oggi = datetime.date.today()
            anno_corrente = oggi.year
            if tipo == "grafico":
                self.stats_view_mode.set("grafico")
                category_totals = defaultdict(float)
                for giorno, entries in self.spese.items():
                    if giorno.year != anno_corrente: 
                        continue
                    for entry in entries:
                        if isinstance(entry, dict):
                            categoria = entry.get("categoria", "Altro")
                            importo = entry.get("importo", 0)
                            tipo_voce = entry.get("tipo", "")
                        elif isinstance(entry, tuple) and len(entry) >= 4:
                            categoria = entry[0]
                            importo = entry[2]
                            tipo_voce = entry[3]
                        else:
                            continue
                        if tipo_voce == "Uscita" and importo > 0:
                            category_totals[categoria] += importo
                self.data_for_chart = [{'label': cat, 'value': val} for cat, val in category_totals.items()]
                self.data_for_chart.sort(key=lambda x: x['value'], reverse=True)
                self.total_value = sum(item['value'] for item in self.data_for_chart)
                if not self.data_for_chart:
                    self.stats_canvas.after(50, lambda: self.stats_canvas.create_text(
                        self.stats_canvas.winfo_width() // 2, self.stats_canvas.winfo_height() // 2,
                        text="Nessuna spesa da visualizzare", font=("Helvetica", 16), fill="gray"
                    ))
                    return
                self.stats_canvas.bind("<Configure>", self.draw_bar_chart)
                self.stats_canvas.after(100, self.draw_bar_chart) 
            elif tipo == "grafico_mensile":
                self.visualizza_tutti_gli_anni = False
                self.stats_view_mode.set("grafico_mensile")
                mensili = defaultdict(lambda: {"Entrata": 0.0, "Uscita": 0.0})
                for giorno, entries in self.spese.items():
                    if giorno.year != anno_corrente: continue
                    for entry in entries:
                        if isinstance(entry, dict):
                            imp = entry.get("importo", 0)
                            tipo_voce = entry.get("tipo", "")
                        elif isinstance(entry, tuple) and len(entry) >= 4:
                            imp = entry[2]
                            tipo_voce = entry[3]
                        else: continue
                        mese = giorno.month
                        if tipo_voce in ("Entrata", "Uscita"):
                            mensili[mese][tipo_voce] += imp
                self.data_for_chart = []
                for mese in range(1, 13):
                    self.data_for_chart.append({
                        "label": nomi_mesi_italiano[mese],
                        "entrata": mensili[mese]["Entrata"],
                        "uscita": mensili[mese]["Uscita"]
                    })
                self.stats_canvas.bind("<Configure>", self.draw_mensile_chart)
                self.stats_canvas.after(100, self.draw_mensile_chart) 
            elif tipo == "grafico_saldo":
                self.visualizza_tutti_gli_anni = False
                self.stats_view_mode.set("grafico_saldo")
                mensili = defaultdict(lambda: {"Entrata": 0.0, "Uscita": 0.0})
                for giorno, entries in self.spese.items():
                    if giorno.year != anno_corrente: continue
                    for entry in entries:
                        if isinstance(entry, dict):
                            imp = entry.get("importo", 0)
                            tipo_voce = entry.get("tipo", "")
                        elif isinstance(entry, tuple) and len(entry) >= 4:
                            imp = entry[2]
                            tipo_voce = entry[3]
                        else: continue
                        mese = giorno.month
                        if tipo_voce == "Entrata":
                            mensili[mese]["Entrata"] += imp
                        elif tipo_voce == "Uscita":
                            mensili[mese]["Uscita"] += imp
                self.data_for_chart = []
                max_abs_val = 0
                for mese in range(1, 13):
                    saldo = mensili[mese]["Entrata"] - mensili[mese]["Uscita"]
                    self.data_for_chart.append({
                        "label": nomi_mesi_italiano[mese],
                        "saldo": saldo
                    })
                    if abs(saldo) > max_abs_val:
                        max_abs_val = abs(saldo)
                if max_abs_val == 0:
                    self.stats_canvas.after(50, lambda: self.stats_canvas.create_text(
                        self.stats_canvas.winfo_width() // 2, self.stats_canvas.winfo_height() // 2,
                        text="Nessun saldo disponibile (tutti i saldi sono zero).",
                        font=("Helvetica", 12), fill="gray"
                    ))
                    return
                self.stats_canvas.bind("<Configure>", self.draw_saldo_chart)
                self.stats_canvas.after(100, self.draw_saldo_chart) 
        else:
            self.stats_table = ttk.Treeview(parent_frame, columns=("A", "B", "C", "D", "E", "F"), show="headings")
            headers = {
                "A": "Data", "B": "Categoria", "C": "Descrizione",
                "D": "Importo (‚Ç¨)", "E": "Tipo", "F": "Modifica"
            }
            for col in headers:
                self.stats_table.heading(col, text=headers[col], command=lambda _col=col: self.treeview_sort_column(self.stats_table, _col, False))
            self.stats_table.column("A", width=100, anchor="center")
            self.stats_table.column("B", width=150, anchor="center")
            self.stats_table.column("C", width=250, anchor="w")
            self.stats_table.column("D", width=100, anchor="e")
            self.stats_table.column("E", width=80, anchor="center")
            self.stats_table.column("F", width=60, anchor="center")
            
            # Cambia stato in mese se il Carosello e' attivo
            if self.chiamato_da_carosello:
                self.set_stats_mode("mese")
            else:
                self.set_stats_mode("giorno")
            #self.set_stats_mode("giorno")
            
            self.stats_table.tag_configure("uscita", foreground="red")
            self.stats_table.tag_configure("entrata", foreground="green")
            self.stats_table.bind("<Double-1>", self.on_stats_table_double_click)
            self.stats_table.bind("<ButtonRelease-1>", self.on_table_click)
            self.stats_table.bind("<Button-3>", self.on_stats_table_right_click)
            self.stats_table.pack(fill=tk.BOTH, expand=True) 
            if hasattr(self, 'stats_label'):
                self.stats_label.grid()
            if hasattr(self, 'totali_label'):
                self.totali_label.pack(side=tk.LEFT)
            self.stats_view_mode.set("tabella")
            for btn in self.filtri_temporali:
                btn.pack(side=tk.LEFT, padx=1)
                
    def draw_bar_chart(self, event=None):
        if self.stats_view_mode.get() != "grafico":
            return
        if getattr(self, '_drawing_bar', False) or not self.stats_canvas.winfo_exists():
            return
        if event is not None and not hasattr(self, '_interno_ciclo'):
            self.stats_step = 0
            self.visualizza_tutti_gli_anni = False
        self._drawing_bar = True
        try:
            canvas = self.stats_canvas
            canvas.xview_moveto(0)
            canvas.update_idletasks()
            canvas.delete("all")
            for child in canvas.winfo_children():
                child.destroy()
            def ciclo_viste():
                if not canvas.winfo_exists(): return
                self.stats_step = (self.stats_step + 1) % 4
                self.visualizza_tutti_gli_anni = self.stats_step in [1, 3]
                self._interno_ciclo = True
                self.draw_bar_chart()
                if hasattr(self, '_interno_ciclo'): del self._interno_ciclo
            category_totals = defaultdict(float)
            income_totals = defaultdict(float)
            oggi = datetime.date.today()
            anno_corrente = oggi.year
            anni_presenti = [g.year for g in self.spese.keys() if hasattr(g, 'year')]
            min_anno = min(anni_presenti) if anni_presenti else anno_corrente
            periodo_str = f"{min_anno} - {anno_corrente}" if self.visualizza_tutti_gli_anni else str(anno_corrente)
            for giorno, entries in self.spese.items():
                if hasattr(giorno, "year") and (self.visualizza_tutti_gli_anni or giorno.year == anno_corrente):
                    for entry in entries:
                        if isinstance(entry, dict):
                            cat, imp, tipo = entry.get("categoria", "Altro"), entry.get("importo", 0), entry.get("tipo", "")
                        elif isinstance(entry, tuple) and len(entry) >= 4:
                            cat, imp, tipo = entry[0], entry[2], entry[3]
                        else: continue
                        try: imp = float(str(imp).replace(",", ".").replace("‚Ç¨", "").strip())
                        except: imp = 0
                        if str(tipo).lower() == "uscita" and imp > 0:
                            category_totals[cat] += imp
                        elif str(tipo).lower() == "entrata" and imp > 0:
                            income_totals[cat] += imp
            data_out = sorted([{'label': k, 'value': v} for k, v in category_totals.items() if v > 0], key=lambda x: x['value'], reverse=True)
            data_in = sorted([{'label': k, 'value': v} for k, v in income_totals.items() if v > 0], key=lambda x: x['value'], reverse=True)
            BAR_SPACE, CHART_LEFT = 40, 50
            c_height = canvas.winfo_height()
            if c_height < 200: c_height = 400
            c_width = canvas.winfo_width() if canvas.winfo_width() > 10 else 800
            CHART_TOP, CHART_BOTTOM = 80, c_height - 120 
            CHART_HEIGHT = CHART_BOTTOM - CHART_TOP
            num_bars = len(data_out) if self.stats_step < 2 else (len(data_out) + len(data_in))
            total_draw_width = CHART_LEFT + (num_bars * BAR_SPACE) + 150
            canvas.config(scrollregion=(0, 0, total_draw_width, c_height))
            titoli = ["üìä Uscite per Categoria", "üìä Uscite Storico", "‚öñÔ∏è Bilancio Anno", "üìú Bilancio Storico"]
            testi_btn = ["üóì Passa a Storico", "‚öñÔ∏è Bilancio Anno", "üìú Bilancio Storico", "üìä Torna a Categorie"]
            lbl_titolo = tk.Label(canvas, text=f"{titoli[self.stats_step]} ({periodo_str})", font=("Arial", 9, "bold"), bg="white", padx=5)
            self.win_titolo = canvas.create_window(10, 10, window=lbl_titolo, anchor="nw")
            btn_toggle = ttk.Button(canvas, text=testi_btn[self.stats_step], command=ciclo_viste, style="Blu.TButton")
            self.win_btn = canvas.create_window(c_width - 10, 10, window=btn_toggle, anchor="ne")
            t_in, t_out = sum(x['value'] for x in data_in), sum(x['value'] for x in data_out)
            saldo = t_in - t_out
            col_saldo = "#28a745" if saldo >= 0 else "#dc3545"
            frame_tot = tk.Frame(canvas, bg="white")
            if self.stats_step < 2:
                tk.Label(frame_tot, text=f"Totale Uscite: ‚Ç¨ {t_out:,.2f}", font=("Arial", 9, "bold"), fg="#dc3545", bg="white").pack(side="left")
            else:
                tk.Label(frame_tot, text=f"Entrate: ‚Ç¨ {t_in:,.2f}", font=("Arial", 9, "bold"), fg="#28a745", bg="white").pack(side="left")
                tk.Label(frame_tot, text=" | ", font=("Arial", 9), bg="white").pack(side="left")
                tk.Label(frame_tot, text=f"Uscite: ‚Ç¨ {t_out:,.2f}", font=("Arial", 9, "bold"), fg="#dc3545", bg="white").pack(side="left")
                tk.Label(frame_tot, text=" | Saldo: ", font=("Arial", 9, "bold"), bg="white", fg=col_saldo).pack(side="left")
                col_saldo = "#28a745" if saldo >= 0 else "#dc3545"
                tk.Label(frame_tot, text=f"‚Ç¨ {saldo:,.2f}", font=("Arial", 9, "bold"), fg=col_saldo, bg="white").pack(side="left")
            self.win_totale = canvas.create_window(10, c_height - 10, window=frame_tot, anchor="sw")
            visible_vals = [x['value'] for x in data_out] if self.stats_step < 2 else [x['value'] for x in data_out + data_in]
            max_v = max(visible_vals) if visible_vals else 1
            canvas.create_line(CHART_LEFT, CHART_BOTTOM, total_draw_width - 100, CHART_BOTTOM, width=2, fill="#888")
            COLORS = ["#36A2EB", "#FF6384", "#FFCE56", "#4BC0C0", "#9966FF", "#FF9F40"]
            def draw_item(x, val, label, color, tipo):
                h_barra = max((val / max_v) * CHART_HEIGHT, 4)
                tag = f"bar_{x}"
                canvas.create_rectangle(x-18, CHART_BOTTOM-h_barra, x+18, CHART_BOTTOM, fill=color, outline="#333", tags=tag)
                canvas.create_text(x, CHART_BOTTOM + 5, text=label, anchor="ne", angle=45, font=("Arial", 7, "bold"), fill=color)
                canvas.create_text(x, CHART_BOTTOM-h_barra-5, text=f"‚Ç¨{val:.0f}", anchor="s", font=("Arial", 7, "bold"), fill="#333")
                tooltip_txt = f"{label}: ‚Ç¨{val:,.2f}"
                canvas.tag_bind(tag, "<Enter>", lambda e, t=tooltip_txt: self.show_tooltip(e, t))
                canvas.tag_bind(tag, "<Leave>", lambda e: self.hide_tooltip())
                filtro = {"anno": None if self.visualizza_tutti_gli_anni else str(anno_corrente), "categoria": label, "tipo": tipo}
                canvas.tag_bind(tag, "<Double-1>", lambda e, f=filtro, l=label: self.mostra_transazioni_popup(f, f"Dettaglio {l}"))
            if self.stats_step < 2:
                for i, item in enumerate(data_out):
                    draw_item(CHART_LEFT + (i * BAR_SPACE) + 20, item['value'], item['label'], COLORS[i % len(COLORS)], "Uscita")
            else:
                for i, item in enumerate(data_in):
                    draw_item(CHART_LEFT + (i * BAR_SPACE) + 20, item['value'], item['label'], "#28a745", "Entrata")
                sep_x = CHART_LEFT + (len(data_in) * BAR_SPACE) + 20
                canvas.create_line(sep_x, CHART_BOTTOM, sep_x, CHART_TOP, dash=(4,4), fill="#ccc")
                for i, item in enumerate(data_out):
                    draw_item(sep_x + 40 + (i * BAR_SPACE), item['value'], item['label'], COLORS[i % len(COLORS)], "Uscita")
            def update_sticky(event=None):
                if not canvas.winfo_exists(): return
                ox = canvas.canvasx(0)
                canvas.coords(self.win_titolo, ox + 10, 10)
                canvas.coords(self.win_btn, ox + canvas.winfo_width() - 10, 10)
                canvas.coords(self.win_totale, ox + 10, canvas.winfo_height() - 10)
            canvas.config(xscrollcommand=lambda f, l: (self.hsb_stats.set(f, l), update_sticky() if canvas.winfo_exists() else None))
            self.hsb_stats.config(command=lambda *args: (canvas.xview(*args), update_sticky()) if canvas.winfo_exists() else None)
            update_sticky()
        finally:
            self._drawing_bar = False
                           
    def draw_mensile_chart(self, event=None):
        if self.stats_view_mode.get() != "grafico_mensile":
            return
        if getattr(self, '_drawing_mensile', False):
            return
        self._drawing_mensile = True
        try:
            canvas = self.stats_canvas
            canvas.xview_moveto(0)
            canvas.update_idletasks()
            canvas.delete("all")
            for child in canvas.winfo_children():
                child.destroy()
            mesi_completi = ["Gennaio", "Febbraio", "Marzo", "Aprile", "Maggio", "Giugno",
                             "Luglio", "Agosto", "Settembre", "Ottobre", "Novembre", "Dicembre"]
            if not hasattr(self, 'visualizza_tutti_gli_anni_mensile'):
                self.visualizza_tutti_gli_anni_mensile = False
            def toggle_anni():
                self.visualizza_tutti_gli_anni_mensile = not self.visualizza_tutti_gli_anni_mensile
                self.draw_mensile_chart()
            oggi = datetime.date.today()
            anno_corrente = oggi.year
            if self.visualizza_tutti_gli_anni_mensile:
                aggregati = {}
                for giorno, entries in self.spese.items():
                    if hasattr(giorno, "year"):
                        anno = giorno.year
                        if anno not in aggregati:
                            aggregati[anno] = {"label": str(anno), "entrata": 0.0, "uscita": 0.0}
                        for entry in entries:
                            tipo = entry[3] if isinstance(entry, tuple) else entry.get("tipo", "")
                            importo = float(entry[2]) if isinstance(entry, tuple) and len(entry) >= 4 else float(entry.get("importo", 0))
                            if tipo == "Entrata":
                                aggregati[anno]["entrata"] += importo
                            elif tipo == "Uscita":
                                aggregati[anno]["uscita"] += importo
                self.data_for_chart = [aggregati[anno] for anno in sorted(aggregati)]
            else:
                mesi_brevi = ["Gen", "Feb", "Mar", "Apr", "Mag", "Giu", "Lug", "Ago", "Set", "Ott", "Nov", "Dic"]
                mensili = [{"label": m, "entrata": 0.0, "uscita": 0.0} for m in mesi_brevi]
                for giorno, entries in self.spese.items():
                    if hasattr(giorno, "year") and giorno.year == anno_corrente:
                        mese_index = giorno.month - 1
                        for entry in entries:
                            tipo = entry[3] if isinstance(entry, tuple) else entry.get("tipo", "")
                            importo = float(entry[2]) if isinstance(entry, tuple) and len(entry) >= 4 else float(entry.get("importo", 0))
                            if tipo == "Entrata":
                                mensili[mese_index]["entrata"] += importo
                            elif tipo == "Uscita":
                                mensili[mese_index]["uscita"] += importo
                self.data_for_chart = mensili
            c_width = canvas.winfo_width() if canvas.winfo_width() > 10 else 800
            c_height = canvas.winfo_height() if canvas.winfo_height() > 10 else 400
            CHART_LEFT = 50
            CHART_RIGHT = c_width - 10
            CHART_TOP = 60
            CHART_BOTTOM = c_height - 80
            CHART_AREA_WIDTH = CHART_RIGHT - CHART_LEFT
            CHART_HEIGHT = CHART_BOTTOM - CHART_TOP
            if not self.data_for_chart or all(item["entrata"] == 0 and item["uscita"] == 0 for item in self.data_for_chart):
                canvas.create_text(c_width // 2, c_height // 2, text="Nessun dato disponibile.", font=("Arial", 12), fill="gray")
                return
            btn_text = "üóì Tutti gli anni" if not self.visualizza_tutti_gli_anni_mensile else "üìÖ Solo anno corrente"
            btn_toggle = ttk.Button(canvas, text=btn_text, command=toggle_anni, style="Blu.TButton")
            self.win_btn_mensile = canvas.create_window(c_width - 10, 10, window=btn_toggle, anchor="ne")
            titolo_g = f"üìä Movimenti Entrate/Uscite per Mese ({anno_corrente})"
            if self.visualizza_tutti_gli_anni_mensile:
                anni_p = [item["label"] for item in self.data_for_chart]
                label_p = f"({anni_p[0]} - {anni_p[-1]})" if anni_p else ""
                titolo_g = f"üìä Movimenti Entrate/Uscite Aggregate per Anno {label_p}"
            lbl_titolo = tk.Label(canvas, text=titolo_g, font=("Arial", 9, "bold"), bg="white", padx=5)
            self.win_titolo_mensile = canvas.create_window(10, 10, window=lbl_titolo, anchor="nw")
            max_value = max(max(item["entrata"], item["uscita"]) for item in self.data_for_chart)
            if max_value == 0: max_value = 1
            num_bars = len(self.data_for_chart)
            bar_space_total = CHART_AREA_WIDTH / num_bars
            bar_width = (bar_space_total * 0.95) / 2
            canvas.create_line(CHART_LEFT, CHART_BOTTOM, CHART_LEFT, CHART_TOP, fill="black", width=2)
            canvas.create_line(CHART_LEFT, CHART_BOTTOM, CHART_RIGHT, CHART_BOTTOM, fill="black", width=2)
            for i, item in enumerate(self.data_for_chart):
                x_center = CHART_LEFT + (i + 0.5) * bar_space_total
                h_e = max((item["entrata"] / max_value) * CHART_HEIGHT, 4 if item["entrata"] > 0 else 0)
                h_u = max((item["uscita"] / max_value) * CHART_HEIGHT, 4 if item["uscita"] > 0 else 0)         
                tag_e, tag_u = f"e_{i}", f"u_{i}"
                rect_e = canvas.create_rectangle(x_center-bar_width, CHART_BOTTOM-h_e, x_center, CHART_BOTTOM, 
                                                 fill="green", outline="black", tags=tag_e)
                rect_u = canvas.create_rectangle(x_center, CHART_BOTTOM-h_u, x_center+bar_width, CHART_BOTTOM, 
                                                 fill="red", outline="black", tags=tag_u)
                canvas.create_text(x_center, CHART_BOTTOM + 5, text=item["label"], anchor="ne", angle=45, font=("Arial", 8))
                if item['entrata'] > 0:
                    canvas.create_text(x_center - bar_width/2, CHART_BOTTOM-h_e-5, text=f"{item['entrata']:.0f}", 
                                        anchor="s", font=("Arial", 7), fill="green")
                if item['uscita'] > 0:
                    canvas.create_text(x_center + bar_width/2, CHART_BOTTOM-h_u-5, text=f"{item['uscita']:.0f}", 
                                        anchor="s", font=("Arial", 7), fill="red")
                if self.visualizza_tutti_gli_anni_mensile:
                    f_anno, f_mese = item["label"], None
                    p_text = f"Anno {item['label']}"
                else:
                    f_anno, f_mese = str(anno_corrente), i + 1
                    p_text = f"{mesi_completi[i]} {anno_corrente}"
                canvas.tag_bind(tag_e, "<Double-1>", lambda e, a=f_anno, m=f_mese, t=p_text: 
                    self.mostra_transazioni_popup({"anno": a, "mese": m, "categoria": None, "tipo": "Entrata"}, f"Transazioni {t} - Solo Entrate"))
                canvas.tag_bind(tag_u, "<Double-1>", lambda e, a=f_anno, m=f_mese, t=p_text: 
                    self.mostra_transazioni_popup({"anno": a, "mese": m, "categoria": None, "tipo": "Uscita"}, f"Transazioni {t} - Solo Uscite"))
                canvas.tag_bind(tag_e, "<Enter>", lambda e, v=item['entrata'], l=item['label']: self.show_tooltip(e, f"{l} - Entrata: ‚Ç¨{v:,.2f}"))
                canvas.tag_bind(tag_e, "<Leave>", self.hide_tooltip)
                canvas.tag_bind(tag_u, "<Enter>", lambda e, v=item['uscita'], l=item['label']: self.show_tooltip(e, f"{l} - Uscita: ‚Ç¨{v:,.2f}"))
                canvas.tag_bind(tag_u, "<Leave>", self.hide_tooltip)
            canvas.create_text(CHART_LEFT - 5, CHART_TOP, text=f"{max_value:,.0f}", anchor="e", font=("Arial", 8))
            canvas.create_text(CHART_LEFT - 5, CHART_BOTTOM, text="0", anchor="e", font=("Arial", 8))
            tot_e = sum(it["entrata"] for it in self.data_for_chart)
            tot_u = sum(it["uscita"] for it in self.data_for_chart)
            saldo = tot_e - tot_u
            lbl_footer = tk.Label(canvas, text=f"Entrate: ‚Ç¨{tot_e:,.2f}  |  Uscite: ‚Ç¨{tot_u:,.2f}  |  Saldo: ‚Ç¨{saldo:,.2f}", 
                                   font=("Arial", 9, "bold"), fg=("green" if saldo >= 0 else "red"), bg="white", padx=5)
            self.win_footer_mensile = canvas.create_window(c_width // 2, c_height - 10, window=lbl_footer, anchor="s")
            def update_sticky_mensile(event=None):
                ox = canvas.canvasx(0)
                cw, ch = canvas.winfo_width(), canvas.winfo_height()
                canvas.coords(self.win_titolo_mensile, ox + 10, 10)
                canvas.coords(self.win_btn_mensile, ox + cw - 10, 10)
                canvas.coords(self.win_footer_mensile, ox + cw // 2, ch - 10)
            update_sticky_mensile()
            canvas.bind("<Configure>", lambda e: (update_sticky_mensile(), self.draw_mensile_chart() if not hasattr(self, '_resizing') else None))
        finally:
            self._drawing_mensile = False
                      
    def show_tooltip(self, event, text):
        self.hide_tooltip()
        self.tooltip_window = tk.Toplevel(self.stats_canvas)
        self.tooltip_window.withdraw() 
        self.tooltip_window.wm_overrideredirect(True)
        label = ttk.Label(self.tooltip_window, text=text, style="Tooltip.TLabel")
        label.pack()
        self.tooltip_window.update_idletasks()
        tw = self.tooltip_window.winfo_reqwidth()
        th = self.tooltip_window.winfo_reqheight()
        x = event.x_root + 15
        y = event.y_root + 10
        screen_width = self.tooltip_window.winfo_screenwidth()
        screen_height = self.tooltip_window.winfo_screenheight()
        if x + tw > screen_width:
            x = event.x_root - tw - 10
        if y + th > screen_height:
            y = event.y_root - th - 10
        if x < 0:
            x = 10
        self.tooltip_window.wm_geometry(f"+{int(x)}+{int(y)}")
        self.tooltip_window.deiconify()
        self.tooltip_window.attributes("-alpha", 1.0)

    def hide_tooltip(self, event=None):
        if hasattr(self, 'tooltip_window') and self.tooltip_window:
            self.tooltip_window.destroy()
            self.tooltip_window = None
                           
    def draw_saldo_chart(self, event=None):
        if self.stats_view_mode.get() != "grafico_saldo":
            return
        if getattr(self, '_drawing_saldo', False):
            return
        self._drawing_saldo = True
        try:
            oggi = datetime.date.today()
            anno_corrente = oggi.year
            canvas = self.stats_canvas
            canvas.delete("all")
            canvas.update_idletasks()
            canvas_width = canvas.winfo_width()
            canvas_height = canvas.winfo_height()
            CHART_LEFT = 80
            CHART_RIGHT = canvas_width - 20
            CHART_TOP = 50
            NUOVO_SPAZIO_LEGENDA = 80  
            CHART_BOTTOM = canvas_height - NUOVO_SPAZIO_LEGENDA
            CHART_AREA_WIDTH = CHART_RIGHT - CHART_LEFT
            CHART_HEIGHT = CHART_BOTTOM - CHART_TOP
            NUOVO_OFFSET_TESTO = 30
            BAR_RATIO = 0.8
            mesi_completi = ["Gennaio", "Febbraio", "Marzo", "Aprile", "Maggio", "Giugno",
                              "Luglio", "Agosto", "Settembre", "Ottobre", "Novembre", "Dicembre"]
            if not hasattr(self, 'visualizza_saldo_totale'):
                self.visualizza_saldo_totale = False
            if not hasattr(self, 'visualizza_saldo_10_anni'):
                self.visualizza_saldo_10_anni = False
            if CHART_AREA_WIDTH < 100 or CHART_HEIGHT < 50:
                canvas.create_text(canvas_width // 2, canvas_height // 2,
                                    text="Area di disegno insufficiente.",
                                    font=("Arial", 12), fill="gray")
                return
            def toggle_saldo_mode():
                if not self.visualizza_saldo_totale and not self.visualizza_saldo_10_anni:
                    self.visualizza_saldo_totale = True
                    self.visualizza_saldo_10_anni = False
                elif self.visualizza_saldo_totale and not self.visualizza_saldo_10_anni:
                    self.visualizza_saldo_totale = False
                    self.visualizza_saldo_10_anni = True
                else:
                    self.visualizza_saldo_totale = False
                    self.visualizza_saldo_10_anni = False
                self.draw_saldo_chart()
            if self.visualizza_saldo_10_anni:
                btn_text = "üìÖ Solo anno corrente"
            elif self.visualizza_saldo_totale:
                btn_text = "üìà 10 anni (Linea)"
            else:
                btn_text = "üí∞ Tutti gli anni"
            btn_toggle = ttk.Button(canvas, text=btn_text, command=toggle_saldo_mode, style="Blu.TButton")
            self.win_btn_saldo = canvas.create_window(canvas_width - 10, 2, window=btn_toggle, anchor="ne")
            if self.visualizza_saldo_10_anni:
                transazioni_totali = []
                for giorno, entries in self.spese.items():
                    if hasattr(giorno, "year") and giorno >= self.saldo_data:
                        for entry in entries:
                            importo = float(entry[2]) if isinstance(entry, tuple) else float(entry.get("importo", 0))
                            tipo = entry[3] if isinstance(entry, tuple) else entry.get("tipo", "")
                            variazione = importo if tipo == "Entrata" else -importo
                            transazioni_totali.append({"data": giorno, "variazione": variazione})
                transazioni_totali.sort(key=lambda x: x["data"])
                saldo_cumulativo_corrente = self.saldo_iniziale
                saldi_mensili_cumulativi = {}
                if hasattr(self, 'saldo_data'):
                    saldi_mensili_cumulativi[self.saldo_data] = self.saldo_iniziale
                ultima_data_registrata = self.saldo_data
                for transazione in transazioni_totali:
                    data_transazione = transazione["data"]
                    if data_transazione.year != ultima_data_registrata.year or data_transazione.month != ultima_data_registrata.month:
                        ultima_data_registrata = data_transazione
                    saldo_cumulativo_corrente += transazione["variazione"]
                    if data_transazione.month == 12:
                        data_fine_mese = datetime.date(data_transazione.year + 1, 1, 1) - datetime.timedelta(days=1)
                    else:
                        data_fine_mese = datetime.date(data_transazione.year, data_transazione.month + 1, 1) - datetime.timedelta(days=1)
                    saldi_mensili_cumulativi[data_fine_mese] = saldo_cumulativo_corrente
                self.data_for_chart = []
                for data, saldo in sorted(saldi_mensili_cumulativi.items()):
                     self.data_for_chart.append({
                         "label": data.strftime("%m/%Y"),
                         "saldo": saldo,
                         "data": data
                     })
            elif self.visualizza_saldo_totale:
                aggregati_anno = {}
                for giorno, entries in self.spese.items():
                    if hasattr(giorno, "year"):
                        anno = giorno.year
                        if anno not in aggregati_anno:
                            aggregati_anno[anno] = 0.0
                        for entry in entries:
                            tipo = entry[3] if isinstance(entry, tuple) else entry.get("tipo", "")
                            importo = float(entry[2]) if isinstance(entry, tuple) else float(entry.get("importo", 0))
                            variazione = importo if tipo == "Entrata" else -importo
                            aggregati_anno[anno] += variazione
                self.data_for_chart = [
                    {"label": str(anno), "saldo": saldo}  
                    for anno, saldo in sorted(aggregati_anno.items())
                ]          
            else:
                mesi = ["Gen", "Feb", "Mar", "Apr", "Mag", "Giu", "Lug", "Ago", "Set", "Ott", "Nov", "Dic"]
                mensili_saldo = [{"label": m, "saldo": 0.0} for m in mesi]
                for giorno, entries in self.spese.items():
                    if hasattr(giorno, "year") and giorno.year == anno_corrente:
                        mese_index = giorno.month - 1
                        for entry in entries:
                            tipo = entry[3] if isinstance(entry, tuple) else entry.get("tipo", "")
                            importo = float(entry[2]) if isinstance(entry, tuple) else float(entry.get("importo", 0))
                            variazione = importo if tipo == "Entrata" else -importo
                            mensili_saldo[mese_index]["saldo"] += variazione
                self.data_for_chart = mensili_saldo
            if not hasattr(self, 'data_for_chart') or not self.data_for_chart:
                canvas.create_text(canvas_width // 2, canvas_height // 2,
                                    text="Nessun dato saldo disponibile.",
                                    font=("Arial", 12), fill="gray")
                return
            saldi = [item["saldo"] for item in self.data_for_chart]
            max_saldo = max(saldi)
            min_saldo = min(saldi)
            buffer = (max_saldo - min_saldo) * 0.1 or 100 
            y_max = max_saldo + buffer
            y_min = min_saldo - buffer
            y_range = y_max - y_min
            def scale_y(saldo):
                if y_range == 0:
                    return CHART_TOP + CHART_HEIGHT / 2
                return CHART_BOTTOM - ((saldo - y_min) / y_range) * CHART_HEIGHT
            if self.visualizza_saldo_10_anni:
                canvas.delete("y_labels", "axis")
                canvas.create_line(CHART_LEFT, CHART_BOTTOM, CHART_LEFT, CHART_TOP, fill="black", width=2, tags="axis")
                canvas.create_text(CHART_LEFT - 5, scale_y(max_saldo), text=f"‚Ç¨{max_saldo:,.0f}", anchor="e", font=("Arial", 8), fill="black", tags="y_labels")
                canvas.create_text(CHART_LEFT - 5, scale_y(min_saldo), text=f"‚Ç¨{min_saldo:,.0f}", anchor="e", font=("Arial", 8), fill="black", tags="y_labels")
                if y_min < 0 < y_max:
                    ZERO_LINE_Y = scale_y(0)
                    canvas.create_line(CHART_LEFT, ZERO_LINE_Y, CHART_RIGHT, ZERO_LINE_Y, fill="gray", width=1, dash=(5, 5), tags="axis")
                    canvas.create_text(CHART_LEFT - 5, ZERO_LINE_Y, text="0", anchor="e", font=("Arial", 8), fill="black", tags="y_labels")
                data_min = self.data_for_chart[0]['data']
                data_max = self.data_for_chart[-1]['data']
                data_range_days = (data_max - data_min).days or 1
                def scale_x(date):
                    if data_range_days == 0:
                        return CHART_LEFT + CHART_AREA_WIDTH / 2
                    days_since_start = (date - data_min).days
                    return CHART_LEFT + (days_since_start / data_range_days) * CHART_AREA_WIDTH
                points = []
                for i, item in enumerate(self.data_for_chart):
                    x = scale_x(item['data'])
                    y = scale_y(item['saldo'])
                    points.append((x, y))
                    
                    point_radius = 4
                    point_id = canvas.create_oval(x - point_radius, y - point_radius, 
                                                   x + point_radius, y + point_radius, 
                                                   fill="blue", outline="")
                    d_data = item['data']
                    popup_title = f"Transazioni {d_data.strftime('%m %Y')}"
                    d_filter = {
                        "anno": str(d_data.year),
                        "mese": d_data.month,
                        "categoria": None,
                        "tipo": None
                    }
                    canvas.tag_bind(point_id, "<Double-1>", 
                                    lambda e, f=d_filter, t=popup_title: self.mostra_transazioni_popup(f, t))
                    tooltip_text = f"Data: {item['label']}\nSaldo: ‚Ç¨{item['saldo']:,.2f}"
                    canvas.tag_bind(point_id, "<Enter>", lambda e, txt=tooltip_text: self.show_tooltip(e, txt))
                    canvas.tag_bind(point_id, "<Leave>", self.hide_tooltip)
                    if i == 0 or (item['data'].month == 1 and item['data'].day == 1) or i == len(self.data_for_chart) - 1:
                        canvas.create_text(x, CHART_BOTTOM + NUOVO_OFFSET_TESTO, text=item['data'].strftime("%Y"), anchor="n", angle=45, font=("Arial", 8))
                if len(points) > 1:
                    canvas.create_line(points, fill="blue", width=2, tags="line_chart")
            else:
                max_positive = max((item["saldo"] for item in self.data_for_chart if item["saldo"] >= 0), default=0) or 1
                max_negative = min((item["saldo"] for item in self.data_for_chart if item["saldo"] < 0), default=0) or -1
                ZERO_LINE_Y = CHART_TOP + CHART_HEIGHT / 2 
                canvas.delete("y_labels", "axis")
                canvas.create_line(CHART_LEFT, CHART_BOTTOM, CHART_LEFT, CHART_TOP, fill="black", width=2, tags="axis")
                canvas.create_line(CHART_LEFT, ZERO_LINE_Y, CHART_RIGHT, ZERO_LINE_Y, fill="gray", width=2, tags="axis")
                canvas.create_text(CHART_LEFT - 5, CHART_TOP, text=f"‚Ç¨{max_positive:,.0f}", anchor="e", font=("Arial", 8), fill="green", tags="y_labels")
                canvas.create_text(CHART_LEFT - 5, ZERO_LINE_Y, text="0", anchor="e", font=("Arial", 8), fill="black", tags="y_labels")
                canvas.create_text(CHART_LEFT - 5, CHART_BOTTOM, text=f"‚Ç¨{max_negative:,.0f}", anchor="e", font=("Arial", 8), fill="red", tags="y_labels")
                num_bars = len(self.data_for_chart)
                bar_space_total = CHART_AREA_WIDTH / num_bars
                bar_width = bar_space_total * BAR_RATIO
                for i, item in enumerate(self.data_for_chart):
                    saldo = item["saldo"]
                    if saldo >= 0:
                        bar_height = max((saldo / max_positive) * (CHART_HEIGHT / 2), 4 if saldo > 0 else 0)
                    else:
                        bar_height = max((abs(saldo) / abs(max_negative)) * (CHART_HEIGHT / 2), 4 if saldo < 0 else 0)
                    x_center = CHART_LEFT + (i + 0.5) * bar_space_total
                    x1 = x_center - bar_width / 2
                    x2 = x_center + bar_width / 2
                    if saldo >= 0:
                        y1 = ZERO_LINE_Y - bar_height
                        y2 = ZERO_LINE_Y
                        color = "green"
                        text_anchor = "s"
                        text_y = y1 - 5
                    else:
                        y1 = ZERO_LINE_Y
                        y2 = ZERO_LINE_Y + bar_height
                        color = "red"
                        text_anchor = "n"
                        text_y = y2 + 5
                    rect_id = canvas.create_rectangle(x1, y1, x2, y2, fill=color, outline="black")
                    if saldo != 0:
                        if self.visualizza_saldo_totale:
                            anno = item["label"]
                            popup_title = f"Transazioni per l'Anno {anno} (Entrate e Uscite)"
                            data_filter = {
                                "anno": anno,
                                "mese": None,
                                "categoria": None,
                                "tipo": None
                            }
                        else:
                            mese_index = i + 1  # 1-12
                            mese_nome = mesi_completi[i]
                            anno = str(anno_corrente)
                            popup_title = f"Transazioni per {mese_nome} {anno} (Entrate e Uscite)"
                            data_filter = {
                                "anno": anno,
                                "mese": mese_index,
                                "categoria": None,
                                "tipo": None
                            }
                        canvas.tag_bind(rect_id, "<Double-1>", 
                                        lambda e, f=data_filter, t=popup_title: 
                                            self.mostra_transazioni_popup(f, t))
                    canvas.tag_bind(rect_id, "<Enter>", lambda e, txt=f"{item['label']}: ‚Ç¨{saldo:,.2f}": self.show_tooltip(e, txt))
                    canvas.tag_bind(rect_id, "<Leave>", self.hide_tooltip)
                    canvas.create_text(x_center, CHART_BOTTOM + NUOVO_OFFSET_TESTO, text=item["label"], anchor="n", angle=45, font=("Arial", 8))
                    canvas.create_text(x_center, text_y, text=f"‚Ç¨{saldo:.0f}", anchor=text_anchor, font=("Arial", 8, "bold"), fill=color)
            total_entrata = 0.0
            total_uscita = 0.0
            anni_da_includere = set()
            data_min_vis = None
            data_max_vis = None
            if self.visualizza_saldo_10_anni and self.data_for_chart:
                  data_min_vis = self.data_for_chart[0]['data']
                  data_max_vis = self.data_for_chart[-1]['data']
            elif self.visualizza_saldo_totale:
                anni_da_includere = set([int(item["label"]) for item in self.data_for_chart if item["label"].isdigit()])
            else:
                anni_da_includere = {anno_corrente}
            for giorno, entries in self.spese.items():
                include_entry = False
                if self.visualizza_saldo_10_anni and data_min_vis and data_max_vis:
                      if hasattr(giorno, "year") and giorno >= self.saldo_data and giorno <= data_max_vis:
                          include_entry = True
                elif hasattr(giorno, "year") and giorno.year in anni_da_includere:
                      include_entry = True
                if include_entry:
                    for entry in entries:
                        tipo = entry[3] if isinstance(entry, tuple) else entry.get("tipo", "")
                        importo = float(entry[2]) if isinstance(entry, tuple) else float(entry.get("importo", 0))
                        if tipo == "Entrata":
                            total_entrata += importo
                        elif tipo == "Uscita":
                            total_uscita += importo
            total_saldo = total_entrata - total_uscita
            saldo_color = "green" if total_saldo >= 0 else "red"
            if self.visualizza_saldo_10_anni and self.data_for_chart:
                primo_anno = self.data_for_chart[0]['data'].year
                ultimo_anno = self.data_for_chart[-1]['data'].year
                label_periodo = f"({primo_anno} - {ultimo_anno})"
                titolo_grafico = f"üìà Saldo Conto Corrente Cumulativo {label_periodo}"
            elif self.visualizza_saldo_totale:
                anni_presenti = sorted(list(set([int(item["label"]) for item in self.data_for_chart if item["label"].isdigit()])))
                label_periodo = f"({anni_presenti[0]} - {anni_presenti[-1]})" if anni_presenti else "(N.D.)"
                titolo_grafico = f"üí∞ Saldo Netto Annuale Aggregato {label_periodo}"
            else:
                label_periodo = f"({anno_corrente})"
                titolo_grafico = f"üìÖ Saldo Netto Mensile {label_periodo}"
            canvas.create_text(canvas_width // 2, CHART_TOP / 3, 
                                text=titolo_grafico, 
                                font=("Arial", 8, "bold"), fill="black")
            text_y_pos = canvas_height - 20 
            x_pos_1 = CHART_LEFT + CHART_AREA_WIDTH * 0.15 
            x_pos_2 = CHART_LEFT + CHART_AREA_WIDTH * 0.5  
            x_pos_3 = CHART_LEFT + CHART_AREA_WIDTH * 0.85 
            font_style = ("Arial", 10, "bold")
            canvas.create_text(x_pos_1, text_y_pos, 
                                text=f"Totale Entrate: ‚Ç¨{total_entrata:,.2f}", 
                                anchor="center", font=font_style, fill="green")
            canvas.create_text(x_pos_2, text_y_pos, 
                                text=f"Totale Uscite: ‚Ç¨{total_uscita:,.2f}", 
                                anchor="center", font=font_style, fill="red")
            canvas.create_text(x_pos_3, text_y_pos, 
                                text=f"Saldo Complessivo: ‚Ç¨{total_saldo:,.2f}", 
                                anchor="center", font=font_style, fill=saldo_color)
            canvas.bind("<Configure>", lambda e: self.draw_saldo_chart() if not hasattr(self, '_resizing') else None)
        finally:
            self._drawing_saldo = False

    # Gestione Categorie
    def mostra_categorie_popup(self):
        import datetime
        if hasattr(self, 'categorie_popup') and self.categorie_popup.winfo_exists():
            self.categorie_popup.deiconify()
            self.categorie_popup.lift()
            self.categorie_popup.focus_force()
            self.cat_mod_menu.configure(style="Border.TCombobox")
            self.reset_campi_categoria() 
            return
        self.categorie_popup = tk.Toplevel(self, bg=self.COLOR_TOPLEVEL)
        self.categorie_popup.title("Gestione Categorie")
        self.categorie_popup.resizable(False, False)
        window_width = 650
        window_height = 200
        screen_width = self.winfo_screenwidth()
        screen_height = self.winfo_screenheight()
        center_x = int(screen_width / 2 - window_width / 2)
        center_y = int(screen_height / 2 - window_height / 2)
        self.categorie_popup.geometry(f'{window_width}x{window_height}+{center_x}+{center_y}')
        self.categorie_popup.bind("<Escape>", lambda event: self.categorie_popup.withdraw())
        main_frame = ttk.Frame(self.categorie_popup)
        main_frame.pack(padx=10, pady=10, fill="both", expand=True)
        aggiungi_cat_frame = ttk.LabelFrame(main_frame, text="‚úì Configurazione Categorie", style="RedBold.TLabelframe")
        aggiungi_cat_frame.pack(padx=5, pady=5, fill="both", expand=True)
        aggiungi_cat_frame.columnconfigure(1, weight=1)
        if not hasattr(self, 'nuova_cat'):
            self.nuova_cat = tk.StringVar()
            self.cat_mod_sel = tk.StringVar(value=self.categorie[0] if self.categorie else "")
            self.tipo_categoria = tk.StringVar(value="Uscita")
        def convalida_categoria(valore):
            return len(valore) <= 20
        vcmd_cat = aggiungi_cat_frame.register(convalida_categoria)
        ttk.Label(aggiungi_cat_frame, text="üîç Nome:").grid(row=0, column=0, sticky="e", padx=4, pady=2)
        self.entry_nuova_cat = ttk.Entry(
            aggiungi_cat_frame,
            textvariable=self.nuova_cat,
            width=22,
            validate="key",
            validatecommand=(vcmd_cat, "%P")
        )
        self.entry_nuova_cat.grid(row=0, column=1, sticky="w", padx=2, pady=2)
        ttk.Label(aggiungi_cat_frame, text="üìÇ Tipo:").grid(row=0, column=2, sticky="e", padx=4, pady=2)
        def toggle_tipo_spesa_popup_cat():
            tipo_corrente = self.tipo_categoria.get()
            nuovo_tipo = "Entrata" if tipo_corrente == "Uscita" else "Uscita"
            self.tipo_categoria.set(nuovo_tipo)
            self._aggiorna_stile_pulsante_tipo_popup()
        self.btn_gestisci_tipo = ttk.Button(
            aggiungi_cat_frame,
            text=self.tipo_categoria.get(),
            width=10,
            command=toggle_tipo_spesa_popup_cat,
            style='RedOutline.TButton',
            takefocus=0
        )
        self.btn_gestisci_tipo.grid(row=0, column=3, sticky="w", padx=2, pady=2)
        self._aggiorna_stile_pulsante_tipo_popup()
        ttk.Label(aggiungi_cat_frame, text="‚öôÔ∏è Modifica:").grid(row=1, column=0, sticky="e", padx=4, pady=2)
        self.cat_mod_menu = ttk.Combobox(
            aggiungi_cat_frame,
            textvariable=self.cat_mod_sel,
            values=sorted(self.categorie),
            style="Border.TCombobox",
            state="readonly",
            width=22
        )
        self.cat_mod_menu.grid(row=1, column=1, sticky="w", padx=2, pady=2)
        self.cat_mod_menu.bind("<<ComboboxSelected>>", lambda e: self.on_categoria_modifica_changed_popup())
        btn_frame_cat = ttk.Frame(aggiungi_cat_frame)
        btn_frame_cat.grid(row=2, column=0, columnspan=2, pady=10)
        ttk.Button(btn_frame_cat, text="‚ûï Aggiungi", command=self.add_categoria, style="Verde.TButton").pack(side="left", padx=2)
        self.btn_modifica_categoria = ttk.Button(btn_frame_cat, text="‚öôÔ∏è Modifica", command=self.modifica_categoria, style="Verde.TButton")
        self.btn_modifica_categoria.pack(side="left", padx=2)
        self.btn_cancella_categoria = ttk.Button(btn_frame_cat, text="‚ùå Cancella", command=self.cancella_categoria, style="Rosso.TButton")
        self.btn_cancella_categoria.pack(side="left", padx=2)
        ttk.Button(btn_frame_cat, text="‚ú®", command=self.apri_categorie_suggerite, style="Arancio.TButton", width=2).pack(side="left", padx=2)
        ttk.Button(btn_frame_cat, text="üìÑ", command=self.apri_cancella_multiplo, style="Yellow.TButton").pack(side="left", padx=2)
        ttk.Button(btn_frame_cat, text="üìã Elenco", command=self.mostra_tutte_le_categorie, style="Arancio.TButton").pack(side="left", padx=2)
        ttk.Button(btn_frame_cat,text="üîô", width=2, command=self.reset_campi_categoria,style="Giallo.TButton").pack(side="left", padx=2)
        ttk.Button(main_frame, text="‚ùå Chiudi", command=self.categorie_popup.withdraw, style="Giallo.TButton").pack(side="bottom", pady=(0, 2))
        self.aggiorna_combobox_categorie()
        self.reset_campi_categoria()
        if not self.categorie:
            self.cat_mod_menu['state'] = 'disabled'

    def _aggiorna_stile_pulsante_tipo_popup(self):
        tipo = self.tipo_categoria.get()
        btn_style = 'GreenOutline.TButton' if tipo == "Entrata" else 'RedOutline.TButton'
        self.btn_gestisci_tipo.config(
            text=tipo,
            style=btn_style
        )
    def on_categoria_modifica_changed_popup(self):
        nome = self.cat_mod_sel.get()
        tipo = self.categorie_tipi.get(nome, "Uscita")
        self.nuova_cat.set(nome)
        self.tipo_categoria.set(tipo)
        self._aggiorna_stile_pulsante_tipo_popup()
    def on_categoria_modifica_changed(self):
        nome = self.cat_mod_sel.get()
        tipo = self.categorie_tipi.get(nome, "Uscita")
        self.nuova_cat.set(nome)  
        self.tipo_categoria.set(tipo)
    def reset_campi_categoria(self):
        self.nuova_cat.set("")                          
        self.cat_mod_sel.set("")                        
        self.tipo_categoria.set("Uscita")    
        self._aggiorna_stile_pulsante_tipo_popup()           
    def reset_ricorrenza_popup(self):
        oggi = datetime.date.today().strftime("%d-%m-%Y")
        self.importo_ricorrenza.set("")
        self.ricorrenza_tipo.set("Nessuna")
        self.ricorrenza_n.set(1)
        self.ricorrenza_data_inizio.set(oggi)
        self.ricorrenza_cat_sel.set(self.categorie[0])
        self.ricorrenza_desc.set("")
        self.ricorrenza_imp.set("")
        self.ricorrenza_bloccata = False
        self.ricorrenza_tipo_voce.set("Uscita")
        self.aggiorna_stile_tipo_voce_popup()
        self.ric_percentuali_label.config(text="0% Entrate / 0% Uscite")
        self.label_smartcat_ric.config(text="üõ†Ô∏è SmartCat in attesa...", foreground="gray")
        self.ric_cat_menu.configure(style="Border.TCombobox")

    # Popup gestione e pianificazione ricorrenze
    def mostra_ricorrenza_popup(self):
        oggi = datetime.date.today().strftime("%d-%m-%Y")
        if hasattr(self, 'ricorrenza_popup') and self.ricorrenza_popup.winfo_exists():
            self.reset_ricorrenza_popup()
            self.ricorrenza_popup.deiconify()
            self.ricorrenza_popup.lift()
            self.ric_cat_menu.configure(style="Border.TCombobox")
            self.ric_combo.configure(style="Border.TCombobox")
            if hasattr(self, 'ric_imp_entry'):
                self.ricorrenza_popup.after(100, self.ric_imp_entry.focus_set) 
            return
        self.ricorrenza_popup = tk.Toplevel(self, bg=self.COLOR_TOPLEVEL)
        self.ricorrenza_popup.title("Gestione Ricorrenze")
        self.ricorrenza_popup.resizable(False, False)
        self.ricorrenza_popup.protocol(
            "WM_DELETE_WINDOW", 
            lambda: (
                self.ricorrenza_popup.withdraw(), 
                (self.popup_calendario.destroy(), setattr(self, 'popup_calendario', None))
                if hasattr(self, 'popup_calendario') and self.popup_calendario and self.popup_calendario.winfo_exists()
                else None,
                setattr(self, 'ricorrenza_bloccata', False) 
            )
        )
        self.ricorrenza_bloccata = False
        self.ricorrenza_popup.bind(
            "<Escape>", 
            lambda event: (
                self.ricorrenza_popup.withdraw(),
                (self.popup_calendario.destroy(), setattr(self, 'popup_calendario', None))
                if hasattr(self, 'popup_calendario') and self.popup_calendario and self.popup_calendario.winfo_exists()
                else None,
                setattr(self, 'ricorrenza_bloccata', False) 
            )
        )
        window_width = 650
        window_height = 250
        screen_width = self.winfo_screenwidth()
        screen_height = self.winfo_screenheight()
        center_x = int(screen_width/2 - window_width/2)
        center_y = int(screen_height/2 - window_height/2)
        self.ricorrenza_popup.geometry(f'{window_width}x{window_height}+{center_x}+{center_y}')
        if not hasattr(self, 'importo_ricorrenza'):
            self.importo_ricorrenza = tk.StringVar()
            self.ricorrenza_tipo = tk.StringVar(value="Nessuna")
            self.ricorrenza_n = tk.IntVar(value=1)
            self.ricorrenza_data_inizio = tk.StringVar(value=oggi)
            self.ricorrenza_cat_sel = tk.StringVar(value=self.categorie[0])
            self.ricorrenza_desc = tk.StringVar()
            self.ricorrenza_imp = tk.StringVar()
            self.ricorrenza_tipo_voce = tk.StringVar(value="Uscita")
            self.ricorrenza_bloccata = False
        def on_ric_cat_selected(event=None, manuale=True):
            if manuale:
                self.ricorrenza_bloccata = True
                self.label_smartcat_ric.config(text="üõ†Ô∏è SmartCat disattivata", foreground="green")
                self.ric_percentuali_label.config(text="0% Entrate / 0% Uscite")
            categoria = self.ricorrenza_cat_sel.get()
            tipo = self.categorie_tipi.get(categoria, "Uscita")
            self.ricorrenza_tipo_voce.set(tipo)
            self.aggiorna_stile_tipo_voce_popup()
            if self.ricorrenza_bloccata:
                self.ric_cat_menu.configure(style="Border.TCombobox")
        def aggiorna_categoria_automatica_ricorrenza(*args):
            valore_imp = self.ricorrenza_imp.get().replace(",", ".").strip()
            if not valore_imp:
                self.ric_percentuali_label.config(text="0% Entrate / 0% Uscite")
                self.ricorrenza_bloccata = False
                self.ricorrenza_cat_sel.set("Generica")
                self.ricorrenza_tipo_voce.set("Uscita")
                self.aggiorna_stile_tipo_voce_popup()
                self.label_smartcat_ric.config(text="üõ†Ô∏è SmartCat in attesa...", foreground="gray")
                self.ric_cat_menu.configure(style="Border.TCombobox")
                return
            if self.ricorrenza_bloccata:
                return
            try:
                imp_corrente = float(valore_imp)
            except ValueError:
                self.ric_percentuali_label.config(text="0% Entrate / 0% Uscite")
                return
            oggi_ric = datetime.date.today()
            un_anno_fa = oggi_ric - datetime.timedelta(days=365)
            frequenze_per_categoria_tipo = {}
            for d, lista in self.spese.items():
                if d < un_anno_fa:
                    continue
                for voce in lista:
                    try:
                        categoria, _, importo, tipo = voce[:4]
                        if categoria not in frequenze_per_categoria_tipo:
                            frequenze_per_categoria_tipo[categoria] = {"Entrata": 0, "Uscita": 0, "importi": []}
                        frequenze_per_categoria_tipo[categoria][tipo] += 1
                        frequenze_per_categoria_tipo[categoria]["importi"].append(importo)
                    except (ValueError, IndexError):
                        continue
            if not self.suggerimenti_attivi:
                self.ricorrenza_bloccata = False
                self.label_smartcat_ric.config(text="üõ†Ô∏è SmartCat disattivata", foreground="green")
                self.ric_cat_menu.configure(style="Border.TCombobox")
                categoria_selezionata = self.ricorrenza_cat_sel.get()
                percentuale_entrate, percentuale_uscite = 0.0, 0.0
                if categoria_selezionata in frequenze_per_categoria_tipo:
                    conteggi = frequenze_per_categoria_tipo[categoria_selezionata]
                    totale = conteggi["Entrata"] + conteggi["Uscita"]
                    if totale > 0:
                        percentuale_entrate = (conteggi["Entrata"] / totale) * 100
                        percentuale_uscite = (conteggi["Uscita"] / totale) * 100
                self.ric_percentuali_label.config(text=f'{percentuale_entrate:.0f}% Entrate / {percentuale_uscite:.0f}% Uscite')
                return
            miglior_punteggio = float("inf")
            categoria_migliore = None
            if frequenze_per_categoria_tipo:
                for categoria, dati in frequenze_per_categoria_tipo.items():
                    if not dati["importi"]:
                        continue
                    media_importi = sum(dati["importi"]) / len(dati["importi"])
                    diff = abs(media_importi - imp_corrente)
                    bonus_frequenza = math.log(dati["Entrata"] + dati["Uscita"] + 1) * 0.5
                    punteggio = diff - bonus_frequenza
                    if punteggio < miglior_punteggio:
                        miglior_punteggio = punteggio
                        categoria_migliore = categoria
            if categoria_migliore and not self.ricorrenza_bloccata:
                self.ricorrenza_cat_sel.set(categoria_migliore)
                conteggi = frequenze_per_categoria_tipo.get(categoria_migliore, {"Entrata": 0, "Uscita": 0})
                totale = conteggi["Entrata"] + conteggi["Uscita"]
                if totale > 0:
                    percentuale_entrate = (conteggi["Entrata"] / totale) * 100
                    percentuale_uscite = (conteggi["Uscita"] / totale) * 100
                else:
                    percentuale_entrate, percentuale_uscite = 0.0, 0.0
                colore_percentuale = "black"
                if percentuale_entrate > percentuale_uscite:
                    colore_percentuale = "forestgreen"
                elif percentuale_uscite > percentuale_entrate:
                    colore_percentuale = "firebrick"
                self.ric_percentuali_label.config(
                    text=f'{percentuale_entrate:.0f}% Entrate / {percentuale_uscite:.0f}% Uscite',
                    foreground=colore_percentuale
                )
                on_ric_cat_selected(manuale=False)
                self.label_smartcat_ric.config(text="üí° SmartCat attiva", foreground="red")
                self.ric_cat_menu.configure(style="Highlight.TCombobox")
                self.ric_cat_menu.after(500, lambda: self.ric_cat_menu.configure(style="Border.TCombobox"))
                self.label_smartcat_ric.config(text="üí° SmartCat attiva", foreground="red")
                self.ric_cat_menu.configure(style="Highlight.TCombobox")
                self.ric_cat_menu.after(2000, lambda: self.ric_cat_menu.configure(style="Border.TCombobox"))
        self.ricorrenza_imp.trace_add("write", aggiorna_categoria_automatica_ricorrenza)
        ric_frame = ttk.LabelFrame(self.ricorrenza_popup, text="üîÑ Pianificazione Ricorrenze", style="RedBold.TLabelframe")
        ric_frame.pack(padx=10, pady=10, fill="both", expand=True)
        row = 0
        ttk.Label(ric_frame, text="üîç Categoria:").grid(row=row, column=0, sticky="e", padx=2, pady=2)
        self.ric_cat_menu = ttk.Combobox(ric_frame, textvariable=self.ricorrenza_cat_sel, values=sorted(self.categorie), state="readonly", style="Border.TCombobox", width=22, font=("Arial", 10, "bold"))
        self.ric_cat_menu.grid(row=row, column=1, sticky="w", padx=2, pady=2)
        self.ric_cat_menu.bind("<<ComboboxSelected>>", on_ric_cat_selected)
        info_frame = ttk.Frame(ric_frame)
        info_frame.grid(row=row, column=2, columnspan=5, sticky="w", padx=2, pady=2)
        self.label_smartcat_ric = ttk.Label(info_frame, text="üõ†Ô∏è SmartCat in attesa...", foreground="gray")
        self.label_smartcat_ric.pack(side="left", padx=2, pady=2)
        row += 1
        ttk.Label(ric_frame, text="üí∞ Importo (‚Ç¨):").grid(row=row, column=0, sticky="e", padx=2, pady=2)
        ttk.Button(ric_frame, text="üõ†", style="Yellow.TButton", command=self.apri_calcolatrice).grid(row=row, column=1, sticky="e", padx=2, pady=2)
        def convalida_importo(valore):
            if valore == "":
              return True  
            import re
            return len(valore) <= 7 and re.fullmatch(r"^\d*[.,]?\d{0,2}$", valore) is not None
        vcmd_importo = ric_frame.register(convalida_importo)  
        self.ric_imp_entry = ttk.Entry(ric_frame, width=20, textvariable=self.ricorrenza_imp, validate="key", validatecommand=(vcmd_importo, "%P"))  
        self.ric_imp_entry.grid(row=row, column=1, sticky="w", padx=2, pady=2)
        self.ric_imp_entry.focus_set()
        
        def start_blinking_callback_ric(event):
            if hasattr(self, 'lbl_ric_inizio'):
                self.start_blinking(self.lbl_ric_inizio)
            if self.STATO_CORRENTE != 0:
                self.mostra_treeview_statistiche()
        def stop_blinking_callback_ric(event):
            if hasattr(self, 'lbl_ric_inizio'):
                self.stop_blinking(self.lbl_ric_inizio)

        self.ric_imp_entry.bind('<FocusIn>', start_blinking_callback_ric)
        self.ric_imp_entry.bind('<FocusOut>', stop_blinking_callback_ric)
        self.ric_percentuali_label = ttk.Label(info_frame, text="0% Entrate / 0% Uscite")
        self.ric_percentuali_label.pack(side="left", padx=2, pady=2)
        row += 1
        ttk.Label(ric_frame, text="‚ÑπÔ∏è Descrizione:").grid(row=row, column=0, sticky="e", padx=2, pady=2)
        
        def convalida_descrizione(valore):
            return len(valore) <= 30
        vdesc = ric_frame.register(convalida_descrizione)
        self.ric_desc_entry = ttk.Entry(ric_frame, width=25, textvariable=self.ricorrenza_desc, validate="key", validatecommand=(vdesc, "%P"))
        self.ric_desc_entry.grid(row=row, column=1, sticky="w", padx=2, pady=2)
        row += 1
        ttk.Label(ric_frame, text="Tipo:").grid(row=row, column=0, sticky="e", padx=2, pady=2)
        self.ricorrenza_tipo_voce.set("Uscita")
        def toggle_tipo_voce():
            tipo_corrente = self.ricorrenza_tipo_voce.get()
            nuovo_tipo = "Entrata" if tipo_corrente == "Uscita" else "Uscita"
            self.ricorrenza_tipo_voce.set(nuovo_tipo)
            self.aggiorna_stile_tipo_voce_popup()
        def aggiorna_stile_tipo_voce_popup():
            tipo = self.ricorrenza_tipo_voce.get()
            if tipo == "Entrata":
                stile_da_applicare = "GreenOutline.TButton"
            else:
                stile_da_applicare = "RedOutline.TButton"
            self.btn_tipo_voce.config(
                text=tipo,
                style=stile_da_applicare
            )
        self.btn_tipo_voce = ttk.Button(
            ric_frame,
            text=self.ricorrenza_tipo_voce.get(),
            command=toggle_tipo_voce,
            style=("GreenOutline.TButton" if self.ricorrenza_tipo_voce.get() == "Entrata" else "RedOutline.TButton")
        )
        self.btn_tipo_voce.grid(row=row, column=1, sticky="w", padx=2, pady=2)
        self.aggiorna_stile_tipo_voce_popup = aggiorna_stile_tipo_voce_popup
        self.aggiorna_stile_tipo_voce_popup()
        row += 1
        ripeti_frame = ttk.Frame(ric_frame)
        ripeti_frame.grid(row=row, column=0, columnspan=6, sticky="w", padx=2, pady=2)
        ttk.Label(ripeti_frame, text="üìÖ Ripeti:").pack(side="left", padx=2, pady=2)
        self.ric_combo = ttk.Combobox(ripeti_frame, values=["Nessuna", "Ogni giorno", "Ogni mese", "Ogni anno"], width=10, state="readonly", style="Border.TCombobox", textvariable=self.ricorrenza_tipo)
        self.ric_combo.pack(side="left", padx=2, pady=2)
        ttk.Label(ripeti_frame, text="Ripeti volte:").pack(side="left", padx=10, pady=2)

        def convalida_ric_n(valore):
            if valore == "":
                self.ricorrenza_n.set(1) 
                return True
            try:
                n = int(valore)
                return True
            except ValueError:
                self.ricorrenza_n.set(1)
                return False
        self.ric_n_entry = ttk.Entry(
            ripeti_frame,
            width=4,
            textvariable=self.ricorrenza_n,
        )
        self.ric_n_entry.pack(side="left", padx=2, pady=2)
        self.ric_n_entry.bind("<FocusOut>", lambda event: convalida_ric_n(self.ricorrenza_n.get()))
        self.ric_n_entry.bind("<Return>", lambda event: convalida_ric_n(self.ricorrenza_n.get()))
        self.ric_n_entry.bind("<KP_Enter>", lambda event: convalida_ric_n(self.ricorrenza_n.get()))
        self.lbl_ric_inizio = ttk.Label(ripeti_frame, text="Data Inizio:", style="BlinkAllarme.TLabel")
        self.lbl_ric_inizio.pack(side="left", padx=10, pady=2) 
        ric_data_frame = ttk.Frame(ripeti_frame)
        ric_data_frame.pack(side="left")
        self.ric_data_entry = ttk.Entry(ric_data_frame, textvariable=self.ricorrenza_data_inizio, width=15, font=("Arial", 10, "bold"))
        self.ric_data_entry.pack(side="left") 
        btn_cal_popup = ttk.Button(
            ric_data_frame,
            text="üóìÔ∏è",
            command=lambda: self.mostra_calendario_popup(self.ric_data_entry, self.ricorrenza_data_inizio),
            style="Yellow.TButton"
        )
        btn_cal_popup.pack(side="left", padx=4)
        self.btn_reset_ric_data = ttk.Button(
            ric_data_frame,
            text="üîô",
            command=self.reset_ric_data_inizio,
            style="Yellow.TButton"
        )
        self.btn_reset_ric_data.pack(side="left", padx=4)
        row += 1 
        btn_frame = tk.Frame(self.ricorrenza_popup, bg=self.COLOR_TOPLEVEL)
        btn_frame.pack(pady=10)
        self.btn_add_ricorrenza = ttk.Button(btn_frame, text="üìÇ Aggiungi", command=self.add_ricorrenza, style="Verde.TButton")
        self.btn_add_ricorrenza.pack(side="left", padx=4)
        self.btn_reset_ricorrenza = ttk.Button(btn_frame, text="üîô", width=2, style="Giallo.TButton", command=self.reset_ricorrenza_popup)
        self.btn_reset_ricorrenza.pack(side="left", padx=4)
        self.btn_modifica_ricorrenza = ttk.Button(btn_frame, text="‚ôªÔ∏è Lista", command=self.mostra_lista_ricorrenze, style="Arancio.TButton")
        self.btn_modifica_ricorrenza.pack(side="left", padx=4)
        self.btn_chiudi_ricorrenza = ttk.Button(btn_frame, text="‚ùå Chiudi", command=self.ricorrenza_popup.withdraw, style="Giallo.TButton")
        self.btn_chiudi_ricorrenza.pack(side="left", padx=4)
 
    # Gestione Promemoria
    def gestisci_promemoria(self):
        if hasattr(self, '_promemoria_popup') and self._promemoria_popup and self._promemoria_popup.winfo_exists():
            self._promemoria_popup.lift()
            return
        def chiudi_promemoria_popup():
            try:
                promemoria_popup.grab_release()
            except:
                pass 
            promemoria_popup.destroy()
            self._promemoria_popup = None
        def salva_promemoria():
            promemoria_text = promemoria_text_widget.get("1.0", tk.END).strip()
            data = {"promemoria": promemoria_text} 
            try:
                with open(PROMEMORIA_FILE, "w", encoding="utf-8") as f:
                    json.dump(data, f, indent=4)
                self.show_custom_warning("Salvataggio", "Promemoria salvato con successo!")
                chiudi_promemoria_popup()
            except Exception as e:
                self.show_custom_warning("Errore", f"Impossibile salvare il file: {e}")
        def carica_promemoria():
            if os.path.exists(PROMEMORIA_FILE):
                try:
                    with open(PROMEMORIA_FILE, "r", encoding="utf-8") as f:
                        data = json.load(f)
                    promemoria = data.get("promemoria", "")
                    promemoria_text_widget.delete("1.0", tk.END)
                    promemoria_text_widget.insert("1.0", promemoria)
                except (json.JSONDecodeError, FileNotFoundError) as e:
                    self.show_custom_warning("Errore", f"Impossibile caricare il file promemoria.json: {e}")
                    pass
        def esporta_promemoria():
            now = datetime.date.today()
            promemoria_text = promemoria_text_widget.get("1.0", tk.END).strip()
            filename = f"Promemoria_Export_{now.day:02d}-{now.month:02d}-{now.year}.txt"
            file = filedialog.asksaveasfilename(
                defaultextension=".txt",
                filetypes=[("File di testo", "*.txt"), ("Tutti i file", "*.*")],
                initialdir=EXPORT_FILES,
                initialfile=filename,
                title="Esporta Promemoria",
                confirmoverwrite=False,
                parent=promemoria_popup
            )
            if file:
                if os.path.exists(file):
                    conferma = self.show_custom_askyesno(
                        "Sovrascrivere file?",
                        f"Il file '{os.path.basename(file)}' \nesiste gi√†. Vuoi sovrascriverlo?"
                    )
                    if not conferma:
                        return
                
                try:
                    with open(file, "w", encoding="utf-8") as f:
                        f.write(promemoria_text)  
                    self.show_custom_warning("Esportazione", "Promemoria esportato con successo!")
                except Exception as e:
                    self.show_custom_warning("Errore", f"Impossibile salvare il file: {e}")
        if hasattr(self, 'popup_calendario') and self.popup_calendario and self.popup_calendario.winfo_exists():
            self.popup_calendario.destroy()
            self.popup_calendario = None
        promemoria_popup = tk.Toplevel(self)
        self._promemoria_popup = promemoria_popup
        promemoria_popup.title("üìù Promemoria")
        promemoria_popup.resizable(True, True)
        promemoria_popup.withdraw()
        promemoria_popup.transient(self)
        promemoria_popup.protocol("WM_DELETE_WINDOW", chiudi_promemoria_popup) 
        promemoria_popup.bind('<Escape>', lambda e: chiudi_promemoria_popup())
        main_frame = ttk.Frame(promemoria_popup, padding=10)
        main_frame.pack(fill="both", expand=True)
        main_frame.columnconfigure(0, weight=1)
        main_frame.columnconfigure(1, weight=1)
        main_frame.columnconfigure(2, weight=1) 
        main_frame.rowconfigure(0, weight=1)
        promemoria_text_widget = tk.Text(
            main_frame, 
            wrap="word", 
            width=50, 
            height=15, 
            bg="#ADD8E6",
            fg="black",
            selectforeground="white",
            relief=tk.FLAT,
            borderwidth=1
        )
        promemoria_text_widget.grid(row=0, column=0, columnspan=3, pady=(0, 10), sticky="nsew") 
        scrollbar = ttk.Scrollbar(main_frame, command=promemoria_text_widget.yview, style="Vertical.TScrollbar")
        scrollbar.grid(row=0, column=3, sticky='ns')
        promemoria_text_widget['yscrollcommand'] = scrollbar.set
        btn_salva_promemoria = ttk.Button(main_frame, text="‚úì Salva", command=salva_promemoria, style="Verde.TButton")
        btn_salva_promemoria.grid(row=1, column=0, padx=5, sticky="e") 
        center_btn_frame = ttk.Frame(main_frame)
        center_btn_frame.grid(row=1, column=1, padx=5, sticky="we")
        center_btn_frame.columnconfigure(0, weight=1)
        center_btn_frame.columnconfigure(1, weight=1)
        btn_stampa_promemoria = ttk.Button(
            center_btn_frame, 
            text="üìÑ Stampa", 
            command=lambda: self._stampa_lista_diretta(
                promemoria_text_widget.get("1.0", tk.END).strip(),
                self.show_custom_warning
            ), 
            style="Blu.TButton"
        )
        btn_stampa_promemoria.grid(row=0, column=0, sticky="we") 
        btn_esporta_promemoria = ttk.Button(center_btn_frame, text="üìÑ Esporta", command=esporta_promemoria, style="Arancio.TButton")
        btn_esporta_promemoria.grid(row=0, column=1, sticky="we", padx=(5, 0))
        btn_cancella_promemoria = ttk.Button(main_frame, text="‚ùå Chiudi", command=chiudi_promemoria_popup, style="Giallo.TButton")
        btn_cancella_promemoria.grid(row=1, column=2, padx=5, sticky="w")
        carica_promemoria()
        self.update_idletasks() 
        window_width = 800  
        window_height = 400     
        app_x = self.winfo_rootx()
        app_y = self.winfo_rooty()
        app_width = self.winfo_width()
        app_height = self.winfo_height()
        center_x = app_x + (app_width // 2) - (window_width // 2)
        center_y = app_y + (app_height // 2) - (window_height // 2)
        promemoria_popup.geometry(f'{window_width}x{window_height}+{center_x}+{center_y}')
        promemoria_popup.deiconify() 
        promemoria_popup.grab_set()
        
    # Colora Giorni Cal in base al Movimento
    def colora_giorni_spese(self):
        self.cal.calevent_remove('all')
        if not self.spese: return
        for data, entries in self.spese.items():
            if not entries: continue
            try:
                e_voci, u_voci = [], []
                tot_e, tot_u = 0.0, 0.0
                for e in entries:
                    cat, imp, tipo = e[0] or "Varie", float(e[2]), str(e[3]).lower()
                    if tipo == "entrata":
                        tot_e += imp
                        e_voci.append((cat, imp))
                    else:
                        tot_u += imp
                        u_voci.append((cat, imp))
                linee = []
                W = 38
                if e_voci:
                    ve = f"‚Ç¨ {tot_e:.2f}"
                    linee.append(f"{'‚ñ≤ SALDO (+):'.ljust(W - len(ve))}{ve}")
                    for c, v in e_voci:
                        vs = f"{v:.2f}"
                        linee.append(f"{f' {c}'.ljust(W - len(vs))}{vs}")
                if u_voci:
                    if linee: linee.append("‚îÄ" * W)
                    vu = f"‚Ç¨ {tot_u:.2f}"
                    linee.append(f"{'‚ñº SALDO (-):'.ljust(W - len(vu))}{vu}")
                    for c, v in u_voci:
                        vs = f"{v:.2f}"
                        linee.append(f"{f' {c}'.ljust(W - len(vs))}{vs}")
                testo_tooltip = "\n" + "\n".join(linee)
                if tot_e > 0 and tot_u > 0: tag = "misto"
                elif tot_e > 0: tag = "verde"
                elif tot_u > 0: tag = "rosso"
                else: continue
                self.cal.calevent_create(data, testo_tooltip, tag)
            except Exception as e:
                print(f"Errore colore giorno {data}: {e}"); continue
        self.cal.calevent_create(datetime.date.today(), "Oggi", "today")
        
    # Sincronizza Calendari    
    def on_calendar_change(self, event=None):
        self.mostra_treeview_statistiche()
        self.after(0, self.imp_entry.focus_set)
        try:
            data = self.cal.selection_get()
            if not data:
                return
            if not self.blocca_data_var.get():
                self.data_spesa_var.set(data.strftime("%d-%m-%Y"))
            mese_corrente = self.estratto_month_var.get()
            anno_corrente = self.estratto_year_var.get()
            mese_da_cal = f"{data.month:02d}"
            anno_da_cal = str(data.year)
            if mese_corrente != mese_da_cal:
                self.estratto_month_var.set(mese_da_cal)
                self.estratto_month_var.set(self.months[data.month - 1])
            if anno_corrente != anno_da_cal:
                self.estratto_year_var.set(anno_da_cal)
                self.estratto_year_var.set(anno_da_cal)
            self.after(100, lambda: self.apply_estratto("giorno"))
        except Exception as e:
            print(f"Errore durante il cambio data: {e}")
    
    # Sincronizza Calendari/imposta data inizio mese
    def on_month_changed(self, event=None):
        m, y = self.cal.get_displayed_month()
        primo = datetime.date(y, m, 1)
        if self.cal.selection_get() != primo:
            self.cal.selection_set(primo)
        if not self.blocca_data_var.get():
           self.data_spesa_var.set(primo.strftime("%d-%m-%Y"))
        self.estratto_month_var.set(self.months[m-1])
        self.estratto_year_var.set(str(y))
        self.apply_estratto("giorno")
    
    # Imposta Titolo Finestra
    def aggiorna_titolo_finestra(self):
        stato_db = "üì° [RETE]" if DB_CONDIVISO else "üè† [LOCALE]"
        current_folder = os.path.basename(os.getcwd())
        self.title(f"üí∞ {NAME} Pro v {VERSION} ‚Äî {stato_db} S-ID: {self.SESSION_ID} ‚Äî Email: helpcasafacilepro@gmail.com ‚Äî  Utente:‚ñ∫ {current_folder}")
    
    # Bottone Movimenti Simili
    def aggiorna_bottone_spese_simili(self, visibile=True):
        if visibile:
            if not self.btn_spese_simili.winfo_ismapped():
                self.btn_spese_simili.pack(side="left", padx=(6, 0))
        else:
            if self.btn_spese_simili.winfo_ismapped():
                self.btn_spese_simili.pack_forget()
    
    # SmartCat
    def aggiorna_categoria_automatica(self, event=None):
        if not self.suggerimenti_attivi:
            self.label_smartcat.config(text="üõ†Ô∏è SmartCat disattiva", foreground="green")
            self.aggiorna_bottone_spese_simili(visibile=False)
            return
        valore = self.imp_entry.get().replace(",", ".").strip()
        if not valore:
            self.categoria_bloccata = False
            self.aggiorna_bottone_spese_simili(visibile=False)
            self.cat_sel.set("Generica") 
            self.label_smartcat.config(text="üõ†Ô∏è SmartCat in attesa...", foreground="gray") 
            self.tipo_spesa_var.set("Uscita") 
            self.aggiorna_stile_tipo_spesa()
            self.lbl_tipo_percentuale.config(text="0% Entrate / 0% Uscite ")  
            return
        try:
            imp_corrente = float(valore)
        except ValueError:
            return
        oggi = datetime.date.today()
        un_anno_fa = oggi - datetime.timedelta(days=365)
        frequenze = {}
        spese_valide = []
        for d, lista in self.spese.items():
            if d < un_anno_fa:
                continue
            for voce in lista:
                try:
                    categoria, _, importo, _ = voce[:4]
                    frequenze[categoria] = frequenze.get(categoria, 0) + 1
                    spese_valide.append((categoria, importo))
                except ValueError:
                    continue
        if not spese_valide:
            return
        miglior_punteggio = float("inf")
        categoria_migliore = None
        categorie_gia_valutate = set()
        for categoria, importo in spese_valide:
            if categoria in categorie_gia_valutate:
                continue
            categorie_gia_valutate.add(categoria)
            diff = abs(importo - imp_corrente)
            bonus_frequenza = math.log(frequenze.get(categoria, 1)) * 0.5 # Il valore 0.5 pu√≤ essere regolato
            punteggio = diff - bonus_frequenza
            if punteggio < miglior_punteggio:
                miglior_punteggio = punteggio
                categoria_migliore = categoria
        if categoria_migliore and not self.categoria_bloccata:
            self.cat_sel.set(categoria_migliore)
            self.on_categoria_changed(manuale=False)
            self.label_smartcat.config(text="üí° SmartCat attiva", foreground="red")
            self.btn_spese_simili.pack(side="left", padx=(6, 0))
            self.cat_menu.configure(style="Highlight.TCombobox")
            self.cat_menu.after(500, lambda: self.cat_menu.configure(style="Border.TCombobox"))
         
    # Popup Movimenti Simili     
    def mostra_spese_simili(self):
        if hasattr(self, "popup_simili") and self.popup_simili.winfo_exists():
            self.popup_simili.lift()
            self.popup_simili.focus_force()
            return
        valore = self.imp_entry.get().replace(",", ".").strip()
        try:
            target = float(valore)
        except ValueError:
            self.show_custom_warning("Errore", "Importo mancante o non valido.")
            return
        tolleranza = int(self.spin_tolleranza.get()) if hasattr(self, "spin_tolleranza") else 10
        limite_basso = target - tolleranza
        limite_alto = target + tolleranza
        voci_simili = [
            (d, *voce)
            for d, lista in self.spese.items()
            for voce in lista
            if len(voce) >= 4 and isinstance(voce[2], (int, float)) and limite_basso <= voce[2] <= limite_alto
        ]
        if not voci_simili:
            self.show_custom_warning("Nessuna corrispondenza", "Nessuna spesa trovata con questo importo.")
            return
        popup = tk.Toplevel(self, bg=self.COLOR_TOPLEVEL)
        popup.title(f"Movimenti simili a ‚Ç¨{target:.2f}")
        popup.resizable(False, False)
        popup.bind("<Escape>", lambda e: popup.destroy())
        larghezza, altezza = 650, 460
        x = (popup.winfo_screenwidth() // 2) - (larghezza // 2)
        y = (popup.winfo_screenheight() // 2) - (altezza // 2)
        popup.geometry(f"{larghezza}x{altezza}+{x}+{y}")
        label_range = ttk.Label(
            popup,
            text=f"üîé Movimenti compresi tra ‚Ç¨{limite_basso:.2f} e ‚Ç¨{limite_alto:.2f}",
            style="White.TLabel"
        )
        label_range.pack(pady=(10, 4))
        ttk.Label(
            popup,
            text="üéØ Margine di tolleranza (‚Ç¨):",
            style="WhiteSmall.TLabel"
        ).pack(pady=(4, 2))
        tolleranza_var = tk.StringVar(value=str(tolleranza))
        def aggiorna_auto(*args):
            try:
                nuovo_tolleranza = int(tolleranza_var.get())
            except ValueError:
                return
            limite_basso = target - nuovo_tolleranza
            limite_alto = target + nuovo_tolleranza
            label_range.config(text=f"üîé Movimenti compresi tra ‚Ç¨{limite_basso:.2f} e ‚Ç¨{limite_alto:.2f}")
            nuove_voci = [
                (d, *voce)
                for d, lista in self.spese.items()
                for voce in lista
                if len(voce) >= 4 and isinstance(voce[2], (int, float)) and limite_basso <= voce[2] <= limite_alto
            ]
            for item in tree.get_children():
                tree.delete(item)
            nuove_voci.sort(key=lambda x: x[0], reverse=True)
            for voce in nuove_voci:
                try:
                    if len(voce) == 6:
                        data, categoria, descrizione, importo, tipo, _ = voce
                    else: 
                        data, categoria, descrizione, importo, tipo = voce
                    tag = "entrata" if tipo.lower() == "entrata" else "uscita"
                    tree.insert("", tk.END, values=(
                        data.strftime("%d-%m-%Y"),
                        tipo,
                        categoria,
                        descrizione,
                        f"‚Ç¨{importo:.2f}"
                    ), tags=(tag,))
                except Exception:
                    continue
        spin_tolleranza_popup = tk.Spinbox(
            popup,
            from_=0,
            to=100,
            increment=1,
            width=6,
            font=("Arial", 10),
            justify="center",
            textvariable=tolleranza_var
        )
        spin_tolleranza_popup.pack(pady=(0, 10))
        tolleranza_var.trace_add("write", aggiorna_auto)
        columns = ("data", "tipo", "categoria", "descrizione", "importo")
        headers = {
            "data": "Data",
            "tipo": "Tipo",
            "categoria": "Categoria",
            "descrizione": "Descrizione",
            "importo": "Importo"
        }
        tree_frame = ttk.Frame(popup)
        tree_frame.pack(padx=12, pady=(0, 6), fill="both", expand=True)
        vsb = ttk.Scrollbar(tree_frame, orient="vertical", style="Vertical.TScrollbar")
        vsb.pack(side="right", fill="y")
        tree = ttk.Treeview(
            tree_frame, 
            columns=columns, 
            show="headings", 
            height=10,
            yscrollcommand=vsb.set,
        )
        tree.pack(fill="both", expand=True)
        tree.bind("<Double-1>", lambda e: usa_categoria())
        vsb.config(command=tree.yview)
        for col in columns:
            tree.heading(col, text=headers[col], command=lambda c=col: sort_column(tree, c, False))
        tree.column("data", width=90, anchor="center")
        tree.column("tipo", width=80, anchor="center")
        tree.column("categoria", width=120, anchor="w")
        tree.column("descrizione", width=220, anchor="w")
        tree.column("importo", width=80, anchor="e")
        voci_simili.sort(key=lambda x: x[0], reverse=True)
        for voce in voci_simili:
            try:
                if len(voce) == 6:
                    data, categoria, descrizione, importo, tipo, _ = voce
                else: 
                    data, categoria, descrizione, importo, tipo = voce
                
                tag = "entrata" if tipo.lower() == "entrata" else "uscita"
                tree.insert("", tk.END, values=(
                    data.strftime("%d-%m-%Y"),
                    tipo,
                    categoria,
                    descrizione,
                    f"‚Ç¨{importo:.2f}"
                ), tags=(tag,))
            except Exception as e:
                print(f"[Voce malformata]: {voce} ‚Üí {e}")
                continue
        tree.tag_configure("entrata", foreground="green")
        tree.tag_configure("uscita", foreground="red")
        def usa_categoria():
            selezione = tree.selection()
            if not selezione:
                self.show_custom_warning("Attenzione", "Seleziona una spesa per copiarne la categoria.")
                return
            valori = tree.item(selezione[0], "values")
            self.cat_sel.set(valori[2])
            self.on_categoria_changed(manuale=True)
            popup.destroy()
        btn_frame = tk.Frame(popup, bg=self.COLOR_TOPLEVEL)
        btn_frame.pack(pady=(4, 12))
        ttk.Button(btn_frame, text="üì• Usa questa categoria", style="Blu.TButton", command=usa_categoria).pack(side="left", padx=8)
        ttk.Button(btn_frame, text="‚ùå Chiudi", style="Giallo.TButton", command=popup.destroy).pack(side="left", padx=8)
        def sort_column(tv, col, reverse):
            def extract(val):
                try:
                    if col == "importo":
                        return float(val.replace("‚Ç¨", "").replace(",", "").strip())
                    elif col == "data":
                        return datetime.datetime.strptime(val, "%d-%m-%Y")
                    return str(val).lower()
                except:
                    return val
            idx = columns.index(col)
            dati = [(tv.item(k)["values"], k) for k in tv.get_children()]
            try:
                dati.sort(key=lambda x: extract(x[0][idx]), reverse=reverse)
            except Exception as e:
                print(f"[Errore ordinamento '{col}']: {e}")
                return
            for i, (valori, k) in enumerate(dati):
                tv.move(k, "", i)
            tv.heading(col, command=lambda: sort_column(tv, col, not reverse))

    # Carica Geometria Finestra
    def load_window_geometry(self):
        self._window_geometry = None 
        if not self.salva_geometria:
            return 
        if not os.path.exists(DB_FILE):
            return
        try:
            with open(DB_FILE, "r", encoding="utf-8") as f:
                data = json.load(f)
                self._window_geometry = data.get("_window_geometry", None)
        except Exception:
            self._window_geometry = None
    # Salva Geometria Finestra
    def save_window_geometry(self):
        if not self.salva_geometria:
            return
        geometry = self.geometry()
        self._window_geometry = geometry
        try:
            data = {}
            if os.path.exists(DB_FILE):
                with open(DB_FILE, "r", encoding="utf-8") as f:
                    data = json.load(f) 
            data["_window_geometry"] = geometry 
            with open(DB_FILE, "w", encoding="utf-8") as f:
                json.dump(data, f, indent=2, ensure_ascii=False)
        except Exception as e:
            print("Errore salvataggio geometria finestra:", e)

    # Rilascio del lock file e pulizia all'uscita (Non-Windows)
    def _on_close_lock(self):
        try:
            if sys.platform != "win" and _lock_file_handle:
                _lock_file_handle.close()
                lock_dir = os.path.dirname(os.path.abspath(sys.argv[0]))
                lock_file_path = os.path.join(lock_dir, 'casa_facile.lock')
                if os.path.exists(lock_file_path):
                    os.remove(lock_file_path)
                    print("üìÑ File di lock cancellato.")
        except Exception as e:
            print(f"‚ö†Ô∏è Errore durante la pulizia del lock file: {e}")

    # Gestore della chiusura pulita dell'applicazione (Cleanup e Uscita)
    def _on_close(self):
        print("üîö Chiusura dell'app in corso...")
        self.save_window_geometry()
        self.save_db()
        self._esegui_backup_json()
        self.backup_documenti()
        try:
            if hasattr(self, "server"):
                self.server.shutdown()
                self.server.server_close()
                print("üåê Web server chiuso.")
            else:
                print("üåê Nessun web server attivo.")
        except Exception as e:
            print(f"‚ö†Ô∏è Web server non attivo o errore in chiusura: {e}")
        try:
            self.destroy()
        except Exception as e:
            print(f"‚ö†Ô∏è Errore nella chiusura della GUI: {e}")
        self._on_close_lock()
        sys.exit(0)

    # Memoria Categorie per importazione Estratto
    def carica_memoria_descrizioni(self):
        if os.path.exists(MEM_CAT):
            try:
                with open(MEM_CAT, "r", encoding="utf-8") as f:
                    self.memoria_descrizioni_categoria = json.load(f)
            except Exception as e:
                print(f"‚ö†Ô∏è Errore lettura memoria categorie: {e}. Ripristino a vuoto.")
                self.memoria_descrizioni_categoria = {}
        else:
            self.memoria_descrizioni_categoria = {}

    # Caricamento del database JSON e inizializzazione dei dati applicativi 
    def load_db(self):
        if not os.path.exists(DB_FILE):
            self.db = {
                "categorie": ["Generica"],
                "categorie_tipi": {"Generica": "Uscita"},
                "spese": [],
                "ricorrenze": {},
                "_window_geometry": None
            }
            self.categorie = self.db["categorie"]
            self.categorie_tipi = self.db["categorie_tipi"]
            self.spese = {}
            self.ricalcola_operazioni_web()
            self.ricorrenze = self.db["ricorrenze"]
            self._window_geometry = self.db["_window_geometry"]
            return
        try:
            with open(DB_FILE, "r", encoding="utf-8") as f:
                self.db = json.load(f)
            self.categorie = self.db.get("categorie", ["Generica"])
            self.categorie_tipi = self.db.get("categorie_tipi", {"Generica": "Uscita"})
            self.spese = {}
            for obj in self.db.get("spese", []):
                d = datetime.datetime.strptime(obj["date"], "%d-%m-%Y").date()
                entries = []
                for e in obj.get("entries", []):
                    if "id_ricorrenza" in e:
                        entries.append((e["categoria"], e["descrizione"], float(e["importo"]), e["tipo"], e["id_ricorrenza"]))
                    else:
                        entries.append((e["categoria"], e["descrizione"], float(e["importo"]), e["tipo"]))
                self.spese[d] = entries
            self.ricorrenze = self.db.get("ricorrenze", {})
            self._window_geometry = self.db.get("_window_geometry", None)
            self.carica_memoria_descrizioni()
            self.carica_saldo()
            self.ricalcola_operazioni_web()

        except Exception as e:
            print("‚ùå Errore critico caricamento DB:", e)
            bak_file = DB_FILE + ".bak"
            if os.path.exists(bak_file):
                domanda_bak = (
                    f"Il database principale √® illeggibile ({e}).\n\n"
                    "√à stato trovato un file di backup (.bak) dell'ultima sessione valida.\n"
                    "Vuoi tentare il ripristino automatico dei dati?"
                )
                style = ttk.Style()
                style.configure("Giallo.TButton", background="#E5C07B", foreground="black", font=("Arial", 8, "bold"))
                style.map("Giallo.TButton", background=[("pressed", "#B89B62"), ("active", "#CFB076")])
                style.configure("Verde.TButton", background="green", foreground="black", font=("Arial", 8, "bold"))
                style.map("Verde.TButton", background=[("pressed", "#7A9A5F"), ("active", "#8AAB6F")], foreground=[('disabled', "yellow")])
                if self.show_custom_askyesno("Recupero Database", domanda_bak):
                    try:
                        import shutil
                        os.replace(DB_FILE, DB_FILE + ".corrotto") 
                        shutil.copy2(bak_file, DB_FILE)
                        print("‚úì Ripristino completato dal file .bak")
                        return self.load_db()
                    except Exception as err_bak:
                        print(f"Ripristino fallito: {err_bak}")
            self.db = {"categorie": ["Generica"], "categorie_tipi": {"Generica": "Uscita"}, "spese": [], "ricorrenze": {}, "_window_geometry": None}
            self.categorie = self.db["categorie"]
            self.categorie_tipi = self.db["categorie_tipi"]
            self.spese = {}
            self.ricorrenze = {}
            self.carica_saldo()
            self.ricalcola_operazioni_web()
            msg_errore = (
                f"ATTENZIONE: Il database ({DB_FILE}) √® corrotto.\n\n"
                f"Dettaglio: {e}\n\n"
                "Il programma √® stato avviato con un database vuoto.\n"
                "Puoi importare un backup manualmente dal menu Opzioni."
            )
            self.show_custom_warning("Attenzione", msg_errore)
           
    # Salvataggio del database JSON e dei dati applicativi
    def save_db(self):
        self.config(cursor="watch")
        self.update_idletasks()
        try:
            with self.save_lock:
                limite = datetime.date.today() - datetime.timedelta(days=365 * ANNI_DA_MANTENERE)
                spese_da_rimuovere = [d for d in self.spese.keys() if d < limite]
                if spese_da_rimuovere:
                    if os.path.exists(DB_FILE):
                        cartella_storico = os.path.join(os.path.dirname(os.path.abspath(DB_FILE)), "storico")
                        try:
                            if not os.path.exists(cartella_storico):
                                os.makedirs(cartella_storico)
                            timestamp = datetime.datetime.now().strftime("%d%m%Y_%H%M")
                            nome_base = os.path.basename(DB_FILE)
                            backup_storico = os.path.join(cartella_storico, f"{nome_base}_{timestamp}.storico")
                            shutil.copy2(DB_FILE, backup_storico)
                            print(f"üì¶ ARCHIVIAZIONE: Backup creato in /storico/{os.path.basename(backup_storico)}")
                            lista_storici = sorted([
                                os.path.join(cartella_storico, f) for f in os.listdir(cartella_storico) 
                                if f.endswith(".storico")
                            ], key=os.path.getmtime)
                            while len(lista_storici) > 2:
                                vecchio = lista_storici.pop(0) 
                                os.remove(vecchio)
                                print(f"üì¶ ROTAZIONE: Rimosso archivio datato: {os.path.basename(vecchio)}")
                        except Exception as e:
                            print(f"üì¶ Errore durante l'archiviazione: {e}")
                    else:
                        print("üì¶ Primo salvataggio: DB_FILE non ancora presente, salto creazione storico.")
                    conteggio_giorni = len(spese_da_rimuovere)
                    for d in spese_da_rimuovere:
                        del self.spese[d]
                    print(f"üì¶ PULIZIA: Rimosse {conteggio_giorni} giornate di dati antecedenti al {limite.strftime('%d-%m-%Y')}.")
                categorie_tipi_ordinati = dict(sorted(self.categorie_tipi.items()))
                CATEGORIA_PRIORITARIA = "Generica"
                categorie_temporanee = sorted([c for c in self.categorie if c != CATEGORIA_PRIORITARIA])
                categorie_ordinate = ([CATEGORIA_PRIORITARIA] if CATEGORIA_PRIORITARIA in self.categorie else []) + categorie_temporanee
                data = {
                    "categorie": categorie_ordinate,
                    "categorie_tipi": categorie_tipi_ordinati,
                    "spese": [
                        {"date": d.strftime("%d-%m-%Y"), "entries": [
                            {"categoria": c, "descrizione": desc, "importo": imp, "tipo": tipo, 
                             **({"id_ricorrenza": rid} if len(entry) == 5 else {})}
                                for entry in sp
                                for c, desc, imp, tipo, *rest in [entry]
                                for rid in [rest[0] if rest else None]
                        ]} for d, sp in sorted(self.spese.items())
                    ],
                    "ricorrenze": self.ricorrenze,
                    "_window_geometry": self._window_geometry or (self.geometry() if hasattr(self, 'geometry') else None)
                }
                if os.path.exists(DB_FILE):
                    shutil.copy2(DB_FILE, DB_FILE + ".bak")
                temp_file = DB_FILE + ".tmp"
                with open(temp_file, "w", encoding="utf-8") as f:
                    json.dump(data, f, indent=2, ensure_ascii=False)
                    f.flush()
                    os.fsync(f.fileno())
                os.replace(temp_file, DB_FILE)
                self.ricalcola_operazioni_web()
                with open(MEM_CAT, "w", encoding="utf-8") as f:
                    json.dump(self.memoria_descrizioni_categoria, f, indent=2, ensure_ascii=False)
                if DB_CONDIVISO:
                    self.notifica_modifica_web()
                    print("üì° Notifica di aggiornamento inviata e backup .bak creato.")
        except Exception as e:
            print(f"‚ùå Errore critico durante il salvataggio: {e}")
        finally:
            self.config(cursor="")
             
    # Ripristino dello stato predefinito del modulo di inserimento spesa
    def reset_form(self):
        today = datetime.date.today()
        self.data_spesa_var.set(today.strftime("%d-%m-%Y"))
        self.desc_entry.delete(0, tk.END)
        self.imp_entry.delete(0, tk.END)
        self.blocca_data_var.set(False)
        self.metodo_pagamento_var.set("")
        self.cat_sel.set(self.categorie[0])
        self.suggerimenti_attivi = True
        self.categoria_bloccata = False 
        self.on_categoria_changed(manuale=False) 
        self.btn_aggiungi["state"] = tk.NORMAL
        self.after(0, self.imp_entry.focus_set)
    
    # Toggle tra tipo 'Entrata' e 'Uscita' con aggiornamento visivo
    def toggle_tipo_spesa(self):
        v = self.tipo_spesa_var.get()
        nuovo = "Entrata" if v == "Uscita" else "Uscita"
        self.tipo_spesa_var.set(nuovo)
        self.btn_tipo_spesa.config(text=nuovo)
        new_style = 'GreenOutline.TButton' if nuovo == "Entrata" else 'RedOutline.TButton'
        self.btn_tipo_spesa.config(style=new_style)

    # Riordino e Aggiornamento delle Categorie nei Combobox
    def aggiorna_combobox_categorie(self):
        altre = sorted([c for c in self.categorie if c != "Generica"], key=str.lower)
        ordinata = ["Generica"] + altre if "Generica" in self.categorie else altre
        self.categorie = ordinata
        if hasattr(self, 'cat_menu') and self.cat_menu.winfo_exists():
            self.cat_menu["values"] = self.categorie
            try:
                if "Generica" in self.categorie:
                    self.cat_menu.current(self.categorie.index("Generica"))
                elif self.categorie:
                    self.cat_menu.current(0)
            except: pass
        if hasattr(self, 'cat_mod_menu') and self.cat_mod_menu.winfo_exists():
            self.cat_mod_menu["values"] = self.categorie
            try:
                if "Generica" in self.categorie:
                    idx = self.categorie.index("Generica")
                    self.cat_mod_menu.current(idx)
                elif self.categorie:
                    self.cat_mod_menu.current(0)
            except: pass
            
    # Sincronizzazione Tipo Voce (Entrata/Uscita) e Aggiornamento Stile UI
    def on_categoria_changed(self, event=None, manuale=True):
        if manuale:
            self.categoria_bloccata = True
        cat = self.cat_sel.get()
        tipo_cat = self.categorie_tipi.get(cat, "Uscita")
        self.tipo_spesa_var.set(tipo_cat)
        self.btn_tipo_spesa.config(text=tipo_cat)
        new_style = 'GreenOutline.TButton' if tipo_cat == "Entrata" else 'RedOutline.TButton'
        self.btn_tipo_spesa.config(style=new_style)
        tipo_cat_suggerito, perc_entrate, perc_uscite = self.suggerisci_tipo_categoria(cat)
        colore_percentuale = "gray"
        if perc_entrate > perc_uscite:
            colore_percentuale = "forestgreen"
        elif perc_uscite > perc_entrate:
            colore_percentuale = "firebrick"
        self.lbl_tipo_percentuale.config(
            text=f"{perc_entrate}% Entrate / {perc_uscite}% Uscite",
            foreground=colore_percentuale
        )
        self.label_smartcat.config(text="üõ†Ô∏è SmartCat disattiva", foreground="green")
        self.aggiorna_bottone_spese_simili(visibile=False)

    # Popup Mostra Categorie Attive
    def mostra_tutte_le_categorie(self):
        popup = tk.Toplevel(self, bg=self.COLOR_TOPLEVEL)
        popup.title("üìã Elenco Categorie")
        popup.resizable(False, False)
        popup_width = 320
        popup_height = 420
        screen_width = self.winfo_screenwidth()
        screen_height = self.winfo_screenheight()
        center_x = int((screen_width / 2) - (popup_width / 2))
        center_y = int((screen_height / 2) - (popup_height / 2))
        popup.geometry(f"{popup_width}x{popup_height}+{center_x}+{center_y}")
        popup.transient(self)
        popup.lift()
        popup.focus_force()
        popup.grab_set()
        popup.bind("<Escape>", lambda e: (popup.grab_release(), popup.destroy()))
        frame = ttk.Frame(popup, padding=10)
        frame.pack(fill="both", expand=True)
        label = ttk.Label(frame, text="Categorie disponibili:", font=("Arial", 11, "bold"))
        label.pack(pady=(0, 10))
        text_frame = ttk.Frame(frame)
        text_frame.pack(fill="both", expand=True)
        vsb = ttk.Scrollbar(text_frame, orient="vertical", style="Vertical.TScrollbar")
        vsb.pack(side="right", fill="y")
        text = tk.Text( 
            text_frame, 
            font=("Arial", 10), 
            height=18, 
            wrap="none", 
            state="normal",
            bg=self.COLOR_TOPLEVEL,
            fg=self.TEXT_COLOR,
            insertbackground=self.TEXT_COLOR,
            highlightthickness=0,
            yscrollcommand=vsb.set
        )
        text.pack(side="left", fill="both", expand=True)
        vsb.config(command=text.yview)
        text.tag_configure("entrata", foreground="green")
        text.tag_configure("uscita", foreground="red")
        for nome in sorted(self.categorie, key=lambda x: x.lower()):
            tipo = self.categorie_tipi.get(nome, "Uscita")
            riga = f"‚Ä¢ {nome}  ("
            text.insert("end", riga)
            if tipo == "Entrata":
                text.insert("end", tipo, "entrata")
            else:
                text.insert("end", tipo, "uscita")
            text.insert("end", ")\n")
        text.config(state="disabled") 
        btn_frame = tk.Frame(popup, bg=self.COLOR_TOPLEVEL)
        btn_frame.pack(pady=10)
        ttk.Button(btn_frame, text="‚ùå Chiudi", style='Giallo.TButton', command=lambda: (popup.grab_release(), popup.destroy()),).pack()

    # Gestione Completa delle Categorie (Aggiunta, Modifica, Eliminazione e Controllo Spese)
    def add_categoria(self):
        nome = self.nuova_cat.get().strip()
        tipo = self.tipo_categoria.get()
        if not nome or nome in self.categorie or nome == self.CATEGORIA_RIMOSSA:
            self.reset_campi_categoria()
            self.show_custom_warning("Attenzione", "Nome categoria vuoto, gi√† esistente o riservato.")
            return
        self.categorie.append(nome)
        self.categorie_tipi[nome] = tipo
        self.aggiorna_combobox_categorie()
        self.save_db()
        self.refresh_gui()
        self.reset_campi_categoria()  
        if hasattr(self, 'ricorrenza_popup') and self.ricorrenza_popup.winfo_exists():
            if hasattr(self, 'ric_cat_menu'):
                self.ric_cat_menu['values'] = sorted(self.categorie)
        self.show_custom_info("Attenzione", f"La categoria '{nome}' '{tipo}' √® stata aggiunta.")
    def modifica_categoria(self):
        old_nome = self.cat_mod_sel.get()
        if not old_nome:
            self.show_custom_warning("Attenzione", "Seleziona una categoria da modificare.")
            return
        if old_nome == "Generica":
         self.show_custom_warning("Attenzione", "La categoria 'Generica' non pu√≤ essere rinominata.")
         self.reset_campi_categoria()  
         return
        new_nome = self.nuova_cat.get().strip()
        if not new_nome:
            self.show_custom_warning("Attenzione", "Inserisci il nuovo nome della categoria.")
            return
        if new_nome == old_nome:
            tipo = self.tipo_categoria.get()
            self.categorie_tipi[new_nome] = tipo
            self.save_db()
            self.refresh_gui()
            self.show_custom_info("Info", f"Tipo categoria '{new_nome}' aggiornato a ''{tipo}'.")
            self.reset_campi_categoria()  
            return
        if new_nome in self.categorie:
            self.show_custom_warning("Attenzione", "Esiste gi√† una categoria con questo nome.")
            return
        idx = self.categorie.index(old_nome)
        self.categorie[idx] = new_nome
        nuovo_tipo = self.tipo_categoria.get()
        self.categorie_tipi[new_nome] = nuovo_tipo
        if new_nome != old_nome:
            self.categorie_tipi.pop(old_nome, None)
        for d in self.spese:
            new_entries = []
            for entry in self.spese[d]:
                if entry[0] == old_nome:
                    entry = (new_nome,) + entry[1:]
                new_entries.append(entry)
            self.spese[d] = new_entries
        self.cat_menu["values"] = self.categorie
        self.cat_mod_menu["values"] = self.categorie
        self.save_db()
        self.refresh_gui()
        self.show_custom_info("Attenzione", f"Categoria '{old_nome}' rinominata in '{new_nome}' '{nuovo_tipo}' .")
        self.aggiorna_combobox_categorie()
        self.reset_campi_categoria() 
        if hasattr(self, 'ricorrenza_popup') and self.ricorrenza_popup.winfo_exists():
            if hasattr(self, 'ric_cat_menu'):
                self.ric_cat_menu['values'] = sorted(self.categorie)
    def conferma_cancella_categoria(self, cat):
        popup = tk.Toplevel(self)
        popup.title("Conferma eliminazione")
        popup.resizable(False, False)
        width, height = 320, 160
        popup.withdraw()
        popup.update_idletasks()
        parent_x = self.winfo_rootx()
        parent_y = self.winfo_rooty()
        parent_w = self.winfo_width()
        parent_h = self.winfo_height()
        x = parent_x + (parent_w // 2) - (width // 2)
        y = parent_y + (parent_h // 2) - (height // 2)
        popup.geometry(f"{width}x{height}+{x}+{y}")
        popup.deiconify()
        popup.grab_set()
        popup.configure(bg="#FFFACD")
        messaggio_var = tk.StringVar()
        messaggio_var.set(
            f"Eliminare la categoria '{cat}'?\nI Movimenti saranno Mantenuti ma etichettati\n'{self.CATEGORIA_RIMOSSA}'."
        )
        label = tk.Label(
            popup,
            textvariable=messaggio_var,
            font=("Arial", 10),
            justify="center",
            wraplength=280,
            bg="#FFFACD"
        )
        label.pack(pady=8, padx=10)
        elimina_importi_var = tk.BooleanVar()
        def aggiorna_messaggio(*_):
            if elimina_importi_var.get():
                messaggio_var.set(
                    f"Eliminare la categoria '{cat}'?\nI Movimenti e gli importi saranno eliminati."
                )
            else:
                messaggio_var.set(
                    f"Eliminare la categoria '{cat}'?\nI Movimenti saranno etichettati '{self.CATEGORIA_RIMOSSA}'."
                )
        elimina_importi_var.trace_add("write", aggiorna_messaggio)
        tk.Checkbutton(
            popup,
            text="Elimina TUTTO anche gli importi associati",
            variable=elimina_importi_var,
            bg="#FFFACD",
            anchor="w",
            selectcolor="#FFFACD",
            activebackground="#FFFACD",
            highlightthickness=0,
            relief="flat",
            borderwidth=0
        ).pack(pady=(0, 6), padx=10, anchor="w")
        frame = tk.Frame(popup, bg="#FFFACD")
        frame.pack(pady=4)
        result = {"ok": False, "elimina_importi": False}
        def do_ok():
            result["ok"] = True
            result["elimina_importi"] = elimina_importi_var.get()
            popup.destroy()
        def do_cancel():
            popup.destroy()
        b1 = ttk.Button(frame, text="Elimina", style="Rosso.TButton", command=do_ok)
        b2 = ttk.Button(frame, text="Annulla", style="Giallo.TButton", command=do_cancel)
        b1.pack(side="left", padx=8)
        b2.pack(side="right", padx=8)
        popup.wait_window()
        return result
    def cancella_categoria(self):
        cat = self.cat_mod_sel.get()
        if not cat:
            self.show_custom_warning("Attenzione", "Seleziona una categoria da cancellare.")
            return
        if cat in ("Generica", self.CATEGORIA_RIMOSSA):
            self.show_custom_warning("Attenzione", f"Non puoi cancellare la categoria '{cat}'.")
            self.reset_campi_categoria()
            return
        conferma = self.conferma_cancella_categoria(cat)
        if not conferma["ok"]:
            return
        elimina_importi = conferma["elimina_importi"]
        if cat in self.categorie:
            self.categorie.remove(cat)
        if cat in self.categorie_tipi:
            del self.categorie_tipi[cat]
        for giorno in list(self.spese):
            nuove_spese = []
            for voce in self.spese[giorno]:
                voce_cat = voce[0]
                if voce_cat == cat:
                    if not elimina_importi:
                        nuove_spese.append((self.CATEGORIA_RIMOSSA,) + voce[1:])
                else:
                    nuove_spese.append(voce)
            if nuove_spese:
                self.spese[giorno] = nuove_spese
            else:
                del self.spese[giorno]
        self.save_db()
        self.refresh_gui()
        self.on_categoria_changed()
        self.aggiorna_combobox_categorie()
        self.reset_campi_categoria()
        if hasattr(self, 'ricorrenza_popup') and self.ricorrenza_popup.winfo_exists():
            if hasattr(self, 'ric_cat_menu'):
                self.ric_cat_menu['values'] = sorted(self.categorie)
    
    # Calcolatrice Interattiva
    def apri_calcolatrice(self):
        if hasattr(self, '_calcolatrice_popup') and self._calcolatrice_popup and self._calcolatrice_popup.winfo_exists():
            self._calcolatrice_popup.lift()
            return
        def chiudi_calcolatrice():
            calcolatrice.destroy()
            self._calcolatrice_popup = None          
        def inserisci(valore):
            entry_var.set(entry_var.get() + valore)
        def cancella():
            entry_var.set("")
            cronologia_text.config(state="normal")
            cronologia_text.delete("1.0", tk.END)
            cronologia_text.config(state="disabled")
        def calcola(event=None):
            try:
                espressione = entry_var.get().replace('%', '/100')
                risultato = eval(espressione)
                cronologia_text.config(state="normal")
                cronologia_text.insert(tk.END, f"{espressione} = {risultato}\n")
                cronologia_text.config(state="disabled")
                entry_var.set(str(risultato))
            except Exception:
                entry_var.set("Errore")
        def usa_risultato_ricorrenze():
            try:
                risultato = entry_var.get()
                self.ricorrenza_imp.set(risultato)
                chiudi_calcolatrice()
            except Exception as e:
                entry_var.set("Errore")
        def usa_risultato_principale():
            try:
                risultato = entry_var.get()
                self.imp_entry.delete(0, tk.END) 
                self.imp_entry.insert(0, risultato) 
                chiudi_calcolatrice()
            except Exception as e:
                entry_var.set("Errore")
        calcolatrice = tk.Toplevel(self, bg=self.COLOR_TOPLEVEL)
        self._calcolatrice_popup = calcolatrice
        calcolatrice.withdraw()
        calcolatrice.title("Calcolatrice")
        calcolatrice.resizable(True, True)
        calcolatrice.protocol("WM_DELETE_WINDOW", chiudi_calcolatrice) 
        calcolatrice.bind("<Escape>", lambda e: chiudi_calcolatrice())
        calcolatrice.bind("<Return>", calcola)
        calcolatrice.bind("<KP_Enter>", calcola)
        larghezza, altezza = 340, 340
        calcolatrice.update_idletasks()
        x = (calcolatrice.winfo_screenwidth() // 2) - (larghezza // 2)
        y = (calcolatrice.winfo_screenheight() // 2) - (altezza // 2)
        calcolatrice.geometry(f"{larghezza}x{altezza}+{x}+{y}")
        calcolatrice.deiconify()
        entry_var = tk.StringVar()
        entry = ttk.Entry(
            calcolatrice,
            textvariable=entry_var,
            font=("Arial", 16),
            justify="right"
        )
        entry.pack(fill="x", padx=10, pady=10)
        cronologia_text = tk.Text(
            calcolatrice, 
            height=4, 
            width=30, 
            wrap="word", 
            state="disabled",
            bg=self.COLOR_WIDGET_BG,
            fg=self.TEXT_COLOR,
            borderwidth=0,
            padx=5, pady=5
        )
        cronologia_text.pack(fill="x", padx=10, pady=(0, 10))
        tasti = [
            ["7", "8", "9", "/"],
            ["4", "5", "6", "*"],
            ["1", "2", "3", "-"],
            ["0", ".", "%", "+"]
        ]
        for riga in tasti:
            frame = ttk.Frame(calcolatrice)
            frame.pack(expand=True, fill="both")
            for tasto in riga:
                comando = lambda val=tasto: inserisci(val)
                stile_bottone = "Num.TButton" if tasto.isdigit() or tasto == "." else "Arancio.TButton"
                bottone = ttk.Button(
                    frame,
                    text=tasto,
                    style=stile_bottone,
                    command=comando
                )
                bottone.pack(side="left", expand=True, fill="both", padx=1, pady=1)
        frame_finale = ttk.Frame(calcolatrice)
        frame_finale.pack(fill="x", padx=10, pady=10)
        bottone_c = ttk.Button(
            frame_finale,
            text="C",
            style="Giallo.TButton",
            command=cancella
        )
        bottone_c.pack(side="left", expand=True, fill="x", padx=1)
        bottone_usa_ricorrenze = ttk.Button(
            frame_finale,
            text="Usa in Ricorrenze",
            style="Blu.TButton",
            command=usa_risultato_ricorrenze
        )
        bottone_usa_ricorrenze.pack(side="left", expand=True, fill="x", padx=1)
        bottone_usa_normale = ttk.Button(
            frame_finale,
            text="Usa in Principale",
            style="Blu.TButton",
            command=usa_risultato_principale
        )
        bottone_usa_normale.pack(side="left", expand=True, fill="x", padx=1)
        bottone_eq = ttk.Button(
            frame_finale,
            text="=",
            style="Verde.TButton",
            command=calcola
        )
        bottone_eq.pack(side="right", expand=True, fill="x", padx=1)
        
    # Popup Messaggi di Sistema
    def show_custom_warning(self, title, message):
        self._show_custom_message(title, message, "yellow", "black", "warning")
    def show_custom_info(self, title, message):
        self._show_custom_message(title, message, "lightblue", "black", "info")
    def show_custom_askyesno(self, title, message):
        dialog = tk.Toplevel(self, bg="orange")
        dialog.withdraw()
        dialog.title(title)
        dialog.resizable(False, False)
        dialog.grab_set()
        label = tk.Label(dialog, text=message, font=("Arial", 10), justify="left", padx=16, pady=12, bg="orange")
        label.pack()
        btns = tk.Frame(dialog, bg="orange")
        btns.pack(pady=(0,10))
        result = {"value": False}
        timer_data = {"id": None}
        def timeout_close():
            if timer_data["id"]:
                dialog.after_cancel(timer_data["id"])
            result["value"] = False
            dialog.destroy()
        def yes():
            if timer_data["id"]:
                dialog.after_cancel(timer_data["id"])
            result["value"] = True
            dialog.destroy()
        def no():
            if timer_data["id"]:
                dialog.after_cancel(timer_data["id"])
            result["value"] = False
            dialog.destroy()
        def update_timer(remaining_ms):
            remaining_s = int(remaining_ms / 1000)
            if remaining_s > 0:
                dialog.title(f"{title} ({remaining_s}s rim.)")
                timer_data["id"] = dialog.after(1000, update_timer, remaining_ms - 1000)
            else:
                timeout_close()
        b1 = ttk.Button(btns, text="S√¨", style="Verde.TButton", command=yes)
        b2 = ttk.Button(btns, text="No", style="Giallo.TButton", command=no)
        b1.grid(row=0, column=0, padx=8)
        b2.grid(row=0, column=1, padx=8)
        dialog.update_idletasks()
        w = dialog.winfo_reqwidth()
        h = dialog.winfo_reqheight()
        w = max(320, w)
        parent_x = self.winfo_rootx()
        parent_y = self.winfo_rooty()
        parent_w = self.winfo_width()
        parent_h = self.winfo_height()
        x = parent_x + (parent_w // 2) - (w // 2)
        y = parent_y + (parent_h // 2) - (h // 2)
        dialog.geometry(f"{w}x{h}+{x}+{y}")
        dialog.deiconify()
        dialog.lift()
        dialog.attributes("-topmost", True)
        if not USE_WAIT_WINDOW:
            update_timer(WARN_TIMEOUT) 
        dialog.wait_window()
        return result["value"]
    def _show_custom_message(self, title, message, bg, fg, icon=None):
        dialog = tk.Toplevel(self)
        dialog.attributes("-topmost", True)
        dialog.withdraw()  
        dialog.title(title)
        dialog.grab_set()
        dialog.resizable(False, False)
        timer_data = {"id": None}
        def close_dialog():
            if timer_data["id"]:
                dialog.after_cancel(timer_data["id"]) 
            dialog.destroy()
        def update_timer(remaining_ms):
            remaining_s = int(remaining_ms / 1000)
            if remaining_s > 0:
                dialog.title(f"{title} ({remaining_s}s rim.)") 
                timer_data["id"] = dialog.after(1000, update_timer, remaining_ms - 1000)
            else:
                dialog.destroy() 
        frame = tk.Frame(dialog, bg=bg)
        frame.pack(fill="both", expand=True)
        frame.pack_propagate(False) 
        label = tk.Label(frame, text=message, font=("Arial", 10), bg=bg, fg=fg, justify="left", padx=16, pady=12)
        label.pack(fill="x", expand=True)
        btn = ttk.Button(frame, text="OK", style="Verde.TButton", command=close_dialog)
        btn.pack(pady=(0, 15))
        btn.focus_set()
        dialog.bind("<Return>", lambda e: close_dialog())
        dialog.bind("<KP_Enter>", lambda e: close_dialog())
        dialog.bind("<Escape>", lambda e: close_dialog())
        dialog.update_idletasks() 
        msg_w = label.winfo_reqwidth() + 60
        width = max(msg_w, 350) 
        height = label.winfo_reqheight() + btn.winfo_reqheight() + 30
        parent_x = self.winfo_rootx()
        parent_y = self.winfo_rooty()
        parent_w = self.winfo_width()
        parent_h = self.winfo_height()
        x = parent_x + (parent_w // 2) - (width // 2)
        y = parent_y + (parent_h // 2) - (height // 2)
        dialog.geometry(f"{width}x{height}+{x}+{y}")
        dialog.deiconify() 
        if not USE_WAIT_WINDOW:
            update_timer(WARN_TIMEOUT) 
        if USE_WAIT_WINDOW:
            dialog.wait_window()
    
    # Ripristino del campo Data Spesa alla data odierna
    def reset_data_spesa(self):
        today = datetime.date.today()
        self.data_spesa_var.set(today.strftime("%d-%m-%Y"))
        
    # Ripristino della Data di Inizio Ricorrenza alla data
    def reset_ric_data_inizio(self):
        oggi = datetime.date.today()
        self.ricorrenza_data_inizio.set(oggi.strftime("%d-%m-%Y"))

    # Programmazione e Registrazione di Transazioni Ricorrenti (Ricorrenza)
    def add_ricorrenza(self):
        self.mostra_treeview_statistiche()
        self.after(0, self.imp_entry.focus_set)
        ric_type = self.ricorrenza_tipo.get()
        if ric_type == "Nessuna":
            self.show_custom_warning("Errore", "Seleziona un tipo di ricorrenza valido.")
            return
        try:
            n = int(self.ricorrenza_n.get())
            if n <= 0 or n > 365:
                raise ValueError
        except Exception:
            self.show_custom_warning("Errore", "Numero ripetizioni non valido (1-365)")
            return
        try:
            data_inizio = datetime.datetime.strptime(self.ricorrenza_data_inizio.get(), "%d-%m-%Y").date()
        except Exception:
            self.show_custom_warning("Errore", "Data inizio ricorrenza non valida")
            return
        cat = self.ricorrenza_cat_sel.get()
        desc = self.ricorrenza_desc.get().strip()
        try:
            imp_str = self.ricorrenza_imp.get().replace(",", ".")
            imp = float(imp_str)
            if imp <= 0:
                self.show_custom_warning("Errore", "L'importo non pu√≤ essere negativo.")
                return
        except Exception:
            self.show_custom_warning("Errore", "Importo mancante o non valido.")
            return
        tipo = self.ricorrenza_tipo_voce.get()
        self.ricorrenza_tipo_voce = self.tipo_spesa_var
        ric_id = str(uuid.uuid4())
        id_visibile = ric_id[:8]
        simbolo_ricorrenza = "‚ôªÔ∏è"
        if desc:
            desc = f"{simbolo_ricorrenza} {desc} ID:{id_visibile}"
        else:
            desc = f"{simbolo_ricorrenza} ID:{id_visibile}"
        date_list = []
        for i in range(n):
            if ric_type == "Ogni giorno":
                d = data_inizio + datetime.timedelta(days=i)
            elif ric_type == "Ogni mese":
                month = (data_inizio.month - 1 + i) % 12 + 1
                year = data_inizio.year + (data_inizio.month - 1 + i) // 12
                day = min(data_inizio.day, [31,
                    29 if year % 4 == 0 and (year % 100 != 0 or year % 400 == 0) else 28,
                    31, 30, 31, 30, 31, 31, 30, 31, 30, 31][month-1])
                try:
                    d = datetime.date(year, month, day)
                except Exception:
                    d = datetime.date(year, month, 1)
            elif ric_type == "Ogni anno":
                year = data_inizio.year + i
                try:
                    d = datetime.date(year, data_inizio.month, data_inizio.day)
                except Exception:
                    d = datetime.date(year, data_inizio.month, 1)
            else:
                break
            date_list.append(d)
        for d in date_list:
            if d not in self.spese:
                self.spese[d] = []
            self.spese[d].append((cat, desc, imp, tipo, ric_id))
        self.ricorrenze[ric_id] = {
            "tipo": ric_type,
            "n": n,
            "data_inizio": data_inizio.strftime("%d-%m-%Y"),
            "cat": cat,
            "desc": desc,
            "imp": imp,
            "tipo_voce": tipo,
            "date_list": [d.strftime("%d-%m-%Y") for d in date_list]
        }
        self.save_db()
        self.refresh_gui()
        self.show_custom_info("Ricorrenza Programmata", f"Sono state generate e registrate {n} nuove transazioni future in base alla ricorrenza definita.")
        oggi = datetime.date.today().strftime("%d-%m-%Y")
        self.importo_ricorrenza.set("")
        self.ricorrenza_tipo.set("Nessuna")
        self.ricorrenza_n.set(1)
        self.ricorrenza_data_inizio.set(oggi)
        self.ricorrenza_cat_sel.set(self.categorie[0])
        self.ricorrenza_desc.set("")
        self.ricorrenza_imp.set("")
        self.ricorrenza_tipo_voce.set("Uscita")
        self.ricorrenza_tipo_voce.set("Uscita")
        self.btn_tipo_voce.configure(
            text="Uscita", 
            style="RedOutline.TButton"
        )
      
    # Visualizzazione Dettagliata (Popup) delle Scadenze di una Ricorrenza
    def on_ricorrenza_double_click(self, event):
        tree = event.widget
        parent_window = tree.winfo_toplevel()
        item_id = tree.focus()
        if not item_id or item_id not in self.ricorrenze:
            return
        ricorrenza_dati = self.ricorrenze.get(item_id, {})
        descrizione_ricorrenza = ricorrenza_dati.get("cat", "N/D")
        importo_ricorrenza = ricorrenza_dati.get("imp", 0.0)
        tipo_std = ricorrenza_dati.get('tipo_voce', 'Uscita')
        n_volte = ricorrenza_dati.get("n", 0)
        popup_movimenti = tk.Toplevel(parent_window)
        popup_movimenti.configure(bg=self.COLOR_WIDGET_BG)
        popup_movimenti.title(f"Movimenti di '{descrizione_ricorrenza}'")
        width, height = 850, 550
        screen_width = popup_movimenti.winfo_screenwidth()
        screen_height = popup_movimenti.winfo_screenheight()
        x = (screen_width // 2) - (width // 2)
        y = (screen_height // 2) - (height // 2)
        popup_movimenti.geometry(f"{width}x{height}+{x}+{y}")
        popup_movimenti.transient(parent_window)
        popup_movimenti.focus_set()
        tree_movimenti = ttk.Treeview(
            popup_movimenti,
            columns=("data", "descrizione", "importo", "saldato", "da_saldare"),
            show="headings"
        )
        tree_movimenti.pack(fill="both", expand=True, padx=10, pady=10)
        for col in ("data", "descrizione", "importo", "saldato", "da_saldare"):
            tree_movimenti.heading(col, text=col.capitalize())
            tree_movimenti.column(col, width=100 if col != "descrizione" else 300, anchor="center")
        tree_movimenti.tag_configure("verde", foreground="green")
        tree_movimenti.tag_configure("rosso", foreground="red")
        tree_movimenti.tag_configure("grigio", foreground="gray")
        tree_movimenti.bind("<Double-1>", self.on_scadenza_doppio_click)
        oggi = datetime.date.today()
        date_list_str = ricorrenza_dati.get("date_list", [])
        for data_str in date_list_str:
            try:
                data_movimento = datetime.datetime.strptime(data_str, "%d-%m-%Y").date()
            except: continue
            voce_trovata = False
            importo_effettivo = importo_ricorrenza
            if data_movimento in self.spese:
                for voce in self.spese[data_movimento]:
                    if len(voce) >= 5 and str(voce[4]) == str(item_id):
                        importo_effettivo = voce[2]
                        voce_trovata = True
                        break
            if data_movimento <= oggi:
                if voce_trovata:
                    icona_p, icona_dp = "‚úîÔ∏è", ""
                    tag = "verde" if tipo_std == "Entrata" else "rosso"
                else:
                    icona_p, icona_dp = "", "‚ùå"
                    tag = "grigio"
            else:
                icona_p, icona_dp = "", "‚ùå"
                tag = "verde" if tipo_std == "Entrata" else "rosso"

            tree_movimenti.insert("", "end", values=(
                data_str, descrizione_ricorrenza, f"{importo_effettivo:,.2f} ‚Ç¨", icona_p, icona_dp
            ), tags=(tag,))
        info_frame = ttk.Frame(popup_movimenti, padding=(10, 5))
        info_frame.pack(fill="x", expand=False)
        
        info_text = (
            f"Dettagli ricorrenza: {descrizione_ricorrenza} - "
            f"Importo: {importo_ricorrenza:,.2f} ‚Ç¨ - "
            f"Periodo: {ricorrenza_dati.get('tipo', 'N/D')} - "
            f"Durata: {n_volte} volte"
        )
        ttk.Label(info_frame, text=info_text, font=("Arial", 10, "bold")).pack(side="left")
        ttk.Button(info_frame, text="‚ùå Chiudi", command=popup_movimenti.destroy, style='Giallo.TButton').pack(side="right", padx=5)
        popup_movimenti.bind("<Escape>", lambda e: popup_movimenti.destroy())
    
    # Gestore dell'Inserimento di una Singola Transazione
    def add_spesa(self):
        self.mostra_treeview_statistiche()
        self.after(0, self.imp_entry.focus_set)
        if hasattr(self, 'ricorrenza_tipo') and self.ricorrenza_tipo.get() != "Nessuna":
            self.add_ricorrenza()
            return
        data = self.data_spesa_var.get()
        cat = self.cat_sel.get()
        desc = self.desc_entry.get().strip()
        try:
            imp = float(self.imp_entry.get().replace(",", "."))
        except ValueError:
            self.show_custom_warning("Errore", "Importo mancante o non valido.")
            return
        tipo = self.tipo_spesa_var.get()
        try:
            d = datetime.datetime.strptime(data, "%d-%m-%Y").date()
        except ValueError:
            self.show_custom_warning("Errore", "Formato data non valido.")
            return
        if d not in self.spese:
            self.spese[d] = []
        self.spese[d].append((cat, desc, imp, tipo))
        self.desc_entry.delete(0, tk.END)
        self.imp_entry.delete(0, tk.END)
        self.save_db()
        self.reset_modifica_form()
        self.refresh_gui()
        if not self.blocca_data_var.get():
            self.data_spesa_var.set(datetime.date.today().strftime("%d-%m-%Y"))
        self.categoria_bloccata = False
        self.label_smartcat.config(text="üõ†Ô∏è SmartCat attiva", foreground="red")
        self.metodo_pagamento_var.set("")
        def destroy_window_and_cleanup():
            if hasattr(self, 'lista_window_ref') and self.lista_window_ref.winfo_exists():
                self.lista_window_ref.destroy() 
                delattr(self, 'lista_window_ref')
            self.refresh_gui() 
            self.ricorrenza_cat_sel.set(self.categorie[0]) 
            self.ricorrenza_tipo_voce.set("Uscita")
            self.ricorrenza_tipo_voce.set("Uscita")
            self.btn_tipo_voce.configure(
                text="Uscita", 
                style="RedOutline.TButton"
            )

    # Visualizzazione e Gestione di Tutte le Ricorrenze Programmate (Dashboard)
    def mostra_lista_ricorrenze(self):
        import datetime
        if hasattr(self, 'lista_window_ref') and self.lista_window_ref.winfo_exists():
            self.lista_window_ref.lift()
            self.lista_window_ref.focus_force()
            return
        def parse_data(data_str):
            if isinstance(data_str, datetime.date):
                return data_str
            try:
                return datetime.datetime.strptime(data_str, "%d-%m-%Y").date()
            except (ValueError, TypeError):
                return None
        def calcola_data_fine(data_inizio, n_volte, periodo):
            if not data_inizio or not isinstance(n_volte, int) or n_volte < 1:
                return "N/D"
            periodo = periodo.lower().strip()
            if periodo == "ogni giorno":
                data_fine_obj = data_inizio + datetime.timedelta(days=n_volte - 1)
            elif periodo == "ogni mese":
                total_months = data_inizio.month + n_volte - 1
                anno_fine = data_inizio.year + (total_months - 1) // 12
                mese_fine = (total_months - 1) % 12 + 1
                giorno_inizio = data_inizio.day
                try:
                    data_fine_obj = datetime.date(anno_fine, mese_fine, giorno_inizio)
                except ValueError:
                    if mese_fine == 12:
                        primo_giorno_mese_successivo = datetime.date(anno_fine + 1, 1, 1)
                    else:
                        primo_giorno_mese_successivo = datetime.date(anno_fine, mese_fine + 1, 1)
                    ultimo_giorno_mese_fine = (primo_giorno_mese_successivo - datetime.timedelta(days=1)).day
                    data_fine_obj = datetime.date(anno_fine, mese_fine, ultimo_giorno_mese_fine)
            elif periodo == "ogni anno":
                anno_fine = data_inizio.year + n_volte - 1
                try:
                    data_fine_obj = data_inizio.replace(year=anno_fine)
                except ValueError:
                    data_fine_obj = data_inizio.replace(year=anno_fine, day=28)
            else:
                return "N/D"
            return data_fine_obj.strftime("%d-%m-%Y")
        def destroy_window_and_cleanup():
            if hasattr(self, 'lista_window_ref') and self.lista_window_ref.winfo_exists():
                self.lista_window_ref.destroy() 
                delattr(self, 'lista_window_ref')
        def _delete_selected_ricorrenze():
            selected_ids = tree.selection()
            if not selected_ids:
                self.show_custom_warning("Attenzione", "Seleziona almeno una ricorrenza da cancellare.")
                return
            response = self.show_custom_askyesno(
                "Conferma Cancellazione", 
                f"Sei sicuro di voler cancellare {len(selected_ids)} ricorrenza/e selezionata/e?"
            )
            if not response:
                return
            ids_to_delete = list(selected_ids)
            deleted_count = 0
            for ric_id in ids_to_delete:
                if ric_id not in self.ricorrenze:
                    continue
                keys_to_delete = []
                for data_key, voci in list(self.spese.items()):
                    nuove_voci = [
                        voce for voce in voci 
                        if not (len(voce) >= 5 and voce[4] == ric_id)
                    ]
                    if nuove_voci:
                        self.spese[data_key] = nuove_voci
                    else:
                        keys_to_delete.append(data_key)
                for data_key in keys_to_delete:
                    del self.spese[data_key]
                del self.ricorrenze[ric_id]
                try:
                    tree.delete(ric_id) 
                    deleted_count += 1
                except tk.TclError:
                    pass
            if deleted_count > 0:
                if hasattr(self, "db"):
                    self.db["spese"] = self.spese
                    self.db["ricorrenze"] = self.ricorrenze
                self.save_db()
                self.show_custom_info("Cancellazione Eseguita", f"Sono state rimosse con successo {deleted_count} transazione/i dal registro.")
            self.refresh_gui() 
            self.ricorrenza_cat_sel.set(self.categorie[0]) 
            self.ricorrenza_tipo_voce.set("Uscita")
            self.btn_tipo_voce.configure(text="Uscita", style="RedOutline.TButton")
        def treeview_sort_column(tv, col, reverse):
            l = [(tv.set(k, col), k) for k in tv.get_children('')]
            try:
                l.sort(key=lambda t: float(t[0].replace(' ‚Ç¨', '').replace(',', '.').strip()), reverse=reverse)
            except (ValueError, IndexError):
                l.sort(key=lambda t: t[0], reverse=reverse)
            for index, (val, k) in enumerate(l):
                tv.move(k, '', index)
            tv.heading(col, command=lambda: treeview_sort_column(tv, col, not reverse))
        lista_window = tk.Toplevel(self)
        self.lista_window_ref = lista_window
        lista_window.withdraw()
        self.update_idletasks()
        main_x = self.winfo_rootx()
        main_y = self.winfo_rooty()
        main_width = self.winfo_width()
        main_height = self.winfo_height()
        lista_window_width = 1200
        lista_window_height = 600
        center_x = main_x + (main_width // 2) - (lista_window_width // 2)
        center_y = main_y + (main_height // 2) - (lista_window_height // 2)
        lista_window.geometry(f"{lista_window_width}x{lista_window_height}+{center_x}+{center_y}")
        lista_window.transient(self)
        lista_window.title("Lista delle Ricorrenze Programmate")
        lista_window.deiconify()
        lista_window.lift()
        lista_window.bind("<Escape>", lambda e: lista_window.after(50, destroy_window_and_cleanup))
        lista_window.protocol("WM_DELETE_WINDOW", lambda: lista_window.after(50, destroy_window_and_cleanup))
        main_frame = ttk.Frame(lista_window, padding=10)
        main_frame.pack(fill="both", expand=True)
        columns = ("Categoria", "Tipo", "Importo", "Durata", "Saldate", "Data Inizio", "Data Fine", "Importo Totale", "Contabilizzato", "Residuo", "ID")
        tree = ttk.Treeview(main_frame, columns=columns, show="headings", height=12)
        tree.tag_configure("uscita", foreground="red")
        tree.tag_configure("entrata", foreground="green")
        larghezze = {"Categoria": 110, "Tipo": 50, "Importo": 60, "Durata": 30, "Saldate": 30, "Data Inizio": 60, "Data Fine": 60, "Importo Totale": 80, "Contabilizzato": 70, "Residuo": 60, "ID": 250}
        for col in columns:
            tree.heading(col, text=col, command=lambda _col=col: treeview_sort_column(tree, _col, False))
            tree.column(col, width=larghezze[col], anchor="center")
        tree.pack(fill="both", expand=True)
        oggi = datetime.date.today()
        bilancio_mensile = 0.0
        evasi_per_ricorrenza = {id_ric: [] for id_ric in self.ricorrenze.keys()}
        for id_ricorrenza, dati in self.ricorrenze.items():
            data_inizio_str = dati.get("data_inizio", "N/D")
            data_inizio_obj = parse_data(data_inizio_str)
            if data_inizio_obj:
                 if dati.get("tipo", "").lower() == "ogni mese":
                    volte_passate = (oggi.year - data_inizio_obj.year) * 12 + (oggi.month - data_inizio_obj.month)
                    for i in range(volte_passate + 1):
                        data_movimento = (data_inizio_obj.replace(day=1) + datetime.timedelta(days=32 * i)).replace(day=data_inizio_obj.day)
                        if data_movimento <= oggi:
                            evasi_per_ricorrenza[id_ricorrenza].append({
                                'data': data_movimento.strftime("%d-%m-%Y"),
                                'descrizione': f"{dati['cat']} del {data_movimento.strftime('%B')}",
                                'importo': dati['imp'],
                                'tipo': dati['tipo_voce']
                            })
        for i, (id_ricorrenza, dati) in enumerate(self.ricorrenze.items()):
            cat = dati.get("cat", "Sconosciuta")
            tipo_voce = dati.get("tipo_voce", dati.get("tipo", "N/D"))
            imp = dati.get("imp", 0.0)
            n_volte = dati.get("n", 0)
            ric_periodo = dati.get("tipo", "N/D")
            data_inizio_str = dati.get("data_inizio", "N/D")
            data_inizio_obj = parse_data(data_inizio_str)
            data_fine = calcola_data_fine(data_inizio_obj, n_volte, ric_periodo)
            importo_totale = imp * n_volte if isinstance(n_volte, int) else 0.0
            volte_passate = 0
            if data_inizio_obj:
                if oggi >= data_inizio_obj:
                    if ric_periodo.lower() == "ogni mese":
                        diff_mesi = (oggi.year - data_inizio_obj.year) * 12 + (oggi.month - data_inizio_obj.month)
                        volte_passate = diff_mesi + 1
                    elif ric_periodo.lower() == "ogni anno":
                        volte_passate = (oggi.year - data_inizio_obj.year) + 1
                    elif ric_periodo.lower() == "ogni giorno":
                        diff_giorni = (oggi - data_inizio_obj).days
                        volte_passate = diff_giorni + 1
            volte_passate = min(volte_passate, n_volte)
            importo_gia_pagato = imp * volte_passate
            importo_rimasto = importo_totale - importo_gia_pagato
            tag = "uscita" if tipo_voce == "Uscita" else "entrata"
            values = (cat, tipo_voce, f"{imp:,.2f} ‚Ç¨", n_volte, volte_passate, data_inizio_str, data_fine, f"{importo_totale:,.2f} ‚Ç¨", f"{importo_gia_pagato:,.2f} ‚Ç¨", f"{importo_rimasto:,.2f} ‚Ç¨", id_ricorrenza)
            tree.insert("", "end", iid=id_ricorrenza, values=values, tags=(tag,))
            if ric_periodo.lower() == "ogni mese":
                bilancio_mensile += imp if tipo_voce == "Entrata" else -imp
        tree.bind("<Double-1>", self.on_ricorrenza_double_click)
        summary_frame = ttk.Frame(main_frame, padding=(0, 10))
        summary_frame.pack(fill="x", expand=False)
        bilancio_colore = "green" if bilancio_mensile >= 0 else "red"
        ttk.Label(summary_frame, text="Impatto Mensile Stimato (su base 'Mese'):", font=("Arial", 10)).pack(side="left")
        ttk.Label(summary_frame, text=f"{bilancio_mensile:,.2f} ‚Ç¨", font=("Arial", 11, "bold"), foreground=bilancio_colore).pack(side="left", padx=5)
        button_frame = ttk.Frame(main_frame, padding=(0, 10))
        button_frame.pack(fill="x", expand=False)
        cancel_button = ttk.Button(button_frame, text="‚ùå Cancella Selezionate", command=_delete_selected_ricorrenze, style="Verde.TButton")
        cancel_button.pack(side="left", padx=5)
        close_button = ttk.Button(button_frame, text="‚úì Chiudi", command=lambda: lista_window.after(50, destroy_window_and_cleanup), style="Giallo.TButton")
        close_button.pack(side="right", padx=5)
        
    # Abilita/Disabilita l'interazione con il pulsante Tipo Transazione    
    def set_tipo_spesa_editable(self, editable=True):
        if editable:
            self.btn_tipo_spesa.state(["!disabled"])
        else:
            self.btn_tipo_spesa.state(["disabled"])
            
    # Inserimento forzato del valore Importo (bypassando la validazione)
    def _inserisci_importo_senza_validazione(self, imp_value):
        self.imp_entry.config(validate="none") 
        self.imp_entry.delete(0, tk.END)
        self.imp_entry.insert(0, imp_value)
        vcmd = self.imp_entry.cget('validatecommand')
        self.imp_entry.config(validate="key", validatecommand=vcmd)

    # Caricamento Voce di Spesa nel Modulo (Preparazione per Modifica/Cancellazione)
    def on_table_click(self, event):
        self.label_smartcat.config(text="üõ†Ô∏è SmartCat disattiva", foreground="green")
        self.aggiorna_bottone_spese_simili(visibile=False)
        mode = self.stats_mode.get()
        if mode != "giorno":
            return
        region = self.stats_table.identify("region", event.x, event.y)
        if region != "cell":
            return
        col = self.stats_table.identify_column(event.x)
        if col != "#6":
            return
        self.suggerimenti_attivi = False 
        rowid = self.stats_table.identify_row(event.y)
        if not rowid:
            return
        vals = self.stats_table.item(rowid, "values")
        giorno_str, cat, desc, imp, tipo, _ = vals
        giorno = datetime.datetime.strptime(giorno_str, "%d-%m-%Y").date()
        idx = self.stats_table.index(rowid)
        voce = self.spese[giorno][idx]
        self.modifica_idx = (giorno, idx)
        self.cat_sel.set(cat)
        self.desc_entry.delete(0, tk.END)
        self.desc_entry.insert(0, desc)
        self.imp_entry.delete(0, tk.END)
        self.imp_entry.insert(0, imp)
        self.after(0, lambda: self._inserisci_importo_senza_validazione(imp))
        self.tipo_spesa_var.set(tipo)
        self.btn_tipo_spesa.config(text=tipo)
        self.btn_modifica["state"] = tk.NORMAL
        self.btn_modifica["cursor"] = "arrow"
        self.btn_aggiungi["state"] = tk.DISABLED
        self.btn_aggiungi["cursor"] = "X_cursor"
        self.btn_cancella["state"] = tk.NORMAL
        self.btn_cancella["cursor"] = "arrow"
        self.data_spesa_var.set(giorno.strftime("%d-%m-%Y"))
        self.btn_reset_form["state"] = tk.DISABLED
        self.set_tipo_spesa_editable(True) #Modifica Tipo entrata/uscita consentita
        new_style = 'GreenOutline.TButton' if tipo == "Entrata" else 'RedOutline.TButton'
        self.btn_tipo_spesa.config(style=new_style)
        if len(voce) == 5:
            ric_id = voce[4]
            if ric_id in self.ricorrenze:
                ric = self.ricorrenze[ric_id]
                self.show_custom_info("Voce ricorrente", f"Questa voce √® parte di una ricorrenza: {ric['tipo']} x{ric['n']} da {ric['data_inizio']}.\nPuoi cancellare tutta la ricorrenza dal pannello Ricorrenze sotto.\nIn alternativa puoi modificare la singola voce o cancellarla")

    # Sincronizzazione visiva (colore/testo) del pulsante Tipo Spesa
    def aggiorna_stile_tipo_spesa(self):
        tipo = self.tipo_spesa_var.get()
        btn_style = 'GreenOutline.TButton' if tipo == "Entrata" else 'RedOutline.TButton'
        self.btn_tipo_spesa.config(
            text=tipo,
            style=btn_style
        )
        
    # Gestione delle Transazioni Esistenti (Modifica e Cancellazione di Singole Voci)
    def reset_modifica_form(self):
        self.suggerimenti_attivi = True  
        self.label_smartcat.config(text="üõ†Ô∏è SmartCat attiva", foreground="red")
        self.modifica_idx = None
        self.btn_modifica["state"] = tk.DISABLED
        self.btn_modifica["cursor"] = "X_cursor"
        self.btn_aggiungi["state"] = tk.NORMAL
        self.btn_aggiungi["cursor"] = "arrow"
        self.btn_cancella["state"] = tk.DISABLED
        self.btn_cancella["cursor"] = "X_cursor"
        self.desc_entry.delete(0, tk.END)
        self.imp_entry.delete(0, tk.END)
        self.cat_sel.set("Generica")
        self.metodo_pagamento_var.set("")
        self.on_categoria_changed()
        self.set_tipo_spesa_editable(True)
        if not self.blocca_data_var.get():
         self.data_spesa_var.set(datetime.date.today().strftime("%d-%m-%Y"))
        self.categoria_bloccata = False  
        self.btn_reset_form["state"] = tk.NORMAL
        self.btn_aggiungi["state"] = tk.NORMAL
    def salva_modifica(self):
        if not self.modifica_idx:
            return
        old_dt, idx = self.modifica_idx
        new_data = self.data_spesa_var.get()
        new_dt = datetime.datetime.strptime(new_data, "%d-%m-%Y").date()
        cat = self.cat_sel.get()
        desc = self.desc_entry.get().strip()
        try:
            imp = float(self.imp_entry.get().replace(",", "."))
        except Exception:
            self.show_custom_warning("Errore", "Importo mancante o non valido.")
            return
        tipo = self.tipo_spesa_var.get()
        if old_dt not in self.spese or idx >= len(self.spese[old_dt]):
            self.show_custom_warning("Errore", "La voce selezionata non esiste pi√π.")
            self.reset_modifica_form()
            return
        voce_old = self.spese[old_dt][idx]
        id_ric = voce_old[4] if len(voce_old) == 5 else None
        del self.spese[old_dt][idx]
        if not self.spese[old_dt]:
            del self.spese[old_dt]
        if new_dt not in self.spese:
            self.spese[new_dt] = []
        voce_new = (cat, desc, imp, tipo)
        if id_ric is not None:
            voce_new += (id_ric,)
        self.spese[new_dt].append(voce_new)
        self.save_db()
        self.refresh_gui()
        self.reset_modifica_form()
        self.suggerimenti_attivi = True 
        self.btn_aggiungi["state"] = tk.NORMAL
    def cancella_voce(self):
        if not self.modifica_idx:
            return
        dt, idx = self.modifica_idx
        if dt in self.spese and 0 <= idx < len(self.spese[dt]):
            del self.spese[dt][idx]
            if not self.spese[dt]:
                del self.spese[dt]
            self.save_db()
            self.refresh_gui()
        self.reset_modifica_form()
        self.colora_giorni_spese()
        self.suggerimenti_attivi = True 
        self.btn_aggiungi["state"] = tk.NORMAL
        
    # Popolamento della Tabella Riepilogo Transazioni del Mese Corrente    
    def update_spese_mese_corrente(self):
        for i in self.spese_mese_tree.get_children():
            self.spese_mese_tree.delete(i)
        now = datetime.date.today()
        year, month = now.year, now.month
        spese_mese = []
        for d in sorted(self.spese.keys()):
            if d.year == year and d.month == month:
                for entry in self.spese[d]:
                    cat, desc, imp, tipo = entry[:4]
                    spese_mese.append((d, cat, desc, imp, tipo))
        for d, cat, desc, imp, tipo in spese_mese:
            tag = 'entrata' if tipo == 'Entrata' else 'uscita'
            self.spese_mese_tree.insert("", "end", values=(
                d.strftime("%d-%m-%Y"), cat, desc, f"{imp:.2f}", tipo
            ), tags=(tag,))
 
    # Applicazione Filtro Mese/Anno (Estratto Conto) e Aggiornamento Viste Statistiche
    def apply_estratto(self, forza_modalita=None):
        try:
            month_str = self.estratto_month_var.get()
            match = re.match(r'(\d+)\s*-\s*', month_str)
            if match:
                m = int(match.group(1))
            else:
                try:
                    m = int(month_str)
                except ValueError:
                    raise ValueError("Il formato del mese non √® corretto o √® vuoto.")
            y = int(self.estratto_year_var.get())
            d = datetime.date(y, m, 1)
            self.stats_refdate = d
            if not forza_modalita:
                self.toggle_stats_view("tabella")
            if not hasattr(self, 'stats_table') or not self.stats_table.winfo_exists():
                return 
            if forza_modalita:
                self.set_stats_mode(forza_modalita)
            self.update_totalizzatore_anno_corrente()
            self.update_totalizzatore_mese_corrente()
            self.update_spese_mese_corrente()           
        except Exception:
            self.show_custom_warning("Errore", "Mese o anno non validi")
            
    # Reconfigurazione Dinamica della Tabella Statistiche per Modalit√† di Visualizzazione
    def set_stats_mode(self, mode):
        if not hasattr(self, 'stats_table') or not self.stats_table.winfo_exists():
            return 
        if hasattr(self, 'stats_mode'):
            self.stats_mode.set(mode)
        self.stats_table["displaycolumns"] = ("A", "B", "C", "D", "E", "F")
        if mode == "giorno":
            try:
                data_corrente = self.cal.selection_get()
            except:
                data_corrente = datetime.date.today()
            
            self.stats_label.config(text=f"Riepilogo Giornaliero - {data_corrente.strftime('%d-%m-%Y')}", 
                                  foreground="purple", font=("Arial", 10, "bold"))
            cols = {
                "A": (80, "center", "Data"),
                "B": (150, "w", "Categoria"),
                "C": (240, "w", "Descrizione"),
                "D": (100, "center", "Importo (‚Ç¨)"),
                "E": (80, "center", "Tipo"),
                "F": (60, "center", "Modifica")
            }
        else:
            if mode == "mese":
                ref = getattr(self, 'stats_refdate', datetime.date.today())
                m_name = self.get_month_name(ref.month) if hasattr(self, 'get_month_name') else str(ref.month)
                self.stats_label.config(text=f"Riepilogo Mensile {m_name} {ref.year}", foreground="dodgerblue", font=("Arial", 10, "bold"))
            elif mode == "anno":
                ref = getattr(self, 'stats_refdate', datetime.date.today())
                self.stats_label.config(text=f"Riepilogo Annuale {ref.year}", foreground="forest green", font=("Arial", 10, "bold"))
            else:
                self.stats_label.config(text="Riepilogo Totale Categorie", foreground="firebrick", font=("Arial", 10, "bold"))
            self.stats_table["displaycolumns"] = ("A", "B", "C")
            cols = {
                "A": (300, "w", "Categoria"),
                "B": (200, "center", "Totale (‚Ç¨)"),
                "C": (150, "center", "Tipo")
            }
        for col_id, (width, anchor, txt) in cols.items():
            self.stats_table.column(col_id, width=width, anchor=anchor)
            self.stats_table.heading(col_id, text=txt)
        funcs = [self.update_stats, self.update_totalizzatore_anno_corrente, 
                 self.update_totalizzatore_mese_corrente, self.update_spese_mese_corrente]
        for f in funcs:
            try: f()
            except: pass
        if hasattr(self, 'vsb_stats'):
            self.stats_table.configure(yscrollcommand=self.vsb_stats.set)
            self.vsb_stats.config(command=self.stats_table.yview)
            self.vsb_stats.lift() 
            self.stats_table.yview_moveto(0)
            
    def treeview_sort_column(self, tv, col, reverse):
        items = [(tv.set(k, col), k) for k in tv.get_children('')]
        try:  
            items.sort(key=lambda t: float(str(t[0]).replace(",", ".").replace("‚Ç¨", "")), reverse=reverse)
        except Exception:
            items.sort(key=lambda t: t[0], reverse=reverse)
        for index, (val, k) in enumerate(items):
            tv.move(k, '', index)
        tv.heading(col, command=lambda: self.treeview_sort_column(tv, col, not reverse))
        
    def get_month_name(self, month):
        mesi = [
            "Gennaio", "Febbraio", "Marzo", "Aprile", "Maggio", "Giugno",
            "Luglio", "Agosto", "Settembre", "Ottobre", "Novembre", "Dicembre"
        ]
        return mesi[month-1] if 1 <= month <= 12 else str(month)
    def update_stats(self):
        if not hasattr(self, 'stats_table') or not self.stats_table.winfo_exists():
            return
        for i in self.stats_table.get_children():
            self.stats_table.delete(i)
        mode = self.stats_mode.get()
        tot_entrate, tot_uscite = 0.0, 0.0
        oggi = datetime.date.today()
        ref = self.stats_refdate
        if mode == "giorno":
            try:
                giorno = datetime.datetime.strptime(self.cal.get_date(), "%d-%m-%Y").date()
            except Exception:
                giorno = oggi
            spese = self.spese.get(giorno, [])
            for idx, entry in enumerate(spese):
                cat, desc, imp, tipo = entry[:4]
                tag = "entrata" if tipo == "Entrata" else "uscita"
                self.stats_table.insert(
                    "", "end",
                    values=(giorno.strftime("%d-%m-%Y"), cat, desc, f"{imp:.2f}", tipo, "Modifica"),
                    tags=(f"{giorno.strftime('%d-%m-%Y')}|{idx}", tag)
                )
                if tipo == "Entrata":
                    tot_entrate += imp
                else:
                    tot_uscite += imp
        else:
            totali = {}
            for d, sp in self.spese.items():
                if mode == "mese":
                    if not (d.year == ref.year and d.month == ref.month):
                        continue
                elif mode == "anno":
                    if d.year != ref.year:
                        continue
                for entry in sp:
                    data_voce = d
                    if not self.considera_ricorrenze_var.get():
                        if mode == "totali":
                            if data_voce > oggi:
                                continue
                        elif mode == "anno":
                            if ref.year == oggi.year:
                                if data_voce > oggi:
                                    continue    
                        elif mode == "mese":
                            if ref.year == oggi.year and ref.month == oggi.month:
                                if data_voce > oggi:
                                    continue
                    cat, desc, imp, tipo = entry[:4]
                    if cat not in totali:
                        totali[cat] = {"Entrata": 0.0, "Uscita": 0.0}
                    totali[cat][tipo] += imp
            for cat in sorted(totali.keys()):
                for tipo in ("Entrata", "Uscita"):
                    if totali[cat][tipo] > 0:
                        tag = "entrata" if tipo == "Entrata" else "uscita"
                        self.stats_table.insert(
                            "", "end",
                            values=(cat, f"{totali[cat][tipo]:.2f}", tipo),
                            tags=(tag,)
                        )
                        if tipo == "Entrata":
                            tot_entrate += totali[cat][tipo]
                        else:
                            tot_uscite += totali[cat][tipo]
        diff = tot_entrate - tot_uscite
        colore_fg = "dodgerblue" if diff >= 0 else "red" 
        txt_tot = f"Totale Entrate: {tot_entrate:.2f}    Totale Uscite: {tot_uscite:.2f}    Differenza: {diff:.2f}"
        self.totali_label.config(text=txt_tot, foreground=colore_fg, font=("Arial", 10, "bold"))

    # Calcolo e Visualizzazione Totali Riassuntivi (Annuali e Mensili)
    def update_totalizzatore_anno_corrente(self):
        anno = datetime.date.today().year
        totale_entrate = 0.0
        totale_uscite = 0.0
        for d, sp in self.spese.items():
            if d.year == anno:
                for entry in sp:
                    if hasattr(self, "considera_ricorrenze_var") and not self.considera_ricorrenze_var.get() and len(entry) == 5:
                        if d > datetime.date.today():
                            continue
                    tipo = entry[3]
                    imp = entry[2]
                    if tipo == "Entrata":
                        totale_entrate += imp
                    else:
                        totale_uscite += imp
        differenza = totale_entrate - totale_uscite
        self.totalizzatore_entrate_label.config(text=f"{totale_entrate:.2f} ‚Ç¨")
        self.totalizzatore_uscite_label.config(text=f"{totale_uscite:.2f} ‚Ç¨")
        self.totalizzatore_diff_label.config(text=f"{differenza:.2f} ‚Ç¨")
        if differenza < 0:
            self.start_blinking_colors(self.totalizzatore_diff_label)
        else:
            self.stop_blinking_colors(self.totalizzatore_diff_label)
            self.totalizzatore_diff_label.config(foreground="dodgerblue")
    def update_totalizzatore_mese_corrente(self):
        now = datetime.date.today()
        year, month = now.year, now.month
        totale_entrate = 0.0
        totale_uscite = 0.0
        for d, sp in self.spese.items():
            if d.year == year and d.month == month:
                for entry in sp:
                    if hasattr(self, "considera_ricorrenze_var") and not self.considera_ricorrenze_var.get() and len(entry) == 5:
                        if d > now:
                            continue
                    tipo = entry[3]
                    imp = entry[2]
                    if tipo == "Entrata":
                        totale_entrate += imp
                    else:
                        totale_uscite += imp
        differenza = totale_entrate - totale_uscite
        self.totalizzatore_mese_entrate_label.config(text=f"{totale_entrate:.2f} ‚Ç¨")
        self.totalizzatore_mese_uscite_label.config(text=f"{totale_uscite:.2f} ‚Ç¨")
        self.totalizzatore_mese_diff_label.config(text=f"{differenza:.2f} ‚Ç¨")
        if differenza < 0:
            self.start_blinking_colors(self.totalizzatore_mese_diff_label)
        else:
            self.stop_blinking_colors(self.totalizzatore_mese_diff_label)
            self.totalizzatore_mese_diff_label.config(foreground="dodgerblue")
 
    # Dialogo di Reset Avanzato Dati e Configurazioni (Database, Categorie, Password)
    def show_reset_dialog(self):
        dialog = tk.Toplevel(self, bg=self.COLOR_TOPLEVEL)
        dialog.title("Reset Database")
        dialog.grab_set()
        dialog.resizable(False, False)
        dialog.transient(self)
        screen_width = self.winfo_screenwidth()
        screen_height = self.winfo_screenheight()
        window_width = 600  
        window_height = 250 
        x_coordinate = (screen_width - window_width) // 2
        y_coordinate = (screen_height - window_height) // 2
        dialog.geometry(f"{window_width}x{window_height}+{x_coordinate}+{y_coordinate}")
        dialog.bind("<Escape>", lambda e: dialog.destroy())
        label = tk.Label(dialog, text=(
            "Vuoi cancellare tutti Movimenti e/o le categorie?\n\n"
            "Scegli 'S√¨' per cancellare tutto (Movimenti + categorie, rester√† solo la categoria di default)\n\n"
            "'No' per cancellare solo i Movimenti.\n\n"
            "'Password' per cancellare la password\n\n"
            "'Reset' Azzera tutti i Dati\n"
        ),bg=self.COLOR_TOPLEVEL, fg=self.TEXT_COLOR, font=("Arial", 10), justify="left", padx=12, pady=10)
        label.pack()
        btns = tk.Frame(dialog, bg=self.COLOR_TOPLEVEL)
        btns.pack(pady=(0, 10))
        def show_custom_warning(titolo, messaggio, duration_ms=2500):
            parent = self
            width = 350
            height = 80
            parent.update_idletasks()
            parent_width = parent.winfo_width()
            parent_height = parent.winfo_height()
            x_pos = (parent_width // 2) - (width // 2)
            y_pos = (parent_height // 2) - (height // 2)
            popup_frame = tk.Frame(parent, bg="orange", bd=3, relief="raised")
            popup_frame.place(x=x_pos, y=y_pos, width=width, height=height)
            popup_frame.lift() 
            label = tk.Label(popup_frame, text=messaggio, font=("Arial", 10, "bold"), 
                              justify="center", padx=10, pady=10, bg="orange", fg="black")
            label.pack(expand=True, fill='both')
            popup_frame.update()
            parent.after(duration_ms, popup_frame.destroy)
        def do_yes():           
            try:
                dialog.destroy()
                self.spese = {}
                self.categorie = ["Generica"]
                self.categorie_tipi = {"Generica": "Uscita"}
                self.ricorrenze = {}
                self.save_db()
                self.update_stats()
                self.update_totalizzatore_anno_corrente()
                self.update_totalizzatore_mese_corrente()
                self.update_spese_mese_corrente()
                try:
                    self.cat_menu["values"] = self.categorie
                    self.cat_mod_menu["values"] = self.categorie
                    self.cat_sel.set(self.categorie[0])
                    self.cat_mod_sel.set(self.categorie[0])
                except Exception as widget_error:
                    pass 
                show_custom_warning("Movimenti", "Movimenti e Categorie azzerate")
            except Exception as e:
                print(f"Errore durante il reset: {e}")
        def do_no():
            dialog.destroy()
            self.spese = {}
            self.ricorrenze = {}
            self.save_db()
            self.update_stats()
            self.update_totalizzatore_anno_corrente()
            self.update_totalizzatore_mese_corrente()
            self.update_spese_mese_corrente()
            show_custom_warning("Movimenti", "Movimenti azzerati")
        def do_password():
            dialog.destroy()
            if os.path.exists(PW_FILE):
             os.remove(PW_FILE)
            show_custom_warning("Password", "Password azzerata")
        def do_reset():
            import subprocess, sys, os
            dialog.destroy()
            shutil.rmtree(DB_DIR) 
            shutil.rmtree(EXPORT_FILES)
            show_custom_warning("Ripristino", "Riavvio in corso. Dati azzerati allo stato predefinito!")
            self._on_close_lock()
            def restart_application():
                script_path = os.path.abspath(sys.argv[0])
                args = [sys.executable, script_path] + sys.argv[1:]
                if os.name == 'nt':
                    subprocess.Popen(args, creationflags=0x00000008, shell=False, close_fds=True)
                else:
                    subprocess.Popen(args, start_new_session=True, close_fds=True)
                os._exit(0)
            self.after(2600, restart_application)
        def do_cancel():
            dialog.destroy()
        ttk.Button(btns, text="‚úì S√¨", command=do_yes, style="Rosso.TButton").grid(row=0, column=0, padx=5)
        ttk.Button(btns, text="‚ùå No", command=do_no, style="Rosso.TButton").grid(row=0, column=1, padx=5)
        ttk.Button(btns, text="üìÖ Password", command=do_password, style="Blu.TButton").grid(row=0, column=4, padx=5)
        ttk.Button(btns, text="‚ùå RESET", command=do_reset, style="Giallo.TButton").grid(row=0, column=5, padx=5)
        ttk.Button(btns, text="‚ùå Annulla", command=do_cancel, style="Giallo.TButton").grid(row=0, column=6, padx=5)
        btns.focus_set()
        dialog.bind("<Escape>", lambda e: do_cancel())
        dialog.bind("<Return>", lambda e: do_yes())
        dialog.bind("<KP_Enter>", lambda e: do_yes())

    # Esportazione Forzata delle Statistiche in Modalit√† Giornaliera
    def export_giorno_forzato(self):
        old_mode = self.stats_mode.get()
        self.stats_mode.set("giorno")
        self.export_stats()
        self.stats_mode.set(old_mode)

    # Generazione di Report Testuale Formattato per Esportazione Statistiche
    def export_stats(self):
        mode = self.stats_mode.get()
        lines = []
        label_width = 20
        desc_width = 30
        value_width = 14
        tipo_width = 10
        tot_entrate, tot_uscite = 0.0, 0.0
        if mode == "giorno":
            try:
                giorno = datetime.datetime.strptime(self.cal.get_date(), "%d-%m-%Y").date()
            except Exception:
                giorno = datetime.date.today()
            spese = self.spese.get(giorno, []) or self.spese.get(giorno.strftime("%d-%m-%Y"), [])
            header = f"{'Categoria':<{label_width}} {'Descrizione':<{desc_width}} {'Importo (‚Ç¨)':>{value_width}}  {'Tipo':<{tipo_width}}"
            sep = "-" * len(header)
            lines.append("=" * len(header))
            lines.append(f"{('Riepilogo Giornaliero - ' + giorno.strftime('%d-%m-%Y')).center(len(header))}")
            lines.append("=" * len(header))
            lines.append("")
            lines.append(header)
            lines.append(sep)
            if not spese:
                lines.append("Nessuna spesa trovata per il giorno selezionato.")
            else:
                for entry in spese:
                    cat, desc, imp, tipo = entry[:4]
                    lines.append(f"{cat:<{label_width}.{label_width}} {desc:<{desc_width}.{desc_width}} {imp:>{value_width}.2f}  {tipo:<{tipo_width}}")
                    if tipo == "Entrata":
                        tot_entrate += imp
                    else:
                        tot_uscite += imp
            lines.append(sep)
        else:
            totali = {}
            tipo_cat = {}
            ref = self.stats_refdate
            if mode == "mese":
                year, month = ref.year, ref.month
                monthname = self.get_month_name(month)
                title = f"Riepilogo Mensile - {monthname} {year}"
            elif mode == "anno":
                year = ref.year
                title = f"Riepilogo Anno {year}"
            else:
                title = "Riepilogo Categorie"
            header = f"{'Categoria':<{label_width}} {'Totale (‚Ç¨)':>{value_width}}  {'Tipo':<{tipo_width}}"
            sep = "-" * len(header)
            lines.append("=" * len(header))
            lines.append(title.center(len(header)))
            lines.append("=" * len(header))
            lines.append("")
            lines.append(header)
            lines.append(sep)
            for d, sp in self.spese.items():
                try:
                    d2 = datetime.datetime.strptime(d, "%d-%m-%Y").date() if isinstance(d, str) else d
                except:
                    continue
                if (mode == "mese" and d2.year == year and d2.month == month) or \
                   (mode == "anno" and d2.year == year) or \
                   (mode == "totali"):
                    for entry in sp:
                        cat, desc, imp, tipo = entry[:4]
                        totali[cat] = totali.get(cat, 0.0) + imp
                        tipo_cat[cat] = self.categorie_tipi.get(cat, tipo)
            for cat in sorted(totali.keys()):
                val = totali[cat]
                tipo = tipo_cat.get(cat, "Uscita")
                lines.append(f"{cat:<{label_width}.{label_width}} {val:>{value_width}.2f}  {tipo:<{tipo_width}}")
                if tipo == "Entrata":
                    tot_entrate += val
                else:
                    tot_uscite += val
            lines.append(sep)
        diff = tot_entrate - tot_uscite
        lines.append(f"{'Totale Entrate:':<{label_width}} {tot_entrate:>{value_width}.2f}")
        lines.append(f"{'Totale Uscite:':<{label_width}} {tot_uscite:>{value_width}.2f}")
        lines.append(f"{'Differenza:':<{label_width}} {diff:>{value_width}.2f} ‚Ç¨")
        lines.append("=" * max(len(header), label_width + value_width + tipo_width + 3))
        now = datetime.date.today()
        filename = ""
        if mode == "giorno":
            try:
                giorno = datetime.datetime.strptime(self.cal.get_date(), "%d-%m-%Y").date()
            except Exception:
                giorno = now
            filename = f"Riepilogo_Giorno_{giorno.strftime('%d-%m-%Y')}.txt"
        elif mode == "mese":
            monthname = self.get_month_name(ref.month)
            filename = f"Riepilogo_Mese_{monthname}_{ref.year}.txt"
        elif mode == "anno":
            filename = f"Riepilogo_Anno_{ref.year}.txt"
        else:
            filename = f"Riepilogo_Per_Categoria.txt"
        self.show_export_preview("\n".join(lines), default_filename=filename)
        
    # Generazione di Report Mensile Dettagliato con Ripartizione Giornaliera   
    def export_month_detail(self):
        ref = self.stats_refdate
        month = ref.month
        year = ref.year
        monthname = self.get_month_name(month)
        oggi = datetime.date.today()
        giorni_settimana = [
            "Luned√¨", "Marted√¨", "Mercoled√¨", "Gioved√¨",
            "Venerd√¨", "Sabato", "Domenica"
        ]
        lines = []
        tot_entrate, tot_uscite = 0.0, 0.0
        lines.append("=" * 100)
        lines.append(f"{('Riepilogo Mensile ' + monthname + ' ' + str(year)).center(100)}")
        lines.append("=" * 100 + "\n")
        days_in_month = [
            d for d in sorted(self.spese.keys())
            if d.year == year and d.month == month
        ]
        if not days_in_month:
            lines.append("Nessuna spesa registrata in questo mese.\n")
        else:
            for d in days_in_month:
                giorno_it = giorni_settimana[d.weekday()]
                lines.append(f"{giorno_it:<10} {d.strftime('%d/%m/%Y')}")
                lines.append("-" * 100)
                lines.append(f"{'':2}{'Categoria':<20}{'Descrizione':<40}{'Tipo':<10}{'Importo (‚Ç¨)':>14}")
                ent_giorno, usc_giorno = 0.0, 0.0
                for entry in self.spese.get(d, []):
                    is_ricorrenza = len(entry) == 5
                    if not self.considera_ricorrenze_var.get():
                        if d > oggi:
                            continue
                    if len(entry) >= 4:
                        cat, desc, imp, tipo = entry[:4]
                        lines.append(f"{'':2}{cat:<20.20}{desc:<40.40}{tipo:<10}{imp:14.2f}")
                        if tipo == "Entrata":
                            ent_giorno += imp
                            tot_entrate += imp
                        else:
                            usc_giorno += imp
                            tot_uscite += imp
                lines.append(f"\n{'':2}Totale giorno ‚Üí Entrate: {ent_giorno:8.2f} ‚Ç¨   Uscite: {usc_giorno:8.2f} ‚Ç¨\n")
        lines.append("-" * 100)
        lines.append(f"{'Totale entrate mese:':<60}{tot_entrate:14.2f} ‚Ç¨")
        lines.append(f"{'Totale uscite mese:':<60}{tot_uscite:14.2f} ‚Ç¨")
        lines.append(f"{'Saldo finale:':<60}{(tot_entrate - tot_uscite):14.2f} ‚Ç¨")
        now = datetime.date.today()
        month = now.strftime("%m-%Y")
        filename = f"Riepilogo_Mese_{month}.txt"
        self.show_export_preview("\n".join(lines), default_filename=filename)

    # Finestra di Anteprima, Salvataggio e Stampa del Report Testuale
    def show_export_preview(self, content, default_filename=None):
        preview = tk.Toplevel(self, bg=self.COLOR_TOPLEVEL )
        preview.withdraw()  
        preview.title("Anteprima Esportazione Riepilogo")
        larghezza_finestra = 1300
        altezza_finestra = 600
        def centra_finestra():
                screen_width = preview.winfo_screenwidth()
                screen_height = preview.winfo_screenheight()
                x = (screen_width - larghezza_finestra) // 2
                y = (screen_height - altezza_finestra) // 2
                preview.geometry(f"{larghezza_finestra}x{altezza_finestra}+{x}+{y}")
                preview.deiconify()
                preview.lift()
                preview.focus_force()
        preview.after(0, centra_finestra)
        preview.bind("<Escape>", lambda e: preview.destroy())
        container = tk.Frame(preview)
        container.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)

        v_scroll = ttk.Scrollbar(container, orient="vertical")
        h_scroll = ttk.Scrollbar(container, orient="horizontal")
        text = tk.Text(container, wrap="none", font=("Courier new", 10),
                       yscrollcommand=v_scroll.set, xscrollcommand=h_scroll.set)
        v_scroll.config(command=text.yview)
        h_scroll.config(command=text.xview)
        v_scroll.pack(side=tk.RIGHT, fill=tk.Y)
        h_scroll.pack(side=tk.BOTTOM, fill=tk.X)
        text.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        text.insert("1.0", content)
        text.config(state="disabled")
        text.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        def save_file():
            now = datetime.date.today()
            filename = default_filename or f"Riepilogo_Export_{now.day:02d}-{now.month:02d}-{now.year}.txt"
            file = filedialog.asksaveasfilename(
                defaultextension=".txt",
                filetypes=[("File txt", "*.txt")],
                initialdir=EXPORT_FILES,
                initialfile=filename,
                title="Salva Riepilogo",
                confirmoverwrite=False,
                parent=preview)
            if file:
                if os.path.exists(file):
                    conferma = self.show_custom_askyesno(
                        "Sovrascrivere file?",
                        f"Il file '{os.path.basename(file)}' \nesiste gi√†. Vuoi sovrascriverlo?"
                    )
                    if not conferma:
                        return  
                with open(file, "w", encoding="utf-8") as f:
                    f.write(content)
                preview.destroy()
                self.show_custom_warning("Esportazione completata", f"Riepilogo esportato in {file}")
        btn_frame = tk.Frame(preview, bg=self.COLOR_TOPLEVEL )
        btn_frame.pack(fill=tk.X, pady=8)
        btn_salva = ttk.Button(btn_frame, text="üíæ Esporta", command=save_file, style="Verde.TButton")
        btn_salva.pack(side=tk.LEFT, padx=10)
        btn_stampa = ttk.Button(
            btn_frame, 
            text="üìÑ Stampa", command=lambda: self._stampa_lista_diretta(content, self.show_custom_warning),
            style="Blu.TButton"
        )
        btn_stampa.pack(side=tk.LEFT, padx=5)
        btn_chiudi = ttk.Button(btn_frame, text="‚ùå Chiudi", command=preview.destroy, style="Giallo.TButton")
        btn_chiudi.pack(side=tk.RIGHT, padx=10)
        preview.update() 
        
    # Gestione del Database: Importazione e Esportazione del File di Dati    
    def import_db(self):
        file = filedialog.askopenfilename(
            title="Importa Database",
            defaultextension=".json",
            initialdir=EXP_DB,
            filetypes=[("File JSON", "*spese_db.json"), ("Tutti i file", "*.*")]
        )
        if file:
            try:
                with open(file, "r", encoding="utf-8") as fsrc:
                    dbdata = fsrc.read()
                with open(DB_FILE, "w", encoding="utf-8") as fdst:
                    fdst.write(dbdata)
                self.load_db()
                if hasattr(self, 'cat_menu'):
                    self.cat_menu["values"] = self.categorie
                    if self.categorie:
                        self.cat_sel.set(self.categorie[0])
                if hasattr(self, 'cat_mod_menu'):
                    self.cat_mod_menu["values"] = self.categorie
                    if self.categorie:
                        self.cat_mod_sel.set(self.categorie[0])
                self.update_stats()
                self.update_totalizzatore_anno_corrente()
                self.update_totalizzatore_mese_corrente()
                self.update_spese_mese_corrente()
                self.show_custom_warning("Importazione completata", f"Database importato da {file}")
            except Exception as e:
                print(f"Errore durante l'importazione: {e}")
                self.show_custom_warning("Errore", f"Errore durante l'importazione: {e}")
    def export_db(self):
        now = datetime.date.today()
        default_dir = EXP_DB
        default_filename = f"{now.day:02d}-{now.month:02d}-{now.year}-spese_db.json"
        file = filedialog.asksaveasfilename(
            title="Esporta Database",
            defaultextension=".json",
            initialdir=default_dir,
            initialfile=default_filename,
            confirmoverwrite=False,
            filetypes=[("File JSON", "*spese_db.json"), ("Tutti i file", "*.*")]
        )
        if file:
            try:
                with open(DB_FILE, "r", encoding="utf-8") as fsrc:
                    dbdata = fsrc.read()
                with open(file, "w", encoding="utf-8") as fdst:
                    fdst.write(dbdata)
                self.show_custom_warning("Esportazione completata", f"Database esportato in {file}")
            except Exception as e:
                self.show_custom_warning("Errore", "Errore durante l'esportazione:", f"{e}")
                
    # Esportazione di un Report Annuale Dettagliato (Matrice Categoria vs. Mese)
    def export_anno_dettagliato(self):
        try:
            year = int(self.estratto_year_var.get())
        except Exception:
            year = datetime.date.today().year

        mesi = ["Gen", "Feb", "Mar", "Apr", "Mag", "Giu",
                "Lug", "Ago", "Set", "Ott", "Nov", "Dic"]
        label_width = 22
        categorie = sorted(
            set(
                entry[0]
                for sp in self.spese.values()
                for entry in sp
                if isinstance(entry, (list, tuple)) and len(entry) >= 4
            ).union(self.categorie)
        )
        tot_entrate_mese = [0.0] * 12
        tot_uscite_mese = [0.0] * 12
        cat_entrate = {cat: [0.0] * 12 for cat in categorie}
        cat_uscite = {cat: [0.0] * 12 for cat in categorie}
        tot_entrate_anno = 0.0
        tot_uscite_anno = 0.0
        oggi = datetime.date.today()
        def date_from_key(d):
            if isinstance(d, datetime.date):
                return d
            try:
                return datetime.datetime.strptime(d, "%d-%m-%Y").date()
            except:
                return None
        for d, sp in self.spese.items():
            d2 = date_from_key(d)
            if d2 and d2.year == year:
                m = d2.month - 1
                for entry in sp:
                    is_ricorrenza = len(entry) == 5
                    if hasattr(self, "considera_ricorrenze_var") and not self.considera_ricorrenze_var.get():
                        if year == oggi.year:
                            if d2 > oggi:
                                continue
                    if len(entry) >= 4:
                        cat, desc, imp, tipo = entry[:4]
                        if tipo == "Entrata":
                            tot_entrate_mese[m] += imp
                            tot_entrate_anno += imp
                            cat_entrate[cat][m] += imp
                        else:
                            tot_uscite_mese[m] += imp
                            tot_uscite_anno += imp
                            cat_uscite[cat][m] += imp
        def format_row(label, values):
            label_fmt = f"{label:<{label_width}.{label_width}}"
            numeri = "".join(f"{v:10.2f}" for v in values)
            return f"{label_fmt}{numeri}{sum(values):12.2f}"
        header = f"{'Categoria':<{label_width}}" + "".join(f"{m:>10}" for m in mesi) + f"{'Totale':>12}"
        sep = "-" * len(header)
        lines = []
        lines.append("=" * len(header))
        lines.append(f"{('RIEPILOGO ENTRATE/USCITE ANNO ' + str(year)).center(len(header))}")
        lines.append("=" * len(header))
        lines.append("")
        lines.append(header)
        lines.append(sep)
        lines.append("")
        lines.append("ENTRATE PER CATEGORIA:")
        lines.append(header)
        for cat in categorie:
            if any(cat_entrate[cat]):
                lines.append(format_row(cat, cat_entrate[cat]))
        lines.append(sep)
        lines.append(format_row("‚Ä¢ Totale Entrate", tot_entrate_mese))
        lines.append(sep)
        lines.append("")
        lines.append("USCITE PER CATEGORIA:")
        lines.append(header)
        for cat in categorie:
            if any(cat_uscite[cat]):
                lines.append(format_row(cat, cat_uscite[cat]))
        lines.append("")
        lines.append(sep)
        lines.append(format_row("‚Ä¢ Totale Uscite", tot_uscite_mese))
        lines.append("-" * len(header))
        saldo = tot_entrate_anno - tot_uscite_anno
        lines.append(f"{'SALDO FINALE:':<{label_width}}{saldo:>{len(header) - label_width}.2f} ‚Ç¨")
        lines.append("=" * len(header))
        text = "\n".join(lines)
        now = datetime.date.today()
        self.show_export_preview(text, default_filename=f"Riepilogo_Anno_{year}.txt")

    # Esportazione Report Storico Totale Dettagliato (Matrice Categoria vs. Anno)
    def export_storico_totale(self):
        anni_presenti = set()
        def get_year(d):
            if isinstance(d, datetime.date): return d.year
            try: return datetime.datetime.strptime(d, "%d-%m-%Y").date().year
            except: return None
        for d in self.spese.keys():
            y = get_year(d)
            if y: anni_presenti.add(y)
        anni_lista = sorted(list(anni_presenti))
        if not anni_lista: return
        label_width = 32
        col_width = 10    
        categorie = sorted(
            set(
                entry[0]
                for sp in self.spese.values()
                for entry in sp
                if isinstance(entry, (list, tuple)) and len(entry) >= 4
            ).union(self.categorie)
        )
        cat_entrate = {cat: {anno: 0.0 for anno in anni_lista} for cat in categorie}
        cat_uscite = {cat: {anno: 0.0 for anno in anni_lista} for cat in categorie}
        tot_entrate_anno = {anno: 0.0 for anno in anni_lista}
        tot_uscite_anno = {anno: 0.0 for anno in anni_lista}
        for d, sp in self.spese.items():
            y = get_year(d)
            if y in anni_lista:
                for entry in sp:
                    if len(entry) >= 4:
                        cat, desc, imp, tipo = entry[:4]
                        if str(tipo).lower() == "entrata":
                            cat_entrate[cat][y] += imp
                            tot_entrate_anno[y] += imp
                        else:
                            cat_uscite[cat][y] += imp
                            tot_uscite_anno[y] += imp
        def format_row(label, data_dict):
            label_display = label[:label_width-1]
            row = f"{label_display:<{label_width}}"
            riga_sum = 0.0
            for anno in anni_lista:
                val = data_dict[anno]
                row += f"{val:>{col_width}.2f}"
                riga_sum += val
            row += f"{riga_sum:>{col_width+2}.2f}"
            return row
        header = f"{'CATEGORIA':<{label_width}}" + "".join(f"{str(a):>{col_width}}" for a in anni_lista) + f"{'TOT.CAT.':>{col_width+2}}"
        sep = "-" * len(header)
        lines = []
        lines.append("=" * len(header))
        lines.append(f"{'MATRICE STORICA CATEGORIE'.center(len(header))}")
        lines.append("=" * len(header))
        lines.append("")
        lines.append("RIEPILOGO ENTRATE:")
        lines.append(header); lines.append(sep)
        for cat in categorie:
            if any(cat_entrate[cat].values()):
                lines.append(format_row(cat, cat_entrate[cat]))
        lines.append(sep); lines.append(format_row("TOTALI ENTRATE", tot_entrate_anno)); lines.append("")

        lines.append("RIEPILOGO USCITE:")
        lines.append(header); lines.append(sep)
        for cat in categorie:
            if any(cat_uscite[cat].values()):
                lines.append(format_row(cat, cat_uscite[cat]))
        lines.append(sep); lines.append(format_row("TOTALI USCITE", tot_uscite_anno)); lines.append(sep)
        saldo_riga = f"{'SALDO NETTO':<{label_width}}"
        risparmio_totale = 0.0
        for anno in anni_lista:
            s = tot_entrate_anno[anno] - tot_uscite_anno[anno]
            saldo_riga += f"{s:>{col_width}.2f}"
            risparmio_totale += s
        saldo_riga += f"{risparmio_totale:>{col_width+2}.2f}"
        lines.append(saldo_riga); lines.append("=" * len(header))
        text = "\n".join(lines)
        self.show_export_preview(text, default_filename="Report_Storico_Allargato.txt")

    # Analisi e Suggerimento del Tipo Prevalente (Entrata/Uscita) per Categoria
    def suggerisci_tipo_categoria(self, categoria):
        n_entrate = 0
        n_uscite = 0
        for voci in self.spese.values():
            for voce in voci:
                if len(voce) >= 4 and voce[0] == categoria:
                    tipo = voce[3]
                    if tipo == "Entrata":
                        n_entrate += 1
                    elif tipo == "Uscita":
                        n_uscite += 1
        totale = n_entrate + n_uscite
        if totale == 0:
            return ("Uscita", 0, 0)
        perc_entrate = int(n_entrate / totale * 100)
        perc_uscite = int(n_uscite / totale * 100)
        tipo_prevalente = "Entrata" if n_entrate >= n_uscite else "Uscita"
        return (tipo_prevalente, perc_entrate, perc_uscite)

    # Finestra Interattiva per l'Analisi Dettagliata per Categoria e Periodo
    def open_analisi_categoria(self):
        popup = tk.Toplevel(self, bg=self.COLOR_TOPLEVEL)
        popup.title("Analisi Categoria")
        popup.geometry("700x600")
        popup.transient(self)
        popup.bind("<Escape>", lambda e: popup.destroy())
        self.update_idletasks()
        x = self.winfo_rootx() + (self.winfo_width() // 2) - 350
        y = self.winfo_rooty() + (self.winfo_height() // 2) - 300
        popup.geometry(f"+{x}+{y}")
        frame_top = tk.Frame(popup, bg=self.COLOR_TOPLEVEL)
        frame_top.pack(padx=18, pady=10, fill=tk.X)
        tk.Label(frame_top, text="üîç Seleziona modalit√†:",bg=self.COLOR_TOPLEVEL ,fg=self.TEXT_COLOR).pack(side=tk.LEFT)
        mode_var = tk.StringVar(value="Giorno")
        mode_combo = ttk.Combobox(frame_top, values=["Giorno", "Mese", "Anno", "Totale"], style="Border.TCombobox", textvariable=mode_var, state="readonly", width=10)
        mode_combo.pack(side=tk.LEFT, padx=10)
        frame_period = tk.Frame(popup, bg=self.COLOR_TOPLEVEL)
        frame_period.pack(padx=18, pady=2, fill=tk.X)
        months = [
            "Gennaio", "Febbraio", "Marzo", "Aprile", "Maggio", "Giugno",
            "Luglio", "Agosto", "Settembre", "Ottobre", "Novembre", "Dicembre"
        ]
        today = datetime.date.today()
        anni_presenti = sorted({d.year for d in self.spese.keys()}, reverse=True)
        if not anni_presenti:
            anni_presenti = [today.year]
        year_var_initial = str(anni_presenti[0]) if anni_presenti else str(today.year)
        year_var = tk.StringVar(value=today.year)
        day_var = tk.StringVar(value=str(today.day))
        month_var = tk.StringVar(value=months[today.month - 1]) 
        def get_years_presenti():
            return [str(y) for y in anni_presenti]
        year_combo = ttk.Combobox(frame_period, values=get_years_presenti(), textvariable=year_var, style="Border.TCombobox", state="readonly", width=8)
        month_combo = ttk.Combobox(frame_period, values=months, textvariable=month_var, style="Border.TCombobox", state="readonly", width=16)
        day_combo = ttk.Combobox(frame_period, values=[str(d) for d in range(1, 32)], textvariable=day_var, style="Border.TCombobox", state="readonly", width=4)
        year_combo_only = ttk.Combobox(frame_period, values=get_years_presenti(), textvariable=year_var, style="Border.TCombobox", state="readonly", width=8)
        def update_days(*_):
            try:
                m = months.index(month_var.get()) + 1
                y = int(year_var.get())
            except Exception:
                m = today.month
                y = today.year
            n_days = calendar.monthrange(y, m)[1]
            days = [str(d) for d in range(1, n_days+1)]
            day_combo['values'] = days
            if day_var.get() not in days:
                day_var.set(days[-1])
        month_var.trace_add("write", update_days)
        year_var.trace_add("write", update_days)
        def reset_period():
            oggi = datetime.date.today()
            day_var.set(str(oggi.day))
            month_var.set(months[oggi.month - 1])
            year_var.set(str(oggi.year))
        def update_period_inputs(*_):
            for widget in frame_period.winfo_children():
                widget.pack_forget()
            mode = mode_var.get()
            reset_btn = ttk.Button(frame_period, text="üîô", style='Yellow.TButton', command=reset_period)
            if mode == "Giorno":
                day_combo.pack(side=tk.LEFT)
                month_combo.pack(side=tk.LEFT, padx=(4,8))
                year_combo.pack(side=tk.LEFT)
                reset_btn.pack(side=tk.LEFT, padx=(10, 0))
                update_days()
            elif mode == "Mese":
                month_combo.pack(side=tk.LEFT, padx=(0,8))
                year_combo.pack(side=tk.LEFT)
                reset_btn.pack(side=tk.LEFT, padx=(10, 0))
            elif mode == "Anno":
                year_combo_only.pack(side=tk.LEFT)
                reset_btn.pack(side=tk.LEFT, padx=(10, 0))
        mode_combo.bind("<<ComboboxSelected>>", update_period_inputs)
        update_period_inputs()
        frame_cat = tk.Frame(popup, bg=self.COLOR_TOPLEVEL)
        frame_cat.pack(padx=18, pady=12, fill=tk.X)
        tk.Label(frame_cat, bg=self.COLOR_TOPLEVEL ,fg=self.TEXT_COLOR, text="Categoria:").pack(side=tk.LEFT)
        def get_catlist():
            return ["Tutte le categorie"] + sorted(self.categorie)
        cat_var = tk.StringVar(value="Tutte le categorie")
        cat_combo = ttk.Combobox(frame_cat, values=get_catlist(), textvariable=cat_var, style="Border.TCombobox", state="readonly", width=25)
        cat_combo.pack(side=tk.LEFT, padx=10)
        main_result_frame = ttk.Frame(popup)
        main_result_frame.pack(padx=18, fill=tk.BOTH, expand=True) 
        main_result_frame.grid_rowconfigure(0, weight=1)
        main_result_frame.grid_columnconfigure(0, weight=1)
        scroll_y = ttk.Scrollbar(main_result_frame, orient=tk.VERTICAL, style="Vertical.TScrollbar")
        scroll_y.grid(row=0, column=1, sticky="ns")
        text_result = tk.Text(
            main_result_frame, 
            height=22, 
            width=90, 
            font=("Courier New", 10), 
            wrap='none',
            yscrollcommand=scroll_y.set, 
            bg=self.COLOR_TOPLEVEL, 
            fg=self.TEXT_COLOR 
        )
        text_result.grid(row=0, column=0, sticky="nsew") 
        scroll_y.config(command=text_result.yview)
        frame_buttons = ttk.Frame(popup)
        frame_buttons.pack(fill=tk.X, padx=18, pady=8) 
        export_btn = ttk.Button(frame_buttons, text="üíæ Esporta", style='Verde.TButton')
        export_btn.pack(side=tk.LEFT, padx=4)
        close_btn = ttk.Button(frame_buttons, text="‚ùå Chiudi", command=popup.destroy, style='Giallo.TButton')
        close_btn.pack(side=tk.RIGHT, padx=4)
        def aggiorna_cat_combo():
            cat_combo['values'] = get_catlist()
            if cat_var.get() not in cat_combo['values']:
                cat_var.set("Tutte le categorie")
        aggiorna_cat_combo()
        def mostra_dettagli(*_):
            cat = cat_var.get()
            mode = mode_var.get()
            result_lines = []
            today = datetime.date.today()
            def calcola_totali(entries):
                entrate = sum(e[2] for _, e in filtered if "entrata" in e[3].lower())
                uscite = sum(e[2] for _, e in filtered if "entrata" not in e[3].lower())
                return entrate, uscite, entrate - uscite
            filtered = []
            label_intestazione = ""
            if mode == "Giorno":
                try:
                    m = months.index(month_var.get()) + 1
                    d = int(day_var.get())
                    y = int(year_var.get())
                    giorno = datetime.date(y, m, d)
                except Exception:
                    giorno = today
                spese = self.spese.get(giorno, [])
                filtered = [(giorno, e) for e in spese if cat == "Tutte le categorie" or e[0] == cat]
                label_intestazione = f"{'Entrate/Uscite' if cat == 'Tutte le categorie' else 'Spese ' + cat} per il giorno {giorno.strftime('%d-%m-%Y')}"
            elif mode == "Mese":
                try:
                    m = months.index(month_var.get()) + 1
                    y = int(year_var.get())
                except Exception:
                    m = today.month
                    y = today.year
                for d, sp in self.spese.items():
                    if d.year == y and d.month == m:
                        for e in sp:
                            if cat == "Tutte le categorie" or e[0] == cat:
                                filtered.append((d, e))
                label_intestazione = f"{'Entrate/Uscite' if cat == 'Tutte le categorie' else 'Spese ' + cat} per {self.get_month_name(m)} {y}"
            elif mode == "Anno":
                try:
                    y = int(year_var.get())
                except Exception:
                    y = today.year
                for d, sp in self.spese.items():
                    if d.year == y:
                        for e in sp:
                            if cat == "Tutte le categorie" or e[0] == cat:
                                filtered.append((d, e))
                label_intestazione = f"{'Entrate/Uscite' if cat == 'Tutte le categorie' else 'Spese ' + cat} per l'anno {y}"
            elif mode == "Totale":
                for d, sp in self.spese.items():
                    for e in sp:
                        if cat == "Tutte le categorie" or e[0] == cat:
                            filtered.append((d, e))
                label_intestazione = f"{'Entrate/Uscite' if cat == 'Tutte le categorie' else 'Spese ' + cat} totali"
            text_result.configure(font=("Courier New", 10))
            result_lines.clear()
            if not filtered:
                result_lines.append(f"Nessuna spesa per '{cat}'.")
            else:
                result_lines.append("=" * 80)
                result_lines.append(label_intestazione)
                result_lines.append("-" * 80)
                result_lines.append(f"{'Data':<12}  {'Categoria':<20}  {'Descrizione':<15}  {'Importo':>10}")
                result_lines.append("-" * 80)
                for d, e in sorted(filtered, key=lambda x: x[0], reverse=True):
                    valore = abs(e[2])
                    categoria = e[0][:20]
                    descrizione = e[1][:15]
                    result_lines.append(
                        f"{d.strftime('%d-%m-%Y'):<12}  {categoria:<20}  {descrizione:<15}  {valore:>9.2f} ‚Ç¨ ({e[3]})"
                    )
                result_lines.append("-" * 80)
                entrate, uscite, saldo = calcola_totali([e for _, e in filtered])
                result_lines.append(f"{'Totale entrate':<54}  {entrate:>9.2f} ‚Ç¨")
                result_lines.append(f"{'Totale uscite':<54}  {uscite:>9.2f} ‚Ç¨")
                result_lines.append(f"{'Saldo finale':<54}  {saldo:+9.2f} ‚Ç¨")
                result_lines.append("=" * 80)
            text_result.delete("1.0", tk.END)
            text_result.insert("end", "\n".join(result_lines))
        def esporta_analisi():
            contenuto = text_result.get("1.0", tk.END).strip()
            if not contenuto:
                self.show_custom_warning("Esporta", "Nulla da esportare.")
                return
            preview = tk.Toplevel(popup, bg=self.COLOR_TOPLEVEL)
            preview.title("Preview esportazione")
            larghezza_finestra = 800
            altezza_finestra = 500
            x = popup.winfo_rootx() + (popup.winfo_width() // 2) - (larghezza_finestra // 2)
            y = popup.winfo_rooty() + (popup.winfo_height() // 2) - (altezza_finestra // 2)
            preview.geometry(f"{larghezza_finestra}x{altezza_finestra}+{x}+{y}")
            preview.transient(popup)
            preview.grab_set()
            preview.focus_set()
            preview.bind("<Escape>", lambda e: preview.destroy())
            tx = tk.Text(preview, font=("Courier new", 10), wrap="none")
            tx.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
            contenuto_preview = "\n".join(" " + l for l in contenuto.splitlines())
            tx.insert(tk.END, contenuto_preview)
            tx.config(state="disabled")
            frm = tk.Frame(preview, bg=self.COLOR_TOPLEVEL)
            frm.pack(fill=tk.X, padx=10, pady=8)
            def do_save():
                now = datetime.date.today()
                default_filename = f"Analisi_Export_{now.day:02d}-{now.month:02d}-{now.year}.txt"
                file = filedialog.asksaveasfilename(
                    defaultextension=".txt",
                    filetypes=[("File txt", "*.txt")],
                    initialdir=EXPORT_FILES,
                    title="Esporta Analisi Categoria",
                    initialfile=default_filename,
                    confirmoverwrite=False,
                    parent=preview)
                if file:
                    if os.path.exists(file):
                        conferma = self.show_custom_askyesno(
                            "Sovrascrivere file?",
                            f"Il file '{os.path.basename(file)}' \nesiste gi√†. Vuoi sovrascriverlo?"
                        )
                        if not conferma:
                            return  
                    with open(file, "w", encoding="utf-8") as f:
                        f.write(contenuto_preview)
                        self.show_custom_warning("Esporta", f"Analisi esportata in {file}")
                    preview.destroy()
            ttk.Button(frm, text="üíæ Salva", command=do_save, style="Verde.TButton").pack(side=tk.LEFT, padx=6)
            ttk.Button(frm, text="üìÑ Stampa", style="Blu.TButton", command=lambda: self._stampa_lista_diretta(
                    contenuto_preview.rstrip('\n'),self.show_custom_warning)).pack(side=tk.LEFT, padx=6)
            ttk.Button(frm, text="‚ùå Chiudi", command=preview.destroy, style="Giallo.TButton").pack(side=tk.RIGHT, padx=6)
            preview.lift()
            preview.attributes('-topmost', True)
            preview.after(100, lambda: preview.attributes('-topmost', False))
            preview.bind("<Escape>", lambda e: preview.destroy())
        export_btn.config(command=esporta_analisi)
        mode_var.trace_add("write", mostra_dettagli)
        month_var.trace_add("write", mostra_dettagli)
        year_var.trace_add("write", mostra_dettagli)
        day_var.trace_add("write", mostra_dettagli)
        cat_var.trace_add("write", mostra_dettagli)
        mostra_dettagli()

    # Apertura Diretta del Link Bancario nel Browser di Sistema
    def chiama_banca(self):
        if not LINK_BANCA or LINK_BANCA.strip() == "":
            messaggio_istruzioni = (
                "L'indirizzo del link bancario non √® stato configurato.\n\n"
                "Per risolvere:\n"
                "1. Vai al menu *Opzioni*.\n"
                "2. Seleziona *Impostazioni App*.\n"
                "3. Inserisci l'URL completo della tua banca nel campo dedicato."
            )
            self.show_custom_warning(
                "Link Bancario Mancante", 
                messaggio_istruzioni
            )
            return
        try:
            webbrowser.open_new_tab(LINK_BANCA)
        except Exception as e:
            self.show_custom_warning(
                "‚ùå Errore di Apertura", 
                f"Impossibile aprire il link: {LINK_BANCA}\nErrore: {e}"
            )
            print(f"Errore durante l'apertura del link: {e}")

    def calcola_saldo(self, filtro):
        saldo = self.saldo_iniziale if hasattr(self, 'saldo_iniziale') else 0.0
        data_saldo = self.saldo_data if hasattr(self, 'saldo_data') else datetime.date.today()
        saldo_totale = saldo
        saldo_mese = 0.0
        saldo_anno = 0.0
        oggi = datetime.date.today()
        mese = oggi.month
        anno = oggi.year
        for d in sorted(self.spese.keys()):
            for entry in self.spese[d]:
                imp = entry[2]
                tipo = entry[3]
                valore = imp if tipo == "Entrata" else -imp
                saldo_totale += valore
                if d >= data_saldo:
                    if d.year == anno:
                        saldo_anno += valore
                        if d.month == mese:
                            saldo_mese += valore
        return {"mese": saldo_mese, "anno": saldo_anno + saldo, "totale": saldo_totale}[filtro]

    def carica_saldo(self):
        self.saldo_iniziale = 0.0
        self.saldo_data = datetime.date.today()
        if os.path.exists(SALDO_FILE):
            try:
                with open(SALDO_FILE, "r", encoding="utf-8") as f:
                    saldo_db = json.load(f)
                self.saldo_iniziale = float(saldo_db.get("saldo", 0.0))
                self.saldo_data = datetime.datetime.strptime(
                    saldo_db.get("saldo_data", self.saldo_data.strftime("%d-%m-%Y")),
                    "%d-%m-%Y"
                ).date()
            except Exception as e:
                print("Errore caricamento saldo:", e)
        self.saldo_attuale = self.calcola_saldo("anno")
        self.saldo_previsto = self.calcola_saldo("totale")

    # Calcolo Dinamico del Saldo Finanziario per Periodo
    def open_saldo_conto(self):
        if hasattr(self, '_saldo_popup') and self._saldo_popup and self._saldo_popup.winfo_exists():
            self._saldo_popup.lift()
            return
        def valida_saldo(valore):
            if len(valore) > 8:
                return False
            if valore == "":
                return True
            return valore.replace(",", "").replace(".", "").isdigit()
        popup = tk.Toplevel(self, bg=self.COLOR_TOPLEVEL)
        self._saldo_popup = popup
        popup.title("Saldo Conto Corrente")
        popup.withdraw()
        larghezza_finestra = 480
        altezza_finestra = 500
        larghezza_schermo = self.winfo_screenwidth()
        altezza_schermo = self.winfo_screenheight()
        x = (larghezza_schermo // 2) - (larghezza_finestra // 2)
        y = (altezza_schermo // 2) - (altezza_finestra // 2)
        popup.geometry(f"{larghezza_finestra}x{altezza_finestra}+{x}+{y}")
        popup.resizable(False, False)
        popup.transient(self)
        popup.deiconify()
        popup.bind("<Escape>", lambda e: popup.destroy())
        saldo_data = {"saldo": 0.0, "data": datetime.date.today().strftime("%d-%m-%Y")}
        if os.path.exists(SALDO_FILE):
            try:
                with open(SALDO_FILE, "r", encoding="utf-8") as f:
                    db = json.load(f)
                saldo_data["saldo"] = db.get("saldo", 0.0)
                saldo_data["data"] = db.get("saldo_data", saldo_data["data"])
            except Exception:
                pass
        frame = tk.Frame(popup, bg=self.COLOR_TOPLEVEL)
        frame.pack(padx=28, pady=18, fill=tk.BOTH, expand=True)
        lastframe = ttk.LabelFrame(frame, text="Ultimo saldo inserito", padding=10)
        lastframe.pack(fill=tk.X, padx=0, pady=(0, 18))
        last_saldo_var = tk.StringVar(value=f"{saldo_data['saldo']:.2f}")
        last_data_var = tk.StringVar(value=saldo_data["data"])
        ttk.Label(lastframe, text="üí∞ Ultimo saldo:", font=("Arial", 11)).grid(row=0, column=0, sticky="e", padx=(0,8), pady=2)
        ttk.Entry(lastframe, textvariable=last_saldo_var, width=15, font=("Arial", 11), state="readonly").grid(row=0, column=1, padx=(0,8), pady=2)
        ttk.Label(lastframe, text="‚Ç¨", font=("Arial", 11)).grid(row=0, column=2, sticky="w", pady=2)
        ttk.Label(lastframe, text="üóìÔ∏è Data inserimento:", font=("Arial", 11)).grid(row=1, column=0, sticky="e", padx=(0,8), pady=2)
        ttk.Entry(lastframe, textvariable=last_data_var, width=12, font=("Arial", 11), state="readonly").grid(row=1, column=1, pady=2, sticky="w")
        btmframe = ttk.LabelFrame(frame, text="üîÑ Aggiorna saldo bancario", padding=10)
        btmframe.pack(fill=tk.X, padx=0, pady=(0, 0))
        ttk.Label(btmframe, text="Data saldo:", font=("Arial", 10, "bold")).grid(row=0, column=0, sticky="e", padx=(0,8), pady=2)
        data_var = tk.StringVar(value=datetime.date.today().strftime("%d-%m-%Y"))
        data_entry = ttk.Entry(btmframe, textvariable=data_var, width=15, font=("Arial", 11), state="normal")
        data_entry.grid(row=0, column=1, sticky="w", padx=(0,2))
        ttk.Button(
            btmframe, 
            text="üóìÔ∏è", 
            width=3, 
            command=lambda: self.mostra_calendario_popup_semplice(data_entry, data_var)
        ).grid(row=0, column=2, padx=2)
        ttk.Button(
            btmframe,
            text="üîô",
            style='Yellow.TButton',
            width=3,
            command=lambda: data_var.set(datetime.date.today().strftime("%d-%m-%Y"))
        ).grid(row=0, column=3, padx=2)

        ttk.Label(btmframe, text="Nuovo saldo:", font=("Arial", 11)).grid(row=1, column=0, sticky="e", pady=(14,2))
        saldo_var = tk.StringVar()
        vcmd = (popup.register(valida_saldo), "%P")
        ttk.Entry(
            btmframe,
            textvariable=saldo_var,
            width=15,
            font=("Arial", 11),
            validate="key",
            validatecommand=vcmd
        ).grid(row=1, column=1, sticky="w", padx=4, pady=(14,2))
        ttk.Label(btmframe, text="‚Ç¨", font=("Arial", 11)).grid(row=1, column=2, sticky="w", pady=(14,2))
        lbl_saldo_mese = tk.Label(frame, bg=self.COLOR_TOPLEVEL, fg=self.TEXT_COLOR, font=("Courier New", 9))
        lbl_saldo_anno = tk.Label(frame, bg=self.COLOR_TOPLEVEL, fg=self.TEXT_COLOR, font=("Courier New", 9))
        lbl_saldo_tot  = tk.Label(frame, bg=self.COLOR_TOPLEVEL, fg=self.TEXT_COLOR, font=("Courier New", 9, "bold"))
        lbl_saldo_mese.pack(anchor="w", pady=(20, 0))
        lbl_saldo_anno.pack(anchor="w")
        lbl_saldo_tot.pack(anchor="w", pady=(0, 12))
        def get_selected_date():
            try:
                return datetime.datetime.strptime(data_var.get(), "%d-%m-%Y").date()
            except Exception:
                return datetime.date.today()
        def calcola_saldo_popup(filtro):
            try:
                saldo = float(last_saldo_var.get())
            except Exception:
                saldo = 0.0
            data_saldo = get_selected_date()
            saldo_totale = saldo
            saldo_mese = 0.0
            saldo_anno = 0.0
            oggi = datetime.date.today()
            mese = oggi.month
            anno = oggi.year
            for d in sorted(self.spese.keys()):
                for entry in self.spese[d]:
                    imp = entry[2]
                    tipo = entry[3]
                    valore = imp if tipo == "Entrata" else -imp
                    saldo_totale += valore
                    if d >= data_saldo:
                        if d.year == anno:
                            saldo_anno += valore
                            if d.month == mese:
                                saldo_mese += valore
            return {"mese": saldo_mese, "anno": saldo_anno + saldo, "totale": saldo_totale}[filtro]
        def aggiorna_saldi(*_):
            W = 38 
            sm = f"{calcola_saldo_popup('mese'):>10.2f} ‚Ç¨"
            sa = f"{calcola_saldo_popup('anno'):>10.2f} ‚Ç¨"
            st = f"{calcola_saldo_popup('totale'):>10.2f} ‚Ç¨"
            lbl_saldo_mese.config(text=f"{'Saldo nel mese:'.ljust(W-len(sm))}{sm}")
            lbl_saldo_anno.config(text=f"{'Saldo nell''anno:'.ljust(W-len(sa))}{sa}")
            lbl_saldo_tot.config(text=f"{'Saldo totale:'.ljust(W-len(st))}{st}")
        data_var.trace_add("write", aggiorna_saldi)
        aggiorna_saldi()

        def salva_saldo():
            try:
                nuovo_saldo = float(saldo_var.get().replace(",", "."))
                nuova_data = data_var.get()
                last_saldo_var.set(f"{nuovo_saldo:.2f}")
                last_data_var.set(nuova_data)
                db = {}
                if os.path.exists(SALDO_FILE):
                    try:
                        with open(SALDO_FILE, "r", encoding="utf-8") as f:
                            db = json.load(f)
                    except json.JSONDecodeError:
                        db = {}
                db["saldo"] = nuovo_saldo
                db["saldo_data"] = nuova_data
                with open(SALDO_FILE, "w", encoding="utf-8") as f:
                    json.dump(db, f, indent=2, ensure_ascii=False)
                saldo_var.set("")
                aggiorna_saldi()
                self.show_custom_warning("Salvataggio","‚úì Saldo aggiornato correttamente.")
                self.carica_saldo()
                self.aggiorna_treeview()
                self.aggiorna_riepilogo()
            except ValueError:
                self.show_custom_warning("Salvataggio", "‚ùå Inserisci un numero valido.")
        def esporta():
            sm = calcola_saldo_popup("mese")
            sa = calcola_saldo_popup("anno")
            st = calcola_saldo_popup("totale")
            lines = [
                f"Saldo inserito il {last_data_var.get()}: {last_saldo_var.get()} ‚Ç¨",
                f"Saldo nel mese: {sm:.2f} ‚Ç¨",
                f"Saldo nell'anno: {sa:.2f} ‚Ç¨",
                f"Saldo totale: {st:.2f} ‚Ç¨",
            ]
            preview = tk.Toplevel(popup, bg=self.COLOR_TOPLEVEL )
            preview.title("Esporta saldo")
            preview.geometry("420x250")
            preview.transient(popup)
            preview.grab_set()
            preview.resizable(False, False)
            preview.bind("<Escape>", lambda e: preview.destroy())
            txt = tk.Text(preview, font=("Arial", 10), wrap="word", height=6)
            txt.insert("1.0", "\n".join(lines))
            txt.configure(state="disabled")
            txt.pack(fill="both", expand=True, padx=10, pady=10)
            def do_save():
                default_filename = f"Saldo_Export_{datetime.date.today().strftime('%d-%m-%Y')}.txt"
                path = filedialog.asksaveasfilename(
                    initialfile= default_filename,
                    initialdir=EXPORT_FILES,
                    defaultextension=".txt",
                    title="Salva Saldo",
                    confirmoverwrite=False,
                    filetypes=[("File di testo", "*.txt")],
                    parent=preview
                )
                if path:
                    if os.path.exists(path):
                        conferma = self.show_custom_askyesno(
                            "Sovrascrivere file?",
                            f"Il file '{os.path.basename(path)}' \nesiste gi√†. Vuoi sovrascriverlo?"
                        )
                        if not conferma: return
                    with open(path, "w", encoding="utf-8") as f:
                        f.write("\n".join(lines))
                    self.show_custom_warning("Salvataggio","‚úì Esportazione completata.")
                    preview.destroy()
            btns = tk.Frame(preview, bg=self.COLOR_TOPLEVEL )
            btns.pack(pady=10)
            ttk.Button(btns, text="üíæ Salva", command=do_save, style="Verde.TButton").pack(side="left", padx=6)
            ttk.Button(btns, text="‚ùå Chiudi", command=preview.destroy, style="Giallo.TButton").pack(side="right", padx=6)
        btn_frame = tk.Frame(popup, bg=self.COLOR_TOPLEVEL)
        btn_frame.pack(pady=(12, 10))
        ttk.Button(btn_frame, text="üíæ Salva saldo", command=salva_saldo, style="Verde.TButton").pack(side="left", padx=6)
        ttk.Button(btn_frame, text="üìÑ Preview Esporta", command=esporta, style="Arancio.TButton").pack(side="left", padx=6)
        ttk.Button(btn_frame, text="‚ùå Chiudi", command=popup.destroy, style="Giallo.TButton").pack(side="right", padx=6)
    def show_tooltip_saldo(self, event):
        self.carica_saldo()
        if hasattr(self, "tooltip_label"):
            self.tooltip_label.destroy()
        tooltip_text = (
            "üíº Saldo conto corrente\n\n"
            f"{'Saldo iniziale:':<18} ‚Ç¨ {self.saldo_iniziale:>10.2f}\n"
            f"{'Saldo attuale:':<18} ‚Ç¨ {self.saldo_attuale:>10.2f}\n"
            f"{'Saldo previsto:':<18} ‚Ç¨ {self.saldo_previsto:>10.2f}\n"
            f"{'Data saldo:':<18}   {self.saldo_data.strftime('%d-%m-%Y'):>12}\n"
        )
        self.tooltip_label = ttk.Label(
            self, 
            text=tooltip_text, 
            style="Tooltip.TLabel",
            font=("Courier New", 9)
        )
        self.update_idletasks()
        x = self.winfo_width() - 280
        y = 50
        self.tooltip_label.place(x=x, y=y)
    def hide_tooltip_saldo(self,event):
        if hasattr(self, "tooltip_label"):
            self.tooltip_label.destroy()
            del self.tooltip_label
            
    # Ripristino della Visualizzazione alla Data Attuale        
    def goto_today(self):
        self.mostra_treeview_statistiche()
        today = datetime.date.today()
        if hasattr(self, "cal"):
            self.cal.selection_set(today)
            self.cal._sel_date = today
        self.stats_refdate = today
        mesi = [
            "Gennaio", "Febbraio", "Marzo", "Aprile", "Maggio", "Giugno",
            "Luglio", "Agosto", "Settembre", "Ottobre", "Novembre", "Dicembre"
        ]
        self.estratto_month_var.set(mesi[today.month - 1])
        self.estratto_year_var.set(str(today.year))
        self.set_stats_mode("giorno")
        self.after_idle(self.update_stats)
        self.update_totalizzatore_anno_corrente()
        self.update_totalizzatore_mese_corrente()
        self.update_spese_mese_corrente()
        self.stats_label.config(
            text=f"Riepilogo Giornaliero - {today.strftime('%d-%m-%Y')}", foreground="purple",
    font=("Arial", 10, "bold"))

    # Confronto Avanzato Delle Spese/Entrate per Categoria (Mese vs Mese / Anno vs Anno)
    def open_compare_window(self):
        today = datetime.date.today()
        mese_oggi = f"{today.month:02d}"
        anno_oggi = str(today.year)
        compare_by_year = tk.BooleanVar(value=False)
        mostra_future_var = tk.BooleanVar(value=True)
        def parse_date(d):
            if isinstance(d, datetime.date):
                return d
            try:
                if len(d.split("-")[0]) == 4:
                    return datetime.datetime.strptime(d, "%Y-%m-%d").date()
                else:
                    return datetime.datetime.strptime(d, "%d-%m-%Y").date()
            except Exception:
                return None
        def get_rows(mese, anno, per_anno=False):
            rows = []
            oggi = datetime.date.today()
            for d_raw in sorted(self.spese):
                d = parse_date(d_raw)
                if not d:
                    continue
                if not mostra_future_var.get() and d > oggi:
                    continue
                if (per_anno and d.year == anno) or \
                   (not per_anno and d.month == mese and d.year == anno):
                    for voce in self.spese[d_raw]:
                        try:
                            if len(voce) >= 4:
                                if len(voce) == 5:
                                    cat, desc, imp, tipo, _ = voce 
                                else: 
                                    cat, desc, imp, tipo = voce
                                data_pagamento = d.strftime("%d-%m-%Y")
                                entrata = imp if tipo == "Entrata" else 0
                                uscita = imp if tipo == "Uscita" else 0
                                rows.append((cat, data_pagamento, entrata, uscita))
                        except Exception as e:
                            continue
            return rows
        def aggregate_rows_by_category(raw_rows, date_placeholder="Totale"):
            aggregated_data = defaultdict(lambda: [0.0, 0.0])
            for cat, _, ent, usc in raw_rows:
                aggregated_data[cat][0] += ent
                aggregated_data[cat][1] += usc
            result_rows = []
            for cat in sorted(aggregated_data.keys()):
                 ent, usc = aggregated_data[cat]
                 result_rows.append((cat, date_placeholder, ent, usc)) 
            return result_rows
        popup = tk.Toplevel(self, bg=self.COLOR_TOPLEVEL)
        popup.withdraw()
        self.update_idletasks()
        main_x = self.winfo_rootx()
        main_y = self.winfo_rooty()
        main_width = self.winfo_width()
        main_height = self.winfo_height()
        popup_width = 1030    
        popup_height = 560
        center_x = main_x + (main_width // 2) - (popup_width // 2)
        center_y = main_y + (main_height // 2) - (popup_height // 2)
        popup.geometry(f"{popup_width}x{popup_height}+{center_x}+{center_y}")
        popup.transient(self)
        popup.title("Confronta mesi/anni per categoria")
        popup.deiconify()
        popup.bind("<Escape>", lambda e: popup.destroy())
        frame = ttk.Frame(popup)
        frame.pack(fill=tk.BOTH, expand=True, padx=14, pady=14)
        frame.columnconfigure(0, weight=1)
        frame.columnconfigure(1, weight=1)
        anni_presenti_nel_db = set()
        for d_raw in self.spese.keys():
            d = parse_date(d_raw)
            if d:
                anni_presenti_nel_db.add(d.year)
        anni_correnti_e_db = sorted(list(anni_presenti_nel_db.union({today.year, today.year - 1, today.year + 1})), reverse=True) 
        anni = anni_correnti_e_db 
        mesi = [f"{i:02d}" for i in range(1, 13)]

        mode_frame = tk.Frame(frame, bg=self.COLOR_TOPLEVEL)
        mode_frame.grid(row=0, column=0, columnspan=2, sticky="ew", pady=(0, 8))
        tk.Label(mode_frame, text="Modalit√† confronto:", bg=self.COLOR_TOPLEVEL ,fg=self.TEXT_COLOR, font=("Arial", 10, "bold")).pack(side=tk.LEFT, padx=(0, 10))
        ttk.Radiobutton(mode_frame, text="Mese", style="Custom.TRadiobutton", variable=compare_by_year, value=False, command=lambda: update_tables()).pack(side=tk.LEFT)
        ttk.Radiobutton(mode_frame, text="Anno", style="Custom.TRadiobutton", variable=compare_by_year, value=True, command=lambda: update_tables()).pack(side=tk.LEFT)
        ttk.Checkbutton(mode_frame, text="Includi movimenti futuri nei totali", variable=mostra_future_var).pack(side=tk.LEFT, padx=(30, 0))
        left_select_frame = ttk.Frame(frame)
        left_select_frame.grid(row=1, column=0, sticky="ew", padx=(0, 16), pady=(0, 6))
        ttk.Label(left_select_frame, text="Mese/Anno 1", font=("Arial", 10, "bold")).pack(side=tk.LEFT, padx=(0, 8))
        left_mese = tk.StringVar(value=mese_oggi)
        left_anno = tk.StringVar(value=anno_oggi)
        cb_lm = ttk.Combobox(left_select_frame, textvariable=left_mese, values=mesi, width=4, style="Border.TCombobox", state="readonly", font=("Arial", 10))
        cb_la = ttk.Combobox(left_select_frame, textvariable=left_anno, values=[str(a) for a in anni], width=7, style="Border.TCombobox", state="readonly", font=("Arial", 10))
        cb_lm.pack(side="left", padx=(0, 3))
        cb_la.pack(side="left")
        def reset_left():
            left_mese.set(mese_oggi)
            left_anno.set(anno_oggi)
        ttk.Button(left_select_frame, text="üîô", command=reset_left, style='Yellow.TButton').pack(side="right", padx=7)
        left_container = ttk.Frame(frame)
        left_container.grid(row=2, column=0, sticky="nswe", padx=(0, 16))
        left_container.grid_rowconfigure(0, weight=1)
        left_container.grid_columnconfigure(0, weight=1)
        left_vsb = ttk.Scrollbar(left_container, orient="vertical", style="Vertical.TScrollbar")
        left_vsb.grid(row=0, column=1, sticky="ns")
        left_tree = ttk.Treeview(left_container, columns=("Categoria", "Data", "Entrata", "Uscita"), show="headings", height=14,
                                 yscrollcommand=left_vsb.set)
        left_tree.grid(row=0, column=0, sticky="nswe")
        left_vsb.config(command=left_tree.yview)
        left_tree.tag_configure('entrata', foreground='green')
        left_tree.tag_configure('uscita', foreground='red')
        for col, w, anchor in [("Categoria", 180, "center"), ("Data", 110, "center"), ("Entrata", 100, "center"), ("Uscita", 100, "center")]:
            left_tree.heading(col, text=col, anchor=anchor, command=lambda _col=col: treeview_sort_column(left_tree, _col, False))
            left_tree.column(col, width=w, anchor=anchor, stretch=False)
        left_diff_frame = tk.Frame(left_container, bg=self.COLOR_TOPLEVEL)
        left_diff_frame.grid(row=1, column=0, columnspan=2, pady=(4, 0), sticky=tk.W+tk.E)
        tk.Label(left_diff_frame, bg=self.COLOR_TOPLEVEL ,fg=self.TEXT_COLOR, text="Entrate:", font=("Arial", 10, "bold")).pack(side=tk.LEFT)
        left_total_ent_lbl = tk.Label(left_diff_frame, bg=self.COLOR_TOPLEVEL ,fg=self.TEXT_COLOR, text="", font=("Arial", 10, "bold"))
        left_total_ent_lbl.pack(side=tk.LEFT, padx=(2, 10))
        tk.Label(left_diff_frame, bg=self.COLOR_TOPLEVEL ,fg=self.TEXT_COLOR, text="Uscite:", font=("Arial", 10, "bold")).pack(side=tk.LEFT)
        left_total_usc_lbl = tk.Label(left_diff_frame, bg=self.COLOR_TOPLEVEL ,fg=self.TEXT_COLOR, text="", font=("Arial", 10, "bold"))
        left_total_usc_lbl.pack(side=tk.LEFT, padx=(2, 10))
        tk.Label(left_diff_frame, bg=self.COLOR_TOPLEVEL ,fg=self.TEXT_COLOR, text="Differenza:", font=("Arial", 10, "bold")).pack(side=tk.LEFT)
        left_diff_val_lbl = tk.Label(left_diff_frame, bg=self.COLOR_TOPLEVEL ,fg=self.TEXT_COLOR, text="", font=("Arial", 10, "bold"))
        left_diff_val_lbl.pack(side=tk.LEFT, padx=(2, 0))
        right_select_frame = ttk.Frame(frame)
        right_select_frame.grid(row=1, column=1, sticky="ew", pady=(0, 6))
        ttk.Label(right_select_frame, text="Mese/Anno 2", font=("Arial", 10, "bold")).pack(side=tk.LEFT, padx=(0, 8))
        right_mese = tk.StringVar(value=mese_oggi)
        right_anno = tk.StringVar(value=anno_oggi)
        cb_rm = ttk.Combobox(right_select_frame, textvariable=right_mese, values=mesi, width=4, style="Border.TCombobox", state="readonly", font=("Arial", 10))
        cb_ra = ttk.Combobox(right_select_frame, textvariable=right_anno, values=[str(a) for a in anni], width=7, style="Border.TCombobox", state="readonly", font=("Arial", 10))
        cb_rm.pack(side="left", padx=(0, 3))
        cb_ra.pack(side="left")
        def reset_right():
            right_mese.set(mese_oggi)
            right_anno.set(anno_oggi)
        ttk.Button(right_select_frame, text="üîô", command=reset_right, style='Yellow.TButton').pack(side="right", padx=7)
        right_container = ttk.Frame(frame)
        right_container.grid(row=2, column=1, sticky="nswe")
        right_container.grid_rowconfigure(0, weight=1)
        right_container.grid_columnconfigure(0, weight=1)
        right_vsb = ttk.Scrollbar(right_container, orient="vertical", style="Vertical.TScrollbar")
        right_vsb.grid(row=0, column=1, sticky="ns")
        right_tree = ttk.Treeview(right_container, columns=("Categoria", "Data", "Entrata", "Uscita"), show="headings", height=14,
                                  yscrollcommand=right_vsb.set)
        right_tree.grid(row=0, column=0, sticky="nswe")
        right_vsb.config(command=right_tree.yview)
        right_tree.tag_configure('entrata', foreground='green')
        right_tree.tag_configure('uscita', foreground='red')
        for col, w, anchor in [("Categoria", 180, "center"), ("Data", 110, "center"), ("Entrata", 100, "center"), ("Uscita", 100, "center")]:
            right_tree.heading(col, text=col, anchor=anchor, command=lambda _col=col: treeview_sort_column(right_tree, _col, False))
            right_tree.column(col, width=w, anchor=anchor, stretch=False)
        right_diff_frame = tk.Frame(right_container, bg=self.COLOR_TOPLEVEL)
        right_diff_frame.grid(row=1, column=0, columnspan=2, pady=(4, 0), sticky=tk.W+tk.E)
        tk.Label(right_diff_frame, bg=self.COLOR_TOPLEVEL ,fg=self.TEXT_COLOR, text="Entrate:", font=("Arial", 10, "bold")).pack(side=tk.LEFT)
        right_total_ent_lbl = tk.Label(right_diff_frame, bg=self.COLOR_TOPLEVEL ,fg=self.TEXT_COLOR, text="", font=("Arial", 10, "bold"))
        right_total_ent_lbl.pack(side=tk.LEFT, padx=(2, 10))
        tk.Label(right_diff_frame, bg=self.COLOR_TOPLEVEL ,fg=self.TEXT_COLOR, text="Uscite:", font=("Arial", 10, "bold")).pack(side=tk.LEFT)
        right_total_usc_lbl = tk.Label(right_diff_frame, bg=self.COLOR_TOPLEVEL ,fg=self.TEXT_COLOR, text="", font=("Arial", 10, "bold"))
        right_total_usc_lbl.pack(side=tk.LEFT, padx=(2, 10))
        tk.Label(right_diff_frame, bg=self.COLOR_TOPLEVEL ,fg=self.TEXT_COLOR, text="Differenza:", font=("Arial", 10, "bold")).pack(side=tk.LEFT)
        right_diff_val_lbl = tk.Label(right_diff_frame, bg=self.COLOR_TOPLEVEL ,fg=self.TEXT_COLOR, text="", font=("Arial", 10, "bold"))
        right_diff_val_lbl.pack(side=tk.LEFT, padx=(2, 0))
        def treeview_sort_column(tv, col, reverse):
            l = [(tv.set(k, col), k) for k in tv.get_children('')]
            if col == "Data":
                try:
                    l.sort(key=lambda t: datetime.datetime.strptime(t[0], "%d-%m-%Y"), reverse=reverse)
                except ValueError:
                    l.sort(key=lambda t: t[0].lower(), reverse=reverse)
            else:
                try:
                    l.sort(key=lambda t: float(t[0].replace('‚Ç¨', '').replace('.', '').replace(',', '.').strip()), reverse=reverse)
                except (ValueError, IndexError):
                    l.sort(key=lambda t: t[0].lower(), reverse=reverse)
            for index, (val, k) in enumerate(l):
                tv.move(k, '', index)
            tv.heading(col, command=lambda: treeview_sort_column(tv, col, not reverse))
        def create_double_click_wrapper(treeview, mese_var, anno_var, per_anno_mode):
            def wrapper(event):
                item_id = treeview.identify_row(event.y)
                if not item_id:
                    return
                values = treeview.item(item_id, "values")
                if not values or len(values) < 1:
                    return
                categoria = values[0] 
                original_stats_table = getattr(self, 'stats_table', None)
                original_mode = getattr(self, 'stats_mode', None)
                original_refdate = getattr(self, 'stats_refdate', None)
                try:
                    self.stats_table = treeview
                    mode_str = "anno" if per_anno_mode.get() else "mese"
                    self.stats_mode = tk.StringVar(value=mode_str)
                    mese_val = int(mese_var.get())
                    anno_val = int(anno_var.get())
                    self.stats_refdate = datetime.date(anno_val, mese_val, 1)
                    simulated_values = [categoria, categoria] 
                    if hasattr(self, 'on_stats_table_double_click'):
                        self.on_stats_table_double_click(event)
                    else:
                        print("Errore: Funzione di dettaglio (on_stats_table_double_click) non trovata.")
                except Exception as e:
                    print(f"Errore critico durante l'esecuzione del wrapper: {e}") 
                if original_stats_table is not None:
                    self.stats_table = original_stats_table
                elif hasattr(self, 'stats_table'):
                    del self.stats_table
                if original_mode is not None:
                    self.stats_mode = original_mode
                elif hasattr(self, 'stats_mode'):
                    del self.stats_mode
                if original_refdate is not None:
                    self.stats_refdate = original_refdate
                elif hasattr(self, 'stats_refdate'):
                    del self.stats_refdate
            return wrapper
        def update_month_visibility():
            is_annual = compare_by_year.get()
            if is_annual:
                cb_lm.pack_forget()
                cb_rm.pack_forget()
            else:
                cb_la.pack_forget() 
                cb_lm.pack(side="left", padx=(0, 3)) 
                cb_la.pack(side="left") 
                
                cb_ra.pack_forget()
                cb_rm.pack(side="left", padx=(0, 3))
                cb_ra.pack(side="left")
        def update_tables():
            update_month_visibility()
            per_anno = compare_by_year.get()
            a1, a2 = int(left_anno.get()), int(right_anno.get())
            m1 = int(left_mese.get()) if not per_anno else 1
            m2 = int(right_mese.get()) if not per_anno else 1
            rows1_raw, rows2_raw = get_rows(m1, a1, per_anno), get_rows(m2, a2, per_anno)
            date_placeholder = "Totale Anno" if per_anno else "Totale Mese"
            rows1 = aggregate_rows_by_category(rows1_raw, date_placeholder)
            rows2 = aggregate_rows_by_category(rows2_raw, date_placeholder)
            left_tree.delete(*left_tree.get_children())
            tot_ent1, tot_usc1 = 0, 0
            for cat, data, ent, usc in sorted(rows1, key=lambda x: x[0].lower()): 
                tag = 'entrata' if ent > 0 else ('uscita' if usc > 0 else '')
                left_tree.insert("", "end", values=(cat, data, f"{ent:,.2f} ‚Ç¨", f"{usc:,.2f} ‚Ç¨"), tags=(tag,))
                tot_ent1, tot_usc1 = tot_ent1 + ent, tot_usc1 + usc
            diff1 = tot_ent1 - tot_usc1
            left_total_ent_lbl.config(text=f"{tot_ent1:,.2f} ‚Ç¨", fg="green")
            left_total_usc_lbl.config(text=f"{tot_usc1:,.2f} ‚Ç¨", fg="red")
            left_diff_val_lbl.config(
                text=f"{diff1:,.2f} ‚Ç¨",
                fg="green" if diff1 >= 0 else "red"
            )
            right_tree.delete(*right_tree.get_children())
            tot_ent2, tot_usc2 = 0, 0
            for cat, data, ent, usc in sorted(rows2, key=lambda x: x[0].lower()):
                tag = 'entrata' if ent > 0 else ('uscita' if usc > 0 else '')
                right_tree.insert("", "end", values=(cat, data, f"{ent:,.2f} ‚Ç¨", f"{usc:,.2f} ‚Ç¨"), tags=(tag,))
                tot_ent2, tot_usc2 = tot_ent2 + ent, tot_usc2 + usc
            diff2 = tot_ent2 - tot_usc2
            right_total_ent_lbl.config(text=f"{tot_ent2:,.2f} ‚Ç¨", fg="green")
            right_total_usc_lbl.config(text=f"{tot_usc2:,.2f} ‚Ç¨", fg="red")
            right_diff_val_lbl.config(
                text=f"{diff2:,.2f} ‚Ç¨",
                fg="green" if diff2 >= 0 else "red"
            )
            left_tree.unbind('<Double-1>')
            right_tree.unbind('<Double-1>')
            left_tree.bind('<Double-1>', create_double_click_wrapper(left_tree, left_mese, left_anno, compare_by_year))
            right_tree.bind('<Double-1>', create_double_click_wrapper(right_tree, right_mese, right_anno, compare_by_year))
        for var in [left_mese, left_anno, right_mese, right_anno, compare_by_year, mostra_future_var]:
            var.trace_add("write", lambda *a: update_tables())
        update_tables()
        def do_preview_export():
            per_anno = compare_by_year.get()
            a1, a2 = int(left_anno.get()), int(right_anno.get())
            m1 = int(left_mese.get()) if not per_anno else 1
            m2 = int(right_mese.get()) if not per_anno else 1
            rows1_raw, rows2_raw = get_rows(m1, a1, per_anno), get_rows(m2, a2, per_anno)
            label1 = f"{m1:02d}/{str(a1)[-2:]}" if not per_anno else str(a1)
            label2 = f"{m2:02d}/{str(a2)[-2:]}" if not per_anno else str(a2)
            lines = [f"Confronto tra {label1} e {label2}\n"]
            lines.append(f"{'Categoria':<33}{'Entrate ' + label1:>13}{'Uscite ' + label1:>13} |{'Entrate ' + label2:>13}{'Uscite ' + label2:>13} |{'Œî Entrate':>13}{'Œî Uscite':>13}")
            lines.append("-" * 130)
            data1 = defaultdict(lambda: [0.0, 0.0])
            for cat, _, ent, usc in rows1_raw:
                data1[cat][0] += ent
                data1[cat][1] += usc
            data2 = defaultdict(lambda: [0.0, 0.0])
            for cat, _, ent, usc in rows2_raw:
                data2[cat][0] += ent
                data2[cat][1] += usc
            tutte_le_categorie = sorted(set(data1.keys()) | set(data2.keys()))
            for cat in tutte_le_categorie:
                ent1, usc1 = data1[cat]
                ent2, usc2 = data2[cat]
                diff_ent, diff_usc = ent2 - ent1, usc2 - usc1
                lines.append(f"{cat:<20.20} {'':<12} {ent1:12,.2f} {usc1:12,.2f} | {ent2:12,.2f} {usc2:12,.2f} | {diff_ent:12,.2f} {diff_usc:12,.2f}")
            tot_ent1, tot_usc1 = sum(v[0] for v in data1.values()), sum(v[1] for v in data1.values())
            diff1 = tot_ent1 - tot_usc1
            tot_ent2, tot_usc2 = sum(v[0] for v in data2.values()), sum(v[1] for v in data2.values())
            diff2 = tot_ent2 - tot_usc2
            diff_ent_tot, diff_usc_tot = tot_ent2 - tot_ent1, tot_usc2 - tot_usc1
            lines.append("-" * 130)
            lines.append(f"{'TOTALI GENERALI':<33} {tot_ent1:12,.2f} {tot_usc1:12,.2f} | {tot_ent2:12,.2f} {tot_usc2:12,.2f} | {diff_ent_tot:12,.2f} {diff_usc_tot:12,.2f}")
            saldo1_str = f"{diff1:,.2f} ‚Ç¨"
            saldo2_str = f"{diff2:,.2f} ‚Ç¨"
            lines.append(f"{'RISPARMIO NETTO (Saldo)':<33} {saldo1_str:>25} | {saldo2_str:>25} |")
            miglioramento = diff2 - diff1
            lines.append("-" * 130)
            text = "\n".join(lines)
            prev = tk.Toplevel(popup, bg=self.COLOR_TOPLEVEL)
            prev.title("Preview Esporta confronto")
            popup_width = 1100
            popup_height = 580
            screen_width = self.winfo_screenwidth()
            screen_height = self.winfo_screenheight()
            center_x = int((screen_width / 2) - (popup_width / 2))
            center_y = int((screen_height / 2) - (popup_height / 2))
            prev.geometry(f"{popup_width}x{popup_height}+{center_x}+{center_y}")
            prev.transient(popup)
            prev.bind("<Escape>", lambda e: prev.destroy())
            text_frame = tk.Frame(prev)
            text_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=(10, 0))
            text_frame.grid_rowconfigure(0, weight=1)
            text_frame.grid_columnconfigure(0, weight=1)
            vsb_text = ttk.Scrollbar(text_frame, orient="vertical", style="Vertical.TScrollbar")
            vsb_text.grid(row=0, column=1, sticky="ns")
            t = tk.Text(text_frame, font=("Courier New", 10), wrap="none", yscrollcommand=vsb_text.set)
            t.grid(row=0, column=0, sticky="nswe")
            vsb_text.config(command=t.yview)
            t.insert(tk.END, text)
            t.config(state="disabled")
            def do_save():
                now = datetime.date.today()
                default_filename = f"Confronto_Export_{now.day:02d}-{now.month:02d}-{now.year}.txt"
                file = filedialog.asksaveasfilename(defaultextension=".txt", filetypes=[("File txt", "*.txt")], initialdir=EXPORT_FILES, initialfile=default_filename, title="Esporta confronto", confirmoverwrite=False, parent=prev)
                if file:
                    if os.path.exists(file) and not hasattr(self, 'show_custom_askyesno') or not self.show_custom_askyesno("Sovrascrivere file?", f"Il file '{os.path.basename(file)}' \nesiste gi√†. Vuoi sovrascriverlo?"):
                        return
                    with open(file, "w", encoding="utf-8") as f:
                        f.write(text)
                    if hasattr(self, "show_custom_warning"):
                        self.show_custom_warning("Esportazione completata", f"Tabella confronti esportata in:\n{file}")
            frm = tk.Frame(prev, bg=self.COLOR_TOPLEVEL)
            frm.pack(fill=tk.X, padx=10, pady=8)
            ttk.Button(frm, text="üíæ Esporta", command=do_save, style="Verde.TButton").pack(side=tk.LEFT, padx=6)
            if hasattr(self, '_stampa_lista_diretta'):
                ttk.Button(frm, text="üìÑ Stampa", command=lambda: self._stampa_lista_diretta(text, self.show_custom_warning), style="Blu.TButton").pack(side=tk.LEFT, padx=6)
            ttk.Button(frm, text="‚ùå Chiudi", command=prev.destroy, style="Giallo.TButton").pack(side=tk.RIGHT, padx=6)
            prev.lift()
            prev.focus_force()
            prev.attributes('-topmost', True)
            prev.after(100, lambda: prev.attributes('-topmost', False))
        btnframe = tk.Frame(popup, bg=self.COLOR_TOPLEVEL)
        btnframe.pack(side=tk.BOTTOM, fill=tk.X, pady=(10, 7))
        ttk.Button(btnframe, text="üìÑ Esporta", command=do_preview_export, style="Verde.TButton").pack(side=tk.LEFT, padx=8)
        ttk.Button(btnframe, text="üìà Mostra Grafico", command=lambda: self.crea_grafico_confronto(
                left_mese.get(), left_anno.get(), right_mese.get(), right_anno.get(), compare_by_year.get()), style="Blu.TButton").pack(side=tk.LEFT, padx=8)
        ttk.Button(btnframe, text="‚ùå Chiudi", command=popup.destroy, style="Giallo.TButton").pack(side=tk.RIGHT, padx=8)
    def crea_grafico_confronto(self, m1_str, a1_str, m2_str, a2_str, per_anno, categoria_sel=None):
        try:
            m1, a1, m2, a2 = int(m1_str), int(a1_str), int(m2_str), int(a2_str)
            p1_color = "#1f77b4"
            p2_color = "#ff7f0e"
            bg_color = getattr(self, "COLOR_TOPLEVEL", None)
            text_color = getattr(self, "TEXT_COLOR", "#000000")
            def parse_amount(s):
                if s is None: return 0.0
                if isinstance(s, (int, float)): return float(s)
                s = str(s).strip().replace('‚Ç¨', '').replace('\xa0', ' ')
                s = re.sub(r'\s+', '', s)
                if '.' in s and ',' in s: s = s.replace('.', '').replace(',', '.')
                elif ',' in s: s = s.replace(',', '.')
                elif '.' in s:
                    last_dot_idx = s.rfind('.')
                    if len(s) - last_dot_idx - 1 != 2: s = s.replace('.', '')
                try: return float(s)
                except Exception:
                    s2 = re.sub(r'[^0-9\-\.+]', '', s)
                    try: return float(s2) if s2 not in ('', '-', '+') else 0.0
                    except Exception: return 0.0
            def format_euro(val, decimals=2):
                neg = val < 0
                val_abs = abs(val)
                formatted = f"{val_abs:,.{decimals}f}"
                formatted = formatted.replace(',', 'X').replace('.', ',').replace('X', '.')
                return ("-" if neg else "") + formatted + ""
            def get_rows_confronto(mese, anno_param, per_anno_mode, categoria_filter):
                def parse_date_obj(d):
                    if isinstance(d, datetime.date): return d
                    if d is None: return None
                    d_str = str(d).strip()
                    try:
                        if re.match(r'^\d{4}-\d{1,2}-\d{1,2}$', d_str): return datetime.datetime.strptime(d_str, "%Y-%m-%d").date()
                        if re.match(r'^\d{1,2}-\d{1,2}-\d{4}$', d_str): return datetime.datetime.strptime(d_str, "%d-%m-%Y").date()
                        for fmt in ("%d/%m/%Y", "%Y/%m/%d", "%d.%m.%Y"):
                            try: return datetime.datetime.strptime(d_str, fmt).date()
                            except Exception: pass
                    except Exception: pass
                    return None
                rows_grouped = defaultdict(lambda: [0.0, 0.0])
                categories_list_raw = getattr(self, "_saved_info", {}).get("categorie", [])
                if not categories_list_raw:
                    categories_list_raw = getattr(self, "categorie", [])
                categorie_known = [c.strip().lower() for c in categories_list_raw if isinstance(c, str)]
                for d_raw, entries in getattr(self, "spese", {}).items():
                    d = d_raw if isinstance(d_raw, datetime.date) else parse_date_obj(d_raw)
                    if not d: continue
                    if per_anno_mode:
                        if d.year != int(anno_param): continue
                        key = f"{d.month:02d}"
                    else:
                        if d.year != int(anno_param) or d.month != int(mese): continue
                        key = f"{d.year}-{d.month:02d}-{d.day:02d}"
                    for entry in entries:
                        try:
                            categoria_val = None
                            if isinstance(entry, (list, tuple)):
                                if len(entry) >= 1 and isinstance(entry[0], str) and entry[0].strip().lower() in categorie_known: categoria_val = entry[0].strip()
                                elif len(entry) >= 5 and isinstance(entry[4], str): categoria_val = entry[4].strip()
                                elif len(entry) >= 2 and isinstance(entry[1], str): categoria_val = entry[1].strip()
                            elif isinstance(entry, dict):
                                c = entry.get('categoria') or entry.get('category') or entry.get('cat')
                                if isinstance(c, str): categoria_val = c.strip()
                            if categoria_filter and categoria_filter != "Tutte le Categorie":
                                if categoria_val is None or categoria_val.strip().lower() != str(categoria_filter).strip().lower(): continue
                            if isinstance(entry, (list, tuple)):
                                if len(entry) >= 4:
                                    imp = entry[2]; tipo = entry[3]
                                elif len(entry) == 3:
                                    imp = entry[1]; tipo = entry[2]
                                else: continue
                            elif isinstance(entry, dict):
                                imp = entry.get('importo') or entry.get('import') or entry.get('amount')
                                tipo = entry.get('tipo') or entry.get('type')
                            else: continue
                            importo_f = parse_amount(imp)
                            if str(tipo).strip().lower() == "entrata": rows_grouped[key][0] += importo_f
                            else: rows_grouped[key][1] += importo_f
                        except Exception: continue
                return rows_grouped
            popup_width = 1100
            popup_height = 600
            popup_grafico = tk.Toplevel(self)
            popup_grafico.title("Grafico Confronto Periodi")
            popup_grafico.transient(self)
            popup_grafico.minsize(600, 300)
            popup_grafico.configure(bg=bg_color)
            popup_grafico.withdraw()
            self.update_idletasks()
            main_x = self.winfo_rootx() 
            main_y = self.winfo_rooty() 
            main_width = self.winfo_width()
            main_height = self.winfo_height()
            center_x = main_x + (main_width // 2) - (popup_width // 2)
            center_y = main_y + (main_height // 2) - (popup_height // 2)
            center_x = max(0, center_x)
            center_y = max(0, center_y)
            popup_grafico.geometry(f"{popup_width}x{popup_height}+{center_x}+{center_y}")
            main_frame = tk.Frame(popup_grafico, bg=bg_color)
            main_frame.pack(fill=tk.BOTH, expand=True)
            controls_frame = tk.Frame(main_frame, bg=bg_color)
            controls_frame.pack(fill=tk.X, side=tk.TOP, padx=6, pady=6)
            categories_list_raw = getattr(self, "_saved_info", {}).get("categorie", [])
            if not categories_list_raw and getattr(self, "categorie", None):
                categories_list_raw = getattr(self, "categorie", [])
            categories_list = sorted([c for c in categories_list_raw if isinstance(c, str) and c])
            if "Tutte le Categorie" not in categories_list: categories_list.insert(0, "Tutte le Categorie")
            initial_categoria = categoria_sel if categoria_sel and categoria_sel in categories_list else "Tutte le Categorie"
            categoria_var = tk.StringVar(value=initial_categoria)
            combobox_cat = ttk.Combobox(controls_frame, textvariable=categoria_var, values=categories_list, state="readonly", style="Border.TCombobox", width=30)
            combobox_cat.pack(side=tk.RIGHT, padx=(0, 6))
            lbl_filter = tk.Label(controls_frame, text="Filtra Categoria:", bg=bg_color, fg=text_color)
            lbl_filter.pack(side=tk.RIGHT, padx=(4, 2))
            title_frame = tk.Frame(main_frame, bg=bg_color)
            title_frame.pack(fill=tk.X, side=tk.TOP)
            title_lbl = tk.Label(title_frame, text=f"Andamento Saldo Netto ({'Mensile' if per_anno else 'Giornaliero'})", bg=bg_color, fg=text_color, font=("Arial", 12, "bold"))
            title_lbl.pack(side=tk.LEFT, padx=8, pady=(0, 4))
            subtitle_frame = tk.Frame(title_frame, bg=bg_color)
            subtitle_frame.pack(side=tk.LEFT, padx=8)
            subtitle_p1_label = tk.Label(subtitle_frame, text="", bg=bg_color, fg=p1_color, font=("Arial", 9, "bold"))
            subtitle_p1_label.pack(side=tk.LEFT, padx=(0,4))
            subtitle_sep_label = tk.Label(subtitle_frame, text="|", bg=bg_color, fg=text_color, font=("Arial", 9))
            subtitle_sep_label.pack(side=tk.LEFT, padx=(0,4))
            subtitle_p2_label = tk.Label(subtitle_frame, text="", bg=bg_color, fg=p2_color, font=("Arial", 9, "bold"))
            subtitle_p2_label.pack(side=tk.LEFT, padx=(0,8))
            subtitle_cat_label = tk.Label(subtitle_frame, text="", bg=bg_color, fg=text_color, font=("Arial", 9))
            subtitle_cat_label.pack(side=tk.LEFT)
            canvas = tk.Canvas(main_frame, bg="white")
            canvas.pack(fill=tk.BOTH, expand=True, padx=6, pady=6)
            bottom_frame = tk.Frame(main_frame, bg=bg_color)
            bottom_frame.pack(fill=tk.X, side=tk.BOTTOM, padx=6, pady=6)
            legenda_frame = tk.Frame(bottom_frame, bg=bg_color)
            legenda_frame.pack(side=tk.LEFT)
            btn_container = tk.Frame(bottom_frame, bg=bg_color)
            btn_container.pack(side=tk.LEFT, padx=(6, 8))
            ttk.Button(btn_container, text="‚ùå Chiudi", command=popup_grafico.destroy, style="Giallo.TButton").pack(side=tk.LEFT)
            right_diff_frame = tk.Frame(bottom_frame, bg=bg_color)
            right_diff_frame.pack(side=tk.RIGHT, padx=(6, 8))
            p1_totals_lbl = tk.Label(right_diff_frame, bg=bg_color, fg=p1_color, text="", font=("Arial", 10, "bold"))
            p1_totals_lbl.pack(anchor="e")
            p2_totals_lbl = tk.Label(right_diff_frame, bg=bg_color, fg=p2_color, text="", font=("Arial", 10, "bold"))
            p2_totals_lbl.pack(anchor="e")
            delta_lbl = tk.Label(right_diff_frame, bg=bg_color, fg=text_color, text="", font=("Arial", 10, "bold"))
            delta_lbl.pack(anchor="e", pady=(6,0))
            saldos1 = []
            saldos2 = []
            labels_x = []
            keys_all = []
            data1_raw_cache = {}
            data2_raw_cache = {}
            month_abbr_it = {'01':'Gen','02':'Feb','03':'Mar','04':'Apr','05':'Mag','06':'Giu','07':'Lug','08':'Ago','09':'Set','10':'Ott','11':'Nov','12':'Dic'}
            def update_totals_display(d1, d2):
                ent_p1 = sum(v[0] for v in d1.values()); usc_p1 = sum(v[1] for v in d1.values()); diff_p1 = ent_p1 - usc_p1
                ent_p2 = sum(v[0] for v in d2.values()); usc_p2 = sum(v[1] for v in d2.values()); diff_p2 = ent_p2 - usc_p2
                p1_totals_lbl.config(text=f"P1 ‚Äî Entrate: {format_euro(ent_p1,2)}  Uscite: {format_euro(usc_p1,2)}  Saldo: {format_euro(diff_p1,2)}")
                p2_totals_lbl.config(text=f"P2 ‚Äî Entrate: {format_euro(ent_p2,2)}  Uscite: {format_euro(usc_p2,2)}  Saldo: {format_euro(diff_p2,2)}")
                delta = diff_p2 - diff_p1
                fg = "#2ca02c" if delta > 0 else ("#d62728" if delta < 0 else text_color)
                delta_lbl.config(text=f"Variazione Saldo (P2 vs P1): {format_euro(delta,2)}", fg=fg)
            def update_data(categoria_choice):
                nonlocal saldos1, saldos2, labels_x, keys_all, data1_raw_cache, data2_raw_cache
                data1_raw_cache = get_rows_confronto(m1, a1, per_anno, categoria_choice)
                data2_raw_cache = get_rows_confronto(m2, a2, per_anno, categoria_choice)
                keys_all = sorted(set(data1_raw_cache.keys()) | set(data2_raw_cache.keys()))
                saldos1 = []; saldos2 = []; labels_x = []
                for key in keys_all:
                    ent1, usc1 = data1_raw_cache.get(key, (0.0, 0.0)); ent2, usc2 = data2_raw_cache.get(key, (0.0, 0.0))
                    saldos1.append(ent1 - usc1); saldos2.append(ent2 - usc2)
                    if per_anno: labels_x.append(key)
                    else:
                        parts = key.split('-'); labels_x.append(parts[2] if len(parts) == 3 else key)
                update_totals_display(data1_raw_cache, data2_raw_cache)
            def update_subtitle(categoria_choice):
                periodo_p1 = f"{a1}" if per_anno else f"{m1:02d}/{a1}"; periodo_p2 = f"{a2}" if per_anno else f"{m2:02d}/{a2}"
                subtitle_p1_label.config(text=f"P1: {periodo_p1}"); subtitle_p2_label.config(text=f"P2: {periodo_p2}"); subtitle_cat_label.config(text=f"Categoria: {categoria_choice}")
            def draw_chart():
                try:
                    MIN_BAR_HEIGHT_PX = 4
                    canvas_width = max(200, canvas.winfo_width()); canvas_height = max(120, canvas.winfo_height())
                    canvas.delete("all")
                    side_padding_factor = 0.035
                    side_padding = max(50, int(canvas_width * side_padding_factor))
                    right_padding = max(20, int(canvas_width * side_padding_factor))
                    top_padding_plot = max(12, int(canvas_height * 0.08))
                    bottom_padding_plot = max(48, int(canvas_height * 0.15))
                    plot_width = canvas_width - side_padding - right_padding
                    plot_height = canvas_height - top_padding_plot - bottom_padding_plot
                    if plot_width <= 0 or plot_height <= 10: return
                    plot_vals1 = [abs(v) for v in saldos1]
                    plot_vals2 = [abs(v) for v in saldos2]
                    all_plot_vals = plot_vals1 + plot_vals2
                    max_val = max(all_plot_vals) if any(all_plot_vals) else 100.0
                    min_val = 0.0
                    y_range = max_val - min_val
                    if y_range == 0: max_val = max_val + 50; y_range = max_val - min_val
                    margin = y_range * 0.15
                    max_val += margin; y_range = max_val - min_val
                    def scale_y_plot(val):
                        normalized = (val - min_val) / y_range
                        return top_padding_plot + plot_height * (1 - normalized)
                    canvas_y_top = top_padding_plot; canvas_y_end = top_padding_plot + plot_height
                    canvas.create_line(side_padding, canvas_y_top, side_padding, canvas_y_end, fill="gray", width=2)
                    canvas.create_text(side_padding - 6, scale_y_plot(max_val), anchor="e", text=format_euro(max_val,0), font=("Arial", 9))
                    canvas.create_text(side_padding - 6, scale_y_plot(min_val), anchor="e", text=format_euro(min_val,0), font=("Arial", 9))
                    num_points = len(labels_x)
                    if num_points == 0: return
                    x_step = plot_width / num_points
                    bar_w = max(6, int(min(40, x_step * 0.35)))
                    gap = max(4, int(bar_w * 0.2))
                    y_base = scale_y_plot(0)
                    month_abbr_it_local = month_abbr_it
                    small_font = ("Arial", 8)
                    y_base_tic = canvas_y_end + 6
                    def _clamp(v, lo, hi): return max(lo, min(hi, v))
                    label_offset = 10
                    for i, label in enumerate(labels_x):
                        x_center = side_padding + x_step * (i + 0.5)
                        x0_p1 = x_center - (bar_w + gap//2); x1_p1 = x_center - (gap//2)
                        x0_p2 = x_center + (gap//2); x1_p2 = x_center + (bar_w + gap//2)
                        v1 = plot_vals1[i] if i < len(plot_vals1) else 0.0; v2 = plot_vals2[i] if i < len(plot_vals2) else 0.0
                        yv1 = scale_y_plot(v1); yv2 = scale_y_plot(v2)
                        top1 = yv1; bottom1 = y_base
                        if v1 > 0 and (bottom1 - top1) < MIN_BAR_HEIGHT_PX:
                            top1 = bottom1 - MIN_BAR_HEIGHT_PX
                        top1 = _clamp(top1, canvas_y_top, canvas_y_end); bottom1 = _clamp(bottom1, canvas_y_top, canvas_y_end)
                        canvas.create_rectangle(x0_p1, top1, x1_p1, bottom1, fill=p1_color, outline="", tags=(f"bar_p1_{i}", "bar_p1", "bar"))
                        signed_v1 = saldos1[i] if i < len(saldos1) else 0.0
                        tx1 = (x0_p1 + x1_p1) / 2
                        ty1 = _clamp(top1 - label_offset, canvas_y_top + 4, canvas_y_end - 4)
                        color_v1 = "#d62728" if signed_v1 < 0 else ("#2ca02c" if signed_v1 > 0 else text_color)
                        canvas.create_text(tx1, ty1, text=format_euro(signed_v1,0), fill=color_v1, font=("Arial", 8))
                        top2 = yv2; bottom2 = y_base
                        if v2 > 0 and (bottom2 - top2) < MIN_BAR_HEIGHT_PX:
                            top2 = bottom2 - MIN_BAR_HEIGHT_PX
                        top2 = _clamp(top2, canvas_y_top, canvas_y_end); bottom2 = _clamp(bottom2, canvas_y_top, canvas_y_end)
                        canvas.create_rectangle(x0_p2, top2, x1_p2, bottom2, fill=p2_color, outline="", tags=(f"bar_p2_{i}", "bar_p2", "bar"))
                        signed_v2 = saldos2[i] if i < len(saldos2) else 0.0
                        tx2 = (x0_p2 + x1_p2) / 2
                        ty2 = _clamp(top2 - label_offset, canvas_y_top + 4, canvas_y_end - 4)
                        color_v2 = "#d62728" if signed_v2 < 0 else ("#2ca02c" if signed_v2 > 0 else text_color)
                        canvas.create_text(tx2, ty2, text=format_euro(signed_v2,0), fill=color_v2, font=("Arial", 8))
                        if per_anno:
                            month_abbr = month_abbr_it_local.get(label, label)
                            canvas.create_text(x_center, y_base_tic, anchor="n", text=month_abbr, font=small_font)
                        else:
                            key_full = keys_all[i] if i < len(keys_all) else None
                            if key_full:
                                parts = key_full.split('-')
                                if len(parts) == 3:
                                    giorno, mese_abbr = parts[2], parts[1]
                                    canvas.create_text(x_center, y_base_tic, anchor="n", text=f"{giorno}/{mese_abbr}", font=small_font)
                                else:
                                    canvas.create_text(x_center, y_base_tic, anchor="n", text=labels_x[i], font=small_font)
                            else:
                                canvas.create_text(x_center, y_base_tic, anchor="n", text=labels_x[i], font=small_font)
                except Exception as e:
                    print("Errore draw_chart:", e)
            def on_bar_double_click(event):
                item_id = canvas.find_closest(event.x, event.y)[0]
                tags = canvas.gettags(item_id)
                index = -1
                period = None
                for tag in tags:
                    if tag.startswith("bar_p1_"):
                        index = int(tag.split("_")[2])
                        period = 1
                        break
                    elif tag.startswith("bar_p2_"):
                        index = int(tag.split("_")[2])
                        period = 2
                        break
                if index == -1 or index >= len(keys_all):
                    return
                key_clicked = keys_all[index]
                categoria_choice = categoria_var.get()
                if per_anno:
                    mese_val = key_clicked
                    anno_val = a1 if period == 1 else a2
                    data_filter = {
                        "anno": str(anno_val),
                        "mese": mese_val,
                        "categoria": categoria_choice if categoria_choice != "Tutte le Categorie" else None
                    }
                    title = f"Dettaglio Mensile - Mese {mese_val} {anno_val}"
                else:
                    try:
                        anno_str, mese_str, giorno_str = key_clicked.split('-')
                        mese_val = mese_str
                        anno_val = anno_str
                        giorno_val = giorno_str
                    except ValueError:
                        print(f"Errore nel parsing della chiave data: {key_clicked}")
                        return
                    data_filter = {
                        "anno": anno_val,
                        "mese": mese_val,
                        "giorno": giorno_val,
                        "categoria": categoria_choice if categoria_choice != "Tutte le Categorie" else None
                    }
                    title = f"Dettaglio Giornaliero - {giorno_val} {mese_val} {anno_val}"
                if categoria_choice != "Tutte le Categorie":
                    title += f" ({categoria_choice})"
                self.mostra_transazioni_popup(data_filter, title)
            update_data(initial_categoria)
            update_subtitle(initial_categoria)
            def finalizza_apertura():
                popup_grafico.update()
                draw_chart()
                popup_grafico.deiconify()
            popup_grafico.after(100, finalizza_apertura)
            resize_after_id = None
            def on_resize(event):
                nonlocal resize_after_id
                if resize_after_id: canvas.after_cancel(resize_after_id)
                resize_after_id = canvas.after(120, draw_chart)
            popup_grafico.bind("<Configure>", on_resize)
            canvas.bind("<Configure>", on_resize)
            def on_categoria_change(event=None):
                scelta = categoria_var.get()
                update_data(scelta)
                update_subtitle(scelta)
                draw_chart()
            combobox_cat.bind("<<ComboboxSelected>>", on_categoria_change)
            popup_grafico.bind("<Escape>", lambda e: popup_grafico.destroy())
            canvas.tag_bind("bar", "<Double-Button-1>", on_bar_double_click)
            for child in legenda_frame.winfo_children(): child.destroy()
            tk.Label(legenda_frame, text=f"P1 (Blu): {a1 if per_anno else f'{m1:02d}/{a1}'}", bg=bg_color, fg=p1_color, font=("Arial", 10, "bold")).pack(side=tk.LEFT, padx=(2, 8))
            tk.Label(legenda_frame, text=f"P2 (Arancione): {a2 if per_anno else f'{m2:02d}/{a2}'}", bg=bg_color, fg=p2_color, font=("Arial", 10, "bold")).pack(side=tk.LEFT, padx=(2, 8))
        except Exception as e:
            self.show_custom_warning("Errore Grafico", f"Si √® verificato un errore critico durante la generazione del grafico: {e}")
            
    # Gestione e Visualizzazione delle Scadenze/Ricorrenze Mensili
    def scadenze_mese(self):
        if hasattr(self, '_scadenze_popup') and self._scadenze_popup and self._scadenze_popup.winfo_exists():
            self._scadenze_popup.lift()
            return
        def ordina_colonna(treeview, col, reverse):
            def converti(valore):
                if col in ("data", "scadenza"):
                    try:
                        return datetime.datetime.strptime(valore, "%d-%m-%Y")
                    except:
                        return datetime.datetime.max
                elif col == "importo":
                    try:
                        return float(valore.replace("‚Ç¨", "").replace(".", "").replace(",", ".").strip())
                    except:
                        return 0
                else:
                    return valore.lower() if isinstance(valore, str) else valore
            dati = [(treeview.set(k, col), k) for k in treeview.get_children("")]
            dati.sort(key=lambda t: converti(t[0]), reverse=reverse)
            for index, (val, k) in enumerate(dati):
                treeview.move(k, "", index)
            treeview.heading(col, command=(lambda c=col: lambda: ordina_colonna(treeview, c, not reverse))())
        oggi = datetime.date.today()
        mese_corrente = oggi.month
        anno_corrente = oggi.year
        mesi_italiani = [
            "Gennaio", "Febbraio", "Marzo", "Aprile", "Maggio", "Giugno",
            "Luglio", "Agosto", "Settembre", "Ottobre", "Novembre", "Dicembre"
        ]
        mese_nome = mesi_italiani[mese_corrente - 1]
        popup_mensile = tk.Toplevel(self, bg=self.COLOR_TOPLEVEL)
        self._scadenze_popup = popup_mensile
        def on_scadenze_close():
            try:
                popup_mensile.grab_release() 
            except:
                pass
            popup_mensile.destroy()
            self._scadenze_popup = None
        popup_mensile.title(f"Scadenze di {mese_nome} {anno_corrente}")
        larghezza_finestra = 1000
        altezza_finestra = 420
        larghezza_schermo = self.winfo_screenwidth()
        altezza_schermo = self.winfo_screenheight()
        x = (larghezza_schermo // 2) - (larghezza_finestra // 2)
        y = (altezza_schermo // 2) - (altezza_finestra // 2)
        popup_mensile.geometry(f"{larghezza_finestra}x{altezza_finestra}+{x}+{y}")
        popup_mensile.transient(self)
        popup_mensile.focus_force()
        popup_mensile.resizable(False, False)
        popup_mensile.protocol("WM_DELETE_WINDOW", on_scadenze_close)
        popup_mensile.bind("<Escape>", lambda e: on_scadenze_close())
        colonne = ("data", "categoria", "descrizione", "importo", "tipo_voce", "scadenza", "pagato", "progressione")
        tree_mensile = ttk.Treeview(popup_mensile, columns=colonne, show="headings")
        tree_mensile.pack(fill="both", expand=True, padx=10, pady=(10, 0))
        tree_mensile.bind("<Double-1>", self.on_scadenza_doppio_click)
        for col in colonne:
            tree_mensile.heading(col, text=col.capitalize(), command=(lambda c=col: lambda: ordina_colonna(tree_mensile, c, False))())
        tree_mensile.column("data", width=80, anchor="center", stretch=False)
        tree_mensile.column("categoria", width=180, anchor="center", stretch=False)
        tree_mensile.column("descrizione", width=307, anchor="w", stretch=False)
        tree_mensile.column("importo", width=100, anchor="e", stretch=False)
        tree_mensile.column("tipo_voce", width=80, anchor="center", stretch=False)
        tree_mensile.column("scadenza", width=80, anchor="center", stretch=False)
        tree_mensile.column("pagato", width=60, anchor="center", stretch=False)
        tree_mensile.column("progressione", width=90, anchor="center", stretch=False)
        tree_mensile.tag_configure("verde", foreground="green")
        tree_mensile.tag_configure("rosso", foreground="red")
        tree_mensile.tag_configure("grigio", foreground="gray")
        for item_id, dati in self.ricorrenze.items():
            try:
                ric_type = dati.get("tipo", "").lower()
                n = dati.get("n", 0)
                data_inizio = datetime.datetime.strptime(dati.get("data_inizio", ""), "%d-%m-%Y").date()
                categoria = dati.get("cat", "N/D")
                descrizione_base = dati.get("desc", "‚Äî")
                tipo_voce = dati.get("tipo_voce", "N/D")
                importo_base = float(str(dati.get("imp", "0")).replace(",", "."))
                date_nel_mese = []
                for i in range(n):
                    if ric_type == "ogni mese":
                        mese = (data_inizio.month - 1 + i) % 12 + 1
                        anno = data_inizio.year + (data_inizio.month - 1 + i) // 12
                        giorno = min(
                            data_inizio.day,
                            [31, 29 if anno % 4 == 0 and (anno % 100 != 0 or anno % 400 == 0) else 28,
                             31, 30, 31, 30, 31, 31, 30, 31, 30, 31][mese - 1]
                        )
                        data_movimento = datetime.date(anno, mese, giorno)
                    elif ric_type == "ogni anno":
                        data_movimento = data_inizio.replace(year=data_inizio.year + i)
                    else:
                        data_movimento = data_inizio + datetime.timedelta(days=i)
                    if data_movimento.month == mese_corrente and data_movimento.year == anno_corrente:
                        date_nel_mese.append((i + 1, data_movimento))
                for indice, data_movimento in date_nel_mese:
                    voce_trovata = False
                    importo_effettivo = importo_base
                    if data_movimento in self.spese:
                        for voce in self.spese[data_movimento]:
                            if len(voce) == 5 and voce[4] == item_id:
                                importo_effettivo = voce[2]
                                voce_trovata = True
                                break
                    valore_importo = f"{importo_effettivo:,.2f} ‚Ç¨" if voce_trovata else "‚Äî"
                    pagato = "‚úîÔ∏è" if data_movimento <= oggi and voce_trovata else "‚ùå"
                    progressione = f"{indice}/{n}"
                    descrizione = descrizione_base
                    tag = "rosso" if tipo_voce == "Uscita" else "verde" if voce_trovata else "grigio"
                    data_scadenza = date_nel_mese[-1][1].strftime("%d-%m-%Y") if date_nel_mese else "N/D"
                    tree_mensile.insert(
                        "",
                        "end",
                        values=(
                            data_movimento.strftime("%d-%m-%Y"),
                            categoria,
                            descrizione,
                            valore_importo,
                            tipo_voce,
                            data_scadenza,
                            pagato,
                            progressione
                        ),
                        tags=(tag,)
                    )
            except Exception as e:
                print(f"Errore nella ricorrenza con ID {item_id}: {e}")
                continue
        fine_mese = datetime.date(anno_corrente, mese_corrente, 28)
        while True:
            try:
                fine_mese = fine_mese.replace(day=fine_mese.day + 1)
            except ValueError:
                break
        for data_voce in sorted(self.spese.keys()):
            if oggi <= data_voce <= fine_mese:
                for voce in self.spese[data_voce]:
                    if len(voce) < 5 or voce[4] not in self.ricorrenze:
                        try:
                            categoria, descrizione, importo, tipo_voce = voce[:4]
                            valore_importo = f"{importo:,.2f} ‚Ç¨"
                            pagato = "‚úîÔ∏è" if data_voce <= oggi else "‚ùå"
                            progressione = "‚Äî"
                            data_scadenza = data_voce.strftime("%d-%m-%Y")
                            tag = "rosso" if tipo_voce == "Uscita" else "verde"
                            tree_mensile.insert(
                                "",
                                "end",
                                values=(
                                    data_voce.strftime("%d-%m-%Y"),
                                    categoria,
                                    descrizione,
                                    valore_importo,
                                    tipo_voce,
                                    data_scadenza,
                                    pagato,
                                    progressione
                                ),
                                tags=(tag,)
                            )
                        except Exception as e:
                            print(f"Errore nella voce normale del {data_voce}: {e}")
                            continue
        ordina_colonna(tree_mensile, "data", False)
        button_frame = tk.Frame(popup_mensile, bg=self.COLOR_TOPLEVEL)
        button_frame.pack(fill="x", pady=10)
        ttk.Button(button_frame, text="üîÑ Calcola Mancanti", command=self.calcola_mancanti, style='Verde.TButton').pack(side="left", padx=20, pady=5)
        ttk.Button(button_frame, text="‚ùå Chiudi", command=on_scadenze_close, style='Giallo.TButton').pack(side="right", padx=20, pady=5)
    def on_scadenza_doppio_click(self, event):
        tree = event.widget
        item_id = tree.focus()
        if not item_id:
            return
        valori = tree.item(item_id, "values")
        if not valori or len(valori) < 1:
            return
        data_str = valori[0]  
        try:
            giorno = datetime.datetime.strptime(data_str, "%d-%m-%Y").date()
        except Exception:
            return
        self.set_stats_mode("giorno")
        if hasattr(self, "cal"):
            self.cal.selection_set(giorno)
            self.cal._sel_date = giorno
            self.stats_refdate = giorno

        self.update_stats()
        self.estratto_month_var.set(f"{giorno.month:02d}")
        self.estratto_year_var.set(str(giorno.year))
        self.stats_label.config(text=f"Riepilogo Giornaliero - {giorno.strftime('%d-%m-%Y')}", foreground="purple",
    font=("Arial", 10, "bold"))

    # Gestione dell'Aggiornamento Forzato e Riavvio dell'Applicazione
    def forza_aggiorna(self):
        messaggio_conferma = (
            "Forzare l'aggiornamento del software?\n\n"
            "L'applicazione verr√† chiusa e riavviata\n"
        )
        risposta = self.show_custom_askyesno(
            title="Aggiornamento",
            message=messaggio_conferma
        )
        if risposta:
            self.aggiorna(GITHUB_FILE_URL, NOME_FILE)
        else:
            self.show_custom_warning("Annullato", "‚ùå Aggiornamento forzato annullato dall'utente.")

    # Esecuzione dell'Aggiornamento del Software con Backup e Riavvio Automatico
    def aggiorna(self, url, nome_file):
        import subprocess, sys, os
        import time
        import os
        global APRI_BROWSER 
        nome_backup = f"{nome_file}.bak"
        try:
            if os.path.exists(nome_file):
                try:
                    shutil.copy2(nome_file, nome_backup)
                except Exception as backup_err:
                    print(f"ERRORE backup: {backup_err}")
                    self.show_custom_warning("Attenzione", "Impossibile creare il backup. Aggiornamento annullato.")
                    return
            try:
                urllib.request.urlretrieve(url, nome_file)
                print(f"Download completato! {nome_file} √® stato aggiornato.")
            except Exception as download_err:
                print(f"ERRORE download: {download_err}")
                if os.path.exists(nome_backup):
                    shutil.copy2(nome_backup, nome_file)
                    os.remove(nome_backup)
                self.show_custom_warning("Attenzione", "‚ùå Aggiornamento NON completato! \n\n Problema di rete/download. üòï")
                return
            if APRI_BROWSER:
                webbrowser.open(URL_QST) 
                APRI_BROWSER = False
            self.save_db()
            self._on_close_lock() 
            messaggio = "Riavvio in corso. File aggiornato! ATTENDERE..."
            duration_s = 2
            width = 350
            height = 80
            parent = self
            parent.update_idletasks()
            parent_width = parent.winfo_width()
            parent_height = parent.winfo_height()
            x_pos = (parent_width // 2) - (width // 2)
            y_pos = (parent_height // 2) - (height // 2)
            popup_frame = tk.Frame(parent, bg="orange", bd=3, relief="raised")
            popup_frame.place(x=x_pos, y=y_pos, width=width, height=height)
            popup_frame.lift()
            label = tk.Label(popup_frame, text=messaggio, font=("Arial", 10, "bold"), 
                              justify="center", padx=10, pady=10, bg="orange", fg="black")
            label.pack(expand=True, fill='both')
            parent.update() 
            time.sleep(duration_s)
            try:
               popup_frame.destroy()
            except:
               pass
            script_path = os.path.abspath(sys.argv[0])
            args = [sys.executable, script_path] + sys.argv[1:]
            if os.name == 'nt':
                subprocess.Popen(args, creationflags=0x00000008, shell=False, close_fds=True)
            else:
                subprocess.Popen(args, start_new_session=True, close_fds=True)
            os._exit(0)           
        except Exception as e:
            print(f"ERRORE FATALE nell'aggiornamento: {str(e)}")
            self.show_custom_warning("Errore Grave", "Si √® verificato un errore inatteso durante l'aggiornamento.")
            return
 
    # Implementazione di Calcolo, Simulazione e Analisi Comparativa di Mutui/Prestiti (Sistema Francese)
    def calcolo_mutuo_prestito(self):
        def popola_piano(tree_widget, capitale_iniziale, anni, mesi, rata_base, spese_mensili, tasso_mensile, title_label, ammortamento_extra=0):
            import datetime
            oggi = datetime.date.today()
            if capitale_iniziale is None or anni is None or mesi is None:
                for row in tree_widget.get_children():
                    tree_widget.delete(row)
                title_label.config(text="Nessun dato disponibile")
                return
            for row in tree_widget.get_children():
                tree_widget.delete(row)
            debito_res = capitale_iniziale
            if ammortamento_extra > 0:
                debito_res -= ammortamento_extra
            capitale_res_dopo_extra = debito_res
            try:
                if tasso_mensile > 0:
                    rata_base_nuova = capitale_res_dopo_extra * (tasso_mensile * (1 + tasso_mensile) ** mesi) / ((1 + tasso_mensile) ** mesi - 1)
                else:
                    rata_base_nuova = capitale_res_dopo_extra / mesi
            except (ZeroDivisionError, OverflowError):
                rata_base_nuova = 0
            totale_capitale = ammortamento_extra
            totale_interessi = 0
            for mese in range(1, mesi + 1):
                m_rata = (oggi.month + mese - 1) % 12 + 1
                a_rata = oggi.year + (oggi.month + mese - 1) // 12
                data_str = f"{oggi.day:02d}-{m_rata:02d}-{a_rata}"
                label_periodo = f"Rata {mese} ({data_str})"
                interessi_rata = debito_res * tasso_mensile
                capitale_rata = rata_base_nuova - interessi_rata
                debito_res -= capitale_rata
                totale_capitale += capitale_rata
                totale_interessi += interessi_rata
                tree_widget.insert("", "end", values=(
                   label_periodo,
                   f"{rata_base_nuova + spese_mensili:.2f} ‚Ç¨",
                   f"{capitale_rata:.2f} ‚Ç¨",
                   f"{interessi_rata:.2f} ‚Ç¨",
                   f"{debito_res if debito_res > 0.005 else 0.0:.2f} ‚Ç¨"
                ))
            totale_rata_pagata = totale_capitale + totale_interessi + (spese_mensili * mesi)
            riepilogo_text = (
                f"Capitale: {capitale_iniziale:.2f} ‚Ç¨\n"
                f"Durata: {anni} anni ({mesi} mesi)\n"
                f"Tasso: {tasso_mensile * 100 * 12:.2f} %\n"
                f"Metodo: Ammortamento Francese (Rata Costante)\n"
                f"Ammortamento Extra: {ammortamento_extra:.2f} ‚Ç¨\n"
                f"Importo Totale Restituito: {totale_rata_pagata:.2f} ‚Ç¨\n"
                f"Interessi Totali: {totale_interessi:.2f} ‚Ç¨"
            )
            title_label.config(text=riepilogo_text, wraplength=1000)
            tree_widget.insert("", "end", values=("TOTALE", f"{totale_rata_pagata:,.2f} ‚Ç¨", f"{totale_capitale:,.2f} ‚Ç¨", f"{totale_interessi:,.2f} ‚Ç¨", "-"), tags=('total_row',))
            tree_widget.tag_configure('total_row', font=('Arial', 10, 'bold'))
        def crea_tab_piano_ammortamento(notebook_widget, title):
            frame = ttk.Frame(notebook_widget, padding=10)
            notebook_widget.add(frame, text=title)
            title_label = ttk.Label(frame, text="Nessun dato disponibile", font=("Arial", 9, "bold"))
            title_label.pack(pady=10, fill=tk.X)
            tree_frame = ttk.Frame(frame)
            tree_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
            tree = ttk.Treeview(tree_frame, columns=("Rata", "Rata Mensile", "Quota Capitale", "Quota Interessi", "Debito Residuo"), show="headings")
            tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
            scrollbar = ttk.Scrollbar(tree_frame, orient="vertical", command=tree.yview, style="Vertical.TScrollbar")
            scrollbar.pack(side='right', fill='y')
            tree.configure(yscrollcommand=scrollbar.set)
            tree.heading("Rata", text="Rata")
            tree.heading("Rata Mensile", text="Rata Mensile")
            tree.heading("Quota Capitale", text="Quota Capitale")
            tree.heading("Quota Interessi", text="Quota Interessi")
            tree.heading("Debito Residuo", text="Debito Residuo")            
            tree.column("Rata", width=50, anchor="center")
            tree.column("Rata Mensile", width=120, anchor="center")
            tree.column("Quota Capitale", width=120, anchor="center")
            tree.column("Quota Interessi", width=120, anchor="center")
            tree.column("Debito Residuo", width=120, anchor="center")            
            return tree, title_label
        def calcola_scenario_singolo(capitale_iniziale, anni_simulazione, tasso_annuo, spese_mensili, ammortamento_extra=0):
            try:
                if ammortamento_extra > capitale_iniziale:
                    raise ValueError("L'ammortamento extra non pu√≤ essere maggiore del capitale.")
                tasso_mensile = tasso_annuo / 100 / 12
                mesi_simulazione = anni_simulazione * 12
                if mesi_simulazione <= 0:
                    return {
                        "rata_mensile_totale": 0,
                        "interessi_totali": 0,
                        "importo_totale": ammortamento_extra,
                        "capitale": capitale_iniziale,
                        "anni": 0,
                        "mesi": 0,
                        "rata_base": 0,
                        "spese_mensili": spese_mensili,
                        "tasso_mensile": tasso_mensile,
                        "tasso_annuo": tasso_annuo,
                        "ammortamento_extra": ammortamento_extra
                    }
                debito_res = capitale_iniziale - ammortamento_extra
                if debito_res <= 0:
                    return {
                        "rata_mensile_totale": 0,
                        "interessi_totali": 0,
                        "importo_totale": ammortamento_extra,
                        "capitale": capitale_iniziale,
                        "anni": 0,
                        "mesi": 0,
                        "rata_base": 0,
                        "spese_mensili": spese_mensili,
                        "tasso_mensile": tasso_mensile,
                        "tasso_annuo": tasso_annuo,
                        "ammortamento_extra": ammortamento_extra
                    }
                if tasso_mensile > 0:
                    rata_base = debito_res * (tasso_mensile * (1 + tasso_mensile) ** mesi_simulazione) / ((1 + tasso_mensile) ** mesi_simulazione - 1)
                else:
                    rata_base = debito_res / mesi_simulazione
                interessi_totali_nuovi = (rata_base * mesi_simulazione) - debito_res
                importo_totale_nuovo = debito_res + interessi_totali_nuovi + (spese_mensili * mesi_simulazione) + ammortamento_extra
                return {
                    "rata_mensile_totale": rata_base + spese_mensili,
                    "interessi_totali": interessi_totali_nuovi,
                    "importo_totale": importo_totale_nuovo,
                    "capitale": capitale_iniziale,
                    "anni": anni_simulazione,
                    "mesi": mesi_simulazione,
                    "rata_base": rata_base,
                    "spese_mensili": spese_mensili,
                    "tasso_mensile": tasso_mensile,
                    "tasso_annuo": tasso_annuo,
                    "ammortamento_extra": ammortamento_extra
                }
            except (ValueError, OverflowError):
                return None
        def aggiorna_simulazione_singola(i):
            campi_input = [entry.get().replace(",", ".").strip() for entry in entry_scenari[i]]
            if not campi_input[0] or not campi_input[1] or not campi_input[2]:
                for lbl in lbl_scenari_risultati[i]: lbl.config(text="N/A", foreground=self.TEXT_COLOR )
                popola_piano(trees_piani[i], None, None, None, None, None, None, labels_piani[i])
                self.tutti_i_risultati[i] = None
                return
            try:
                capitale_simulazione = float(campi_input[0])
                anni_simulazione = int(campi_input[1])
                tasso_annuo = float(campi_input[2])
                spese = float(campi_input[3] or 0)
                ammortamento_extra = float(campi_input[4] or 0)
                if (capitale_simulazione <= 0 or anni_simulazione <= 0 or tasso_annuo < 0 or
                    capitale_simulazione > 500000 or anni_simulazione > 35 or tasso_annuo > 35):
                    self.show_custom_warning("Attenzione", "Assicurati che siano positivi e rientrino in un intervallo ragionevole.\ncapitale_simulazione > 500000 or anni_simulazione > 35 or tasso_annuo > 35")
                    raise ValueError("Uno o pi√π valori non sono validi. Assicurati che siano positivi e rientrino in un intervallo ragionevole.")
                if ammortamento_extra > capitale_simulazione:
                    self.show_custom_warning("Attenzione", "L'ammortamento extra non pu√≤ essere maggiore del capitale.")
                    raise ValueError("L'ammortamento extra non pu√≤ essere maggiore del capitale.")
                risultati_scenario = calcola_scenario_singolo(capitale_simulazione, anni_simulazione, tasso_annuo, spese, ammortamento_extra)
                if risultati_scenario is not None:
                    self.tutti_i_risultati[i] = risultati_scenario
                    risultati_principali = self.tutti_i_risultati[0]
                    lbl_scenari_risultati[i][0].config(text=f"{risultati_scenario['mesi']}")
                    lbl_scenari_risultati[i][1].config(text=f"{risultati_scenario['tasso_mensile'] * 100:.4f} %")
                    lbl_scenari_risultati[i][2].config(text=f"{risultati_scenario['rata_mensile_totale']:.2f} ‚Ç¨")
                    lbl_scenari_risultati[i][3].config(text=f"{risultati_scenario['interessi_totali']:.2f} ‚Ç¨")
                    costo_totale_cap_int = risultati_scenario['capitale'] + risultati_scenario['interessi_totali']
                    lbl_scenari_risultati[i][4].config(text=f"{costo_totale_cap_int:.2f} ‚Ç¨")
                    if risultati_principali:
                        risparmio = risultati_principali["interessi_totali"] - risultati_scenario["interessi_totali"]
                        lbl_scenari_risultati[i][5].config(
                            text=f"{risparmio:.2f} ‚Ç¨", 
                            foreground='green' if risparmio > 0 else ('#E53935' if risparmio < 0 else self.TEXT_COLOR)
                        )
                    else:
                        lbl_scenari_risultati[i][5].config(text="N/A", foreground=self.TEXT_COLOR)
                    popola_piano(
                        trees_piani[i], risultati_scenario["capitale"], risultati_scenario["anni"],
                        risultati_scenario["mesi"], risultati_scenario["rata_base"],
                        risultati_scenario["spese_mensili"], risultati_scenario["tasso_mensile"],
                        labels_piani[i], risultati_scenario["ammortamento_extra"]
                    )
                else:
                    for lbl in lbl_scenari_risultati[i]: lbl.config(text="N/A", foreground=self.TEXT_COLOR)
                    popola_piano(trees_piani[i], None, None, None, None, None, None, labels_piani[i])
                    self.tutti_i_risultati[i] = None
            except ValueError as ve:
                for lbl in lbl_scenari_risultati[i]: lbl.config(text="N/A", foreground=self.TEXT_COLOR)
                popola_piano(trees_piani[i], None, None, None, None, None, None, labels_piani[i])
                self.tutti_i_risultati[i] = None
        def calcola_tutte_simulazioni():
            self.tutti_i_risultati = [None] * 6
            for i in range(6):
                aggiorna_simulazione_singola(i)
            aggiorna_tab_analisi(self.tutti_i_risultati)
        def aggiorna_tab_analisi(risultati):
            for row in tree_analisi.get_children():
                tree_analisi.delete(row)
            risultati_principali = risultati[0] if risultati and risultati[0] else None
            for i, res in enumerate(risultati):
                if res:
                    risparmio = 0.0
                    if risultati_principali:
                        risparmio = risultati_principali["interessi_totali"] - res["interessi_totali"]
                    tree_analisi.insert("", "end", values=(
                        f"Simulazione {i+1}", 
                        f"{res['capitale']:,.2f} ‚Ç¨",
                        f"{res['anni']} anni ({res['mesi']} rate)", 
                        f"{res['tasso_annuo']:,.2f} %",
                        f"{res['ammortamento_extra']:,.2f} ‚Ç¨",
                        f"{res['rata_mensile_totale']:,.2f} ‚Ç¨", 
                        f"{res['importo_totale']:,.2f} ‚Ç¨",
                        f"{res['interessi_totali']:,.2f} ‚Ç¨",
                        f"{risparmio:,.2f} ‚Ç¨"
                    ), tags=('all_rows',))
            tree_analisi.tag_configure('all_rows', font=('Arial', 10, 'bold'))
        def resetta_tutti_i_campi_simulazione():
            for i in range(6):
                for entry_widget in entry_scenari[i]:
                    entry_widget.delete(0, tk.END)
                for lbl in lbl_scenari_risultati[i]:
                    lbl.config(text="N/A", foreground=self.TEXT_COLOR)
                popola_piano(trees_piani[i], None, None, None, None, None, None, labels_piani[i])
                self.tutti_i_risultati[i] = None
            aggiorna_tab_analisi(self.tutti_i_risultati)
        def esporta_dati_con_preview():
            import datetime
            oggi = datetime.date.today()
            try:
                idx_notebook = notebook.index(notebook.select())
            except:
                try:
                    idx_notebook = self.notebook.index(self.notebook.select())
                except:
                    return

            has_sim = hasattr(self, 'tutti_i_risultati') and any(self.tutti_i_risultati)
            has_killer = hasattr(self, 'killer_stats') and self.killer_stats
            if not has_sim and not has_killer:
                self.show_custom_warning("Dati mancanti", "Esegui una simulazione o un Piano Killer per esportare i dati.")
                return
            preview_window = tk.Toplevel(root, bg=self.COLOR_TOPLEVEL)
            preview_window.title("Report di Analisi e Proiezione Finanziaria")
            window_width, window_height = 1250, 800
            preview_window.geometry(f"{window_width}x{window_height}+{int(preview_window.winfo_screenwidth()/2 - window_width/2)}+{int(preview_window.winfo_screenheight()/2 - window_height/2)}")
            preview_window.bind("<Escape>", lambda e: preview_window.destroy())
            preview_window.transient(root)
            preview_window.focus_set()
            contenuto_testo = (
                "=====================================================================================================================\n"
                "           REPORT FINANZIARIO COMPLETO - RIEPILOGO STATISTICHE E PIANO KILLER (AMMORTAMENTO FRANCESE)\n"
                "=====================================================================================================================\n"
            )

            if has_sim:
                contenuto_testo += "Categoria            | Simulazione 1 | Simulazione 2 | Simulazione 3 | Simulazione 4 | Simulazione 5 | Simulazione 6\n"
                contenuto_testo += "---------------------+---------------+---------------+---------------+---------------+---------------+---------------\n"
                
                sim_data = {
                    "Capitale (‚Ç¨)": [], "Durata (anni)": [], "N¬∞ Rate": [], "Scadenza Prevista": [],
                    "Tasso (%)": [], "Spese Incasso (‚Ç¨)": [], "Ammort. Extra (‚Ç¨)": [], 
                    "Rata Mensile (‚Ç¨)": [], "Interessi Totali (‚Ç¨)": [], "Costo Totale (‚Ç¨)": [], 
                    "Risparmio Int. (‚Ç¨)": []
                }
                
                risultati_principali = self.tutti_i_risultati[0] if self.tutti_i_risultati[0] else None
                for i, res in enumerate(self.tutti_i_risultati):
                    if res:
                        mesi_res = int(res['mesi'])
                        target_date = oggi + datetime.timedelta(days=int(mesi_res * 30.44))
                        data_stringa = target_date.strftime('%m/%Y')
                        sim_data["Capitale (‚Ç¨)"].append(f"{res['capitale']:.2f}")
                        sim_data["Durata (anni)"].append(f"{res['anni']}")
                        sim_data["N¬∞ Rate"].append(f"{res['mesi']}")
                        sim_data["Scadenza Prevista"].append(data_stringa)
                        sim_data["Tasso (%)"].append(f"{res['tasso_annuo']:.2f}")
                        sim_data["Spese Incasso (‚Ç¨)"].append(f"{res['spese_mensili']:.2f}")
                        sim_data["Ammort. Extra (‚Ç¨)"].append(f"{res['ammortamento_extra']:.2f}")
                        sim_data["Rata Mensile (‚Ç¨)"].append(f"{res['rata_mensile_totale']:.2f}")
                        sim_data["Interessi Totali (‚Ç¨)"].append(f"{res['interessi_totali']:.2f}")
                        sim_data["Costo Totale (‚Ç¨)"].append(f"{res['capitale'] + res['interessi_totali']:.2f}")
                        risparmio = risultati_principali["interessi_totali"] - res["interessi_totali"] if risultati_principali and i > 0 else 0.0
                        sim_data["Risparmio Int. (‚Ç¨)"].append(f"{risparmio:.2f}")
                    else:
                        for key in sim_data: sim_data[key].append("")
                max_len_cat = max(len(cat) for cat in sim_data.keys())
                for cat, values in sim_data.items():
                    formatted_cat = f"{cat}{' ' * (max_len_cat - len(cat))}"
                    formatted_values = " | ".join(f"{val:<13}" for val in values)
                    contenuto_testo += f"{formatted_cat} | {formatted_values}\n"
                    if cat in ["Ammort. Extra (‚Ç¨)", "Costo Totale (‚Ç¨)", "Risparmio Int. (‚Ç¨)"]:
                        contenuto_testo += "---------------------+---------------+---------------+---------------+---------------+---------------+---------------\n"

            if 2 <= idx_notebook <= 5:
                idx_sim = idx_notebook - 2
                res_sel = self.tutti_i_risultati[idx_sim]
                if res_sel:
                    contenuto_testo += f"\nüìã PIANO AMMORTAMENTO DETTAGLIATO: SIMULAZIONE {idx_sim + 1}\n"
                    linea = "-" * 117
                    contenuto_testo += linea + "\n"
                    contenuto_testo += f"{'Periodo':<30} | {'Rata (‚Ç¨)':>12} | {'Cap. (‚Ç¨)':>12} | {'Int. (‚Ç¨)':>12} | {'Residuo (‚Ç¨)':>15}\n"
                    contenuto_testo += linea + "\n"
                    res_p = res_sel['capitale'] - res_sel.get('ammortamento_extra', 0)
                    tasso_m = res_sel['tasso_mensile']
                    rata_tot = res_sel['rata_mensile_totale']
                    data_inizio = datetime.date.today()
                    for m in range(1, res_sel['mesi'] + 1):
                        mese_rata = (data_inizio.month + m - 1) % 12 + 1
                        anno_rata = data_inizio.year + (data_inizio.month + m - 1) // 12
                        giorno_rata = min(data_inizio.day, 28)
                        data_corrente = f"{giorno_rata:02d}-{mese_rata:02d}-{anno_rata}"
                        q_i = res_p * tasso_m
                        q_c = res_sel['rata_base'] - q_i
                        res_p -= q_c
                        etichetta = f"Rata {m:>3} ({data_corrente})"
                        contenuto_testo += (
                            f"{etichetta:<30} | "
                            f"{rata_tot:>12.2f} | "
                            f"{q_c:>12.2f} | "
                            f"{q_i:>12.2f} | "
                            f"{max(0, res_p):>15.2f}\n"
                        )
                    contenuto_testo += linea + "\n"
                    
            elif idx_notebook >= 6:
                if has_killer:
                    import datetime
                    try:
                        def get_val_local(entry):
                            val = entry.get().strip().replace(",", ".")
                            return float(val) if val else 0.0
                        capitale_input = get_val_local(ent_k_residuo)
                        mesi_input     = int(get_val_local(ent_k_mesi))
                        rata_input     = get_val_local(ent_k_rata)
                        tasso_input    = get_val_local(ent_k_tasso)
                        extra_s_input  = get_val_local(ent_k_extra_subito)
                    except:
                        capitale_input = rata_input = tasso_input = extra_s_input = 0.0
                        mesi_input = 0
                    k_tot = getattr(self, 'killer_totali', {})
                    int_senza_k = k_tot.get('interessi_senza_killer', 0.0)
                    totale_senza_k = capitale_input + int_senza_k
                    risparmio_k = k_tot.get('risparmio', 0.0)
                    mesi_risp = int(k_tot.get('mesi_risparmiati', 0))
                    strat = k_tot.get('strategia', 'N/D')
                    total_int_k = sum(item['quota_int'] for item in self.killer_stats)
                    total_vers_k = sum(item['versato'] for item in self.killer_stats)
                    durata_effettiva = max(0, mesi_input - mesi_risp)
                    oggi = datetime.date.today()
                    def get_date_str(m):
                        if m <= 0: return "IMMEDIATA"
                        target = oggi + datetime.timedelta(days=int(m * 30.44))
                        return target.strftime('%m/%Y')
                    d_fine_std = get_date_str(mesi_input)
                    d_fine_k   = get_date_str(durata_effettiva)
                    contenuto_testo += "\n\nüéØ " + "="*45 + " PIANO KILLER " + "="*55 + "\n"
                    contenuto_testo += f"Sintesi: {getattr(self, 'killer_summary', 'Analisi Estinzione Strategica')}\n"
                    contenuto_testo += f"{'-'*117}\n"
                    contenuto_testo += " SITUAZIONE ATTUALE (DATI INSERITI)\n"
                    contenuto_testo += f"{'-'*117}\n"
                    contenuto_testo += f"{' > Debito Residuo Iniziale:':<45} {capitale_input:>20.2f} ‚Ç¨\n"
                    if extra_s_input > 0:
                        contenuto_testo += f"{' > Abbattimento Immediato:':<45} {extra_s_input:>20.2f} ‚Ç¨\n"
                    contenuto_testo += f"{' > Rata Mensile Attuale:':<45} {rata_input:>20.2f} ‚Ç¨\n"
                    contenuto_testo += f"{' > Durata Residua Dichiarata:':<45} {mesi_input:>20} rate\n"
                    contenuto_testo += f"{' > Tasso Applicato:':<45} {tasso_input:>20.2f} %\n"
                    contenuto_testo += f"{'-'*117}\n"
                    contenuto_testo += " PROIEZIONE SENZA INTERVENTO (PIANO ORIGINARIO)\n"
                    contenuto_testo += f"{'-'*117}\n"
                    contenuto_testo += f"{' > Scadenza Prevista:':<45} {d_fine_std:>20}\n"
                    contenuto_testo += f"{' > Interessi Totali Previsti:':<45} {int_senza_k:>20.2f} ‚Ç¨\n"
                    contenuto_testo += f"{' > Totale Montante (Cap+Int):':<45} {totale_senza_k:>20.2f} ‚Ç¨\n"
                    contenuto_testo += f"{'-'*117}\n"
                    contenuto_testo += " RISULTATI DOPO IL PIANO KILLER\n"
                    contenuto_testo += f"{'-'*117}\n"
                    contenuto_testo += f" Metodo: Ricalcolo interessi su debito residuo (Ammortamento Francese)\n"
                    contenuto_testo += f"{' > Strategia Selezionata:':<45} {strat.upper():>20}\n"
                    contenuto_testo += f"{'-'*117}\n"
                    contenuto_testo += f"{' > Risparmio Interessi Netto:':<45} {risparmio_k:>20.2f} ‚Ç¨\n"
                    contenuto_testo += f"{' > Totale Interessi da Pagare:':<45} {total_int_k:>20.2f} ‚Ç¨\n"
                    contenuto_testo += f"{'-'*117}\n"
                    contenuto_testo += f"{' > Nuova Scadenza (Killer):':<45} {d_fine_k:>20}\n"
                    contenuto_testo += f"{' > Numero Rate Residue:':<45} {durata_effettiva:>20} rate\n"
                    contenuto_testo += f"{' > Anticipo su Estinzione:':<45} {mesi_risp:>20} mesi\n"
                    contenuto_testo += f"{'-'*117}\n"
                    contenuto_testo += f"{' > TOTALE VERSATO FINALE:':<45} {total_vers_k:>20.2f} ‚Ç¨\n"
                    contenuto_testo += f"{'='*117}\n"
                    if hasattr(self, 'killer_annuali') and self.killer_annuali:
                        import datetime
                        oggi = datetime.date.today()
                        
                        contenuto_testo += "\n--- Piano di Recupero Cash-Flow Annuale (Auto-Finanziamento) ---\n"
                        contenuto_testo += "-"*117 + "\n"
                        contenuto_testo += f"{'ANNO':<10} | {'ANNO SOLARE':<12} | {'Extra Previsto':>18} | {'Risparmio Rate':>18} | {'Impatto Reale':>20}\n"
                        contenuto_testo += "-"*117 + "\n"
                        anticipo_val = 0.0
                        if self.killer_stats and "Anticipo" in str(self.killer_stats[0]['mese']):
                            anticipo_val = self.killer_stats[0]['versato']
                            contenuto_testo += (
                                f"{'ANTICIPO':<10} | "
                                f"{oggi.year:<12} | "
                                f"{anticipo_val:>18.2f} | "
                                f"{0.0:>18.2f} | "
                                f"{anticipo_val:>20.2f}\n"
                            )
                        try:
                            val_extra_ricorrente = float(ent_k_extra_annuo.get().replace(",", "."))
                        except:
                            val_extra_ricorrente = 0.0
                        for ann in self.killer_annuali:
                            anno_solare = oggi.year + ann['anno']
                            extra_anno = val_extra_ricorrente
                            risparmio = ann.get('risparmio_rate', 0.0)
                            impatto_reale = extra_anno - risparmio
                            
                            contenuto_testo += (
                                f"Anno {ann['anno']:<5} | "
                                f"{anno_solare:<12} | "
                                f"{extra_anno:>18.2f} | "
                                f"{risparmio:>18.2f} | "
                                f"{impatto_reale:>20.2f}\n"
                            )
                        if self.killer_stats:
                            ultima_r = self.killer_stats[-1]
                            mesi_totali = len(self.killer_stats)
                            data_fine = oggi + datetime.timedelta(days=int(mesi_totali * 30.44))
                            contenuto_testo += (
                                f"{'CHIUSURA':<10} | "
                                f"{data_fine.year:<12} | "
                                f"{ultima_r['versato']:>18.2f} | "
                                f"{'---':>18} | "
                                f"{ultima_r['versato']:>20.2f} (Saldo Finale)\n"
                            )
                        contenuto_testo += "-"*117 + "\n"
                        contenuto_testo += "* ANTICIPO: Versamento una tantum effettuato oggi per abbattere il capitale.\n"
                        contenuto_testo += "* Extra Previsto: Somma degli extra versati nell'anno solare (esclusa la quota capitale della rata).\n"
                        contenuto_testo += "* Impatto Reale: Sforzo finanziario netto (Extra versato - Risparmio generato dalla riduzione della rata).\n"
                    contenuto_testo += "\nDettaglio Piano Di Ammortamento Killer:\n"
                    contenuto_testo += "-"*117 + "\n"
                    contenuto_testo += f"{'Periodo':<30} | {'Versato (‚Ç¨)':>15} | {'Quota Cap. (‚Ç¨)':>15} | {'Quota Int. (‚Ç¨)':>15} | {'Residuo (‚Ç¨)':>15}\n"
                    contenuto_testo += "-"*117 + "\n"
                    for row in self.killer_stats:
                        contenuto_testo += (
                            f"{str(row['mese']):<30} | "
                            f"{row['versato']:>15.2f} | "
                            f"{row['quota_cap']:>15.2f} | "
                            f"{row['quota_int']:>15.2f} | "
                            f"{row['residuo']:>15.2f}\n"
                        )
                    contenuto_testo += "="*117 + "\n"
            contenuto_testo += f"\nReport generato il: {datetime.datetime.now().strftime('%d/%m/%Y %H:%M:%S')}\n"
            text_frame = ttk.Frame(preview_window, padding=10)
            text_frame.pack(fill=tk.BOTH, expand=True)
            txt_preview = tk.Text(text_frame, wrap=tk.NONE, height=30, width=140, font=('Courier New', 9))
            txt_preview.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
            v_scroll = ttk.Scrollbar(text_frame, orient="vertical", command=txt_preview.yview, style="Vertical.TScrollbar")
            v_scroll.pack(side=tk.RIGHT, fill='y')
            txt_preview.config(yscrollcommand=v_scroll.set)
            txt_preview.insert(tk.END, contenuto_testo)
            txt_preview.config(state="disabled")
            def salva_effettivamente():
                now = datetime.date.today()
                default_filename = f"Analisi_Mutuo_Killer_{now.strftime('%d-%m-%Y')}.txt"
                file = filedialog.asksaveasfilename(
                    defaultextension=".txt",
                    filetypes=[("File di testo", "*.txt")],
                    initialdir=EXPORT_FILES,
                    initialfile=default_filename,
                    title="Salva Report Finanziario",
                    confirmoverwrite=False,
                    parent=preview_window
                )
                if file:
                    if os.path.exists(file):
                        conferma = self.show_custom_askyesno(
                            "Sovrascrivere file?",
                            f"Il file '{os.path.basename(file)}' \nesiste gi√†. Vuoi sovrascriverlo?"
                        )
                        if not conferma:
                            return
                    try:
                        with open(file, "w", encoding="utf-8") as f:
                            f.write(contenuto_testo)
                        self.show_custom_warning("Successo", "Report salvato correttamente!")
                    except Exception as e:
                        self.show_custom_warning("Errore", f"Impossibile salvare il file: {e}")
                    
            button_frame = tk.Frame(preview_window, bg=self.COLOR_TOPLEVEL, pady=10)
            button_frame.pack()
            ttk.Button(button_frame, text="üíæ Salva Report", command=salva_effettivamente, style='Verde.TButton').pack(side=tk.LEFT, padx=5)
            ttk.Button(button_frame, text="üìÑ Stampa", style='Blu.TButton', command=lambda: self._stampa_lista_diretta(contenuto_testo, self.show_custom_warning)).pack(side=tk.LEFT, padx=5)
            ttk.Button(button_frame, text="‚ùå Chiudi", command=preview_window.destroy, style='Giallo.TButton').pack(side=tk.LEFT, padx=5)

        def calcola_ammortamento_killer():
            try:
                import datetime
                oggi = datetime.date.today()
                self.killer_stats = []
                self.killer_annuali = []
                for row in tree_k_piano.get_children():
                    tree_k_piano.delete(row)
                def get_val(entry):
                    val = entry.get().strip().replace(",", ".")
                    return float(val) if val else 0.0
                if not ent_k_residuo.get().strip() or not ent_k_mesi.get().strip() or not ent_k_tasso.get().strip():
                    self.show_custom_warning("Dati Mancanti", "Compila almeno Debito, Mesi e Tasso!")
                    return
                residuo_iniziale = get_val(ent_k_residuo)
                mesi_rimanenti = int(get_val(ent_k_mesi))
                tasso_annuo = get_val(ent_k_tasso)
                rata_originale = get_val(ent_k_rata)
                extra_annuo = get_val(ent_k_extra_annuo)
                extra_subito = get_val(ent_k_extra_subito)
                if (residuo_iniziale <= 0 or mesi_rimanenti <= 0 or tasso_annuo < 0 or
                    residuo_iniziale > 1000000 or mesi_rimanenti > 600 or tasso_annuo > 25):
                    msg = ("Controlla i dati inseriti:\n"
                           "- Il debito deve essere tra 1 e 1.000.000 ‚Ç¨\n"
                           "- I mesi devono essere tra 1 e 600\n"
                           "- Il tasso deve essere tra 0% e 25%")
                    self.show_custom_warning("Dati non validi", msg)
                    return
                if extra_subito > residuo_iniziale:
                    self.show_custom_warning("Attenzione", "L'Abbattimento Iniziale non pu√≤ superare il debito residuo.")
                    return
                if rata_originale <= (residuo_iniziale * (tasso_annuo/100/12)) + 0.01:
                    self.show_custom_warning("Errore Calcolo", "La rata √® troppo bassa per coprire gli interessi mensili!")
                    return
                mese_versamento = int(combo_k_mese.get())
                strategia = combo_k_strategia.get()
                self.killer_strategia_usata = strategia
                tasso_mensile = tasso_annuo / 100 / 12
                interessi_teorici_standard = (rata_originale * mesi_rimanenti) - residuo_iniziale
                debito = residuo_iniziale
                tot_versato_killer = 0
                tot_interessi_killer = 0
                risparmio_rate_anno_corrente = 0
                if extra_subito > 0:
                    data_subito = oggi.strftime("%d-%m-%Y")
                    abbattimento = min(extra_subito, debito)
                    debito -= abbattimento
                    tot_versato_killer += abbattimento
                    tree_k_piano.insert("", "end", values=(
                        f"Anticipo ({data_subito})",
                        f"{abbattimento:.2f} ‚Ç¨", 
                        f"{abbattimento:.2f} ‚Ç¨", 
                        "0.00 ‚Ç¨", 
                        f"{debito:.2f} ‚Ç¨"
                    ), tags=('extra_row',))
                    self.killer_stats.append({
                    'mese': f"Anticipo ({data_subito})", 
                    'versato': abbattimento, 
                    'quota_cap': abbattimento, 
                    'quota_int': 0, 
                    'residuo': debito
                    })
                mese_corrente = 0
                rata_corrente = rata_originale
                if strategia == "Ricalcola Rata" and extra_subito > 0:
                    if tasso_mensile > 0:
                        rata_corrente = debito * (tasso_mensile * (1 + tasso_mensile) ** mesi_rimanenti) / ((1 + tasso_mensile) ** mesi_rimanenti - 1)
                    else:
                        rata_corrente = debito / mesi_rimanenti
                oggi = datetime.date.today()
                mese_corrente = 0
                while debito > 0.01 and mese_corrente < 600:
                    mese_corrente += 1
                    m_rata = (oggi.month + mese_corrente - 1) % 12 + 1
                    a_rata = oggi.year + (oggi.month + mese_corrente - 1) // 12
                    data_str = f"{oggi.day:02d}-{m_rata:02d}-{a_rata}"
                    interessi_mese = debito * tasso_mensile
                    tot_interessi_killer += interessi_mese
                    risparmio_rate_anno_corrente += (rata_originale - rata_corrente)
                    versamento_extra = extra_annuo if (mese_corrente % 12 == mese_versamento % 12) else 0
                    if versamento_extra > 0 and strategia == "Ricalcola Rata":
                        m_res = mesi_rimanenti - mese_corrente
                        if m_res > 0:
                            dp = debito - (rata_corrente - interessi_mese)
                            dn = max(0, dp - versamento_extra)
                            if dn > 0 and tasso_mensile > 0:
                                rata_corrente = dn * (tasso_mensile * (1 + tasso_mensile) ** m_res) / ((1 + tasso_mensile) ** m_res - 1)
                            elif dn > 0:
                                rata_corrente = dn / m_res
                            else:
                                rata_corrente = 0
                    abb_pot = (rata_corrente - interessi_mese) + versamento_extra
                    if abb_pot >= debito:
                        versato_reale = debito + interessi_mese
                        abb_eff = debito
                        debito = 0
                    else:
                        versato_reale = rata_corrente + versamento_extra
                        abb_eff = abb_pot
                        debito -= abb_eff
                        
                    tot_versato_killer += versato_reale
                    label_periodo = f"Rata {mese_corrente:>3} ({data_str})"
                    tree_k_piano.insert("", "end", values=(
                        label_periodo,
                        f"{versato_reale:.2f} ‚Ç¨", 
                        f"{abb_eff:.2f} ‚Ç¨", 
                        f"{interessi_mese:.2f} ‚Ç¨", 
                        f"{max(debito,0):.2f} ‚Ç¨"
                    ), tags=('extra_row' if versamento_extra > 0 else ''))
                    self.killer_stats.append({
                        'mese': label_periodo,
                        'versato': versato_reale, 
                        'quota_cap': abb_eff, 
                        'quota_int': interessi_mese, 
                        'residuo': max(debito, 0)
                    })
                    if mese_corrente % 12 == 0 or debito <= 0:
                        self.killer_annuali.append({
                            'anno': (mese_corrente + 11) // 12,
                            'risparmio_rate': risparmio_rate_anno_corrente,
                            'sforzo_netto': extra_annuo - risparmio_rate_anno_corrente if extra_annuo > 0 else 0
                        })
                        risparmio_rate_anno_corrente = 0
                        if debito <= 0: break
                oggi = datetime.date.today()
                anno_f = oggi.year + (oggi.month + mese_corrente - 1) // 12
                mese_f = (oggi.month + mese_corrente - 1) % 12 + 1
                mesi_ita = ["", "Gennaio", "Febbraio", "Marzo", "Aprile", "Maggio", "Giugno", 
                            "Luglio", "Agosto", "Settembre", "Ottobre", "Novembre", "Dicembre"]
                freedom_date = f"{mesi_ita[mese_f]} {anno_f}"
                risparmio_interessi = interessi_teorici_standard - tot_interessi_killer
                tree_k_piano.tag_configure('extra_row', background='#e1f5fe')
                self.killer_totali = {
                    'tot_versato': tot_versato_killer,
                    'tot_interessi': tot_interessi_killer,
                    'interessi_senza_killer': interessi_teorici_standard,
                    'risparmio': risparmio_interessi,
                    'mesi_risparmiati': mesi_rimanenti - mese_corrente,
                    'freedom_date': freedom_date,
                    'strategia': strategia
                }
                testo_risultato = (
                    f"Strategia: {strategia}  üìÖ Termine: {freedom_date.upper()}\n"
                    f"üéØ Estinzione in {mese_corrente} Mesi (Risparmiati {self.killer_totali['mesi_risparmiati']} mesi)\n"
                    f"üí∞ Tot. Versato: {tot_versato_killer:.2f} ‚Ç¨  üìâ Interessi: {tot_interessi_killer:.2f} ‚Ç¨  üöÄ Risparmio: {max(0, risparmio_interessi):.2f} ‚Ç¨"
                )
                lbl_k_risultato.config(text=testo_risultato, foreground="#2e7d32")
                dati_per_pop = self.killer_annuali.copy()
                ex_val = extra_annuo
                f_date_pop = freedom_date

                def comando_popup():
                    pop = tk.Toplevel(root)
                    pop.title(f"Analisi Impatto - Termine previsto: {f_date_pop}")
                    pop.transient(root)
                    pop.focus_set()
                    w_pop, h_pop = 650, 520 
                    sw = pop.winfo_screenwidth(); sh = pop.winfo_screenheight()
                    x_c = int((sw/2) - (w_pop/2)); y_c = int((sh/2) - (h_pop/2))
                    pop.geometry(f"{w_pop}x{h_pop}+{x_c}+{y_c}")
                    pop.bind("<Escape>", lambda e: pop.destroy())
                    main_container = ttk.Frame(pop, padding="15")
                    main_container.pack(fill=tk.BOTH, expand=True)
                    ttk.Label(main_container, text="Riepilogo Impatto e Cash-Flow Reale", 
                              font=("Arial", 11, "bold")).pack(pady=(0,10))
                    table_frame = ttk.Frame(main_container)
                    table_frame.pack(fill=tk.BOTH, expand=True)
                    tree = ttk.Treeview(table_frame, columns=("a","as","e","r","s"), show="headings", height=12)
                    tree.heading("a", text="Anno"); tree.heading("as", text="Solare")
                    tree.heading("e", text="Extra"); tree.heading("r", text="Risparmio Rate")
                    tree.heading("s", text="Impatto Reale")
                    tree.column("a", width=70, anchor="center")
                    tree.column("as", width=80, anchor="center")
                    tree.column("e", width=100, anchor="e")
                    tree.column("r", width=120, anchor="e")
                    tree.column("s", width=140, anchor="e")
                    oggi = datetime.date.today()
                    if extra_subito > 0:
                        tree.insert("", "end", values=(
                            "ANTICIPO", 
                            f"{oggi.year}",
                            f"{extra_subito:.2f} ‚Ç¨",
                            "0.00 ‚Ç¨",
                            f"{extra_subito:.2f} ‚Ç¨"
                        ), tags=("evidenza",))
                    for r in dati_per_pop:
                        data_target = oggi + datetime.timedelta(days=int(r['anno'] * 12 * 30.44))
                        anno_solare_reale = data_target.year
                        tree.insert("", "end", values=(
                            f"Anno {r['anno']}", 
                            f"{anno_solare_reale}",
                            f"{ex_val:.2f} ‚Ç¨", 
                            f"{r['risparmio_rate']:.2f} ‚Ç¨", 
                            f"{r['sforzo_netto']:.2f} ‚Ç¨"
                        ))
                    if self.killer_stats:
                        ultima_riga = self.killer_stats[-1]
                        mesi_totali = len(self.killer_stats)
                        data_fine = oggi + datetime.timedelta(days=int(mesi_totali * 30.44))
                        tree.tag_configure("saldo", background="#D4EDDA", foreground="#155724")
                        tree.tag_configure("evidenza", background="#FFF9C4", foreground="#856404")
                        tree.insert("", "end", values=(
                            "ESTINZIONE", 
                            f"{data_fine.year}", 
                            f"{ultima_riga['versato']:.2f} ‚Ç¨", 
                            "---", 
                            f"{ultima_riga['versato']:.2f} ‚Ç¨"
                        ), tags=("saldo",))
                    sb = ttk.Scrollbar(table_frame, orient="vertical", command=tree.yview, style="Vertical.TScrollbar")
                    tree.configure(yscrollcommand=sb.set)
                    tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
                    sb.pack(side=tk.RIGHT, fill=tk.Y)
                    
                    note_testo = (
                            "* ANTICIPO: Versamento una tantum effettuato oggi per abbattere il capitale.\n"
                            "* ANNO SOLARE: Indica l'anno in cui si generano i risparmi e i versamenti extra.\n"
                            "* IMPATTO REALE: L'extra versato meno il risparmio accumulato sulle rate (Auto-finanziamento)."
                    )
                    ttk.Label(main_container, text=note_testo).pack(pady=5, anchor="w")
                    ttk.Button(main_container, text="‚ùå Chiudi", 
                               command=pop.destroy, style='Giallo.TButton').pack(pady=10)
                btn_vidi_sforzo.config(state="normal", command=comando_popup)
            except Exception as e:
                self.show_custom_warning("Errore", f"Controlla i dati: {str(e)}")
                
        def reset_killer():
            ent_k_residuo.delete(0, tk.END)
            ent_k_mesi.delete(0, tk.END)
            ent_k_tasso.delete(0, tk.END)
            ent_k_rata.delete(0, tk.END)
            ent_k_extra_annuo.delete(0, tk.END)
            ent_k_extra_subito.delete(0, tk.END)
            combo_k_mese.set("1")
            combo_k_strategia.set("Ricalcola Rata")
            for row in tree_k_piano.get_children():
                tree_k_piano.delete(row)
            lbl_k_risultato.config(text="Pronto per il calcolo")
            self.killer_stats = []
            self.killer_annuali = []
            btn_vidi_sforzo.config(state="disabled", command=None)
            
        self.killer_stats = []
        root = tk.Toplevel(bg=self.COLOR_TOPLEVEL)
        root.title("Gestore Finanziario - Calcolo Finanziamento e Simulazioni - Ammortamento Francese")
        root.geometry("1200x650")
        screen_width = root.winfo_screenwidth()
        screen_height = root.winfo_screenheight()
        window_width = 1200
        window_height = 650
        position_top = int(screen_height / 2 - window_height / 2)
        position_right = int(screen_width / 2 - window_width / 2)
        root.geometry(f'{window_width}x{window_height}+{position_right}+{position_top}')
        root.protocol("WM_DELETE_WINDOW", lambda: (self.deiconify(), self.after(0, self.imp_entry.focus_set), root.destroy()))
        root.bind("<Escape>", lambda e: (self.deiconify(), self.after(0, self.imp_entry.focus_set), root.destroy()))
        self.withdraw()
        self.tutti_i_risultati = [None] * 6
        notebook = ttk.Notebook(root)
        notebook.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        simulazioni_frame = ttk.Frame(notebook, padding=10)
        notebook.add(simulazioni_frame, text="Simulazioni")
        titoli_simulazioni = ["Scenario", "Capitale (‚Ç¨)", "Durata (anni)", "Tasso (%)", "Spese Incasso (‚Ç¨)", "Ammort. Extra (‚Ç¨)", "N¬∞ Rate", "Tasso Mensile", "Rata Mensile", "Interessi Totali", "Costo Totale", "Risparmio Interessi"]
        for i, titolo in enumerate(titoli_simulazioni):
            ttk.Label(simulazioni_frame, text=titolo, font=("Arial", 9, "bold")).grid(row=0, column=i, padx=5, pady=5, sticky="w")
        entry_scenari, lbl_scenari_risultati = [], []
        for i in range(6):
            entry_row, lbl_row = [], []
            ttk.Label(simulazioni_frame, text=f"Simulazione {i+1}").grid(row=i+1, column=0, pady=5, sticky="w")
            entry_capitale_scen = ttk.Entry(simulazioni_frame, width=9); entry_capitale_scen.grid(row=i+1, column=1, padx=5); entry_row.append(entry_capitale_scen)
            entry_durata_scen = ttk.Entry(simulazioni_frame, width=9); entry_durata_scen.grid(row=i+1, column=2, padx=5); entry_row.append(entry_durata_scen)
            entry_tasso_scen = ttk.Entry(simulazioni_frame, width=5); entry_tasso_scen.grid(row=i+1, column=3, padx=5); entry_row.append(entry_tasso_scen)
            entry_spese_scen = ttk.Entry(simulazioni_frame, width=9); entry_spese_scen.grid(row=i+1, column=4, padx=5); entry_row.append(entry_spese_scen)
            entry_ammortamento_extra_scen = ttk.Entry(simulazioni_frame, width=9); entry_ammortamento_extra_scen.grid(row=i+1, column=5, padx=5); entry_row.append(entry_ammortamento_extra_scen)
            lbl_rate_scen = ttk.Label(simulazioni_frame, text="N/A", width=5, anchor="w"); lbl_rate_scen.grid(row=i+1, column=6, padx=5); lbl_row.append(lbl_rate_scen)
            lbl_tasso_mensile_scen = ttk.Label(simulazioni_frame, text="N/A", width=9, anchor="w"); lbl_tasso_mensile_scen.grid(row=i+1, column=7, padx=5); lbl_row.append(lbl_tasso_mensile_scen)
            lbl_rata_scen = ttk.Label(simulazioni_frame, text="N/A", width=12, anchor="w"); lbl_rata_scen.grid(row=i+1, column=8, padx=5); lbl_row.append(lbl_rata_scen)
            lbl_interessi_scen = ttk.Label(simulazioni_frame, text="N/A", width=12, anchor="w"); lbl_interessi_scen.grid(row=i+1, column=9, padx=5); lbl_row.append(lbl_interessi_scen)
            lbl_costo_totale = ttk.Label(simulazioni_frame, text="N/A", width=12, anchor="w"); lbl_costo_totale.grid(row=i+1, column=10, padx=5); lbl_row.append(lbl_costo_totale)
            lbl_risparmiati_scen = ttk.Label(simulazioni_frame, text="N/A", width=15, anchor="w", font=("Arial", 9, "bold")); lbl_risparmiati_scen.grid(row=i+1, column=11, padx=5); lbl_row.append(lbl_risparmiati_scen)
            entry_scenari.append(entry_row)
            lbl_scenari_risultati.append(lbl_row)
        btn_calcola_simulazioni = ttk.Button(simulazioni_frame, text="üìÑ Calcola Tutte le Simulazioni", command=calcola_tutte_simulazioni, style='Verde.TButton')
        btn_calcola_simulazioni.grid(row=7, column=0, columnspan=11, pady=10)
        btn_reset_simulazioni = ttk.Button(
            simulazioni_frame,
            text="üîô",
            command=resetta_tutti_i_campi_simulazione,
            style='Yellow.TButton'
        )
        btn_reset_simulazioni.grid(row=7, column=7, pady=10, padx=5)
        analisi_frame = ttk.Frame(notebook, padding=10)
        notebook.add(analisi_frame, text="Riepilogo Analisi")
        tree_analisi = ttk.Treeview(analisi_frame, columns=("Scenario", "Capitale", "Durata", "Tasso", "Ammortamento Extra", "Rata Mensile", "Importo Totale", "Interessi Totali", "Risparmio Interessi"), show="headings")
        tree_analisi.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        headings = {"Scenario": 120, "Capitale": 120, "Durata": 150, "Tasso": 80, "Ammortamento Extra": 140, "Rata Mensile": 120, "Importo Totale": 150, "Interessi Totali": 120, "Risparmio Interessi": 140}
        for col, width in headings.items():
            tree_analisi.heading(col, text=col)
            tree_analisi.column(col, width=width, anchor="center")
        trees_piani, labels_piani = [], []
        for i in range(6):
            tree, label = crea_tab_piano_ammortamento(notebook, f"Simulazione {i+1}")
            trees_piani.append(tree); labels_piani.append(label)
        killer_frame = ttk.Frame(notebook, padding=10)
        notebook.add(killer_frame, text="üéØ Piano KILLER")
        k_input_frame = ttk.LabelFrame(killer_frame, text=" Parametri Estinzione Anticipata Strategica ", padding=10)
        k_input_frame.pack(fill=tk.X, pady=5)
        ttk.Label(k_input_frame, text="Debito Residuo (‚Ç¨):").grid(row=0, column=0, padx=5, sticky="w")
        ent_k_residuo = ttk.Entry(k_input_frame, width=12); ent_k_residuo.grid(row=0, column=1, padx=5, pady=2)
        ttk.Label(k_input_frame, text="Mesi Rimanenti:").grid(row=0, column=2, padx=5, sticky="w")
        ent_k_mesi = ttk.Entry(k_input_frame, width=8); ent_k_mesi.grid(row=0, column=3, padx=5, pady=2)
        ttk.Label(k_input_frame, text="Tasso Annuo (%):").grid(row=0, column=4, padx=5, sticky="w")
        ent_k_tasso = ttk.Entry(k_input_frame, width=8); ent_k_tasso.grid(row=0, column=5, padx=5, pady=2)
        ttk.Label(k_input_frame, text="Rata Mensile Attuale (‚Ç¨):").grid(row=0, column=6, padx=5, sticky="w")
        ent_k_rata = ttk.Entry(k_input_frame, width=12); ent_k_rata.grid(row=0, column=7, padx=5, pady=2)
        ttk.Label(k_input_frame, text="Extra Annuale (‚Ç¨):").grid(row=1, column=0, padx=5, sticky="w")
        ent_k_extra_annuo = ttk.Entry(k_input_frame, width=12); ent_k_extra_annuo.grid(row=1, column=1, padx=5, pady=2)
        ttk.Label(k_input_frame, text="Extra Anticipo (‚Ç¨):").grid(row=1, column=2, padx=5, sticky="w")
        ent_k_extra_subito = ttk.Entry(k_input_frame, width=8); ent_k_extra_subito.grid(row=1, column=3, padx=5, pady=2)
        ttk.Label(k_input_frame, text="Mese Versamento:").grid(row=1, column=4, padx=5, sticky="w")
        combo_k_mese = ttk.Combobox(k_input_frame, values=[str(i) for i in range(1, 13)], width=5, style="Border.TCombobox"); combo_k_mese.set("12"); combo_k_mese.grid(row=1, column=5, padx=5, pady=2)
        ttk.Label(k_input_frame, text="Strategia:").grid(row=1, column=6, padx=5, sticky="w")
        combo_k_strategia = ttk.Combobox(k_input_frame, values=["Mantieni Rata", "Ricalcola Rata"], width=15, style="Border.TCombobox"); combo_k_strategia.set("Ricalcola Rata"); combo_k_strategia.grid(row=1, column=7, padx=5, pady=2)
        ttk.Button(k_input_frame, text="üöÄ Calcola Piano Killer", 
                   command=calcola_ammortamento_killer, 
                   style='Verde.TButton').grid(row=2, column=0, columnspan=4, pady=10)
        global btn_vidi_sforzo
        btn_vidi_sforzo = ttk.Button(k_input_frame, text="üí° Analisi Esborso", state="disabled", style='Verde.TButton')
        btn_vidi_sforzo.grid(row=2, column=4, columnspan=4, pady=10)
        ttk.Button(k_input_frame, text="üîÑ Reset", 
           command=reset_killer, style='Blu.TButton').grid(row=2, column=6, columnspan=2, pady=10, padx=2)
           
        lbl_k_risultato = ttk.Label(killer_frame, text="Pronto per il calcolo", style="Verde.TLabel")
        lbl_k_risultato.pack(pady=5)
        tree_k_frame = ttk.Frame(killer_frame)
        tree_k_frame.pack(fill=tk.BOTH, expand=True)
        tree_k_piano = ttk.Treeview(tree_k_frame, columns=("Mese", "Versato", "Quota Capitale", "Quota Interessi", "Debito Residuo"), show="headings")
        tree_k_piano.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        for col in tree_k_piano["columns"]:
            tree_k_piano.heading(col, text=col)
            tree_k_piano.column(col, width=120, anchor="center")
        sb_k = ttk.Scrollbar(tree_k_frame, orient="vertical", command=tree_k_piano.yview, style="Vertical.TScrollbar")
        sb_k.pack(side=tk.RIGHT, fill=tk.Y)
        tree_k_piano.configure(yscrollcommand=sb_k.set)

        common_button_frame = tk.Frame(root,bg=self.COLOR_TOPLEVEL, padx=10, pady=10)
        common_button_frame.pack()  
        ttk.Button(common_button_frame, text="üìÑ Esporta Riepilogo", command=esporta_dati_con_preview, style='Arancio.TButton').pack(side=tk.LEFT, padx=5)  
        ttk.Button(common_button_frame, text="‚ùå Chiudi", command=lambda: (self.deiconify(), self.after(0, self.imp_entry.focus_set), common_button_frame.winfo_toplevel().destroy()), 
           style='Giallo.TButton').pack(side=tk.LEFT, padx=5)
    
    # Gestione Interfaccia Statistiche e Grafici Categorie Aggregate (Handler Click Destro)
    def on_stats_table_right_click(self, event):
        try:
            item_id = self.stats_table.identify_row(event.y)
            selezioni_correnti = self.stats_table.selection()
            if item_id and item_id not in selezioni_correnti:
                self.stats_table.selection_set(item_id)
            final_selections = self.stats_table.selection()
            if not final_selections:
                return
            mode = self.stats_mode.get() 
            if mode == "giorno":
                first_item_id = final_selections[0] 
                values = self.stats_table.item(first_item_id, "values") 
                if values and len(values) >= 5:
                    initial_date_str = str(values[0]).strip()
                    initial_category = str(values[1]).strip()
                    initial_description = str(values[2]).strip()
                    initial_amount = str(values[3]).strip().replace('‚Ç¨', '').replace(',', '.')
                    initial_type = str(values[4]).strip().lower()
                    self.launch_qr_svg_generator(
                        initial_category=initial_category,
                        initial_amount=initial_amount,
                        initial_date=initial_date_str,
                        initial_description=initial_description, 
                        initial_type=initial_type                
                    )
                    return 
            self.after(1, lambda: self.crea_grafico_categorie(final_selections))
        except Exception as e:
            print(f"‚ùå Errore critico durante l'elaborazione del click destro: {e}")
    def crea_grafico_categorie(self, id_righe_selezionate):
        anno_filtro = None
        mese_filtro = None
        giorno_filtro = None
        entrate_count = 0
        uscite_count = 0
        tipo_transazione_ricercato = "saldo"
        colore_barra_base = None
        tooltip_window = None 
        stats_mode = getattr(self, 'stats_mode', tk.StringVar(value="totali")).get() 
        stats_refdate = getattr(self, 'stats_refdate', None) 
        categorie_da_elaborare = []
        for item_id in id_righe_selezionate:
            try:
                cat_name_raw = str(self.stats_table.item(item_id, "values")[0]).strip()
                cat_name = ' '.join(cat_name_raw.split()) 
                if cat_name not in categorie_da_elaborare:
                    categorie_da_elaborare.append(cat_name)
            except:
                continue
        if not categorie_da_elaborare:
            self.show_custom_info("Errore", "Nessuna categoria valida trovata.")
            return
        if stats_mode == "giorno" and stats_refdate:
            anno_filtro = str(stats_refdate.year)
            mese_filtro = str(stats_refdate.month).zfill(2)
            giorno_filtro = str(stats_refdate.day).zfill(2)
        elif stats_mode == "mese" and stats_refdate:
            anno_filtro = str(stats_refdate.year)
            mese_filtro = str(stats_refdate.month).zfill(2)
        elif stats_mode == "anno" and stats_refdate:
            anno_filtro = str(stats_refdate.year)
        for data_oggetto, entries in self.spese.items():
            data_anno_str = str(data_oggetto.year)
            data_mese_pad = str(data_oggetto.month).zfill(2)
            if anno_filtro and data_anno_str != anno_filtro: continue
            if mese_filtro and data_mese_pad != mese_filtro: continue
            for entry in entries:
                if len(entry) < 4: continue 
                cat_raw, desc, imp, tipo = entry[:4]
                cat = ' '.join(str(cat_raw).strip().split())
                tipo_lower = str(tipo).lower()
                
                if cat in categorie_da_elaborare:
                    if "entrata" in tipo_lower:
                        entrate_count += 1
                    elif "uscita" in tipo_lower:
                        uscite_count += 1
        if entrate_count > 0 and uscite_count > 0:
            tipo_transazione_ricercato = "misto"
        elif entrate_count > 0:
            tipo_transazione_ricercato = "entrata"
            colore_barra_base = "#28A745"
        else:
            tipo_transazione_ricercato = "uscita"
            colore_barra_base = "#DC3545"
        spese_combinate = defaultdict(lambda: {
            'Entrata': 0.0, 
            'Uscita': 0.0,
            'Dettaglio_Entrata': defaultdict(float),
            'Dettaglio_Uscita': defaultdict(float)
        })
        saldo_aggregato_totale = 0.0 
        for data_objeto, entries in self.spese.items():
            try:
                data_anno_str = str(data_objeto.year)
                data_mese_pad = str(data_objeto.month).zfill(2)
                data_giorno_pad = str(data_objeto.day).zfill(2)
            except:
                continue
            if anno_filtro and data_anno_str != anno_filtro: continue
            if mese_filtro and data_mese_pad != mese_filtro: continue
            if giorno_filtro and data_giorno_pad != giorno_filtro: continue
            if stats_mode == "giorno" or stats_mode == "mese":
                chiave_aggregazione = f"{data_giorno_pad} {data_mese_pad} {data_anno_str}"
            else:
                chiave_aggregazione = f"{data_anno_str}-{data_mese_pad}"
            for entry in entries:
                if len(entry) < 4: continue
                cat_raw, desc, imp, tipo = entry[:4]
                cat = ' '.join(str(cat_raw).strip().split())
                tipo_lower = str(tipo).lower()
                if cat in categorie_da_elaborare:
                    try:
                        importo_numerico = float(imp)
                        
                        if tipo_transazione_ricercato == "misto":
                            if "entrata" in tipo_lower:
                                spese_combinate[chiave_aggregazione]['Entrata'] += importo_numerico
                                spese_combinate[chiave_aggregazione]['Dettaglio_Entrata'][cat] += importo_numerico
                                saldo_aggregato_totale += importo_numerico
                            elif "uscita" in tipo_lower:
                                spese_combinate[chiave_aggregazione]['Uscita'] += abs(importo_numerico)
                                spese_combinate[chiave_aggregazione]['Dettaglio_Uscita'][cat] += abs(importo_numerico)
                                saldo_aggregato_totale -= abs(importo_numerico)
                        elif tipo_transazione_ricercato == "entrata" and "entrata" in tipo_lower:
                            spese_combinate[chiave_aggregazione]['Entrata'] += importo_numerico
                            spese_combinate[chiave_aggregazione]['Dettaglio_Entrata'][cat] += importo_numerico
                            saldo_aggregato_totale += importo_numerico
                        elif tipo_transazione_ricercato == "uscita" and "uscita" in tipo_lower:
                            spese_combinate[chiave_aggregazione]['Uscita'] += abs(importo_numerico)
                            spese_combinate[chiave_aggregazione]['Dettaglio_Uscita'][cat] += abs(importo_numerico)
                            saldo_aggregato_totale -= abs(importo_numerico)
                    except (ValueError, TypeError):
                        continue
        dati_filtrati_non_zero = {}
        totale_entrate_periodo = 0.0
        totale_uscite_periodo = 0.0
        for k, v in spese_combinate.items():
            if v['Entrata'] != 0.0 or v['Uscita'] != 0.0:
                totale_entrate_periodo += v['Entrata']
                totale_uscite_periodo += v['Uscita']
                if tipo_transazione_ricercato == "misto":
                    dati_filtrati_non_zero[k] = v
                else:
                    valore_unico = v['Entrata'] + v['Uscita']
                    if tipo_transazione_ricercato == "entrata":
                        dati_filtrati_non_zero[k] = {'Totale': valore_unico, 'Dettaglio': v['Dettaglio_Entrata']}
                    else:
                        dati_filtrati_non_zero[k] = {'Totale': valore_unico, 'Dettaglio': v['Dettaglio_Uscita']}
        saldo_netto_periodo = totale_entrate_periodo - totale_uscite_periodo
        if not dati_filtrati_non_zero:
            self.show_custom_info("Nessun Dato", "Nessun dato di transazione con importo non zero trovato per il filtro e il periodo selezionati.")
            return
        dati_ordinati = sorted(dati_filtrati_non_zero.items())
        dati_per_grafico = list(reversed(dati_ordinati)) 
        mesi_completi = ["Gennaio", "Febbraio", "Marzo", "Aprile", "Maggio", "Giugno",
                         "Luglio", "Agosto", "Settembre", "Ottobre", "Novembre", "Dicembre"] 
        totale_aggregato = 0.0
        if tipo_transazione_ricercato == "misto":
            tipo_transazione_base = "Entrate vs Uscite"
            totale_copertura_desc_saldo = "Saldo Netto"
            totale_aggregato = saldo_netto_periodo
        elif tipo_transazione_ricercato == "entrata":
            tipo_transazione_base = "Entrate"
            totale_copertura_desc_saldo = "Totale Entrate"
            totale_aggregato = totale_entrate_periodo
        else:
            tipo_transazione_base = "Uscite"
            totale_copertura_desc_saldo = "Totale Uscite"
            totale_aggregato = totale_uscite_periodo
        if len(categorie_da_elaborare) > 1:
            tipo_titolo = "Combinata"
        else:
            tipo_titolo = "Categoria"
        if stats_mode == "giorno" and stats_refdate: 
            data_str = stats_refdate.strftime('%d/%m/%Y')
            etichetta_tempo = "Giornaliero"
            filtro_titolo = f" - Giorno {data_str}"
            totale_copertura_desc = f"{totale_copertura_desc_saldo} Giorno {data_str}"
        elif stats_mode == "mese" and anno_filtro and mese_filtro: 
            mese_nome = ""
            try:
                mese_num = int(mese_filtro)
                if 1 <= mese_num <= 12:
                    mese_nome = mesi_completi[mese_num - 1]
                else:
                    mese_nome = str(mese_filtro) 
            except ValueError:
                mese_nome = str(mese_filtro)
            etichetta_tempo = "Giornalieri" 
            filtro_titolo = f" - Mese {mese_nome} {anno_filtro}"
            totale_copertura_desc = f"{totale_copertura_desc_saldo} Mese {mese_nome} {anno_filtro}"
        elif stats_mode == "anno" and anno_filtro: 
            etichetta_tempo = "Mensili"  
            filtro_titolo = f" - Anno {anno_filtro}"
            totale_copertura_desc = f"{totale_copertura_desc_saldo} Anno {anno_filtro}"
        elif not anno_filtro:
            etichetta_tempo = "Annuale"  
            filtro_titolo = " - Totale Storico"
            totale_copertura_desc = f"{totale_copertura_desc_saldo} Totale Storico"
        else:
            etichetta_tempo = "Generale"  
            filtro_titolo = " - Periodo Non Specificato"
            totale_copertura_desc = f"{totale_copertura_desc_saldo} Generale"
        titolo_grafico = f"{tipo_transazione_base} {tipo_titolo} {etichetta_tempo}{filtro_titolo}"
        popup_width, popup_height = 1200, 600 
        self.popup_grafico = tk.Toplevel(self, bg=self.COLOR_TOPLEVEL)
        self.popup_grafico.title(f"üìä {titolo_grafico}")
        screen_width = self.winfo_screenwidth()
        screen_height = self.winfo_screenheight()
        center_x = int(screen_width/2 - popup_width/2)
        center_y = int(screen_height/2 - popup_height/2)
        self.popup_grafico.geometry(f'{popup_width}x{popup_height}+{center_x}+{center_y}')
        self.popup_grafico.bind('<Escape>', lambda e: self.popup_grafico.destroy())
        main_frame = tk.Frame(self.popup_grafico, bg=self.COLOR_TOPLEVEL)
        main_frame.pack(fill="both", expand=True, padx=10, pady=10)
        tk.Label(main_frame, bg=self.COLOR_TOPLEVEL , fg=self.TEXT_COLOR, text=titolo_grafico, font=("Arial", 12, "bold")).pack(pady=(0, 5))
        saldo_netto_periodo = totale_entrate_periodo - totale_uscite_periodo
        colore_entrate = "green"
        colore_uscite = "red"
        colore_saldo = "green" if saldo_netto_periodo >= 0 else "red"
        colore_testo = self.TEXT_COLOR
        riepilogo_frame = tk.Frame(main_frame, bg=self.COLOR_TOPLEVEL)
        riepilogo_frame.pack(pady=(0, 15))
        font_riepilogo = ("Arial", 10, "bold")
        tk.Label(riepilogo_frame, bg=self.COLOR_TOPLEVEL , fg=colore_testo, text=" Totale Entrate: ", font=font_riepilogo).pack(side=tk.LEFT)
        tk.Label(riepilogo_frame, bg=self.COLOR_TOPLEVEL , fg=colore_entrate, text=f"{totale_entrate_periodo:,.2f}", font=font_riepilogo).pack(side=tk.LEFT)
        tk.Label(riepilogo_frame, bg=self.COLOR_TOPLEVEL , fg=colore_testo, text=" ‚Ç¨ ", font=font_riepilogo).pack(side=tk.LEFT, padx=(0, 10))
        tk.Label(riepilogo_frame, bg=self.COLOR_TOPLEVEL , fg=colore_testo, text=" Totale Uscite: ", font=font_riepilogo).pack(side=tk.LEFT)
        tk.Label(riepilogo_frame, bg=self.COLOR_TOPLEVEL , fg=colore_uscite, text=f"{totale_uscite_periodo:,.2f}", font=font_riepilogo).pack(side=tk.LEFT)
        tk.Label(riepilogo_frame, bg=self.COLOR_TOPLEVEL , fg=colore_testo, text=" ‚Ç¨ ", font=font_riepilogo).pack(side=tk.LEFT, padx=(0, 10))
        tk.Label(riepilogo_frame, bg=self.COLOR_TOPLEVEL , fg=colore_testo, text=" Saldo Netto: ", font=font_riepilogo).pack(side=tk.LEFT)
        tk.Label(riepilogo_frame, bg=self.COLOR_TOPLEVEL , fg=colore_saldo, text=f"{saldo_netto_periodo:,.2f}", font=font_riepilogo).pack(side=tk.LEFT)
        tk.Label(riepilogo_frame, bg=self.COLOR_TOPLEVEL , fg=colore_testo, text=" ‚Ç¨", font=font_riepilogo).pack(side=tk.LEFT)
        canvas_frame_scroll = ttk.Frame(main_frame)
        canvas_frame_scroll.pack(fill="both", expand=True)
        scrollbar_h = ttk.Scrollbar(canvas_frame_scroll, orient="horizontal", style="Horizontal.TScrollbar")
        canvas = tk.Canvas(
            canvas_frame_scroll, 
            bg="white",
            xscrollcommand=scrollbar_h.set 
        )
        canvas.pack(side="top", fill="both", expand=True)
        scrollbar_h.config(command=canvas.xview)
        canvas.bind("<Configure>", lambda e: disegna_barre_scroll(canvas, dati_per_grafico))
        def hide_tooltip_local(event=None):
            nonlocal tooltip_window
            if tooltip_window:
                tooltip_window.destroy()
                tooltip_window = None
        def show_tooltip_local(event, text):
            nonlocal tooltip_window
            hide_tooltip_local()
            root_x = canvas.winfo_rootx()
            root_y = canvas.winfo_rooty()
            screen_x = root_x + event.x + 15
            screen_y = root_y + event.y + 10
            tooltip_window = tk.Toplevel(canvas)
            tooltip_window.wm_overrideredirect(True)
            tooltip_window.wm_geometry(f"+{screen_x}+{screen_y}")
            tooltip_window.wm_attributes("-topmost", True)
            label = ttk.Label(tooltip_window, text=text, style="Tooltip.TLabel")
            label.pack(padx=1, pady=1)
        self.popup_grafico.bind("<Destroy>", lambda e: hide_tooltip_local(), add="+")
        def disegna_barre_scroll(c, dati_tuple):
            hide_tooltip_local()
            c.delete("all")
            LARGHEZZ_STANDARD = 100
            LARGHEZZ_MISTA = 140
            BAR_FACTOR = 0.7
            margine_superiore = 40
            margine_inferiore = 90
            SPAZIO_EXTRA_MINIMO = 200
            altezza = c.winfo_height()
            canvas_larghezza = c.winfo_width()
            if altezza < 50:
                altezza = c.winfo_reqheight()
                if altezza < 50: altezza = popup_height - 150 
            if canvas_larghezza < 50:
                canvas_larghezza = c.winfo_reqwidth()
                if canvas_larghezza < 50: canvas_larghezza = popup_width - 40
            if altezza <= 50 or canvas_larghezza <= 50:
                return
            y_base = altezza - margine_inferiore
            importi_entrate = []
            importi_uscite = []
            for _, val in dati_tuple:
                if isinstance(val, dict):
                    if 'Totale' in val:
                        if tipo_transazione_ricercato == "entrata":
                            importi_entrate.append(val.get('Totale', 0))
                        else:
                            importi_uscite.append(abs(val.get('Totale', 0)))
                    else:
                        importi_entrate.append(val.get('Entrata', 0))
                        importi_uscite.append(val.get('Uscita', 0))
                else:
                    if tipo_transazione_ricercato == "entrata":
                        importi_entrate.append(val)
                    else:
                        importi_uscite.append(abs(val))
            def calculate_capped_max(abs_importi):
                if not abs_importi or max(abs_importi) == 0: return 0
                abs_importi_sorted = sorted([i for i in abs_importi if i > 0], reverse=True)
                if len(abs_importi_sorted) <= 1: return abs_importi_sorted[0]
                valore_base = abs_importi_sorted[1]
                max_val_cap = valore_base * 2
                if abs_importi_sorted[0] / max_val_cap > 2.5: return max_val_cap
                else: return abs_importi_sorted[0]
            max_e = calculate_capped_max(importi_entrate)
            max_u = calculate_capped_max(importi_uscite)
            max_val = max(max_e, max_u)
            altezza_utilizzabile = altezza - (margine_superiore + margine_inferiore)
            scala = altezza_utilizzabile / max(max_val * 1.05, 0.01)
            y_zero = y_base
            x_current = margine_inferiore
            dati_posizioni = []
            anno_per_titolo = ""
            try:
                if stats_mode == "anno" and hasattr(self, 'stats_anno') and self.stats_anno != "Tutti":
                    anno_per_titolo = self.stats_anno
            except NameError:
                pass
            for periodo, dati_valore in dati_tuple:
                is_misto = isinstance(dati_valore, dict) and 'Entrata' in dati_valore and 'Uscita' in dati_valore and 'Totale' not in dati_valore
                barra_width = LARGHEZZ_MISTA if is_misto else LARGHEZZ_STANDARD
                larghezza_gruppo = barra_width if stats_mode != "giorno" else LARGHEZZ_STANDARD 
                dati_posizioni.append({
                    'periodo': periodo,
                    'dati_valore': dati_valore,
                    'x_start': x_current,
                    'barra_width': barra_width
                })
                x_current += larghezza_gruppo
            if dati_tuple:
                larghezza_contenuto_barre = x_current + margine_inferiore
            else:
                larghezza_contenuto_barre = canvas_larghezza
            larghezza_contenuto = max(larghezza_contenuto_barre, canvas_larghezza + SPAZIO_EXTRA_MINIMO) if stats_mode != "giorno" else canvas_larghezza
            c.config(scrollregion=(0, 0, larghezza_contenuto, altezza))
            c.create_line(margine_inferiore/2, y_zero, larghezza_contenuto, y_zero, fill="gray", dash=(4, 2))
            c.bind("<Leave>", hide_tooltip_local)
            def formatta_dettaglio(dettagli_dict):
                if not dettagli_dict:
                    return "  Nessun dettaglio categoria."
                dettaglio_lines = []
                dati_ordinati = sorted(dettagli_dict.items(), key=lambda item: item[0], reverse=False)
                for cat, importo in dati_ordinati:
                    if importo > 0:
                        importo_f = f"{importo:,.2f}"
                        dettaglio_lines.append(f"  {cat}: {importo_f} ‚Ç¨")
                return "\n".join(dettaglio_lines)
            for item in dati_posizioni:
                periodo_originale = item['periodo']
                dati_valore = item['dati_valore']
                LARGHEZZA_BARRA_DINAMICA = item['barra_width']
                x_start_base = item['x_start']
                x_start = x_start_base
                if stats_mode == "giorno":
                    x_center = canvas_larghezza / 2
                    bar_group_width = LARGHEZZA_BARRA_DINAMICA * BAR_FACTOR
                    x_start = x_center - (bar_group_width / 2)
                is_misto = isinstance(dati_valore, dict) and 'Entrata' in dati_valore and 'Uscita' in dati_valore and 'Totale' not in dati_valore
                titolo_per_popup = periodo_originale
                if stats_mode == "anno" and anno_per_titolo:
                    titolo_per_popup = f"{periodo_originale} {anno_per_titolo}"
                if is_misto:
                    valore_e = dati_valore.get('Entrata', 0)
                    valore_u = dati_valore.get('Uscita', 0)
                    dettaglio_e = dati_valore.get('Dettaglio_Entrata', {})
                    dettaglio_u = dati_valore.get('Dettaglio_Uscita', {})
                    barra_singola_w = (LARGHEZZA_BARRA_DINAMICA * BAR_FACTOR) / 2
                    if valore_e > 0:
                        valore_e_scalato = min(valore_e, max_val)
                        altezza_barra_e = valore_e_scalato * scala
                        x0_e, x1_e = x_start, x_start + barra_singola_w
                        rect_e = c.create_rectangle(x0_e, y_zero - altezza_barra_e, x1_e, y_zero, fill="#28A745")
                        testo_etichetta = f"{valore_e:,.2f}".replace(",", "_TEMP_").replace(".", ",").replace("_TEMP_", ".")
                        c.create_text(
                            (x0_e + x1_e) / 2, y_zero - altezza_barra_e - 6,
                            text=testo_etichetta, font=("Arial", 9), fill="#28A745"
                        )
                        dettaglio_cat_e = formatta_dettaglio(dettaglio_e)
                        tooltip_text_e = (
                            f"Totale Entrata: {valore_e:,.2f} ‚Ç¨\n"
                            f"\n"
                            f"{dettaglio_cat_e}"
                        ).replace(",", "_TEMP_").replace(".", ",").replace("_TEMP_", ".")
                        c.tag_bind(rect_e, "<Enter>", lambda e, t=tooltip_text_e: show_tooltip_local(e, t))
                        c.tag_bind(rect_e, "<Leave>", hide_tooltip_local)
                        
                        tipo_bind_e = 'Entrata'
                        titolo_e_popup = f"Entrate aggregate {titolo_per_popup}"
                        c.tag_bind(rect_e, "<Double-1>", 
                            lambda e, p=periodo_originale, t=tipo_bind_e, tit=titolo_e_popup: 
                                self.mostra_transazioni_popup(
                                    self.get_filter_data(p, t, categorie_da_elaborare, stats_mode),
                                    tit
                                )
                        )
                    if valore_u > 0:
                        valore_u_scalato = min(valore_u, max_val)
                        altezza_barra_u = valore_u_scalato * scala
                        x0_u, x1_u = x_start + barra_singola_w, x_start + barra_singola_w * 2
                        rect_u = c.create_rectangle(x0_u, y_zero - altezza_barra_u, x1_u, y_zero, fill="#DC3545")
                        testo_etichetta = f"{valore_u:,.2f}".replace(",", "_TEMP_").replace(".", ",").replace("_TEMP_", ".")
                        c.create_text(
                            (x0_u + x1_u) / 2, y_zero - altezza_barra_u - 6,
                            text=testo_etichetta, font=("Arial", 9), fill="#DC3545"
                        )
                        dettaglio_cat_u = formatta_dettaglio(dettaglio_u)
                        tooltip_text_u = (
                            f"Totale Uscita: {valore_u:,.2f} ‚Ç¨\n"
                            f"\n"
                            f"{dettaglio_cat_u}"
                        ).replace(",", "_TEMP_").replace(".", ",").replace("_TEMP_", ".")
                        c.tag_bind(rect_u, "<Enter>", lambda e, t=tooltip_text_u: show_tooltip_local(e, t))
                        c.tag_bind(rect_u, "<Leave>", hide_tooltip_local)

                        tipo_bind_u = 'Uscita'
                        titolo_u_popup = f"Uscite aggregate {titolo_per_popup}"
                        c.tag_bind(rect_u, "<Double-1>", 
                            lambda e, p=periodo_originale, t=tipo_bind_u, tit=titolo_u_popup: 
                                self.mostra_transazioni_popup(
                                    self.get_filter_data(p, t, categorie_da_elaborare, stats_mode),
                                    tit
                                )
                        )
                        
                    x_center_text = x_start + (LARGHEZZA_BARRA_DINAMICA * BAR_FACTOR) / 2
                else: 
                    if isinstance(dati_valore, dict):
                        valore = dati_valore.get('Totale', 0)
                        dettaglio = dati_valore.get('Dettaglio', {})
                    else:
                        valore = dati_valore
                        dettaglio = {}
                    colore_barra = "#28A745" if tipo_transazione_ricercato == "entrata" else "#DC3545"
                    valore_scalato = min(abs(valore), max_val)
                    altezza_barra_pix = valore_scalato * scala
                    x0 = x_start
                    x1 = x0 + LARGHEZZA_BARRA_DINAMICA * BAR_FACTOR
                    rect = c.create_rectangle(x0, y_zero - altezza_barra_pix, x1, y_zero, fill=colore_barra)
                    importo_formattato = f"{valore:,.2f} ‚Ç¨".replace(",", "_TEMP_").replace(".", ",").replace("_TEMP_", ".")
                    c.create_text((x0 + x1) / 2, y_zero - altezza_barra_pix - 6, text=importo_formattato, font=("Arial", 9), fill=colore_barra)
                    x_center_text = (x0 + x1) / 2
                    tipo_testo = "Entrata" if tipo_transazione_ricercato == "entrata" else "Uscita"
                    dettaglio_cat = formatta_dettaglio(dettaglio)
                    tooltip_text = (
                        f"Totale {tipo_testo}: {valore:,.2f} ‚Ç¨\n"
                        f"\n"
                        f"{dettaglio_cat}"
                    ).replace(",", "_TEMP_").replace(".", ",").replace("_TEMP_", ".")
                    c.tag_bind(rect, "<Enter>", lambda e, t=tooltip_text: show_tooltip_local(e, t))
                    c.tag_bind(rect, "<Leave>", hide_tooltip_local)
                    
                    tipo_bind = tipo_transazione_ricercato.capitalize()
                    titolo_s_popup = f"{tipo_bind} aggregate {titolo_per_popup}"
                    c.tag_bind(rect, "<Double-1>", 
                        lambda e, p=periodo_originale, t=tipo_bind, tit=titolo_s_popup: 
                            self.mostra_transazioni_popup(
                                self.get_filter_data(p, t, categorie_da_elaborare, stats_mode),
                                tit
                            )
                    )
                label_y = altezza - margine_inferiore + 40
                if stats_mode == "giorno": label_y = altezza - 20
                c.create_text(
                    x_center_text,
                    label_y,
                    text=periodo_originale,
                    font=("Arial", 8),
                    angle=45 if stats_mode != "giorno" else 0
                )
        self.get_filter_data = lambda periodo, tipo, categories, mode: self._build_filter_data(periodo, tipo, categories, mode)
        if stats_mode == "giorno":
             scrollbar_h.pack_forget()
        else:
             scrollbar_h.pack(side="bottom", fill="x")
        self.popup_grafico.update_idletasks()
        disegna_barre_scroll(canvas, dati_per_grafico)
        self.popup_grafico.after(100, lambda: disegna_barre_scroll(canvas, dati_per_grafico)) 
        self.popup_grafico.transient(self)
        if stats_mode != "giorno":
            self.popup_grafico.after(200, lambda: canvas.xview_moveto(0)) 
        def chiudi_popup():
            self.popup_grafico.destroy()
        totale_formattato = f"{totale_aggregato:,.2f} ‚Ç¨".replace(",", "_TEMP_").replace(".", ",").replace("_TEMP_", ".")
        colore_totale = "black"
        if tipo_transazione_ricercato == "misto":
              if totale_aggregato > 0:
                  colore_totale = "#28A745"
              elif totale_aggregato < 0:
                  colore_totale = "#DC3545"
              else:
                  colore_totale = "gray"
        elif tipo_transazione_ricercato == "entrata":
            colore_totale = "#28A745"
        elif tipo_transazione_ricercato == "uscita":
            colore_totale = "#DC3545"
        totale_frame = tk.Frame(main_frame, bg=self.COLOR_TOPLEVEL)
        totale_frame.pack(fill='x', pady=(10, 5), padx=20) 
        tk.Label(
            totale_frame,
            bg=self.COLOR_TOPLEVEL,
            fg=self.TEXT_COLOR,
            text=f"{totale_copertura_desc}:",
            font=("Arial", 10),
            anchor="w"
        ).pack(side="left")
        tk.Label(
            totale_frame,
            bg=self.COLOR_TOPLEVEL,
            text=totale_formattato,
            font=("Arial", 10, "bold"),
            anchor="w", 
            padx=5,
            fg=colore_totale 
        ).pack(side="left") 
        ttk.Button(
            main_frame, 
            text="‚úñ Chiudi", 
            command=chiudi_popup,
            style="Giallo.TButton"
        ).pack(pady=10)
        self.popup_grafico.bind("<Escape>", lambda event: chiudi_popup())

    def _build_filter_data(self, periodo, tipo, categories_to_elaborate, stats_mode):
        mesi_abbr = {
            "Gen": 1, "Feb": 2, "Mar": 3, "Apr": 4, 
            "Mag": 5, "Giu": 6, "Lug": 7, "Ago": 8, 
            "Set": 9, "Ott": 10, "Nov": 11, "Dic": 12
        }
        anno_bind = None
        mese_bind = None
        giorno_bind = None
        try:
            if stats_mode == "anno" and periodo in mesi_abbr:
                mese_bind = mesi_abbr[periodo] 
                if hasattr(self, 'stats_anno') and self.stats_anno != "Tutti":
                    anno_bind = self.stats_anno
                giorno_bind = None
            elif ' ' in periodo and len(periodo.split(' ')) == 3:
                g, m, a = periodo.split(' ')
                anno_bind = a
                mese_bind = int(m)
                giorno_bind = int(g)
            elif '-' in periodo and len(periodo.split('-')) == 2:
                a, m = periodo.split('-')
                anno_bind = a
                mese_bind = int(m)
                giorno_bind = None
            elif len(periodo) == 4 and periodo.isdigit():
                anno_bind = periodo
                mese_bind = None
                giorno_bind = None
        except Exception:
            pass
        return {
            "anno": anno_bind, 
            "mese": mese_bind, 
            "giorno": giorno_bind,
            "tipo": tipo,
            "categorie": categories_to_elaborate
        }

    # Sistema di Analisi Statistica e Grafici Interattivi (Finanziari)
    def mostra_analisi_grafici(self):
        def bind_popup(canvas, item, filter_data, title):
            canvas.tag_bind(item, "<Double-1>", 
                            lambda e: self.mostra_transazioni_popup(filter_data, title))
        def disegna_barre(canvas, dati, colori, mostra_anno=False, mostra_tipo=False, centro=False):
            canvas.delete("all")
            canvas.update_idletasks()
            larghezza = canvas.winfo_width()
            altezza = canvas.winfo_height()
            margine = 50
            if isinstance(dati, dict):
                elementi = list(dati.items())
            else:
                elementi = dati
            max_val = max(abs(val) for _, val in elementi) if elementi else 1
            scala = (altezza - margine * 2) / (max_val * 1.5)
            larghezza_barra = (larghezza - margine * 2) // max(len(elementi), 1)
            y_base = altezza // 2 if centro else altezza - margine
            anno_selezionato = canvas.selettore_rif.get()
            mesi_abbr = ["Gen", "Feb", "Mar", "Apr", "Mag", "Giu", "Lug", "Ago", "Set", "Ott", "Nov", "Dic"]
            nomi_completi_mesi = ["Gennaio", "Febbraio", "Marzo", "Aprile", "Maggio", "Giugno", 
                                  "Luglio", "Agosto", "Settembre", "Ottobre", "Novembre", "Dicembre"]
            for i, (etichetta, valore) in enumerate(elementi):
                x0 = margine + i * larghezza_barra
                x1 = x0 + larghezza_barra * 0.6
                colore = colori.get(etichetta, "gray")
                parts = etichetta.split(" ")
                tipo = parts[-1] if mostra_tipo else None
                if anno_selezionato == "Tutti":
                    anno_filter = parts[0]
                    mese_filter = None
                    periodo_title = f"l'anno {anno_filter}"
                else:
                    anno_filter = anno_selezionato
                    nome_mese_abbr = parts[0]
                    try:
                        mese_index = mesi_abbr.index(nome_mese_abbr)
                        mese_filter = mese_index + 1
                        nome_mese_completo = nomi_completi_mesi[mese_index]
                    except ValueError:
                        mese_filter = None
                        nome_mese_completo = nome_mese_abbr
                    periodo_title = f"{nome_mese_completo} {anno_filter}"
                filter_data = {"anno": anno_filter, "mese": mese_filter, "tipo": tipo}
                title_text = f"Transazioni {tipo} per {periodo_title}"
                if valore >= 0:
                    y1 = y_base - valore * scala
                    rect = canvas.create_rectangle(x0, y_base, x1, y1, fill=colore)
                    canvas.create_text((x0 + x1) / 2, y1 - 10, text=f"{int(valore)}", font=("Arial", 8))
                else:
                    y1 = y_base + abs(valore) * scala
                    rect = canvas.create_rectangle(x0, y_base, x1, y1, fill=colore)
                    canvas.create_text((x0 + x1) / 2, y1 + 10, text=f"{int(valore)}", font=("Arial", 8))
                bind_popup(canvas, rect, filter_data, title_text)
                if mostra_tipo and " " in etichetta:
                    tipo_label = etichetta.split(" ")[1]
                    canvas.create_text((x0 + x1) / 2, y_base + 15, text=tipo_label, font=("Arial", 8))
                if not mostra_anno and " " in etichetta:
                    mese_label = etichetta.split(" ")[0]
                    canvas.create_text((x0 + x1) / 2, y_base + 30, text=mese_label, font=("Arial", 8))
                elif mostra_anno:
                    anno_label = etichetta.split(" ")[0] if " " in etichetta else etichetta
                    canvas.create_text((x0 + x1) / 2, y_base + 30, text=anno_label, font=("Arial", 8))
        def disegna_barre_categorie(canvas, dati, colori):
            if hasattr(canvas, "tooltip") and canvas.tooltip:
                canvas.tooltip.destroy()
                canvas.tooltip = None
            canvas.delete("all")
            canvas.update_idletasks()
            LARGHEZZA_BARRA_FISSA = 80
            margine_laterale = 50
            margine_inferiore = 130  
            margine_superiore = 60
            larghezza_visualizzata = canvas.winfo_width()
            altezza = canvas.winfo_height()
            if larghezza_visualizzata < 10:
                canvas.after(100, lambda: disegna_barre_categorie(canvas, dati, colori))
                return
            y_base = altezza - margine_inferiore
            totale = sum(val for _, val in dati) if dati else 1
            max_val = max(val for _, val in dati) if dati else 1
            spazio_utile = altezza - margine_inferiore - margine_superiore
            scala = spazio_utile / (max_val * 1.2)
            numero_barre = max(len(dati), 1)
            larghezza_contenuto = margine_laterale * 2 + numero_barre * LARGHEZZA_BARRA_FISSA
            x_offset = max(0, (larghezza_visualizzata - larghezza_contenuto) // 2)
            anno_selezionato = canvas.anno_corrente
            for i, (categoria, valore) in enumerate(dati):
                x0 = x_offset + margine_laterale + i * LARGHEZZA_BARRA_FISSA
                x1 = x0 + LARGHEZZA_BARRA_FISSA * 0.6
                altezza_pixel = valore * scala
                if valore > 0 and altezza_pixel < 4:
                    altezza_pixel = 4
                y1 = y_base - altezza_pixel
                colore = colori.get(categoria, "#888888")
                rect = canvas.create_rectangle(x0, y_base, x1, y1, fill=colore)
                filter_data = {"anno": anno_selezionato, "categoria": categoria, "tipo": "Uscita"}
                title_text = f"Movimenti Categoria '{categoria}' ({anno_selezionato})"
                bind_popup(canvas, rect, filter_data, title_text)
                percentuale = (valore / totale) * 100
                canvas.create_text((x0 + x1) / 2, y1 - 12, text=f"{valore:,.2f}", font=("Arial", 9))
                canvas.create_text((x0 + x1) / 2, y1 - 26, text=f"{percentuale:.1f}%", font=("Arial", 8), fill="gray")
                canvas.create_text(
                    (x0 + x1) / 2, 
                    y_base + 10, 
                    text=categoria, 
                    font=("Arial", 9),
                    angle=45,
                    anchor="ne",
                    fill=colore
                )
                def show_tooltip(event, text=categoria):
                    if hasattr(canvas, "tooltip") and canvas.tooltip:
                        canvas.tooltip.destroy()
                        canvas.tooltip = None
                    canvas.tooltip = tk.Toplevel(canvas)
                    canvas.tooltip.wm_overrideredirect(True)
                    try:
                        canvas.tooltip.wm_geometry(f"+{event.x_root + 10}+{event.y_root + 10}")
                    except: pass
                    label = ttk.Label(canvas.tooltip, text=text, style="Tooltip.TLabel")
                    label.pack(ipadx=4)
                def hide_tooltip(event):
                    if hasattr(canvas, "tooltip") and canvas.tooltip:
                        canvas.tooltip.destroy()
                        canvas.tooltip = None
                canvas.tag_bind(rect, "<Enter>", show_tooltip)
                canvas.tag_bind(rect, "<Leave>", hide_tooltip)
            lbl_totale = tk.Label(canvas, text=f"Totale uscite: ‚Ç¨ {totale:,.2f}", font=("Arial", 10, "bold"), bg="white", padx=5)
            win_totale = canvas.create_window(10, altezza - 25, window=lbl_totale, anchor="w", tags="fissato")
            def fissa_elementi(event=None):
                x_visibile = canvas.canvasx(10)
                canvas.coords("fissato", x_visibile, altezza - 25)
                canvas.tag_raise("fissato")
            canvas.bind("<Configure>", fissa_elementi)
            scrollbar_h.config(command=lambda *args: [canvas.xview(*args), fissa_elementi()])
            canvas.config(scrollregion=(0, 0, larghezza_contenuto, altezza))
            fissa_elementi()
            
        def aggiorna_legenda_treeview(tree, dati, colori):
                for item in tree.get_children():
                        tree.delete(item)
                dati_ordinati = sorted(dati, key=lambda x: x[1], reverse=True)
                for cat, val in dati_ordinati:
                        colore = colori.get(cat, "#888888")
                        r = int(colore[1:3], 16)
                        g = int(colore[3:5], 16)
                        b = int(colore[5:7], 16)
                        luminosita = (0.2126 * r + 0.7152 * g + 0.0722 * b)
                        colore_testo = "black" if luminosita > 150 else "white"
                        tag_name = cat.replace(" ", "_").replace("(", "").replace(")", "")
                        tree.insert("", "end", values=(cat, f"‚Ç¨ {val:,.2f}"), tags=(tag_name,))
                        try:
                                tree.tag_configure(tag_name, background=colore, foreground=colore_testo)
                        except TclError:
                                pass
        def disegna_barre_saldo(canvas, dati):
            nomi_completi_mesi = ["Gennaio", "Febbraio", "Marzo", "Aprile", "Maggio", "Giugno", 
                                  "Luglio", "Agosto", "Settembre", "Ottobre", "Novembre", "Dicembre"]
            canvas.delete("all")
            canvas.update_idletasks()
            larghezza = canvas.winfo_width()
            altezza = canvas.winfo_height()
            margine = 50
            mesi_ordinati_abbr = ["Gen", "Feb", "Mar", "Apr", "Mag", "Giu", "Lug", "Ago", "Set", "Ott", "Nov", "Dic"]
            chiavi = mesi_ordinati_abbr if set(mesi_ordinati_abbr).issubset(dati.keys()) else list(dati.keys())
            max_val = max(abs(dati[k]) for k in chiavi) if dati else 1
            scala = (altezza - margine * 2) / (max_val * 1.5)
            larghezza_barra = (larghezza - margine * 2) // max(len(chiavi), 1)
            y_base = altezza - margine
            anno_selezionato_selettore = canvas.selettore_rif.get()
            for i, etichetta in enumerate(chiavi):
                    valore = dati.get(etichetta, 0)
                    x0 = margine + i * larghezza_barra
                    x1 = x0 + larghezza_barra * 0.6
                    if abs(valore) < 0.01:
                            y1 = y_base
                    else:
                            y1 = y_base - abs(valore) * scala
                    colore = "green" if valore >= 0 else "red"
                    segno = "+" if valore >= 0 else "‚àí"
                    rect = canvas.create_rectangle(x0, y_base, x1, y1, fill=colore)
                    mese_num = None
                    anno_filtro = anno_selezionato_selettore
                    title_text_base = "Tutte le transazioni"
                    nome_mese_per_titolo = etichetta
                    if anno_selezionato_selettore == "Tutti":
                            anno_filtro = etichetta
                            title_text = f"{title_text_base} per l'anno {anno_filtro}"
                    else:
                            if etichetta in mesi_ordinati_abbr:
                                    try:
                                        mese_index = mesi_ordinati_abbr.index(etichetta)
                                        mese_num = mese_index + 1
                                        nome_mese_per_titolo = nomi_completi_mesi[mese_index]
                                    except ValueError:
                                        pass
                            title_text = f"{title_text_base} per {nome_mese_per_titolo} {anno_filtro}" 
                    filter_data = {"anno": anno_filtro, "mese": mese_num}
                    bind_popup(canvas, rect, filter_data, title_text)
                    testo_y = y1 - 10
                    valore_formattato = f"{abs(valore):,.2f}"
                    canvas.create_text(
                            (x0 + x1) / 2,
                            testo_y,
                            text=f"{segno}{valore_formattato}",
                            font=("Arial", 9)
                    )
                    canvas.create_text((x0 + x1) / 2, y_base + 20, text=etichetta, font=("Arial", 9))

        def on_legenda_double_click(event):
            item_id = self.tree_legenda.selection()
            if not item_id:
                return
            valori = self.tree_legenda.item(item_id[0], "values")
            categoria = valori[0]
            anno = selettore_anno2.get()
            filter_data = {"anno": anno, "categoria": categoria, "tipo": "Uscita"}
            title_text = f"Movimenti Categoria '{categoria}' ({anno})"
            self.mostra_transazioni_popup(filter_data, title_text)
                    
        def aggiorna_tab3(event=None):
            selezione = selettore_anno3.get()
            entrate = defaultdict(float)
            uscite = defaultdict(float)
            for data, voci in self.spese.items():
                anno = data.year
                mese = data.month
                if selezione != "Tutti" and str(anno) != selezione:
                    continue
                for voce in voci:
                    tipo = voce[3].strip().lower()
                    importo = voce[2]
                    chiave = str(anno) if selezione == "Tutti" else mese
                    if tipo == "entrata":
                        entrate[chiave] += importo
                    elif tipo == "uscita":
                        uscite[chiave] += importo
            total_entrate = sum(entrate.values())
            total_uscite = sum(uscite.values())
            saldo_totale = total_entrate - total_uscite
            self.lbl_entrate_tab3.config(text=f"Entrate: ‚Ç¨ {total_entrate:,.2f}")
            self.lbl_uscite_tab3.config(text=f"Uscite: ‚Ç¨ {total_uscite:,.2f}")
            if saldo_totale >= 0:
                self.lbl_saldo_tab3.config(text=f"Saldo: ‚Ç¨ {saldo_totale:,.2f}", style="GSaldoPositivo.TLabel")
            else:
                self.lbl_saldo_tab3.config(text=f"Saldo: ‚Ç¨ {saldo_totale:,.2f}", style="GSaldoNegativo.TLabel")
            saldo_per_grafico = defaultdict(float)
            for chiave, importo in entrate.items():
                saldo_per_grafico[chiave] += importo
            for chiave, importo in uscite.items():
                saldo_per_grafico[chiave] -= importo
            if selezione == "Tutti":
                grafico = {str(a): saldo_per_grafico.get(a, 0) for a in sorted(saldo_per_grafico)}
            else:
                mesi = ["Gen", "Feb", "Mar", "Apr", "Mag", "Giu", "Lug", "Ago", "Set", "Ott", "Nov", "Dic"]
                grafico = {mesi[m - 1]: saldo_per_grafico.get(m, 0) for m in range(1, 13)}
            canvas3.dati_cache = grafico
            ridisegna_tab3()
        def ridisegna_tab3(event=None):
            if hasattr(canvas3, "dati_cache"):
                disegna_barre_saldo(canvas3, canvas3.dati_cache)
        def aggiorna_tab2(event=None):
            anno = selettore_anno2.get()
            canvas2.anno_corrente = anno
            categories = defaultdict(float)
            for data, voci in self.spese.items():
                if anno == "Tutti" or str(data.year) == anno:
                    for voce in voci:
                        if voce[3].strip().lower() == "uscita":
                            categories[voce[0]] += float(voce[2])
            tutte_categorie = sorted(categories.items(), key=lambda x: x[1], reverse=True)
            colore = {}
            for cat, _ in tutte_categorie:
                colore[cat] = f'#{random.randint(50,200):02x}{random.randint(50,200):02x}{random.randint(50,200):02x}'
            canvas2.tutte_categorie = tutte_categorie
            canvas2.colori = colore
            canvas2.dati_cache = tutte_categorie
            canvas2.colori_cache = colore
            ridisegna_tab2()
            aggiorna_legenda_treeview(self.tree_legenda, tutte_categorie, colore)
        def ridisegna_tab2(event=None):
            if hasattr(canvas2, "dati_cache"):
                canvas2.delete("all")
                canvas2.update_idletasks()
                disegna_barre_categorie(canvas2, canvas2.dati_cache, canvas2.colori_cache)
        def aggiorna_tab1(event=None):
            anno_selezionato = selettore_anno1.get()
            entrate = defaultdict(float)
            uscite = defaultdict(float)
            for data, voci in self.spese.items():
                anno = data.year
                mese = data.month
                if anno_selezionato != "Tutti" and str(anno) != anno_selezionato:
                    continue
                for voce in voci:
                    tipo = voce[3].strip().lower()
                    importo = voce[2]
                    chiave = str(anno) if anno_selezionato == "Tutti" else mese
                    if tipo == "entrata":
                        entrate[chiave] += importo
                    elif tipo == "uscita":
                        uscite[chiave] += importo
            total_entrate = sum(entrate.values())
            total_uscite = sum(uscite.values())
            saldo = total_entrate - total_uscite
            lbl_entrate.config(text=f"Entrate: ‚Ç¨ {total_entrate:,.2f}")
            lbl_uscite.config(text=f"Uscite: ‚Ç¨ {total_uscite:,.2f}")
            if saldo >= 0:
                lbl_saldo_tab1.config(text=f"Saldo: ‚Ç¨ {saldo:,.2f}", style="GSaldoPositivo.TLabel")
            else:
                lbl_saldo_tab1.config(text=f"Saldo: ‚Ç¨ {saldo:,.2f}", style="GSaldoNegativo.TLabel")
            grafico = {}
            colore = {}
            if anno_selezionato == "Tutti":
                for anno in sorted(set(entrate.keys()) | set(uscite.keys())):
                    grafico[f"{anno} Entrata"] = entrate[anno]
                    grafico[f"{anno} Uscita"] = uscite[anno]
                    colore[f"{anno} Entrata"] = "green"
                    colore[f"{anno} Uscita"] = "red"
            else:
                mesi = ["Gen", "Feb", "Mar", "Apr", "Mag", "Giu", "Lug", "Ago", "Set", "Ott", "Nov", "Dic"]
                for m in range(1, 13):
                    nome_mese = mesi[m - 1]
                    grafico[f"{nome_mese} Entrata"] = entrate.get(m, 0)
                    grafico[f"{nome_mese} Uscita"] = uscite.get(m, 0)
                    colore[f"{nome_mese} Entrata"] = "green"
                    colore[f"{nome_mese} Uscita"] = "red"
            canvas1.dati_cache = grafico
            canvas1.colori_cache = colore
            canvas1.mostra_anno_cache = (anno_selezionato == "Tutti")
            ridisegna_tab1()
        def ridisegna_tab1(event=None):
            if hasattr(canvas1, "dati_cache"):
                disegna_barre(canvas1, canvas1.dati_cache, canvas1.colori_cache, 
                              mostra_anno=canvas1.mostra_anno_cache, mostra_tipo=True, centro=False)
        larghezza_finestra = 1230
        altezza_finestra = 600
        larghezza_schermo = self.winfo_screenwidth()
        altezza_schermo = self.winfo_screenheight()
        x = (larghezza_schermo // 2) - (larghezza_finestra // 2)
        y = (altezza_schermo // 2) - (altezza_finestra // 2)
        self.grafico_analisi_popup = tk.Toplevel(self)
        self.grafico_analisi_popup.configure(bg=self.COLOR_TOPLEVEL)
        self.grafico_analisi_popup.title("Grafico Analisi Movimenti")
        self.grafico_analisi_popup.geometry(f"{larghezza_finestra}x{altezza_finestra}+{x}+{y}")
        self.grafico_analisi_popup.bind("<Escape>", lambda e: self.grafico_analisi_popup.destroy())
        notebook = ttk.Notebook(self.grafico_analisi_popup)
        notebook.pack(fill="both", expand=True, padx=10, pady=(10, 5))
        anni = sorted({d.year for d in self.spese.keys()}, reverse=True)
        anno_corrente = str(datetime.date.today().year)
        tab1 = ttk.Frame(notebook)
        notebook.add(tab1, text="Entrate/Uscite")
        frame_totali = ttk.Frame(tab1)
        frame_totali.pack(side="bottom", pady=10)
        lbl_entrate = ttk.Label(frame_totali, text="Entrate: ‚Ç¨ 0.00", style="GSaldoPositivo.TLabel")
        lbl_entrate.pack(side="left", padx=10)
        lbl_uscite = ttk.Label(frame_totali, text="Uscite: ‚Ç¨ 0.00", style="GSaldoNegativo.TLabel")
        lbl_uscite.pack(side="left", padx=10)
        lbl_saldo_tab1 = ttk.Label(frame_totali, text="Saldo: ‚Ç¨ 0.00", style="GSaldo.TLabel")
        lbl_saldo_tab1.pack(side="left", padx=10)
        ttk.Label(tab1, text="‚ñ† Seleziona periodo *Dettaglio (Clicca üñ±Ô∏è)*", style="Verde.TLabel", font=("Arial", 10)).pack(side="top", padx=10)
        selettore_anno1 = ttk.Combobox(tab1, values=["Tutti"] + [str(a) for a in anni], style="Border.TCombobox", state='readonly')
        selettore_anno1.set("Tutti")
        selettore_anno1.pack(pady=10)
        selettore_anno1.bind("<<ComboboxSelected>>", aggiorna_tab1)
        canvas1 = tk.Canvas(tab1, bg="white")
        canvas1.pack(fill="both", expand=True, padx=10, pady=10)
        canvas1.selettore_rif = selettore_anno1
        canvas1.bind("<Configure>", ridisegna_tab1)
        tab2 = ttk.Frame(notebook)
        tab2.grid_columnconfigure(0, weight=3)
        tab2.grid_columnconfigure(1, weight=1)
        tab2.grid_rowconfigure(1, weight=1)
        notebook.add(tab2, text="Categorie")
        ttk.Label(tab2, text="‚ñ† Seleziona periodo *Dettaglio (Clicca üñ±Ô∏è)*", style="Verde.TLabel", font=("Arial", 10)).grid(row=0, column=0, sticky="w", padx=10, pady=5)
        selettore_anno2 = ttk.Combobox(tab2, values=["Tutti"] + [str(a) for a in anni], style="Border.TCombobox", state='readonly')
        selettore_anno2.set(anno_corrente if anno_corrente in [str(a) for a in anni] else "Tutti")
        selettore_anno2.grid(row=0, column=0, sticky="n", pady=10)
        selettore_anno2.bind("<<ComboboxSelected>>", aggiorna_tab2)
        canvas_frame_scroll = ttk.Frame(tab2)
        canvas_frame_scroll.grid(row=1, column=0, sticky="nsew", padx=5, pady=(0, 10))
        scrollbar_h = ttk.Scrollbar(canvas_frame_scroll, orient="horizontal", style="Horizontal.TScrollbar")
        scrollbar_h.pack(side="bottom", fill="x")
        canvas2 = tk.Canvas(canvas_frame_scroll, bg="white", xscrollcommand=scrollbar_h.set)
        canvas2.pack(side="top", fill="both", expand=True)
        scrollbar_h.config(command=canvas2.xview)
        canvas2.tooltip = None
        canvas2.anno_corrente = selettore_anno2.get()
        canvas2.bind("<Configure>", ridisegna_tab2)
        frame_legenda = ttk.Frame(tab2)
        frame_legenda.grid(row=1, column=1, sticky="nsew", padx=5, pady=(0, 10))
        lbl_leg = tk.Label(frame_legenda, text="Legenda Categorie", bg=self.COLOR_TOPLEVEL, fg=self.TEXT_COLOR, font=("Arial", 10, "bold"))
        lbl_leg.pack(pady=5)
        columns = ("Categoria", "Importo")
        self.tree_legenda = ttk.Treeview(frame_legenda, columns=columns, show="headings", selectmode="browse")
        self.tree_legenda.heading("Categoria", text="Categoria", 
            command=lambda: self.treeview_sort_column(self.tree_legenda, "Categoria", False))
        self.tree_legenda.heading("Importo", text="Importo", 
            command=lambda: self.treeview_sort_column(self.tree_legenda, "Importo", False))
        self.tree_legenda.column("Categoria", width=120, anchor="w")
        self.tree_legenda.column("Importo", width=80, anchor="e")
        sb_legenda = ttk.Scrollbar(frame_legenda, orient="vertical", command=self.tree_legenda.yview, style="Vertical.TScrollbar")
        self.tree_legenda.configure(yscrollcommand=sb_legenda.set)
        sb_legenda.pack(side="right", fill="y")
        self.tree_legenda.pack(side="left", fill="both", expand=True)
        self.tree_legenda.bind("<Double-1>", on_legenda_double_click)
        tab3 = ttk.Frame(notebook)
        notebook.add(tab3, text="Saldo Mensile/Annuale")
        frame_totali_tab3 = ttk.Frame(tab3)
        frame_totali_tab3.pack(side="bottom", pady=10)
        self.lbl_entrate_tab3 = ttk.Label(frame_totali_tab3, text="Entrate: ‚Ç¨ 0.00", style="GSaldoPositivo.TLabel")
        self.lbl_entrate_tab3.pack(side="left", padx=10)
        self.lbl_uscite_tab3 = ttk.Label(frame_totali_tab3, text="Uscite: ‚Ç¨ 0.00", style="GSaldoNegativo.TLabel")
        self.lbl_uscite_tab3.pack(side="left", padx=10)
        self.lbl_saldo_tab3 = ttk.Label(frame_totali_tab3, text="Saldo: ‚Ç¨ 0.00", style="GSaldo.TLabel")
        self.lbl_saldo_tab3.pack(side="left", padx=10)
        ttk.Label(tab3, text="‚ñ† Seleziona periodo", style="Verde.TLabel", font=("Arial", 10)).pack(side="top", padx=10)
        selettore_anno3 = ttk.Combobox(tab3, values=["Tutti"] + [str(a) for a in anni], style="Border.TCombobox", state='readonly')
        selettore_anno3.set(anno_corrente if anno_corrente in [str(a) for a in anni] else "Tutti")
        selettore_anno3.pack(pady=10)
        selettore_anno3.bind("<<ComboboxSelected>>", aggiorna_tab3)
        canvas3 = tk.Canvas(tab3, bg="white")
        canvas3.pack(fill="both", expand=True, padx=10, pady=10)
        canvas3.selettore_rif = selettore_anno3
        canvas3.bind("<Configure>", ridisegna_tab3)
        frame_footer = ttk.Frame(self.grafico_analisi_popup)
        frame_footer.pack(side="bottom", fill="x", pady=(0, 15), padx=20)
        btn_chiudi = ttk.Button(
                frame_footer, 
                text="‚úñ Chiudi", 
                style="Giallo.TButton", 
                command=self.grafico_analisi_popup.destroy
        )
        btn_chiudi.pack(side="right")
        aggiorna_tab3()
        aggiorna_tab2()
        aggiorna_tab1()

    def mostra_transazioni_popup(self, data_filter, title):
        MESI_NOME_COMPLETO = {
            1: "Gennaio", 2: "Febbraio", 3: "Marzo", 4: "Aprile", 
            5: "Maggio", 6: "Giugno", 7: "Luglio", 8: "Agosto", 
            9: "Settembre", 10: "Ottobre", 11: "Novembre", 12: "Dicembre"
        }
        anno = data_filter.get("anno")
        mese_filtro_raw = data_filter.get("mese") 
        giorno = data_filter.get("giorno")
        tipo_filtro = data_filter.get("tipo")
        categorie_filtro_list = data_filter.get("categorie", []) 
        categoria_singola_raw = data_filter.get("categoria")
        if categoria_singola_raw and categoria_singola_raw != "Tutti":
            if categoria_singola_raw not in categorie_filtro_list:
                categorie_filtro_list.append(categoria_singola_raw)
        categorie_filtro_normalizzate_aggressive = [str(cat).replace(' ', '').lower() for cat in categorie_filtro_list]
        devo_filtrare_categorie = bool(categorie_filtro_normalizzate_aggressive)
        mese_filtro_num = None
        if mese_filtro_raw and mese_filtro_raw != "Tutti":
            try:
                mese_filtro_num = int(mese_filtro_raw)
            except (ValueError, TypeError):
                pass 
        new_title = title
        if mese_filtro_num is not None and anno and anno != "Tutti":
            nome_mese = MESI_NOME_COMPLETO.get(mese_filtro_num, f"{mese_filtro_num:02d}")
            mese_str = str(mese_filtro_num).zfill(2)
            identificatore1 = f"{anno}-{mese_str}"
            identificatore2 = mese_str
            if identificatore1 in title:
                new_title = title.replace(identificatore1, f"{nome_mese} {anno}")
            elif identificatore2 in title and nome_mese not in title:
                new_title = title.replace(identificatore2, nome_mese)
        title = new_title
        spese_filtrate = []
        for data, voci in self.spese.items():
            if anno and anno != "Tutti" and str(data.year) != anno: continue
            if mese_filtro_num is not None and data.month != mese_filtro_num: continue
            if giorno and giorno != "Tutti":
                try:
                    if data.day != int(giorno): continue
                except: continue
            for entry in voci:
                try:
                    cat_originale, desc, imp_str, entry_tipo = entry[:4]
                    cat_normalized_aggressive = str(cat_originale).replace(' ', '').lower()
                    cat_normalized_display = ' '.join(str(cat_originale).strip().split()).title() 
                    entry_imp = float(imp_str)
                    entry_tipo = entry_tipo.strip().capitalize()
                except (ValueError, TypeError, IndexError): 
                    continue 
                if devo_filtrare_categorie and cat_normalized_aggressive not in categorie_filtro_normalizzate_aggressive:
                    continue
                if tipo_filtro and entry_tipo != tipo_filtro.capitalize():
                    continue
                spese_filtrate.append((data, cat_normalized_display, desc, entry_imp, entry_tipo))
        if not spese_filtrate:
            self.show_custom_info("Nessuna transazione", f"Nessuna transazione trovata per {title}.")
            return
        popup_width, popup_height = 800, 450
        popup = tk.Toplevel(self, bg=self.COLOR_TOPLEVEL)
        popup.title(f"Dettaglio Transazioni - {title}")
        popup.resizable(True, True)
        popup.withdraw()
        self.update_idletasks()
        main_x = self.winfo_rootx()
        main_y = self.winfo_rooty()
        main_width = self.winfo_width()
        main_height = self.winfo_height()
        center_x = main_x + (main_width // 2) - (popup_width // 2)
        center_y = main_y + (main_height // 2) - (popup_height // 2)
        popup.geometry(f"{popup_width}x{popup_height}+{center_x}+{center_y}")
        popup.transient(self)
        popup.deiconify() 
        popup.lift()
        popup.focus_force()
        popup.bind("<Escape>", lambda event: popup.destroy()) 
        tk.Label(popup, bg=self.COLOR_TOPLEVEL , fg=self.TEXT_COLOR, text=title, font=("Arial", 12, "bold")).pack(pady=10)
        tree_frame = ttk.Frame(popup)
        tree_frame.pack(fill="both", expand=True, padx=10, pady=6)
        vsb = ttk.Scrollbar(tree_frame, orient="vertical", style="Vertical.TScrollbar")
        vsb.pack(side="right", fill="y")
        columns = ("Data", "Categoria", "Descrizione", "Importo", "Tipo")
        tree = ttk.Treeview(
            tree_frame, 
            columns=columns, 
            show="headings", 
            height=10,
            yscrollcommand=vsb.set
        )
        tree.pack(fill="both", expand=True, side="left") 
        vsb.config(command=tree.yview)
        widths = (90, 150, 250, 100, 100)
        anchors = ("center", "w", "w", "e", "center")
        def treeview_sort_column(tv, col, reverse):
            try:
                data = [(tv.set(k, col), k) for k in tv.get_children('')]
                if col == "Data":
                    data.sort(key=lambda t: datetime.datetime.strptime(t[0], "%d-%m-%Y"), reverse=reverse)
                elif col == "Importo":
                    data.sort(key=lambda t: float(t[0].replace(' ‚Ç¨', '').replace('.', '').replace(',', '.')), reverse=reverse)
                else:
                    data.sort(key=lambda t: t[0].lower(), reverse=reverse)
                
                for index, (_, k) in enumerate(data):
                    tv.move(k, '', index)
                
                tv.heading(col, command=lambda c=col: treeview_sort_column(tv, c, not reverse))
            except Exception as e:
                print(f"Errore ordinamento: {e}")
        for col, w, a in zip(columns, widths, anchors):
            initial_reverse = False 
            tree.heading(
                col,
                text=col,
                command=lambda c=col: treeview_sort_column(tree, c, initial_reverse)
            )
            tree.column(col, width=w, anchor=a)
        tot_entrate = tot_uscite = 0.0
        for d, cat, desc, imp, tipo in sorted(spese_filtrate, key=lambda x: x[0], reverse=True):
            imp_formattato = f"{imp:,.2f}".replace(',', 'X').replace('.', ',').replace('X', '.') 
            tag_name = "green_row" if tipo == "Entrata" else "red_row"
            tree.insert("", "end", values=(d.strftime("%d-%m-%Y"), cat, desc, f"{imp_formattato} ‚Ç¨", tipo), tags=(tag_name,))
            if tipo == "Entrata":
                tot_entrate += imp
            else:
                tot_uscite += imp
        tree.tag_configure("green_row", foreground="green")
        tree.tag_configure("red_row", foreground="red")
        saldo = tot_entrate - tot_uscite
        lbl = tk.Text(
            popup, 
            bg=self.COLOR_TOPLEVEL, 
            fg=self.TEXT_COLOR, 
            height=1, 
            borderwidth=0, 
            font=("Arial", 10, "bold"), 
            wrap="none", 
            background=popup.cget("background"),
            highlightthickness=0,
            relief="flat"
        )
        lbl.pack(pady=7)
        lbl.tag_config("entrate_color", foreground="green")
        lbl.tag_config("uscite_color", foreground="red")
        lbl.tag_config("saldo_pos_color", foreground="green")
        lbl.tag_config("saldo_neg_color", foreground="red")
        tot_entrate_str = f"{tot_entrate:,.2f}".replace(',', 'X').replace('.', ',').replace('X', '.')
        tot_uscite_str = f"{tot_uscite:,.2f}".replace(',', 'X').replace('.', ',').replace('X', '.')
        saldo_str = f"{saldo:,.2f}".replace(',', 'X').replace('.', ',').replace('X', '.')
        text_full = f"Totale Entrate: {tot_entrate_str} ‚Ç¨  Totale Uscite: {tot_uscite_str} ‚Ç¨  Saldo: {saldo_str} ‚Ç¨"
        lbl.config(state="normal")
        lbl.insert("end", text_full)
        entrate_start = text_full.find(tot_entrate_str)
        entrate_end = entrate_start + len(tot_entrate_str)
        lbl.tag_add("entrate_color", f"1.{entrate_start}", f"1.{entrate_end}")
        uscite_start = text_full.find(tot_uscite_str)
        uscite_end = uscite_start + len(tot_uscite_str)
        lbl.tag_add("uscite_color", f"1.{uscite_start}", f"1.{uscite_end}")
        saldo_start = text_full.find(saldo_str)
        saldo_end = saldo_start + len(saldo_str)
        if saldo >= 0:
            lbl.tag_add("saldo_pos_color", f"1.{saldo_start}", f"1.{saldo_end}")
        else:
            lbl.tag_add("saldo_neg_color", f"1.{saldo_start}", f"1.{saldo_end}")
        lbl.config(state="disabled")
        tree.bind("<Double-1>", lambda evt: self.goto_day_from_popup(tree, popup))
        ttk.Button(popup, text="‚ùå Chiudi", command=popup.destroy, style="Giallo.TButton").pack(pady=10)

    # Gestione e Visualizzazione Guida Utente (Help)
    def mostra_help(self):
        if hasattr(self, '_filter_help_popup') and self._filter_help_popup.winfo_exists():
            self._filter_help_popup.destroy()
        testo_stampa_completo = "Guida: Filtri, Tabelle e Grafici\n\n"
        help_content = [
            ("Totali ", "Aggrega e mostra il totale per categoria per TUTTO il periodo storico disponibile."),
            ("Anno ", "Aggrega i dati dell'ANNO selezionato, mostrando le singole categorie totalizzate."),
            ("Mese ", "Aggrega i dati del MESE selezionato, mostrando le singole categorie totalizzate."),
            ("Giorno (Punto Singolo)", "Mostra i Movimenti solo per il GIORNO selezionato."),
        ]
        testo_stampa_completo += "# Filtri Temporali: Controllano l'Aggregazione dei Dati nella Tabella Statistiche.\n"
        for title, description in help_content:
            testo_stampa_completo += f"‚Ä¢ Filtro {title}: {description}\n"
        testo_extra = (
            "\n# Interazioni con le Tabelle Dati (Treeview):\n"
            "‚Ä¢ Scroll e Navigazione: Utilizza la Rotella del Mouse per scorrere verticalmente.\n"
            "‚Ä¢ Ordinamento (Sort): Clicca sull'intestazione di colonna per ordinare i dati.\n"
            "‚Ä¢ Selezione Righe (CTRL/SHIFT): Selezione mista o continua.\n"
            "\n‚Ä¢ Dettaglio Transazioni:\n"
            "  1. Doppio Clic (Statistiche): Apre il pop-up con il Dettaglio.\n"
            "  2. Interazione nel Pop-up Dettaglio:\n"
            "    ‚Ä¢ Doppio Clic: Reindirizza alla transazione principale.\n"
            "    ‚Ä¢ Modalit√† Giorno: Doppio Clic apre PDF, Clic Destro Google Calendar.\n"
            "\n# Avvio e Interazioni del Grafico a Barre:\n"
            "‚Ä¢ Navigazione Grafici: Frecce Destra/Sinistra. Premi ESC per tornare.\n"
            "‚Ä¢ Avvio Archivio PDF: Tasto Destro su riga.\n"
            "‚Ä¢ Avvio Grafico Multiplo: Selezione + Tasto Destro.\n"
            "‚Ä¢ Dettaglio Grafico (Tooltip): Passa il mouse sopra una barra.\n"
            "‚Ä¢ Dettaglio Spesa (Drill-Down): Doppio Clic sulla barra."
        )
        testo_stampa_completo += testo_extra
        popup_aiuto = tk.Toplevel(self, bg=self.COLOR_TOPLEVEL)
        larghezza_finestra, altezza_finestra = 1000, 500
        screen_w, screen_h = self.winfo_screenwidth(), self.winfo_screenheight()
        x, y = (screen_w // 2) - (larghezza_finestra // 2), (screen_h // 2) - (altezza_finestra // 2)
        popup_aiuto.geometry(f"{larghezza_finestra}x{altezza_finestra}+{x}+{y}")
        popup_aiuto.resizable(False, False)
        popup_aiuto.transient(self)
        popup_aiuto.bind("<Escape>", lambda e: popup_aiuto.destroy())
        notebook = ttk.Notebook(popup_aiuto)
        notebook.pack(fill="both", expand=True, padx=10, pady=(5, 0))
        tab1 = ttk.Frame(notebook)
        notebook.add(tab1, text=" üìä Filtri e Tabelle ")
        container1 = tk.Frame(tab1, bg=self.COLOR_WHITE, highlightbackground=self.COLOR_TOPLEVEL, 
                              highlightthickness=4, bd=0)
        container1.pack(fill="both", expand=True, padx=15, pady=15)
        tk.Label(container1, text=testo_stampa_completo, font=("Arial", 9), 
                 bg=self.COLOR_WHITE, fg=self.COLOR_BLACK, justify=tk.LEFT, anchor='nw', 
                 wraplength=920).pack(fill='both', expand=True, padx=15, pady=15)
        tab2 = ttk.Frame(notebook)
        notebook.add(tab2, text=" üïπÔ∏è Pulsanti Icone ")
        container2 = tk.Frame(tab2, bg=self.COLOR_WHITE, highlightbackground=self.COLOR_TOPLEVEL, 
                              highlightthickness=4, bd=0)
        container2.pack(fill="both", expand=True, padx=15, pady=15)
        testo_icone = (
            "üåê PORTALE WEB: Genera QRCode per l'accesso remoto.\n\n"
            "üìå PROMEMORIA: Gestione note e post-it rapidi salvati.\n\n"
            "‚è∞ QR GENERATOR: Crea codici QRCode per i Promemoria Google.\n\n"
            "üîç RICORRENZE: Controllo Movimenti periodici mancanti.\n\n"
            "üìÅ ARCHIVIO PDF: Gestione documenti, scontrini e fatture.\n\n"
            "üõí LISTA SPESA: Lista spesa intelligente divisa per Supermarket.\n\n"
            "üè¶ BANCA: Connessione web con il proprio istituto bancario.\n\n"
            "üí∞ SALDO: Riepilogo liquidit√† attuale e inserimento Saldo Banca.\n\n"
            "‚ûñ RIDUCI: Nasconde l'app nella barra di sistema.\n\n"
            "üì° SYNC: Sincronizzazione intelligente con Gemini per scaricare spese e fatture.\n\n"
            "üìÅ CARTELLA PDF: Apre la cartella locale dove Gemini salva i PDF scaricati da Gmail.\n\n"
            "üîô RESET SYNC: Ricarica i contatori e controlla se ci sono nuovi file o spese da elaborare.\n\n"
        )
        tk.Label(container2, text=testo_icone, font=("Arial", 9), 
                 bg=self.COLOR_WHITE, fg=self.COLOR_BLACK, justify=tk.LEFT, anchor='nw', 
                 wraplength=920).pack(fill='both', expand=True, padx=15, pady=15)
        bottom_frame = ttk.Frame(popup_aiuto)
        bottom_frame.pack(side=tk.BOTTOM, fill=tk.X, pady=5, padx=10)
        ttk.Button(bottom_frame, text="üìÑ Stampa Guida", style='Blu.TButton',
                   command=lambda: self._stampa_lista_diretta(testo_stampa_completo, self.show_custom_warning)).pack(side=tk.LEFT)
        ttk.Button(bottom_frame, text="Ho Capito (OK)", style="Giallo.TButton", 
                   command=popup_aiuto.destroy).pack(side=tk.RIGHT)

    # Finestra Informativa e Dettagli dell'Applicazione (About Box)
    def show_info_app(self):
        def apri_email(event):
            webbrowser.open("mailto:helpcasafacilepro@gmail.com")
        def apri_link_python(event):
            webbrowser.open("https://www.python.org/downloads/")
        info_win = tk.Toplevel(self, bg=self.COLOR_TOPLEVEL)
        info_win.title("Informazioni sull'applicazione e Interazioni")
        info_win.resizable(False, False)
        text = tk.Text(info_win, wrap="word", bg="white", font=("Courier New", 10))
        text.pack(fill="both", expand=True, padx=20, pady=10)
        text.insert("end", f"{NAME} Pro ", "titolo")
        text.insert("end", f"Versione v.{VERSION}\n", "versione")
        text.insert("end", "¬© 2026 Casa Facile Pro - Sviluppo Python/Tkinter (2023-2025)    ")
        text.insert("end", "Email Supporto: ")
        text.insert("end", "helpcasafacilepro@gmail.com\n", "email")
        text.insert("end", "Progetto Python: ")
        text.insert("end", "https://www.python.org/downloads/\n", "link")
        text.insert("end", "\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ FUNZIONALIT√Ä PRINCIPALI ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n", "sezione")
        text.insert("end", "‚Ä¢ Inserimento, modifica e cancellazione di spese ed entrate per categoria.\n")
        text.insert("end", "‚Ä¢ Gestione Categorie personalizzate e Ricorrenze (spese/entrate ripetute).\n")
        text.insert("end", "‚Ä¢ Analisi: Giornaliere, Mensili, Annuali, Totali, Grafici, Time Machine, Confronta, Documenti, Supermarket.\n")
        text.insert("end", "‚Ä¢ Esportazione Dati e Riepilogo dettagliato in formato stampabile (Giorno, Mese, Anno, Utenze).\n")
        text.insert("end", "‚Ä¢ Strumenti Integrati: Saldo Conto, Calcolatrice, Rubrica, Gestione Utenze, Cerca, Report, Finanziamenti, Promemoria.\n")
        text.insert("end", "‚Ä¢ Database: Backup (Automatico e Manuale) , Import/Export database e Reset.\n")
        text.insert("end", "‚Ä¢ L'applicazione integra un WebServer sulla porta 8080 per consentire l'accesso remoto ai dati.\n")
        text.insert("end", "  Questo accesso √® protetto da password per garantirne la sicurezza, consentendo la gestione dell'app tramite\n  browser (PC, SMARTPHONE) solo agli utenti autorizzati.\n")
        text.insert("end", "‚Ä¢ Calendario interattivo con caselle colorate che indicano l'attivit√† del giorno.\n")
        text.insert("end", "\nIl tasto Esc chiude istantaneamente qualsiasi finestra secondaria aperta.\n" "Dopo 20 minuti di inattivit√†, la finestra principale viene iconizzata'")
        text.insert("end", "\npassando il mouse sull'icona o sul popup, l'applicazione si riapre.\n")
        text.insert("end", "\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ INTERAZIONE TABELLE DATI ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n", "sezione")
        text.insert("end", "Le tabelle che mostrano le tue operazioni (Treeview) sono progettate per l'efficienza:\n\n")
        text.insert("end", "1. Ordinamento delle Colonne (Sortby):\n", "sottosezione")
        text.insert("end", "   ‚Ä¢ Clicca sull'intestazione di qualsiasi colonna (Data, Importo, Categoria, tipo, descrizione) per ordinare i dati.\n")
        text.insert("end", "   ‚Ä¢ L'ordinamento gestisce correttamente date e numeri, e alterna la direzione (Ascendente/Discendente).\n\n")
        text.insert("end", "   ‚Ä¢ Funzione Universale (Dettaglio): Fai doppio click su una riga in Qualsiasi Treeview\n     (es. Ricorrenze, Bilancio Mese Dettagliato, Mese/Anno Totali, Grafici, etc.) per ottenere l'azione di dettaglio logica\n     per quel contesto. Ad esempio, aprire il dettaglio del record in un sottomenu o visualizzare la sua posizione\n     nel Treeview principale.\n")
        text.insert("end", "2. Scorrimento con Mouse (Scroll):\n", "sottosezione")
        text.insert("end", "   ‚Ä¢ Tutte le tabelle e le aree di testo scorribili supportano lo scorrimento ovunque tramite la rotella del mouse,\n     senza la necessit√† di cliccare prima sulla barra di scorrimento.\n\n")
        text.tag_config("titolo", foreground="darkblue", font=("Courier New", 12, "bold"))
        text.tag_config("versione", foreground="blue", font=("Courier New", 10, "italic"))
        text.tag_config("sezione", foreground="darkgreen", font=("Courier New", 10, "bold"))
        text.tag_config("sottosezione", foreground="darkorange", font=("Courier New", 10, "bold"))
        text.tag_config("email", foreground="blue", underline=1)
        text.tag_bind("email", "<Button-1>", apri_email)
        text.tag_config("link", foreground="blue", underline=1)
        text.tag_bind("link", "<Button-1>", apri_link_python)
        text.config(state="disabled")    
        text.pack(fill="both", expand=True, padx=20, pady=(10, 0)) 
        text.config(state="disabled")
        button_frame = ttk.Frame(info_win, padding=(10, 10, 10, 10))
        button_frame.pack(fill="x", pady=0) 
        btn_stampa = ttk.Button(
            button_frame, 
            text="üìÑ Stampa Info", 
            command=lambda: self._stampa_lista_diretta(
                text.get("1.0", "end-1c"), 
                self.show_custom_warning
            ), 
            style='Blu.TButton'
        )
        btn_stampa.pack(side=tk.LEFT, padx=5)
        btn_chiudi = ttk.Button(button_frame, text="‚ùå Chiudi", command=info_win.destroy, style='Giallo.TButton')
        btn_chiudi.pack(side=tk.RIGHT, padx=5)
        info_win.withdraw()
        info_win.update_idletasks()
        min_w, min_h = 1160, 650
        w = max(info_win.winfo_width(), min_w)
        h = max(info_win.winfo_height(), min_h)
        x = self.winfo_rootx() + (self.winfo_width() // 2) - (w // 2)
        y = self.winfo_rooty() + (self.winfo_height() // 2) - (h // 2)
        info_win.geometry(f"{w}x{h}+{x}+{y}")
        info_win.grab_set()
        info_win.transient(self)
        info_win.focus_set()
        info_win.deiconify()
        info_win.bind("<Escape>", lambda e: info_win.destroy())

    # Popup Gestione Utenze          
    def check_UTENZE_DB(self):
         if not os.path.exists(UTENZE_DB):
            with open(UTENZE_DB, "w") as file:
                file.write("")  
                self.utenze()

    def utenze(self):
        self.check_UTENZE_DB()
        def get_consumi_per_anno(anno):
            return {
                "Acqua": [(f"{m:02d}/{anno}", 0.0, 0.0, 0.0) for m in range(1, 13)],
                "Luce":  [(f"{m:02d}/{anno}", 0.0, 0.0, 0.0) for m in range(1, 13)],
                "Gas":   [(f"{m:02d}/{anno}", 0.0, 0.0, 0.0) for m in range(1, 13)],
            }
        utenze = ["Acqua", "Luce", "Gas"]
        def carica_db():
            if os.path.exists(UTENZE_DB):
                try:
                    with open(UTENZE_DB, "r", encoding="utf-8") as f:
                        data = json.load(f)
                    letture = data.get("letture_salvate", {u: {} for u in utenze})
                    for utenza, per_anno in letture.items():
                        for anno, righe in per_anno.items():
                            letture_norm = []
                            for r in righe:
                                if len(r) == 4:
                                   mese, prec, att, _ = r
                                   try:
                                       consumo = max(0.0, float(att) - float(prec))
                                   except:
                                       prec, att, consumo = 0.0, 0.0, 0.0
                                       letture_norm.append((mese, prec, att, consumo))
                                else:
                                   letture_norm.append(tuple(r))
                                   letture[utenza][anno] = letture_norm
                    anagrafiche = data.get("anagrafiche", {u: {
                        "Ragione sociale": "",
                        "Telefono": "",
                        "Email": "",
                        "Numero contratto": "",
                        "POD": "",
                        "Note": ""
                    } for u in utenze})
                    for utenza in utenze:
                        if utenza not in anagrafiche:
                            anagrafiche[utenza] = {
                                "Ragione sociale": "",
                                "Telefono": "",
                                "Email": "",
                                "Numero contratto": "",
                                "POD": "",
                                "Note": ""
                            }
                        else:
                            for campo in ["Ragione sociale", "Telefono", "Email", "Numero contratto", "POD", "Note"]:
                                if campo not in anagrafiche[utenza]:
                                    anagrafiche[utenza][campo] = ""
                    return letture, anagrafiche
                except Exception as e:
                    return {u: {} for u in utenze}, {u: {
                        "Ragione sociale": "",
                        "Telefono": "",
                        "Email": "",
                        "Numero contratto": "",
                        "POD": "",
                        "Note": ""
                    } for u in utenze}
            else:
                return {u: {} for u in utenze}, {u: {
                    "Ragione sociale": "",
                    "Telefono": "",
                    "Email": "",
                    "Numero contratto": "",
                    "POD": "",
                    "Note": ""
                } for u in utenze}

        def scrivi_db():
            try:
                data = {
                    "letture_salvate": {
                        u: {a: [list(r) for r in anni] for a, anni in letture_salvate[u].items()}
                        for u in utenze
                    },
                    "anagrafiche": anagrafiche
                }
                with open(UTENZE_DB, "w", encoding="utf-8") as f:
                    json.dump(data, f, indent=1, ensure_ascii=False)
            except Exception as e:
                 self.show_custom_warning("Errore", "Errore scrittura dati")
        letture_salvate, anagrafiche = carica_db()
        self.letture_salvate_utenze = letture_salvate
        self.anagrafiche_salvate_utenze = anagrafiche
        anno_corrente = str(datetime.datetime.now().year)
        year_current = int(anno_corrente)
        anni = [str(a) for a in range(year_current, year_current-11, -1)]
        consumi = get_consumi_per_anno(anno_corrente)
        win = tk.Toplevel(self, bg=self.COLOR_TOPLEVEL)
        win.withdraw() 
        larghezza = 1200
        altezza = 660
        self.update_idletasks()
        self_x = self.winfo_rootx()
        self_y = self.winfo_rooty()
        self_width = self.winfo_width()
        self_height = self.winfo_height()
        x = self_x + (self_width // 2) - (larghezza // 2)
        y = self_y + (self_height // 2) - (altezza // 2)
        win.geometry(f"{larghezza}x{altezza}+{x}+{y}")
        win.title("Gestione Consumi Utenze")
        win.protocol("WM_DELETE_WINDOW", lambda: (self.deiconify(), self.after(0, self.imp_entry.focus_set), win.destroy()))
        win.grab_set()
        win.deiconify() 
        self.withdraw() 
        menu_win = tk.Menu(win, background=self.MENU_BG_DARK, foreground=self.MENU_FG_LIGHT, activebackground=self.MENU_ACT_BG_COLOR, activeforeground=self.MENU_ACT_FG_COLOR)
        menu_funzioni = tk.Menu(menu_win, tearoff=0, bg=self.MENU_BG, fg=self.MENU_FG_LIGHT, activebackground=self.MENU_ACT_BG_COLOR, activeforeground=self.MENU_ACT_FG_COLOR)
        menu_funzioni.add_command(label="üìÇ Esporta Preview", command=lambda: esporta_preview())
        menu_funzioni.add_command(label="‚öôÔ∏è Analizza", command=lambda: crea_tabella_consumi(win, UTENZE_DB))
        menu_funzioni.add_separator()
        menu_funzioni.add_command(label="üì• Tabella Consumi PDF", command=lambda: self.scarica_tabella())
        menu_funzioni.add_separator()
        menu_funzioni.add_command(label="‚ùå Chiudi (ESC)", command=lambda: (self.deiconify(), self.after(0, self.imp_entry.focus_set), win.destroy()))
        menu_win.add_cascade(label="üìÇ Opzioni", menu=menu_funzioni)
        menu_database = tk.Menu(menu_win, tearoff=0, bg=self.MENU_BG, fg=self.MENU_FG_LIGHT, activebackground=self.MENU_ACT_BG_COLOR, activeforeground=self.MENU_ACT_FG_COLOR)
        menu_database.add_command(label="üì§ Esporta Consumi", command=lambda: esporta_letture_data(UTENZE_DB))
        menu_database.add_command(label="üì• Importa Consumi", command=lambda: importa_letture_data(letture_salvate, anagrafiche))
        menu_database.add_separator()
        menu_database.add_command(label="üì• Azzera Consumi", command=lambda: reset_utenze_letture())
        menu_win.add_cascade(label="üóÑÔ∏è Database", menu=menu_database)
        win.config(menu=menu_win)
        win.bind("<Escape>", lambda e: (self.deiconify(), self.after(0, self.imp_entry.focus_set), win.destroy()))
        top_controls = tk.Frame(win, bg=self.COLOR_TOPLEVEL )
        top_controls.pack(pady=(0, 6))
        tk.Label(top_controls, text="Gestione Consumi Utenze", bg=self.COLOR_TOPLEVEL, fg=self.TEXT_COLOR, font=("Arial", 14, "bold")).pack(side=tk.LEFT, padx=(0, 25))
        tk.Label(top_controls, text="Anno: ", bg=self.COLOR_TOPLEVEL, fg=self.TEXT_COLOR).pack(side=tk.LEFT)
        anno_var = tk.StringVar(value=anno_corrente)
        def reset_utenze_letture():
            conferma = self.show_custom_askyesno(
                "Azzeramento Letture",
                "Sei sicuro di voler azzerare TUTTE le letture delle utenze?\n"
                "Questa azione eliminer√† lo storico delle letture."
            )
            if conferma:
                try:
                    if os.path.exists(UTENZE_DB):
                        os.remove(UTENZE_DB)
                    if not os.path.exists(UTENZE_DB):
                        with open(UTENZE_DB, "w") as file:
                            file.write("{\n}\n")  
                    self.deiconify()
                    win.destroy()
                    self.utenze()
                    self.show_custom_warning("Letture", "Letture utenze azzerate con successo.")      
                except Exception as e:
                    self.show_custom_warning("Errore Azzeramento", f"Si √® verificato un errore durante l'azzeramento:\n{e}")
        def salva_letture_preview(txt, preview_win):
            now = datetime.date.today()
            default_filename = f"Letture_Export_{now.day:02d}-{now.month:02d}-{now.year}.txt"
            preview_win.wm_attributes('-topmost', 1)
            file = filedialog.asksaveasfilename(
                defaultextension=".txt",
                filetypes=[("File txt", "*.txt")],
                initialdir=EXPORT_FILES,
                initialfile=default_filename,
                title="Salva Preview",
                confirmoverwrite=False,
                parent=preview_win)
            preview_win.wm_attributes('-topmost', 0)
            if file:
                if os.path.exists(file):
                    conferma = self.show_custom_askyesno(
                        "Sovrascrivere file?",
                        f"Il file '{os.path.basename(file)}' \nesiste gi√†. Vuoi sovrascriverlo?"
                    )
                    if not conferma:
                        return 
                with open(file, "w", encoding="utf-8") as f:
                    lines = txt.get("1.0", tk.END)
                    f.write(lines)
                preview_win.destroy()
                self.show_custom_warning("Esportazione completata", f"Riepilogo esportate in\n{file}")
        def esporta_preview():
            preview_win = tk.Toplevel(win, bg=self.COLOR_TOPLEVEL)
            preview_win.title("Preview Esportazione")
            preview_win.geometry("1050x600")
            screen_width = preview_win.winfo_screenwidth()
            screen_height = preview_win.winfo_screenheight()
            x = (screen_width - 1050) // 2
            y = (screen_height - 600) // 2
            preview_win.geometry(f"1050x600+{x}+{y}")
            preview_win.after(10, lambda: preview_win.focus_force())
            txt = tk.Text(preview_win, font=("Courier New", 10), wrap="none")
            txt.pack(fill=tk.BOTH, expand=True)
            anno_x = anno_var.get()
            txt.insert(tk.END, f"Consumi utenze per anno {anno_x}\n\n")
            header = f"{'Mese':<10}"
            for utenza in utenze:
                header += f"{utenza:^30}"
            txt.insert(tk.END, header + "\n")
            sub_header = f"{'':<10}"
            for _ in utenze:
                sub_header += f"{'Prec':>8}{'Att':>10}{'Cons':>10}  "
            txt.insert(tk.END, sub_header + "\n")
            txt.insert(tk.END, "-" * len(header) + "\n")
            mesi = [self.trees[utenze[0]].item(iid)['values'][0] for iid in self.trees[utenze[0]].get_children()]
            for i, mese in enumerate(mesi):
                riga = f"{mese:<10}"
                for utenza in utenze:
                    values = self.trees[utenza].item(self.trees[utenza].get_children()[i])['values']
                    prec, att, cons = float(values[1]), float(values[2]), float(values[3])
                    riga += f"{prec:8.2f}{att:10.2f}{cons:10.2f}  "
                txt.insert(tk.END, riga + "\n")
            txt.insert(tk.END, "-" * len(header) + "\n")
            tot_riga = f"{'Totale':<10}"
            for utenza in utenze:
                somma = sum(float(self.trees[utenza].item(iid)['values'][3]) for iid in self.trees[utenza].get_children())
                tot_riga += f"{'':8}{'':10}{somma:10.2f}  "
            txt.insert(tk.END, tot_riga + "\n")
            txt.config(state="disabled")
            btn_frame = tk.Frame(preview_win, bg=self.COLOR_TOPLEVEL)
            btn_frame.pack(fill=tk.X, pady=12)
            ttk.Button(btn_frame, text="üíæ Esporta", command=lambda: salva_letture_preview(txt, preview_win), style="Verde.TButton").pack(side=tk.LEFT, padx=10)
            ttk.Button(
            btn_frame,
            text="üìÑ Stampa",
            command=lambda: self._stampa_lista_diretta(
                txt.get("1.0", tk.END),
                self.show_custom_warning
            ),
            style="Blu.TButton" 
        ).pack(side=tk.LEFT, padx=10)
            ttk.Button(btn_frame, text="‚ùå Chiudi", command=preview_win.destroy, style="Giallo.TButton").pack(side=tk.RIGHT, padx=10)
            preview_win.lift()
            preview_win.attributes('-topmost', True)
            preview_win.after(200, lambda: preview_win.attributes('-topmost', False))
            preview_win.bind("<Escape>", lambda e: preview_win.destroy())
        def chiudi():
            win.destroy()
            self.deiconify()
            self.after(0, self.imp_entry.focus_set)
        def cambia_anno(*args):
            nonlocal consumi
            for utenza in utenze:
                if self.trees[utenza].get_children():
                    anno_attuale = self.trees[utenza].item(self.trees[utenza].get_children()[0])['values'][0].split("/")[1]
                    letture_salvate[utenza][anno_attuale] = [
                        tuple(self.trees[utenza].item(iid)['values']) for iid in self.trees[utenza].get_children()
                    ]
            scrivi_db()
            for utenza in utenze:
                self.trees[utenza].delete(*self.trees[utenza].get_children())
            anno_sel = anno_var.get()
            consumi = get_consumi_per_anno(anno_sel)
            for utenza in utenze:
                if (anno_sel not in letture_salvate[utenza]) or (not letture_salvate[utenza][anno_sel]):
                    letture_salvate[utenza][anno_sel] = [
                        (f"{m:02d}/{anno_sel}", 0.0, 0.0, 0.0) for m in range(1, 13)
                    ]
                righe = letture_salvate[utenza][anno_sel]
                righe_norm = []
                for r in righe:
                    if len(r) == 4:
                        mese, prec, att, consumo = r
                        consumo = max(0.0, float(att) - float(prec))
                        righe_norm.append((mese, float(prec), float(att), float(consumo)))
                    else:
                        righe_norm.append(tuple(r))
                letture_salvate[utenza][anno_sel] = righe_norm
                for mese, prec, att, consumo in righe_norm:
                    self.trees[utenza].insert("", "end", values=(mese, float(prec), float(att), float(consumo)))
        anno_cb = ttk.Combobox(top_controls, values=anni, textvariable=anno_var, style="Border.TCombobox", state="readonly", width=8)
        anno_cb.pack(side=tk.LEFT)
        def reset_anno():
            anno_var.set(anno_corrente)
        ttk.Button(top_controls, text="üîÑ", style="Giallo.TButton", width=2, command=reset_anno).pack(side=tk.LEFT, padx=2)
        ttk.Button(top_controls, text="‚ùå Chiudi", style="Giallo.TButton", command=chiudi).pack(side=tk.LEFT, padx=7)
        anno_var.trace_add("write", cambia_anno)
        main_frame = ttk.Frame(win)
        main_frame.pack(fill=tk.BOTH, expand=True, padx=18, pady=6)
        for c in range(len(utenze)):
            main_frame.grid_columnconfigure(c, weight=1)
        colori = {"Acqua": "#ccefff", "Luce": "#fff9cc", "Gas": "#ffe0cc"}
        self.trees = {}
        anag_entries = {}
        def importa_letture_data(letture_salvate, anagrafiche):
            now = datetime.date.today()
            default_dir = EXP_DB
            default_filename = f"{now.day:02d}-{now.month:02d}-{now.year}-utenze_db.json"
            file = filedialog.askopenfilename(
                defaultextension=".json",
                filetypes=[("File JSON", "*utenze_db.json"), ("Tutti i file", "*.*")],
                initialdir=default_dir,
                initialfile=default_filename,
                title="Importa utenze",
            )
            if file:
                try:
                    with open(file, "r", encoding="utf-8") as f:
                        data = json.load(f)
                    letture = data.get("letture_salvate", {})
                    anagrafiche = data.get("anagrafiche", {})
                    self.letture_salvate_utenze.update(letture)
                    self.anagrafiche_salvate_utenze.update(anagrafiche)     
                    scrivi_db()
                    self.deiconify()
                    win.destroy()
                    self.utenze()
                    self.show_custom_warning("Importazione riuscita", "Utenze importate correttamente!")
                except Exception as e:
                    self.show_custom_warning("Errore", f"Errore durante l'importazione:\n{e}")
        def esporta_letture_data(UTENZE_DB):
            now = datetime.date.today()
            default_dir = EXP_DB
            default_filename = f"{now.day:02d}-{now.month:02d}-{now.year}-utenze_db.json"
            file = filedialog.asksaveasfilename(
                defaultextension=".json",
                filetypes=[("File JSON", "*utenze_db.json"), ("Tutti i file", "*.*")],
                initialdir=default_dir,
                initialfile=default_filename,
                confirmoverwrite=False,
                title="Esporta utenze",
            )
            if file:
                try:
                    data = {
                        "letture_salvate": self.letture_salvate_utenze,
                        "anagrafiche": self.anagrafiche_salvate_utenze
                    }
                    with open(file, "w", encoding="utf-8") as f:
                        json.dump(data, f, ensure_ascii=False, indent=2)
                    self.show_custom_warning("Esportazione completata", f"Database utenze salvato in:\n{file}")
                except Exception as e:
                    self.show_custom_warning("Errore", f"Errore durante l'esportazione:\n{e}")
        def crea_tabella_consumi(parent, UTENZE_DB):
            try:
                with open(UTENZE_DB, "r", encoding="utf-8") as f:
                    data = json.load(f)
                    letture_salvate = data.get("letture_salvate", {})
            except Exception as e:
                print(f"‚ùå Errore lettura file: {e}")
                return
            utenze = ["Acqua", "Luce", "Gas"]
            win = tk.Toplevel(parent, bg=self.COLOR_TOPLEVEL )
            win.bind("<Escape>", lambda e: win.destroy())
            win.title("Consumi Utenze - Anteprima")
            win.geometry("1150x600")
            win.transient(parent)
            win.grab_set()
            screen_width = win.winfo_screenwidth()
            screen_height = win.winfo_screenheight()
            x_coordinate = (screen_width - 1150) // 2
            y_coordinate = (screen_height - 600) // 2
            win.geometry(f"1150x600+{x_coordinate}+{y_coordinate}")
            frame_principale = ttk.Frame(win)
            frame_principale.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
            canvas = tk.Canvas(frame_principale, bg=self.COLOR_TOPLEVEL)
            scrollbar = ttk.Scrollbar(frame_principale, orient="vertical", command=canvas.yview, style="Vertical.TScrollbar")
            canvas.configure(yscrollcommand=scrollbar.set)
            scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
            canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
            frame_interno = ttk.Frame(canvas)
            canvas_window = canvas.create_window((0, 0), window=frame_interno, anchor="nw")
            def aggiorna_scrollregion(event):
                canvas.configure(scrollregion=canvas.bbox("all"))
                canvas.itemconfig(canvas_window, width=canvas.winfo_width())
            frame_interno.bind("<Configure>", aggiorna_scrollregion)
            for utenza in utenze:
                frame_tabella = ttk.Frame(frame_interno)
                frame_tabella.pack(fill=tk.BOTH, expand=True, pady=10)
                ttk.Label(
                    frame_tabella,
                    text=f"Consumi {utenza}",
                    font=("Arial", 12, "bold")
                ).pack(pady=5)
                colonne = [
                    "Anno", "Gen", "Feb", "Mar", "Apr", "Mag", "Giu",
                    "Lug", "Ago", "Set", "Ott", "Nov", "Dic", "Totale"
                ]
                tree = ttk.Treeview(
                    frame_tabella,
                    columns=colonne,
                    show="headings",
                    height=4
                )
                for col in colonne:
                    tree.heading(col, text=col)
                    tree.column(col, width=80, anchor="center")
                tree.pack(fill=tk.BOTH, expand=True)
                for anno in sorted(letture_salvate.get(utenza, {}).keys(), reverse=True):
                    row = [anno]
                    tot_consumi = 0.0
                    for mese in range(1, 13):
                        mese_str = f"{mese:02d}/{anno}"
                        consumo = sum(
                            float(r[3])
                            for r in letture_salvate.get(utenza, {}).get(anno, [])
                            if r[0] == mese_str
                        )
                        row.append(consumo)
                        tot_consumi += consumo
                    row.append(tot_consumi)
                    tree.insert("", tk.END, values=row)
            frame_bottoni = tk.Frame(win, bg=self.COLOR_TOPLEVEL )
            frame_bottoni.pack(fill=tk.X, padx=10, pady=10)
            ttk.Button(frame_bottoni, text="üíæ Salva", style="Verde.TButton", command=lambda: salva_dati_letture(letture_salvate)).pack(side=tk.LEFT, padx=10)
            ttk.Button(frame_bottoni, text="‚ùå Chiudi", style="Giallo.TButton", command=win.destroy).pack(side=tk.RIGHT, padx=10)
        def salva_dati_letture(letture_salvate):
            win.focus_force()
            now = datetime.date.today()
            default_filename = f"Letture_anno_Export_{now.day:02d}-{now.month:02d}-{now.year}.txt"
            file_path = filedialog.asksaveasfilename(
                defaultextension=".txt",
                filetypes=[("File txt", "*.txt")],
                initialdir=EXPORT_FILES,
                initialfile=default_filename,
                confirmoverwrite=False,
                title="Salva i dati dei consumi"
               )
            if file_path:
                if os.path.exists(file_path):
                    conferma = self.show_custom_askyesno(
                        "Sovrascrivere file?",
                        f"Il file '{os.path.basename(file_path)}' \nesiste gi√†. Vuoi sovrascriverlo?"
                    )
                    if not conferma:
                        return
            if not file_path:
                return
            mesi = ["Gen", "Feb", "Mar", "Apr", "Mag", "Giu",
            "Lug", "Ago", "Set", "Ott", "Nov", "Dic"]
            try:
                with open(file_path, "w", encoding="utf-8") as f:
                    for utenza, anni in letture_salvate.items():
                        f.write(f"Consumi {utenza}:\n")
                        intestazione = f"{'Anno':>6} " + "".join([f"{mese:>8}" for mese in mesi]) + f"{'Totale':>10}\n"
                        f.write(intestazione)
                        f.write("-" * len(intestazione) + "\n")
                        for anno in sorted(anni.keys(), reverse=True):
                            valori_mensili = {r[0]: float(r[3]) for r in anni[anno]}
                            riga = f"{anno:>6} "
                            totale = 0.0
                            for m in range(1, 13):
                                mese_str = f"{m:02d}/{anno}"
                                consumo = valori_mensili.get(mese_str, 0.0)
                                riga += f"{consumo:8.2f}"
                                totale += consumo
                            riga += f"{totale:10.2f}\n"
                            f.write(riga)
                        f.write("\n")
                self.show_custom_warning("Esportazione", f"Riepilogo esportato correttamente in:\n{file_path}")
            except Exception as e:
                self.show_custom_warning("Errore", f"Errore durante il salvataggio:\n{e}")
        def centra_su_padre(finestra, padre):
            padre.update_idletasks()
            larghezza = finestra.winfo_reqwidth()
            altezza = finestra.winfo_reqheight()
            px = padre.winfo_rootx() + (padre.winfo_width() // 2) - (larghezza // 2)
            py = padre.winfo_rooty() + (padre.winfo_height() // 2) - (altezza // 2)
            finestra.geometry(f"+{px}+{py}")
        def salva_letture_utenza(utenza):
            anno_sel = anno_var.get()
            letture_salvate[utenza][anno_sel] = [
                tuple(self.trees[utenza].item(iid)['values']) for iid in self.trees[utenza].get_children()
            ]
            scrivi_db()
        def salva_anagrafica_utenza(utenza):
            for field, ent in anag_entries[utenza].items():
                if field == "Note":
                    anagrafiche[utenza][field] = ent.get("1.0", "end-1c")
                else:
                    anagrafiche[utenza][field] = ent.get()
            scrivi_db()
        def on_tree_double_click(event, utenza):
            tree = self.trees[utenza]
            item_id = tree.identify_row(event.y)
            if item_id:
                tree.selection_set(item_id)
                tree.focus(item_id)
                apri_modale(utenza)
        def on_tree_right_click(event, utenza):
            tree = self.trees[utenza]
            item_id = tree.identify_row(event.y)
            if not item_id:
                return
            tree.selection_set(item_id)
            tree.focus(item_id)
            apri_modale_solo_totale(utenza)
        def apri_modale_solo_totale(utenza):
            selected = self.trees[utenza].focus()
            if not selected:
                self.show_custom_warning("Errore", "Seleziona un mese dalla tabella")
                return
            item = self.trees[utenza].item(selected)
            mese, prec, att, consumo = item['values']
            try:
                consumo = float(consumo)
            except:
                consumo = 0.0
            modal = tk.Toplevel(win, bg=self.COLOR_TOPLEVEL)
            modal.title(f"Consumo {utenza}")
            modal.geometry("300x140")
            modal.resizable(False, False)
            modal.transient(win)
            centra_su_padre(modal, win)
            modal.after_idle(modal.grab_set)
            def only_numeric_8char(val):
                if len(val) > 8:
                    return False
                if val == "":
                    return True
                if val.count(".") > 1:
                    return False
                return all(c.isdigit() or c == "." for c in val)
            vcmd = modal.register(only_numeric_8char)
            tk.Label(modal, text=f"{utenza} - {mese}", bg=self.COLOR_TOPLEVEL, fg=self.TEXT_COLOR, font=("Arial", 12, "bold")).pack(pady=10)
            tk.Label(modal, text="Consumo:", bg=self.COLOR_TOPLEVEL, fg=self.TEXT_COLOR).pack()
            consumo_var = tk.DoubleVar(value=consumo)
            e_cons = tk.Entry(modal, textvariable=consumo_var, font=("Arial", 10), width=15,
                      validate="key", validatecommand=(vcmd, "%P"))
            e_cons.pack()
            e_cons.focus_set()
            modal.bind("<Return>", lambda event: salva()) 
            modal.bind("<KP_Enter>", lambda event: salva()) 
            def salva():
                val = e_cons.get().strip()
                if not val:
                    self.show_custom_warning("Campo vuoto", "Inserisci il valore del consumo.")
                    return
                try:
                    cons = float(consumo_var.get())
                    if cons < 0:
                        self.show_custom_warning("Errore", "Consumo non pu√≤ essere negativo.")
                        return
                    nuovo_att = float(prec) + cons
                    self.trees[utenza].item(selected, values=(mese, prec, nuovo_att, cons))
                    anno_sel = anno_var.get()
                    righe = [
                        tuple(self.trees[utenza].item(iid)['values'])
                        for iid in self.trees[utenza].get_children()
                    ]
                    letture_salvate[utenza][anno_sel] = righe
                    scrivi_db()
                    modal.destroy()
                except ValueError:
                    self.show_custom_warning("Errore", "Valore non valido.")
            btn_frame = tk.Frame(modal, bg=self.COLOR_TOPLEVEL)
            btn_frame.pack(fill="x", pady=10, padx=10)
            btn_salva = ttk.Button(btn_frame, text="üíæ Salva", command=salva, style="Verde.TButton")
            btn_salva.pack(side=tk.LEFT, padx=(0,10))
            btn_chiudi = ttk.Button(btn_frame, text="‚ùå Chiudi", command=modal.destroy, style="Giallo.TButton")
            btn_chiudi.pack(side=tk.RIGHT, padx=(10,0))
            modal.bind("<Escape>", lambda e: modal.destroy())
        def apri_modale(utenza):
            selected = self.trees[utenza].focus()
            if not selected:
                self.show_custom_warning("Errore", "Seleziona un mese dalla tabella")
                return
            item = self.trees[utenza].item(selected)
            mese, prec, att, _ = item['values']
            items = self.trees[utenza].get_children()
            idx = items.index(selected)
            if idx > 0:
                prev_item = self.trees[utenza].item(items[idx - 1])
                try:
                    prec = float(prev_item['values'][2])
                except:
                    prec = 0.0
            try:
                prec = float(prec)
            except:
                prec = 0.0
            try:
                att = float(att)
            except:
                att = 0.0
            modal = tk.Toplevel(win, bg=self.COLOR_TOPLEVEL)
            modal.title(f"Letture {utenza}")
            modal.geometry("300x180")
            modal.resizable(False, False)
            modal.transient(win)
            centra_su_padre(modal, win)
            modal.after_idle(modal.grab_set)
            modal.bind("<Return>", lambda e: salva())
            modal.bind("<KP_Enter>", lambda e: salva())
            def only_numeric_8char(val):
                if len(val) > 8:
                    return False
                if val == "":
                    return True
                if val.count(".") > 1:
                    return False
                return all(c.isdigit() or c == "." for c in val)
            vcmd = modal.register(only_numeric_8char)
            tk.Label(modal, text=f"{utenza} - {mese}", bg=self.COLOR_TOPLEVEL,fg=self.TEXT_COLOR , font=("Arial", 12, "bold")).pack(pady=10)
            tk.Label(modal, text="Lettura precedente:", bg=self.COLOR_TOPLEVEL,fg=self.TEXT_COLOR).pack()
            prec_var = tk.DoubleVar(value=prec)
            e_prec = tk.Entry(modal, textvariable=prec_var, font=("Arial", 10), width=22,
                      validate="key", validatecommand=(vcmd, "%P"))
            e_prec.pack()
            tk.Label(modal, text="Lettura attuale:", bg=self.COLOR_TOPLEVEL,fg=self.TEXT_COLOR).pack()
            att_var = tk.DoubleVar(value=att)
            e_att = tk.Entry(modal, textvariable=att_var, font=("Arial", 10), width=22,
                     validate="key", validatecommand=(vcmd, "%P"))
            e_att.pack()
            modal.e_prec = e_prec
            modal.e_att = e_att
            modal.prec_var = prec_var
            modal.att_var = att_var
            modal.mese = mese
            modal.utenza = utenza
            def salva():
                try:
                    if not e_prec.get().strip() or not e_att.get().strip():
                        self.show_custom_warning("Campo vuoto", "Compila entrambi i campi prima di salvare.")
                        return
                    p = float(prec_var.get())
                    a = float(att_var.get())
                    if a < p:
                        conferma = tk.Toplevel(modal, bg=self.COLOR_TOPLEVEL)
                        conferma.title("Conferma Forzatura")
                        conferma.geometry("350x120")
                        conferma.resizable(False, False)
                        conferma.transient(modal)
                        conferma.grab_set()
                        centra_su_padre(conferma, modal)
                        msg = ttk.Label(conferma,
                                       text="La lettura attuale √® minore della precedente.\nVuoi forzare l'inserimento?")
                        msg.pack(pady=15)
                        btn_frame = ttk.Frame(conferma)
                        btn_frame.pack()
                        def ok():
                            consumo = round(max(0.0, a - p), 2)
                            self.trees[utenza].item(selected, values=(mese, p, a, consumo))
                            if idx + 1 < len(items):
                                next_item = self.trees[utenza].item(items[idx + 1])
                                next_mese, _, next_att, _ = next_item['values']
                                next_att_f = float(next_att)
                                next_cons = round(next_att_f - a, 2)
                                self.trees[utenza].item(items[idx + 1], values=(next_mese, a, next_att_f, next_cons))
                            conferma.destroy()
                            modal.destroy()
                            salva_letture_utenza(utenza)
                        def annulla():
                            conferma.destroy()
                        ttk.Button(btn_frame, text="Forza", style="Arancio.TButton", width=10, command=ok).pack(side=tk.LEFT, padx=12)
                        ttk.Button(btn_frame, text="Annulla", style="Giallo.TButton", width=10, command=annulla).pack(side=tk.LEFT, padx=12)
                        return
                    consumo = round(a - p, 2)
                    self.trees[utenza].item(selected, values=(mese, p, a, consumo))
                    if idx + 1 < len(items):
                        next_item = self.trees[utenza].item(items[idx + 1])
                        next_mese, _, next_att, _ = next_item['values']
                        next_att_f = float(next_att)
                        next_cons = max(0.0, next_att_f - a)
                        self.trees[utenza].item(items[idx + 1], values=(next_mese, a, next_att_f, next_cons))
                    modal.destroy()
                    salva_letture_utenza(utenza)
                except ValueError:
                    self.show_custom_warning("Errore", "Valori non validi")
            ttk.Button(modal, text="üíæ Salva", command=salva, style="Verde.TButton").pack(side=tk.LEFT, padx=10)
            ttk.Button(modal, text="‚ùå Chiudi", command=modal.destroy, style="Giallo.TButton").pack(side=tk.RIGHT, padx=10)
            modal.bind("<Escape>", lambda e: modal.destroy())
        notebook = ttk.Notebook(main_frame)
        notebook.pack(fill="both", expand=True, padx=10, pady=10)
        for utenza in utenze:
                tab = ttk.Frame(notebook)
                notebook.add(tab, text=f"{'üíß' if utenza=='Acqua' else 'üí°' if utenza=='Luce' else 'üî•'} {utenza}")
                colore_bg = colori[utenza]
                frame = tk.Frame(tab, bg=colore_bg, bd=2, relief="groove")
                frame.pack(fill="both", expand=True, padx=8, pady=8)
                top_btn_fr = tk.Frame(frame, bg=colore_bg)
                top_btn_fr.pack(fill="x", padx=4, pady=(2, 0))
                ttk.Button(top_btn_fr,text="üì• Modifica Letture" , style="Rosso.TButton", command=lambda u=utenza: apri_modale(u)).pack(side=tk.LEFT, padx=5, pady=2)
                ttk.Button(top_btn_fr,text="üü¢ Modifica Consumo", style="Verde.TButton", command=lambda u=utenza: apri_modale_solo_totale(u)).pack(side=tk.LEFT, padx=5, pady=2)
                bg_utenza = colori.get(utenza, "#f0f0f0")  
                tk.Label(
                    top_btn_fr,
                    text="üñ±Ô∏è 2 Click sx: Mod.letture | Click dx: Mod.consumo",
                    font=("Arial", 9, "bold"),
                    fg="black",
                    bg=bg_utenza
                ).pack(side=tk.LEFT, padx=10, pady=2)
                tree = ttk.Treeview(frame, columns=("Mese", "Prec", "Att", "Consumo"), show="headings", height=12)
                for col in ("Mese", "Prec", "Att", "Consumo"):
                        tree.heading(col, text=col)
                        tree.column(col, anchor="center", width=80)
                tree.pack(padx=8, pady=6, fill="both", expand=True)
                anno_sel = anno_var.get()
                if (anno_sel not in letture_salvate[utenza]) or (not letture_salvate[utenza][anno_sel]):
                        letture_salvate[utenza][anno_sel] = [(f"{m:02d}/{anno_sel}", 0.0, 0.0, 0.0) for m in range(1, 13)]
                righe = letture_salvate[utenza][anno_sel]
                righe_norm = []
                for r in righe:
                        if len(r) == 4:
                                mese, prec, att, consumo = r
                                consumo = max(0.0, float(att) - float(prec))
                                righe_norm.append((mese, float(prec), float(att), float(consumo)))
                        else:
                                righe_norm.append(tuple(r))
                letture_salvate[utenza][anno_sel] = righe_norm
                for mese, prec, att, consumo in righe_norm:
                        tree.insert("", "end", values=(mese, float(prec), float(att), float(consumo)))
                self.trees[utenza] = tree
                tree.bind("<Double-1>", lambda event, utenza=utenza: on_tree_double_click(event, utenza))
                tree.bind("<Button-3>", lambda event, utenza=utenza: on_tree_right_click(event, utenza))
                SFONDO_EDITABILE = 'yellow'
                SFONDO_BLOCCATO = 'white'
                anag_frame = tk.LabelFrame(frame, text="Dati Anagrafici", bg=colore_bg)
                anag_frame.pack(fill="x", padx=8, pady=8)
                anag_frame.grid_columnconfigure(3, weight=1)
                anag_frame.grid_columnconfigure(4, weight=0)
                anag_entries[utenza] = {}
                campi = [("Ragione sociale", 40), ("Telefono", 40), ("Email", 40), ("Numero contratto", 40), ("POD", 40)]
                for row, (label, width) in enumerate(campi):
                    tk.Label(anag_frame, text=label+":", bg=colore_bg).grid(row=row, column=0, sticky="e", padx=5, pady=2)
                    ent = tk.Entry(anag_frame, 
                                   width=width, 
                                   bg=SFONDO_EDITABILE, 
                                   readonlybackground=SFONDO_BLOCCATO, 
                                   disabledbackground=SFONDO_BLOCCATO) 
                    ent.grid(row=row, column=1, sticky="w", padx=5, pady=2)
                    ent.insert(0, anagrafiche[utenza][label])
                    ent.config(state="readonly") 
                    anag_entries[utenza][label] = ent
                tk.Label(anag_frame, text="Note:", bg=colore_bg).grid(row=0, column=2, sticky="ne", padx=5, pady=2)
                note_container = tk.Frame(anag_frame, bg=colore_bg)
                note_container.grid(row=0, column=3, rowspan=6, sticky="nsew", padx=5, pady=2)
                note_scrollbar = ttk.Scrollbar(note_container, orient=tk.VERTICAL, style="Vertical.TScrollbar")
                note_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
                note_txt = tk.Text(
                    note_container, 
                    width=60, 
                    height=8, 
                    wrap="word",
                    bg=SFONDO_BLOCCATO,
                    yscrollcommand=note_scrollbar.set
                )
                note_txt.pack(side=tk.LEFT, fill=tk.BOTH, expand=True) 
                note_scrollbar.config(command=note_txt.yview)
                note_txt.insert("1.0", anagrafiche[utenza]["Note"])
                note_txt.config(state="disabled")
                anag_entries[utenza]["Note"] = note_txt
                btns = ttk.Frame(anag_frame)
                btns.grid(row=0, column=4, rowspan=6, sticky="n", padx=(5,10), pady=2)
                def set_editable(editable, u=utenza):
                    colore_sfondo = SFONDO_EDITABILE if editable else SFONDO_BLOCCATO
                    for k, ent in anag_entries[u].items():
                        if k == "Note":
                            ent.config(state="normal" if editable else "disabled")
                            ent.config(background=colore_sfondo) 
                        else:
                            ent.config(state="normal" if editable else "readonly")
                            ent.config(bg=colore_sfondo)
                def salva_dati(u=utenza):
                    for field, ent in anag_entries[u].items():
                        if field == "Note":
                            anagrafiche[u][field] = ent.get("1.0", "end-1c")
                        else:
                            anagrafiche[u][field] = ent.get()
                    set_editable(False, u)
                    scrivi_db()
                    self.show_custom_warning("Attenzione", f"Dati {u} Salvati correttamente !")
                def modifica_dati(u=utenza):
                    set_editable(True, u)
                btns = tk.Frame(anag_frame, bg='') 
                btns.grid(row=0, column=4, rowspan=6, sticky="n", padx=(5,10), pady=2) 
                ttk.Button(btns,text="üíæ Salva",width=10,command=lambda u=utenza: salva_dati(u), style="Verde.TButton").pack(pady=(0, 5))
                ttk.Button(btns,text="üìÑ Modifica",width=10,command=lambda u=utenza: modifica_dati(u), style="Giallo.TButton").pack()
                
    # Gestione ed Eliminazione Multipla Transazioni
    def apri_cancella_spese_treeview_unica(self):
        NOMI_MESI_ITALIANO = ["Gennaio", "Febbraio", "Marzo", "Aprile", "Maggio", "Giugno", 
                              "Luglio", "Agosto", "Settembre", "Ottobre", "Novembre", "Dicembre"]
        if not hasattr(self, 'spese') or not isinstance(self.spese, dict):
            self.spese = {} 
        self.filtri_cancellazione = {
            "descrizione": "",
            "categoria": "‚Äî",
            "tipo": "‚Äî",
            "anno": "‚Äî",
            "mese": "‚Äî",
            "da": "",
            "a": "",
            "icona": "‚Äî"
        }
        if not hasattr(self, 'selezionate_iid'):
            self.selezionate_iid = set()
        self.selezionate_iid.clear() 
        def sort_treeview_column(tree, col, reverse, data_type='string'):
            items_to_sort = []
            for k in tree.get_children(''):
                value = tree.set(k, col)
                if value in ("‚Äî", ""): continue 
                items_to_sort.append((value, k))
            def get_sort_key(item):
                value = item[0]
                try:
                    if data_type == 'float':
                        return float(value.replace(' ‚Ç¨', '').replace(',', '.'))
                    elif data_type == 'date':
                        return datetime.datetime.strptime(value, '%d/%m/%Y')
                    else: 
                        return value.lower()
                except Exception:
                    return value
            items_to_sort.sort(key=get_sort_key, reverse=reverse)
            for index, (val, k) in enumerate(items_to_sort):
                tree.move(k, '', index)
            tree.heading(col, command=lambda: sort_treeview_column(tree, col, not reverse, data_type))
        def toggle_selection_treeview(event):
            row_id = self.spese_treeview.identify_row(event.y)
            if not row_id or row_id in ("EMPTY_MSG", "FILTER_MSG"): return
            is_selected = row_id in self.selezionate_iid
            current_tags = list(self.spese_treeview.item(row_id, 'tags'))
            type_tag = [t for t in current_tags if t in ('entrata', 'uscita')] 
            if is_selected:
                self.selezionate_iid.remove(row_id)
                self.spese_treeview.item(row_id, tags=type_tag, text="[ ]") 
            else:
                self.selezionate_iid.add(row_id)
                new_tags = type_tag + ['selezionata']
                self.spese_treeview.item(row_id, tags=new_tags, text="[X]") 
        def esegui_cancellazione_azione(): 
            if not self.selezionate_iid:
                self.show_custom_warning("Attenzione", "Seleziona almeno una spesa da cancellare.")
                return
            num_selezionate = len(self.selezionate_iid)
            testo_messaggio = (
                f"‚ö†Ô∏è CONFERMA CANCELLAZIONE DEFINITIVA\n\n"
                f"Stai per cancellare {num_selezionate} elementi selezionati.\n\n"
                f"ATTENZIONE: Questa azione √® IRREVERSIBILE e i dati non potranno pi√π essere recuperati.\n"
                f"Sei assolutamente sicuro di voler procedere con l'eliminazione?"
            )
            response = self.show_custom_askyesno("Conferma Cancellazione", testo_messaggio)
            if not response: return
            spese_da_mantenere = {}
            for giorno_obj in self.spese.keys():
                giorno_interno = str(giorno_obj)
                spese_mantenute_giorno = []
                for indice, voce in enumerate(self.spese.get(giorno_obj, [])):
                    iid = f"{giorno_interno}_{indice}"
                    if iid not in self.selezionate_iid:
                        spese_mantenute_giorno.append(voce)
                if spese_mantenute_giorno:
                    spese_da_mantenere[giorno_obj] = spese_mantenute_giorno
            self.spese = spese_da_mantenere
            self.selezionate_iid.clear() 
            popola_treeview_spese()
            if hasattr(self, 'refresh_gui'): self.refresh_gui()
            if hasattr(self, 'save_db'): self.save_db()
            self.show_custom_warning("Successo", f"‚úì {num_selezionate} spese sono state cancellate.")
        def popola_treeview_spese():
            self.spese_treeview.delete(*self.spese_treeview.get_children())
            if not self.spese:
                self.spese_treeview.insert("", "end", iid="EMPTY_MSG", 
                                           text="", 
                                           values=("‚Äî", "‚ö†Ô∏è Dati spese non trovati o database vuoto.", "", "", ""),
                                           tags=('empty',))
                return
            filtri = self.filtri_cancellazione
            items_inserted = 0
            filtro_testo_globale = filtri.get("descrizione", "").lower()
            filtro_categoria_esatta = filtri.get("categoria")
            filtro_tipo = filtri.get("tipo")
            filtro_anno = filtri.get("anno")
            filtro_mese_nome = filtri.get("mese")
            filtro_mese_numero = ""
            if filtro_mese_nome and filtro_mese_nome != "‚Äî":
                try:
                    mese_index = NOMI_MESI_ITALIANO.index(filtro_mese_nome) + 1
                    filtro_mese_numero = f"{mese_index:02d}"
                except ValueError:
                    pass 
            try:
                giorni_ordinati = sorted(self.spese.keys(), 
                                         key=lambda d: d if isinstance(d, datetime.date) else datetime.datetime.strptime(str(d), '%Y-%m-%d').date(), 
                                         reverse=True) 
            except Exception:
                 giorni_ordinati = sorted(self.spese.keys(), reverse=True)
            for giorno_obj in giorni_ordinati:
                d = None
                giorno_interno = str(giorno_obj)
                giorno_visualizzato = str(giorno_obj)
                try:
                    if isinstance(giorno_obj, datetime.date):
                        d = giorno_obj
                    else:
                        d = datetime.datetime.strptime(str(giorno_obj), '%Y-%m-%d').date()
                    giorno_interno = d.strftime('%Y-%m-%d')
                    giorno_visualizzato = d.strftime('%d/%m/%Y')
                except Exception:
                    pass 
                lista_voci = self.spese.get(giorno_obj, [])
                for indice, voce in enumerate(lista_voci): 
                    try:
                        categoria, descrizione, importo = voce[0], voce[1], voce[2]
                        tipo = voce[3].capitalize() if len(voce) > 3 else "N/A" 
                        filtro_icona = filtri.get("icona")
                        if filtro_icona not in ["", "‚Äî"] and filtro_icona not in descrizione:
                            continue
                        matches = True
                        if filtro_testo_globale:
                            testo_da_cercare = f"{descrizione} {categoria}".lower()
                            if filtro_testo_globale not in testo_da_cercare: 
                                matches = False
                        if matches and filtro_categoria_esatta not in ["", "‚Äî"] and categoria != filtro_categoria_esatta: matches = False
                        if matches and filtro_tipo not in ["", "‚Äî"] and tipo != filtro_tipo: matches = False
                        if matches and filtro_anno not in ["", "‚Äî"] and d and str(d.year) != filtro_anno: matches = False
                        if matches and filtro_mese_numero and d:
                            if d.strftime('%m') != filtro_mese_numero:
                                matches = False
                        try:
                            da = float(filtri.get("da", "") or "0")
                            a = float(filtri.get("a", "") or "999999999")
                            if matches and not (da <= float(importo) <= a): matches = False 
                        except (ValueError, TypeError): pass
                        if matches:
                            importo_formattato = f"{float(importo):.2f} ‚Ç¨"
                            iid = f"{giorno_interno}_{indice}" 
                            is_selected = iid in self.selezionate_iid
                            color_tag = 'entrata' if tipo == 'Entrata' else 'uscita'
                            tags = [color_tag]
                            if is_selected:
                                tags.append('selezionata')
                            checkbox_text = "[X]" if is_selected else "[ ]" 
                            self.spese_treeview.insert(
                                "", "end", iid=iid,
                                text=checkbox_text,
                                values=(giorno_visualizzato, categoria, descrizione, tipo, importo_formattato),
                                tags=tags
                            )
                            items_inserted += 1
                    except Exception:
                        continue
            if items_inserted == 0 and self.spese:
                self.spese_treeview.insert("", "end", iid="FILTER_MSG", 
                                           text="", 
                                           values=("‚Äî", "Nessun risultato.", "", "", ""),
                                           tags=('empty',))
        def aggiorna_stato_filtri():
            attivi = {k: v for k, v in self.filtri_cancellazione.items() if v and v != "‚Äî"}
            if not attivi:
                lbl_filtri_attivi.config(text="Nessun filtro attivo. Attiva un Filtro Avanzato.", fg="gray")
            else:
                testo_formattato = []
                for k, v in attivi.items():
                    if k == 'descrizione':
                        testo_formattato.append(f"Testo Globale: {v}")
                    else:
                        testo_formattato.append(f"{k.capitalize()}: {v}")
                testo = ", ".join(testo_formattato)
                lbl_filtri_attivi.config(text=f"Filtri attivi: {testo}", fg="dodgerblue")
        def apri_filtri_avanzati():
            filtro_win = tk.Toplevel(popup, bg=self.COLOR_TOPLEVEL)
            filtro_win.title("‚öôÔ∏è Filtri Avanzati di Cancellazione")
            larghezza_finestra = 400
            altezza_finestra = 350
            x = popup.winfo_rootx() + (popup.winfo_width() // 2) - (larghezza_finestra // 2)
            y = popup.winfo_rooty() + (popup.winfo_height() // 2) - (altezza_finestra // 2)
            filtro_win.geometry(f"{larghezza_finestra}x{altezza_finestra}+{x}+{y}")
            filtro_win.transient(popup)
            filtro_win.grab_set()
            filtro_win.bind("<Escape>", lambda e: filtro_win.destroy())
            descrizione_var = tk.StringVar(value=self.filtri_cancellazione.get("descrizione", ""))
            categoria_var = tk.StringVar(value=self.filtri_cancellazione.get("categoria", "‚Äî"))
            tipo_var = tk.StringVar(value=self.filtri_cancellazione.get("tipo", "‚Äî"))
            anno_var = tk.StringVar(value=self.filtri_cancellazione.get("anno", "‚Äî"))
            mese_var = tk.StringVar(value=self.filtri_cancellazione.get("mese", "‚Äî"))
            da_var = tk.StringVar(value=self.filtri_cancellazione.get("da", ""))
            a_var = tk.StringVar(value=self.filtri_cancellazione.get("a", ""))
            icona_var = tk.StringVar(value=self.filtri_cancellazione.get("icona", "‚Äî"))
            def crea_riga(testo, var, values=None):
                f = tk.Frame(filtro_win, bg=self.COLOR_TOPLEVEL); f.pack(fill="x", padx=12, pady=5)
                tk.Label(f, text=testo, fg=self.TEXT_COLOR, bg=self.COLOR_TOPLEVEL, width=16, anchor="w").pack(side="left") 
                if values:
                    ttk.Combobox(f, textvariable=var, values=values, style="Border.TCombobox", state="readonly", width=20).pack(side="left")
                else:
                    ttk.Entry(f, textvariable=var, width=22).pack(side="left")
            tutte_cat = ["‚Äî"] + sorted(list(self.categorie_tipi.keys()))
            anni = ["‚Äî"]
            for giorno_obj in self.spese.keys():
                try:
                    d = giorno_obj if isinstance(giorno_obj, datetime.date) else datetime.datetime.strptime(str(giorno_obj), "%Y-%m-%d").date()
                    anni.append(str(d.year))
                except Exception: continue
            anni = sorted(list(set(anni)), reverse=True)
            nomi_mesi_dropdown = ["‚Äî"] + NOMI_MESI_ITALIANO
            crea_riga("Testo Globale:", descrizione_var)
            crea_riga("Categoria:", categoria_var, tutte_cat)
            crea_riga("Tipo voce:", tipo_var, ["‚Äî", "Entrata", "Uscita"]) 
            crea_riga("Anno:", anno_var, anni)
            crea_riga("Mese:", mese_var, nomi_mesi_dropdown)
            crea_riga("Simbolo:", icona_var, ["‚Äî", "üí∞", "üîÑ", "üè¶", "üíé", "üí≥"])
            crea_riga("Importo da (‚Ç¨):", da_var)
            crea_riga("Importo a (‚Ç¨):", a_var)
            def applica():
                self.filtri_cancellazione = {
                    "descrizione": descrizione_var.get(),
                    "categoria": categoria_var.get(),
                    "tipo": tipo_var.get(),
                    "anno": anno_var.get(),
                    "mese": mese_var.get(), 
                    "da": da_var.get(),
                    "a": a_var.get(),
                    "icona": icona_var.get()
                }
                filtro_win.destroy()
                self.selezionate_iid.clear() 
                aggiorna_stato_filtri()
                popola_treeview_spese()
            def cancella_filtri():
                self.filtri_cancellazione = {}
                filtro_win.destroy()
                self.selezionate_iid.clear() 
                aggiorna_stato_filtri()
                popola_treeview_spese()
            f_btn = tk.Frame(filtro_win, bg=self.COLOR_TOPLEVEL); f_btn.pack(pady=10)
            ttk.Button(f_btn, text="‚úì Applica Filtri", command=applica, style="Verde.TButton").pack(side="left", padx=10)
            ttk.Button(f_btn, text="üéõ Cancella Filtri", command=cancella_filtri, style="Giallo.TButton").pack(side="right", padx=10)
        def seleziona_tutto_azione():
            all_children = self.spese_treeview.get_children()
            self.selezionate_iid.clear()
            items_to_select = []
            for iid in all_children:
                if iid in ("EMPTY_MSG", "FILTER_MSG", "NO_DATA"):
                    continue
                self.selezionate_iid.add(iid)
                items_to_select.append(iid)
            popola_treeview_spese()
        popup = tk.Toplevel(self.master, bg=self.COLOR_TOPLEVEL)
        popup.title("üìÑ Cancella Movimenti Multipli")
        larg, alt = 800, 600
        x = self.winfo_x() + (self.winfo_width() // 2) - (larg // 2)
        y = self.winfo_y() + (self.winfo_height() // 2) - (alt // 2)
        popup.geometry(f"{larg}x{alt}+{x}+{y}")
        popup.transient(self.master) 
        tk.Label(popup, text="Seleziona Movimenti da cancellare:", bg=self.COLOR_TOPLEVEL, fg=self.TEXT_COLOR, font=("Arial", 12, "bold")).pack(pady=(10, 5))
        filter_control_frame = tk.Frame(popup, bg=self.COLOR_TOPLEVEL)
        filter_control_frame.pack(fill='x', padx=10, pady=5)
        lbl_filtri_attivi = tk.Label(filter_control_frame, bg=self.COLOR_TOPLEVEL, text="", fg="gray")
        lbl_filtri_attivi.pack(side="left", fill='x', expand=True)
        ttk.Button(
            filter_control_frame,
            text="‚öôÔ∏è Filtri Avanzati",
            command=apri_filtri_avanzati, 
            style='Blu.TButton' 
        ).pack(side="right")
        tree_frame = tk.Frame(popup)
        tree_frame.pack(fill='both', expand=True, padx=10, pady=5) 
        scrollbar = ttk.Scrollbar(tree_frame, orient="vertical", style="Vertical.TScrollbar")
        scrollbar.pack(side="right", fill="y")
        self.spese_treeview = ttk.Treeview(
            tree_frame,
            columns=("Giorno", "Categoria", "Descrizione", "Tipo", "Importo"), 
            show=("tree", "headings"), 
            yscrollcommand=scrollbar.set,
            height=15
        )
        self.spese_treeview.pack(side="left", fill="both", expand=True) 
        scrollbar.config(command=self.spese_treeview.yview)
        self.spese_treeview.heading("#0", text="Sel.", anchor="center") 
        self.spese_treeview.heading("Giorno", text="Giorno", anchor="center", 
                                    command=lambda: sort_treeview_column(self.spese_treeview, "Giorno", True, data_type='date')) 
        self.spese_treeview.heading("Categoria", text="Categoria", anchor="center", 
                                    command=lambda: sort_treeview_column(self.spese_treeview, "Categoria", False, data_type='string'))
        self.spese_treeview.heading("Descrizione", text="Descrizione", anchor="center", 
                                    command=lambda: sort_treeview_column(self.spese_treeview, "Descrizione", False, data_type='string'))
        self.spese_treeview.heading("Tipo", text="Tipo", anchor="center", 
                                    command=lambda: sort_treeview_column(self.spese_treeview, "Tipo", False, data_type='string'))
        self.spese_treeview.heading("Importo", text="Importo", anchor="center", 
                                    command=lambda: sort_treeview_column(self.spese_treeview, "Importo", False, data_type='float'))
        self.spese_treeview.column("#0", width=40, anchor="center", stretch=False) 
        self.spese_treeview.column("Giorno", width=90, anchor="w", stretch=False)
        self.spese_treeview.column("Categoria", width=150, anchor="w", stretch=False)
        self.spese_treeview.column("Descrizione", width=200, anchor="w", stretch=True)
        self.spese_treeview.column("Tipo", width=60, anchor="center", stretch=False) 
        self.spese_treeview.column("Importo", width=100, anchor="e", stretch=False)
        self.spese_treeview.tag_configure('selezionata', background='#FFEBCC') 
        self.spese_treeview.tag_configure('entrata', foreground='green')
        self.spese_treeview.tag_configure('uscita', foreground='red') 
        self.spese_treeview.tag_configure('empty', foreground='gray', font=('Arial', 10, 'italic')) 
        self.spese_treeview.bind('<Button-1>', toggle_selection_treeview)
        btn_frame = tk.Frame(popup, bg=self.COLOR_TOPLEVEL)
        btn_frame.pack(pady=10) 
        ttk.Button(
            btn_frame,
            text="üìÑ Cancella Selezionate",
            command=esegui_cancellazione_azione,
            style='Rosso.TButton' 
        ).pack(side="left", padx=5)
        ttk.Button(
            btn_frame, 
            text="‚úì Seleziona Tutto", 
            command=seleziona_tutto_azione, 
            style='Verde.TButton'
        ).pack(side="left", padx=5)
        ttk.Button(
            btn_frame,
            text="üîÑ Deseleziona Tutto",
            command=lambda: [self.selezionate_iid.clear(), popola_treeview_spese()], 
            style='Giallo.TButton' 
        ).pack(side="left", padx=5)
        ttk.Button(
            btn_frame,
            text="‚ùå Chiudi",
            command=popup.destroy,
            style='Giallo.TButton' 
        ).pack(side="left", padx=5)
        aggiorna_stato_filtri() 
        popola_treeview_spese()
        sort_treeview_column(self.spese_treeview, "Giorno", True, data_type='date') 
        popup.grab_set()
    
    # Strumento di Ricerca Avanzata, Filtraggio ed Esportazione Transazioni
    def cerca_operazioni(self):
        larghezza, altezza = 900, 600
        x = self.winfo_screenwidth() // 2 - larghezza // 2
        y = self.winfo_screenheight() // 2 - altezza // 2
        finestra = tk.Toplevel(self, bg=self.COLOR_TOPLEVEL)
        finestra.title("Ricerca operazioni")
        finestra.geometry(f"{larghezza}x{altezza}+{x}+{y}")
        finestra.transient(self)
        finestra.bind("<Escape>", lambda e: finestra.destroy())
        frame_superiore = tk.Frame(finestra, bg=self.COLOR_TOPLEVEL )
        frame_superiore.pack(fill="x", pady=10, padx=10)
        tk.Label(frame_superiore, bg=self.COLOR_TOPLEVEL, fg=self.TEXT_COLOR, text="üîé Ricerca generale:").pack(side="left")
        campo_input = ttk.Entry(frame_superiore, width=30)
        campo_input.pack(side="left", padx=8)
        campo_input.focus_set()
        mostra_futuro_var = tk.BooleanVar(value=True)
        ttk.Checkbutton(frame_superiore, text="Includi futuri", variable=mostra_futuro_var).pack(side="left", padx=10)
        frame_risultati = tk.Frame(finestra)
        frame_risultati.pack(fill="both", expand=True, padx=10)
        columns = ("Data", "Categoria", "Descrizione", "Tipo", "Importo")
        tree = ttk.Treeview(frame_risultati, columns=columns, show="headings")
        tree.pack(side="left", fill="both", expand=True)
        tree.bind("<Double-1>", self.cerca_doppio_click)
        def converti_importo(s):
            s = str(s).strip()
            s = s.replace('‚Ç¨', '').strip()
            s = s.replace(',', '')
            if s.count(',') == 1 and s.count('.') != 1:
                s = s.replace(',', '.')
            try:
                return float(s)
            except ValueError:
                return float('-inf')
        def converti_data(s):
            try:
                return datetime.datetime.strptime(str(s), '%d/%m/%Y')
            except ValueError:
                return datetime.datetime.min
        def formatta_italiano(numero):
            s = "{:,.2f}".format(numero).replace('.', '#').replace(',', '.').replace('#', ',')
            return s
        def sort_by_column(tv, col, reverse):
            cols = list(tv["columns"])
            try:
                col_index = cols.index(col)
            except ValueError:
                return
            l = []
            for k in tv.get_children(''):
                item_values = tv.item(k, 'values')
                if item_values and len(item_values) > col_index:
                    if col == "Importo":
                        sort_value = converti_importo(item_values[col_index])
                    elif col == "Data":
                        sort_value = converti_data(item_values[col_index])
                    else:
                        sort_value = item_values[col_index]
                    l.append((sort_value, k))
                else:
                    l.append(('', k))
            l.sort(key=lambda t: t[0], reverse=reverse)
            for index, (val, k) in enumerate(l):
                tv.move(k, '', index)
            tv.heading(col, command=lambda: sort_by_column(tv, col, not reverse))
        for col in columns:
            tree.heading(col, text=col, command=lambda c=col: sort_by_column(tree, c, False))
            if col == "Importo":
                tree.column(col, anchor="e")
            else:
                tree.column(col, anchor="w")
        tree.column("Data", width=90, stretch=False)
        tree.column("Categoria", width=120, stretch=False)
        tree.column("Descrizione", width=300, stretch=True)
        tree.column("Tipo", width=80, stretch=False)
        tree.column("Importo", width=100, stretch=False)
        scroll = ttk.Scrollbar(frame_risultati, orient="vertical", command=tree.yview, style="Vertical.TScrollbar")
        tree.configure(yscrollcommand=scroll.set)
        scroll.pack(side="right", fill="y")
        tree.tag_configure("entrata_tag", foreground="green")
        tree.tag_configure("uscita_tag", foreground="red")
        tree.tag_configure("neutro_tag", foreground="gray")
        frame_totali = tk.Frame(finestra)
        frame_totali.pack(fill="x", pady=10, padx=10)
        lbl_risultati = tk.Label(frame_totali, text="", anchor="w", font=("Arial", 10))
        lbl_risultati.pack(fill="x")
        lbl_totali = tk.Label(frame_totali, text="", anchor="w", font=("Arial", 10, "bold"))
        lbl_totali.pack(fill="x")
        def esegui_ricerca(event=None):
            parola = campo_input.get().strip().lower()
            filtri = getattr(self, "filtri_avanzati", {})
            if parola:
                filtri = {}
            for item in tree.get_children():
                tree.delete(item)
            risultati = []
            oggi = datetime.date.today()
            mostra_futuro = mostra_futuro_var.get()
            for data_key in sorted(self.spese.keys(), reverse=True):
                try:
                    d = data_key if isinstance(data_key, datetime.date) else datetime.datetime.strptime(data_key, "%d-%m-%Y").date()
                except ValueError:
                    d = datetime.datetime.strptime(data_key, "%Y-%m-%d").date()
                if not mostra_futuro and d > oggi:
                    continue
                for voce in self.spese[data_key]:
                    categoria = str(voce[0]).lower()
                    descrizione = str(voce[1]).lower()
                    importo_voce = voce[2]
                    tipo = str(voce[3]).lower()
                    matches = True
                    if parola:
                        if not any(parola in str(campo).lower() for campo in [categoria, descrizione, tipo, str(importo_voce)]):
                            matches = False
                    elif filtri:
                        if filtri.get("descrizione") and filtri["descrizione"].lower() not in descrizione:
                            matches = False
                        if filtri.get("categoria") not in ["", "‚Äî"] and categoria != filtri["categoria"].lower():
                            matches = False
                        if filtri.get("tipo") not in ["", "‚Äî"] and tipo != filtri["tipo"].lower():
                            matches = False
                        if filtri.get("icona") not in ["", "‚Äî"]:
                            icona = filtri["icona"]
                            if icona not in descrizione:
                                matches = False
                        if filtri.get("anno") not in ["", "‚Äî"] and str(d.year) != filtri["anno"]:
                            matches = False
                        if filtri.get("mese") not in ["", "‚Äî"]:
                            mesi_nomi = ["Gennaio", "Febbraio", "Marzo", "Aprile", "Maggio", "Giugno",
                                         "Luglio", "Agosto", "Settembre", "Ottobre", "Novembre", "Dicembre"]
                            mesi_map = {m: i+1 for i, m in enumerate(mesi_nomi)}
                            if d.month != mesi_map.get(filtri["mese"], 0):
                                matches = False
                        try:
                            da_val = converti_importo(filtri.get("da", "0")) 
                            a_val = converti_importo(filtri.get("a", "999999999"))
                            da = da_val if da_val != float('-inf') else 0.0
                            a = a_val if a_val != float('-inf') else 999999999.0
                            if not (da <= float(importo_voce) <= a):
                                matches = False
                        except (ValueError, TypeError):
                            pass
                    if matches:
                        risultati.append({
                            "data": d.strftime('%d/%m/%Y'),
                            "categoria": voce[0],
                            "descrizione": voce[1],
                            "importo": importo_voce,
                            "tipo": tipo.capitalize()
                        })
            risultati.sort(key=lambda x: datetime.datetime.strptime(x['data'], '%d/%m/%Y'), reverse=True)
            tot_entrate = sum(r['importo'] for r in risultati if r['tipo'] == "Entrata")
            tot_uscite = sum(r['importo'] for r in risultati if r['tipo'] == "Uscita")
            testo_filtri = ""
            if parola:
                testo_filtri = f"Parola chiave: '{parola}'"
            elif filtri:
                testo_filtri = ", ".join([f"{k.capitalize()}: {v}" for k, v in filtri.items() if v not in ["", "‚Äî"]])
            lbl_risultati.config(text=f"üìä Operazioni trovate: {len(risultati)} | Filtri attivi: {testo_filtri or 'Nessuno'}")
            netto = tot_entrate - tot_uscite
            tot_entrate_fmt = formatta_italiano(tot_entrate)
            tot_uscite_fmt = formatta_italiano(tot_uscite)
            netto_fmt = formatta_italiano(netto)
            lbl_totali.config(text=f"‚úì Entrate: {tot_entrate_fmt} ‚Ç¨ | ‚ùå Uscite: {tot_uscite_fmt} ‚Ç¨ | üßÆ Saldo: {netto_fmt} ‚Ç¨")
            if not risultati:
                lbl_risultati.config(
                    text=f"üîç Nessuna corrispondenza per la ricerca attuale.", 
                    fg="gray", 
                    bg=self.COLOR_TOPLEVEL
                )
                lbl_totali.config(text="", fg="gray", bg=self.COLOR_TOPLEVEL)
            else:
                lbl_risultati.config(
                    fg=self.TEXT_COLOR,
                    bg=self.COLOR_TOPLEVEL
                )
                lbl_totali.config(
                    fg=self.TEXT_COLOR,     
                    bg=self.COLOR_TOPLEVEL
                )
                for riga in risultati:
                    tipo = riga['tipo'].lower()
                    tag = "entrata_tag" if tipo == "entrata" else "uscita_tag" if tipo == "uscita" else "neutro_tag"
                    tree.insert("", "end", values=(riga['data'], riga['categoria'], riga['descrizione'], riga['tipo'], f"{riga['importo']:,.2f} ‚Ç¨"), tags=(tag,))
            campo_input.bind("<KeyRelease>", esegui_ricerca)
        def resetta_campo():
            campo_input.delete(0, tk.END)
            self.filtri_avanzati = {}
            for item in tree.get_children():
                tree.delete(item)
            lbl_risultati.config(text="üîç Nessuna corrispondenza per la ricerca attuale.", fg="gray")
            lbl_totali.config(text="")
            self.after(100, esegui_ricerca)
        ttk.Button(frame_superiore, text="üîô", command=resetta_campo, style="Yellow.TButton").pack(side="left", padx=5)
        def apri_filtri_avanzati():
            self.filtri_avanzati = getattr(self, "filtri_avanzati", {})
            parola_chiave = campo_input.get().strip()
            campo_input.delete(0, tk.END)
            if parola_chiave:
                self.filtri_avanzati = {} 
            filtro_win = tk.Toplevel(finestra, bg=self.COLOR_TOPLEVEL)
            filtro_win.title("‚öôÔ∏è Filtri avanzati")
            larghezza_finestra = 400
            altezza_finestra = 350
            x = finestra.winfo_rootx() + (finestra.winfo_width() // 2) - (larghezza_finestra // 2)
            y = finestra.winfo_rooty() + (finestra.winfo_height() // 2) - (altezza_finestra // 2)
            filtro_win.geometry(f"{larghezza_finestra}x{altezza_finestra}+{x}+{y}")
            filtro_win.transient(finestra)
            filtro_win.grab_set()
            filtro_win.bind("<Escape>", lambda e: filtro_win.destroy())
            descrizione_var = tk.StringVar(value=self.filtri_avanzati.get("descrizione", ""))
            categoria_var = tk.StringVar(value=self.filtri_avanzati.get("categoria", "‚Äî"))
            tipo_var = tk.StringVar(value=self.filtri_avanzati.get("tipo", "‚Äî"))
            anno_var = tk.StringVar(value=self.filtri_avanzati.get("anno", "‚Äî"))
            mese_var = tk.StringVar(value=self.filtri_avanzati.get("mese", "‚Äî"))
            da_var = tk.StringVar(value=self.filtri_avanzati.get("da", ""))
            a_var = tk.StringVar(value=self.filtri_avanzati.get("a", ""))
            icona_var = tk.StringVar(value=self.filtri_avanzati.get("icona", "‚Äî"))
            def crea_riga(testo, var, values=None):
                f = tk.Frame(filtro_win, bg=self.COLOR_TOPLEVEL); f.pack(fill="x", padx=12, pady=5)
                tk.Label(f, text=testo, fg=self.TEXT_COLOR, bg=self.COLOR_TOPLEVEL, width=14, anchor="w").pack(side="left")
                if values:
                    ttk.Combobox(f, textvariable=var, values=values, style="Border.TCombobox", state="readonly", width=22).pack(side="left")
                else:
                    ttk.Entry(f, textvariable=var, width=24).pack(side="left")
            tutte_cat = sorted(list(self.categorie_tipi.keys()))
            anni = sorted(set(str(d.year if isinstance(d, datetime.date)else datetime.datetime.strptime(d, "%d-%m-%Y").year) for d in self.spese if self.spese), reverse=True)
            mesi_nomi = ["Gennaio", "Febbraio", "Marzo", "Aprile", "Maggio", "Giugno",
                         "Luglio", "Agosto", "Settembre", "Ottobre", "Novembre", "Dicembre"]           
            crea_riga("Descrizione:", descrizione_var)
            crea_riga("Categoria:", categoria_var, ["‚Äî"] + tutte_cat)
            crea_riga("Tipo voce:", tipo_var, ["‚Äî", "Entrata", "Uscita"])
            crea_riga("Anno:", anno_var, ["‚Äî"] + anni)
            crea_riga("Mese:", mese_var, ["‚Äî"] + mesi_nomi)
            icone_simboli = ["‚Äî", "üí∞", "üîÑ", "üè¶", "üíé", "üí≥"]
            crea_riga("Simbolo:", icona_var, icone_simboli)
            crea_riga("Importo da:", da_var)
            crea_riga("Importo a:", a_var)
            def applica():
                self.filtri_avanzati = {
                    "descrizione": descrizione_var.get(),
                    "categoria": categoria_var.get(),
                    "tipo": tipo_var.get(),
                    "anno": anno_var.get(),
                    "mese": mese_var.get(),
                    "da": da_var.get(),
                    "a": a_var.get(),
                    "icona": icona_var.get()
                }
                filtro_win.destroy()
                esegui_ricerca()
            def cancella():
                self.filtri_avanzati = {}
                filtro_win.destroy()
                esegui_ricerca()
            f_btn = tk.Frame(filtro_win, bg=self.COLOR_TOPLEVEL); f_btn.pack(pady=10)
            ttk.Button(f_btn, text="‚úì Applica", command=applica, style="Verde.TButton").pack(side="left", padx=10)
            ttk.Button(f_btn, text="üéõ Cancella filtri", command=cancella, style="Giallo.TButton").pack(side="right", padx=10)
        def esporta_risultato():
            dati_tree = []
            tot_entrate = 0.0
            tot_uscite = 0.0
            for item in tree.get_children():
                values = tree.item(item, "values")
                if values:
                    data, cat, desc, tipo, importo_str = values
                    importo_float = converti_importo(importo_str) 
                    dati_tree.append((data, cat, desc, tipo, importo_float))
                    if tipo == "Entrata":
                        tot_entrate += importo_float
                    elif tipo == "Uscita":
                        tot_uscite += importo_float
            if not dati_tree:
                self.show_custom_warning("Esportazione", "‚ö†Ô∏è Nessun risultato trovato da salvare o stampare.")
                return
            W_DATA, W_CAT, W_DESC, W_TIPO, W_IMP = 10, 20, 28, 8, 15 
            header = f"{'Data':<{W_DATA}} | {'Categoria':<{W_CAT}} | {'Descrizione':<{W_DESC}} | {'Tipo':<{W_TIPO}} | {'Importo (‚Ç¨)':>{W_IMP}}\n"
            separator = f"{'-'*W_DATA}-+-{'-'*W_CAT}-+-{'-'*W_DESC}-+-{'-'*W_TIPO}-+-{'-'*W_IMP}\n"
            testo_filtri_attivi = lbl_risultati.cget("text").split("| Filtri attivi:")[1].strip()
            contenuto_preview = f"--- RISULTATI RICERCA ({datetime.date.today():%d/%m/%Y}) ---\n"
            contenuto_preview += f"Filtri: {testo_filtri_attivi}\n"
            contenuto_preview += f"Operazioni Trovate: {len(dati_tree)}\n\n"
            contenuto_preview += f"--- RIEPILOGO FINANZIARIO ---\n"
            tot_entrate_fmt = formatta_italiano(tot_entrate)
            tot_uscite_fmt = formatta_italiano(tot_uscite)
            netto_fmt = formatta_italiano(tot_entrate - tot_uscite)
            contenuto_preview += f"Entrate Totali: {tot_entrate_fmt} ‚Ç¨\n"
            contenuto_preview += f"Uscite Totali:¬† {tot_uscite_fmt} ‚Ç¨\n"
            contenuto_preview += f"Saldo Netto:¬† ¬† {netto_fmt} ‚Ç¨\n\n"
            contenuto_preview += "--- DETTAGLIO OPERAZIONI ---\n"
            contenuto_preview += header + separator
            for data, cat, desc, tipo, importo_float in dati_tree:
                imp_display = formatta_italiano(importo_float)
                desc_troncata = (desc[:W_DESC-3] + '...') if len(desc) > W_DESC else desc
                cat_troncata = (cat[:W_CAT-3] + '...') if len(cat) > W_CAT else cat
                contenuto_preview += f"{data:<{W_DATA}} | {cat_troncata:<{W_CAT}} | {desc_troncata:<{W_DESC}} | {tipo:<{W_TIPO}} | {imp_display:>{W_IMP}}\n"
            contenuto_preview += "\n" + separator
            def _salva_su_file(content_text, default_name, preview_popup):
                preview_popup.destroy()
                nome_file = f"Risultati_Ricerca_{datetime.date.today():%d_%m_%Y}.txt"
                file = filedialog.asksaveasfilename(
                    defaultextension=".txt", 
                    filetypes=[("File di testo", "*.txt")],
                    initialdir=EXPORT_FILES,
                    initialfile=nome_file,
                    title="Salva risultati ricerca",
                    confirmoverwrite=False,
                    parent=finestra
                )
                if file:
                    if os.path.exists(file):
                        conferma = self.show_custom_askyesno(
                            "Sovrascrivere file?",
                            f"Il file '{os.path.basename(file)}' \nesiste gi√†. Vuoi sovrascriverlo?"
                        )
                        if not conferma:
                            return
                    try:
                        with open(file, "w", encoding="utf-8") as f:
                            f.write(content_text) 
                        self.show_custom_warning("Esportazione completata", f"‚úì Risultati salvati:\n{file}")
                    except Exception as e:
                        self.show_custom_warning("Errore", f"‚ùå Salvataggio fallito:\n{e}")
            preview_popup = tk.Toplevel(finestra, bg=self.COLOR_TOPLEVEL)
            preview_popup.title("üìÑ Anteprima Risultati Ricerca")
            WIDTH = 800
            HEIGHT = 500
            screen_width = preview_popup.winfo_screenwidth()
            screen_height = preview_popup.winfo_screenheight()
            x = (screen_width - WIDTH) // 2
            y = (screen_height - HEIGHT) // 2
            preview_popup.geometry(f"{WIDTH}x{HEIGHT}+{x}+{y}")
            preview_popup.transient(finestra)
            preview_popup.grab_set()
            preview_popup.bind('<Escape>', lambda e: preview_popup.destroy())
            text_area = tk.Text(preview_popup, wrap='word', font=('Courier', 10), padx=10, pady=10)
            text_area.insert('1.0', contenuto_preview) 
            text_area.config(state='disabled')
            text_area.pack(fill='both', expand=True, padx=10, pady=10)
            frame_btn = tk.Frame(preview_popup, bg=self.COLOR_TOPLEVEL)
            frame_btn.pack(pady=(0, 10))
            nome_file_default = f"Risultati_Ricerca_{datetime.date.today():%d_%m_%Y}.txt"           
            ttk.Button(
                frame_btn, 
                text="‚ùå Chiudi Anteprima", 
                command=preview_popup.destroy, 
                style='Giallo.TButton'
            ).pack(side='right', padx=5)
            ttk.Button(
                frame_btn, 
                text="üì§ Esporta", 
                style='Verde.TButton',
                command=lambda: _salva_su_file(contenuto_preview, nome_file_default, preview_popup)
            ).pack(side='left', padx=5)
            if hasattr(self, '_stampa_lista_diretta'):
                ttk.Button(
                    frame_btn, 
                    text="üìÑ Stampa", 
                    style='Blu.TButton',
                    command=lambda: self._stampa_lista_diretta(
                        contenuto_preview, 
                        self.show_custom_warning
                    )
                ).pack(side='left', padx=5) 
            preview_popup.wait_window(preview_popup)
        frame_bottoni = tk.Frame(finestra, bg=self.COLOR_TOPLEVEL)
        frame_bottoni.pack(pady=(0, 12))
        ttk.Button(frame_bottoni, text="üîç Cerca", command=esegui_ricerca, style="Verde.TButton").pack(side="left", padx=6)
        ttk.Button(frame_bottoni, text="üìÑ Esporta", command=esporta_risultato, style="Arancio.TButton").pack(side="left", padx=6)
        ttk.Button(frame_bottoni, text="‚öôÔ∏è Filtri avanzati", command=apri_filtri_avanzati, style="Blu.TButton").pack(side="left", padx=6)
        ttk.Button(frame_bottoni, text="üîô Reset", command=resetta_campo, style="Giallo.TButton").pack(side="left", padx=6)
        ttk.Button(frame_bottoni, text="‚ùå Chiudi", command=finestra.destroy, style="Giallo.TButton").pack(side="left", padx=6)
        self.after(100, esegui_ricerca)
    def cerca_doppio_click(self, event):
        tree = event.widget
        item_id = tree.focus()
        if not item_id:
            return
        vals = tree.item(item_id, "values")
        if not vals or len(vals) < 1:
            return
        data_str = vals[0]  
        try:
            giorno = datetime.datetime.strptime(data_str, "%d/%m/%Y").date()
        except Exception:
            return
        self.set_stats_mode("giorno")
        if hasattr(self, "cal"):
            self.cal.selection_set(giorno)
            self.cal._sel_date = giorno
            self.stats_refdate = giorno
        self.update_stats()
        self.estratto_month_var.set(f"{giorno.month:02d}")
        self.estratto_year_var.set(str(giorno.year))
        self.stats_label.config(text=f"Riepilogo Giornaliero - {giorno.strftime('%d-%m-%Y')}", foreground="purple",
    font=("Arial", 10, "bold"))

    # Popup Rubrica
    def rubrica_app(self):
        if hasattr(self, '_rubrica_window') and self._rubrica_window and self._rubrica_window.winfo_exists():
            self._rubrica_window.lift()
            return
        root = tk.Toplevel(self) 
        self._rubrica_window = root     
        def on_rubrica_close():
            root.destroy()
            self._rubrica_window = None
        root.protocol("WM_DELETE_WINDOW", on_rubrica_close)
        root.bind("<Escape>", lambda e: on_rubrica_close())
        root.title("Rubrica Contatti")
        window_width, window_height = 1100, 600
        screen_width = root.winfo_screenwidth()
        screen_height = root.winfo_screenheight()
        pos_x = (screen_width - window_width) // 2
        pos_y = (screen_height - window_height) // 2
        root.geometry(f"{window_width}x{window_height}+{pos_x}+{pos_y}")
        root.configure(bg=self.COLOR_TOPLEVEL)
        barra_menu_popup = tk.Menu(root, bg=self.MENU_BG_DARK, fg=self.MENU_FG_LIGHT, activebackground=self.MENU_ACT_BG_COLOR, activeforeground=self.MENU_ACT_FG_COLOR)
        barra_menu_popup.config(bg=self.MENU_BG_DARK, fg=self.MENU_FG_LIGHT)
        root.config(menu=barra_menu_popup)
        menu_db = tk.Menu(barra_menu_popup, tearoff=0,bg=self.MENU_BG, fg=self.MENU_FG_LIGHT, activebackground=self.MENU_ACT_BG_COLOR, activeforeground=self.MENU_ACT_FG_COLOR)
        barra_menu_popup.add_cascade(label="üíæ Database", menu=menu_db)
        menu_db.add_command(label="üì§ Esporta DataBase", command=lambda: esporta_rubrica())
        menu_db.add_command(label="üì• Importa Database", command=lambda: importa_rubrica())
        menu_db.add_separator()
        menu_db.add_command(label="üì• Importa Rubrica vCard", command=lambda: importa_vcf_rubrica())
        menu_db.add_separator()
        menu_db.add_command(label="üì• Reset DataBase", command=lambda: reset_rubrica())
        menu_db.add_separator()
        menu_db.add_command(label="‚ùå Chiudi", command=lambda: on_rubrica_close())
        contatti = []
        def ordina_contatti():
            contatti.sort(key=lambda c: c["nome"].lower())
        def salva_su_json():
            with open(DATI_FILE, "w", encoding="utf-8") as f:
                json.dump(contatti, f, indent=2, ensure_ascii=False)
        def pulisci_campi():
            entry_nome.delete(0, tk.END)
            entry_telefono.delete(0, tk.END)
            entry_email.delete(0, tk.END)
            entry_note.delete("1.0", tk.END)
            tree_contatti.selection_remove(tree_contatti.selection()) 
        def aggiorna_lista():
            for i in tree_contatti.get_children():
                tree_contatti.delete(i)
            if not contatti:
                tree_contatti.insert("", tk.END, text="0", 
                                     values=("Aggiungi il tuo primo contatto!", "", "", ""), 
                                     tags=('empty',))
            else:
                for i, c in enumerate(contatti):
                    tree_contatti.insert("", tk.END, iid=i, 
                                        values=(c["nome"], c["telefono"], c["email"], c["note"]))
        def carica_da_json():
            if os.path.exists(DATI_FILE):
                with open(DATI_FILE, "r", encoding="utf-8") as f:
                    try:
                        dati = json.load(f)
                        contatti.clear()
                        contatti.extend(dati)
                        ordina_contatti()
                        aggiorna_lista()
                    except:
                        self.show_custom_warning("Attenzione", "File rubrica non valido !")
        def seleziona_contatto(event):
            selected_items = tree_contatti.selection()
            if not selected_items:
                return
            iid = selected_items[0]
            if tree_contatti.tag_has('empty', iid):
                pulisci_campi()
                return
            try:
                indice = int(iid)
                c = contatti[indice] 
            except (ValueError, IndexError):
                pulisci_campi()
                return
            entry_nome.delete(0, tk.END)
            entry_nome.insert(0, c["nome"])
            entry_telefono.delete(0, tk.END)
            entry_telefono.insert(0, c["telefono"])
            entry_email.delete(0, tk.END)
            entry_email.insert(0, c["email"])
            entry_note.delete("1.0", tk.END)
            entry_note.insert("1.0", c["note"])
        def aggiungi_contatto():
            nome = entry_nome.get().strip()
            telefono = entry_telefono.get().strip()
            email = entry_email.get().strip()
            note = entry_note.get("1.0", tk.END).strip()
            if len(nome) > 43 or len(telefono) > 43 or len(email) > 43 or len(note) > 100:
                self._show_custom_message("Limite superato", "Hai superato il limite massimo di caratteri:\n\n"
                                     "- Nome: 43\n- Telefono: 43\n- Email: 43\n- Note:100",
                                     "#fff3cd", "#856404")
                return
            if nome:
                contatti.append({"nome": nome, "telefono": telefono, "email": email, "note": note})
                ordina_contatti()
                salva_su_json()
                aggiorna_lista()
                pulisci_campi()
                self.show_custom_warning("Attenzione", "Contatto aggiunto correttamente !")
        def modifica_contatto():
            selected_items = tree_contatti.selection()
            if not selected_items: 
                self.show_custom_warning("Attenzione", "Seleziona un contatto da modificare.")
                return
            iid = selected_items[0]
            if tree_contatti.tag_has('empty', iid):
                 self.show_custom_warning("Attenzione", "Seleziona un contatto valido da modificare.")
                 return
            try:
                i = int(iid)
            except ValueError:
                self.show_custom_warning("Errore", "Selezione non valida per la modifica.")
                return
            contatti[i] = {
                "nome": entry_nome.get().strip(),
                "telefono": entry_telefono.get().strip(),
                "email": entry_email.get().strip(),
                "note": entry_note.get("1.0", tk.END).strip()
            }
            ordina_contatti()
            salva_su_json()
            pulisci_campi() 
            aggiorna_lista()
            self.show_custom_warning("Attenzione", "Contatto modificato correttamente!")
        def cancella_contatto():
            selected_items = tree_contatti.selection()
            if not selected_items: return
            iid = selected_items[0]
            if tree_contatti.tag_has('empty', iid):
                self.show_custom_warning("Attenzione", "Nessun contatto valido selezionato per la cancellazione.")
                return
            try:
                i = int(iid)
            except ValueError:
                return
            contatti.pop(i) 
            salva_su_json()
            pulisci_campi() 
            aggiorna_lista()
            self.show_custom_warning("Attenzione", "Contatto cancellato con successo !")
        def cerca_contatto(event=None):
            query = entry_cerca.get().lower()
            for i in tree_contatti.get_children():
                tree_contatti.delete(i)
            risultati_trovati = False
            if not query:
                aggiorna_lista()
                return
            for i, c in enumerate(contatti):
                if query in c["nome"].lower() or query in c["telefono"].lower() or query in c["email"].lower():
                    tree_contatti.insert("", tk.END, iid=i, 
                                        values=(c["nome"], c["telefono"], c["email"], c["note"]))
                    risultati_trovati = True
            if not risultati_trovati:
                tree_contatti.insert("", tk.END, tags=('empty',), 
                                     values=("Nessun contatto trovato.", "", "", ""))
            pulisci_campi()
        def reset_rubrica():
            conferma = self.show_custom_askyesno(
            )
            if conferma:
                try:
                    if os.path.exists(DATI_FILE):
                        os.remove(DATI_FILE)
                    contatti.clear()
                    aggiorna_lista()
                    self.show_custom_warning("Reset", "Rubrica resettata con successo. Contatti e file dati eliminati.")
                except Exception as e:
                    self.show_custom_warning("Errore", f"Si √® verificato un errore durante il reset del file:\n{e}")
        def _parse_vcard_content_inner(vcard_content):
            contatti_importati = []
            vcard_blocks = re.findall(r"BEGIN:VCARD.*?END:VCARD", vcard_content, re.DOTALL)
            for block in vcard_blocks:
                nome = ""
                all_telefoni = []
                email_principale = ""
                note = [] 
                for line in block.split('\n'):
                    line = line.strip()
                    if not line:
                        continue
                    if line.startswith(' '):
                        if note:
                            note[-1] += line.strip()
                        continue
                    match_prop = re.match(r"([^:]+):(.*)", line, re.IGNORECASE)
                    if not match_prop:
                        continue
                    prop_data = match_prop.group(1).split(';')
                    prop_name = prop_data[0].upper()
                    prop_value = match_prop.group(2).strip()
                    if prop_name == "FN":
                        nome = prop_value                        
                    elif prop_name == "TEL":
                        number = prop_value.replace('-', ' ').strip()
                        if number:
                             all_telefoni.append(number)
                    elif prop_name == "EMAIL":
                        if not email_principale:
                            email_principale = prop_value.strip()
                        else:
                            note.append(prop_value.strip()) 
                    elif prop_name == "ADR":
                        addr_parts = prop_value.split(';')
                        street = addr_parts[2].strip() if len(addr_parts) > 2 and addr_parts[2] else ""
                        city = addr_parts[3].strip() if len(addr_parts) > 3 and addr_parts[3] else ""
                        region = addr_parts[4].strip() if len(addr_parts) > 4 and addr_parts[4] else ""
                        clean_addr = []
                        if street:
                            clean_addr.append(street)
                        if city:
                            clean_addr.append(city)
                        if region and region != city:
                            clean_addr.append(region)
                        if clean_addr:
                            note.append(', '.join(clean_addr))
                    elif prop_name == "ORG":
                        note.append(prop_value.strip())
                    elif prop_name == "NOTE":
                        note.append(prop_value.strip())
                    elif prop_name in ["URL"]:
                        note.append(f"{prop_name}: {prop_value.strip()}")
                telefono_finale = ', '.join(all_telefoni)
                note_finale = "\n".join(note)
                if nome:
                    contatti_importati.append({
                        "nome": nome,
                        "telefono": telefono_finale, 
                        "email": email_principale,
                        "note": note_finale
                    })
            return contatti_importati
        def importa_vcf_rubrica():
            initial_dir = EXP_DB if 'EXP_DB' in globals() else os.getcwd()
            path = filedialog.askopenfilename(
                defaultextension=".vcf",
                filetypes=[("File VCF", "*.vcf")],
                initialdir=initial_dir,
                title="Importa Rubrica da File .vCard",
                parent=root
            )
            if path:
                try:
                    with open(path, "r", encoding="utf-8") as f:
                        vcf_content = f.read()
                    dati_importati = _parse_vcard_content_inner(vcf_content)
                    if dati_importati:
                        conferma = self.show_custom_askyesno(
                            "Importazione vCard",
                            f"Trovati {len(dati_importati)} contatti.\nVuoi SOSTITUIRE la rubrica esistente con i nuovi contatti (S√¨) o UNIRLI (No)?"
                        )
                        if conferma:
                            contatti.clear()
                            contatti.extend(dati_importati)
                            self.show_custom_warning("Importazione vCard", f"Rubrica SOSTITUITA con {len(dati_importati)} contatti.")
                        else:
                            contatti.extend(dati_importati)
                            self.show_custom_warning("Importazione vCard", f"Aggiunti {len(dati_importati)} contatti alla rubrica esistente.")
                        ordina_contatti()
                        salva_su_json()
                        aggiorna_lista()
                    else:
                        self.show_custom_warning("Attenzione", "Il file vCard non contiene contatti validi.")
                except Exception as e:
                    self.show_custom_warning("Errore di Importazione", f"Impossibile leggere o analizzare il file vCard:\n{e}")
        def esporta_rubrica():
            now = datetime.date.today()
            default_dir = EXP_DB 
            default_filename = f"{now.day:02d}-{now.month:02d}-{now.year}-rubrica.json"
            if not contatti:
                self.show_custom_warning("Attenzione", "Nessun contatto, la rubrica e' vuota !")
                return
            path = filedialog.asksaveasfilename(
                defaultextension=".json",
                filetypes=[("File JSON", "*rubrica.json"), ("Tutti i file", "*.*")],
                initialdir=default_dir,
                initialfile=default_filename,
                title="Salva Rubrica .json",
                confirmoverwrite=False,
                parent=root
            )
            if path:
                try:
                    with open(path, "w", encoding="utf-8") as f:
                        json.dump(contatti, f, indent=2, ensure_ascii=False)
                    self.show_custom_warning("Attenzione", f"Rubrica salvata con successo in {path}")
                except Exception as e:
                    self.show_custom_warning("Attenzione", f"Impossibile salvare la rubrica:\n{e}")
        def importa_rubrica():
            path = filedialog.askopenfilename(
                defaultextension=".json",
                filetypes=[("File JSON", "*rubrica.json"), ("Tutti i file", "*.*")],
                initialdir=EXP_DB,
                parent=root
            )
            if path:
                try:
                    with open(path, "r", encoding="utf-8") as f:
                        dati_importati = json.load(f)
                        if isinstance(dati_importati, list):
                            contatti.clear()
                            contatti.extend(dati_importati)
                            ordina_contatti()
                            aggiorna_lista()
                            self.show_custom_warning("Importazione riuscita", "Rubrica importata correttamente!")
                        else:
                            self.show_custom_warning("Errore", "Il file selezionato non contiene una rubrica valida (non √® un elenco).")
                except json.JSONDecodeError:
                    self.show_custom_warning("Errore", "Il file non √® un JSON valido.")
                except Exception as e:
                    self.show_custom_warning("Errore", f"Impossibile importare la rubrica:\n{e}")
        def esporta_txt():
            if not contatti:
                self.show_custom_warning("Attenzione", "Nessun Contatto. Rubrica vuota. L'anteprima non pu√≤ essere aperta.")
                return
            contenuto_txt = []
            for c in contatti:
                linea1 = f"Nome: {c['nome']}  Telefono: {c['telefono']}"
                linea2 = f"Email: {c['email']}"
                linea3 = f"Note: {c['note']}"
                contenuto_txt.append(linea1)
                if c['email']:
                    contenuto_txt.append(linea2)
                if c['note']:
                    contenuto_txt.append(linea3)
                contenuto_txt.append("-" * 70)
            contenuto = "\n".join(contenuto_txt).strip()
            if not contenuto:
                self.show_custom_warning("Esporta", "Contenuto rubrica generato vuoto. Nulla da esportare.")
                return
            try:
                preview = tk.Toplevel(root, bg=self.COLOR_TOPLEVEL) 
                preview.title("Preview Esportazione Rubrica")
                larghezza_finestra = 800
                altezza_finestra = 600
                x = root.winfo_rootx() + (root.winfo_width() // 2) - (larghezza_finestra // 2)
                y = root.winfo_rooty() + (root.winfo_height() // 2) - (altezza_finestra // 2)
                preview.geometry(f"{larghezza_finestra}x{altezza_finestra}+{x}+{y}")
                preview.transient(root)
                preview.grab_set()
                preview.focus_set()
                preview.bind("<Escape>", lambda e: preview.destroy())
                text_frame = tk.Frame(preview)
                text_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=(10, 5))
                vsb = ttk.Scrollbar(text_frame, orient="vertical", style="Vertical.TScrollbar")
                vsb.pack(side=tk.RIGHT, fill=tk.Y)
                tx = tk.Text(text_frame, font=("Courier new", 10), wrap="none", yscrollcommand=vsb.set)
                tx.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
                vsb.config(command=tx.yview)
                tx.insert(tk.END, contenuto)
                tx.config(state="disabled")
                frm = tk.Frame(preview, bg=self.COLOR_TOPLEVEL)
                frm.pack(fill=tk.X, padx=10, pady=8)
                def do_save():
                    now = datetime.date.today()
                    default_filename = f"Rubrica_Export_{now.day:02d}-{now.month:02d}-{now.year}.txt"
                    file = filedialog.asksaveasfilename(
                        defaultextension=".txt",
                        filetypes=[("File txt", "*.txt")],
                        initialdir=EXPORT_FILES,
                        title="Esporta Rubrica",
                        initialfile=default_filename,
                        confirmoverwrite=False,
                        parent=preview)
                    if file:
                        if os.path.exists(file):
                            conferma = self.show_custom_askyesno(
                                "Sovrascrivere file?",
                                f"Il file '{os.path.basename(file)}' \nesiste gi√†. Vuoi sovrascriverlo?"
                            )
                            if not conferma:
                                return  
                        with open(file, "w", encoding="utf-8") as f:
                            f.write(contenuto) 
                            self.show_custom_warning("Esporta", f"Rubrica esportata in {file}")
                        preview.destroy() 
                ttk.Button(frm, text="üíæ Salva", command=do_save, style="Verde.TButton").pack(side=tk.LEFT, padx=6)
                ttk.Button(frm, text="üìÑ Stampa", style="Blu.TButton", 
                           command=lambda: self._stampa_lista_diretta(
                               contenuto, self.show_custom_warning)
                           ).pack(side=tk.LEFT, padx=6)
                ttk.Button(frm, text="‚ùå Chiudi", command=preview.destroy, style="Giallo.TButton").pack(side=tk.RIGHT, padx=6)
                preview.lift()
                preview.attributes('-topmost', True)
                preview.after(100, lambda: preview.attributes('-topmost', False))
            except Exception as e:
                self.show_custom_warning("Errore Apertura", f"Errore nell'apertura dell'anteprima: {e}")
        frame_input = ttk.Frame(root) 
        frame_input.pack(padx=10, pady=10, fill=tk.X)
        ttk.Label(frame_input, text="Nome:").grid(row=0, column=0, sticky="e")
        entry_nome = ttk.Entry(frame_input, width=45)
        entry_nome.grid(row=0, column=1, padx=5, pady=2)
        ttk.Label(frame_input, text="Telefono:").grid(row=1, column=0, sticky="e")
        entry_telefono = ttk.Entry(frame_input, width=45)
        entry_telefono.grid(row=1, column=1, padx=5, pady=2)
        ttk.Label(frame_input, text="Email:").grid(row=2, column=0, sticky="e")
        entry_email = ttk.Entry(frame_input, width=45)
        entry_email.grid(row=2, column=1, padx=5, pady=2)
        ttk.Label(frame_input, text="Note:").grid(row=3, column=0, sticky="ne")
        entry_note_frame = ttk.Frame(frame_input, padding=1)
        entry_note_frame.grid(row=3, column=1, padx=5, pady=2, sticky="ew")
        entry_note = tk.Text(
            entry_note_frame, 
            width=45, 
            height=5, 
            relief=tk.FLAT,
            borderwidth=0,
            bg=self.COLOR_WIDGET_BG,
            fg=self.TEXT_COLOR, 
            insertbackground=self.TEXT_COLOR,
            padx=5, pady=5
        )
        entry_note.pack(fill=tk.BOTH, expand=True)
        frame_cerca = ttk.Frame(root) 
        frame_cerca.pack(padx=10, pady=(5, 10), fill=tk.X)
        ttk.Label(frame_cerca, text="        Cerca:    ").pack(side=tk.LEFT)
        entry_cerca = ttk.Entry(frame_cerca, width=30)
        entry_cerca.pack(side=tk.LEFT, padx=5)
        entry_cerca.bind("<Return>", cerca_contatto)
        entry_cerca.bind("<KP_Enter>", cerca_contatto)
        tree_frame = ttk.Frame(root)
        tree_frame.pack(padx=10, pady=10, fill=tk.BOTH, expand=True)
        vsb = ttk.Scrollbar(tree_frame, orient="vertical", style="Vertical.TScrollbar")
        vsb.pack(side=tk.RIGHT, fill=tk.Y)
        tree_contatti = ttk.Treeview(
            tree_frame, 
            columns=("Nome", "Telefono", "Email", "Note"), 
            show="headings", 
            yscrollcommand=vsb.set
        )
        tree_contatti.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        vsb.config(command=tree_contatti.yview)
        tree_contatti.heading("Nome", text="Nome")
        tree_contatti.heading("Telefono", text="Telefono")
        tree_contatti.heading("Email", text="Email")
        tree_contatti.heading("Note", text="Note")
        tree_contatti.column("Nome", width=180, anchor=tk.W)
        tree_contatti.column("Telefono", width=150, anchor=tk.W)
        tree_contatti.column("Email", width=220, anchor=tk.W)
        tree_contatti.column("Note", width=250, anchor=tk.W)
        tree_contatti.bind("<<TreeviewSelect>>", seleziona_contatto)
        frame_btn = ttk.Frame(root) 
        frame_btn.pack(pady=10)
        ttk.Button(frame_btn, text="üë§ Aggiungi", command=aggiungi_contatto, style="Verde.TButton").pack(side=tk.LEFT, padx=4)
        ttk.Button(frame_btn, text="üîÑ Modifica", command=modifica_contatto, style="Arancio.TButton").pack(side=tk.LEFT, padx=4)
        ttk.Button(frame_btn, text="‚ùå Cancella", command=cancella_contatto, style="Rosso.TButton").pack(side=tk.LEFT, padx=4)
        ttk.Button(frame_btn, text="‚ÑπÔ∏è Esporta/Stampa", command=esporta_txt, style="Verde.TButton").pack(side=tk.LEFT, padx=4)
        ttk.Button(frame_btn, text="‚ùå Chiudi", command=root.destroy, style="Giallo.TButton").pack(side=tk.LEFT, padx=4)
        carica_da_json()        
        root.mainloop()

    def mostra_calendario_popup_semplice(self, entry_widget, var_data):
        if hasattr(self, "popup_calendario") and self.popup_calendario and self.popup_calendario.winfo_exists():
            self.popup_calendario.destroy()
            self.popup_calendario = None
            self.unbind_all('<Button-1>')
            return
        entry_widget.update_idletasks()
        x_entry = entry_widget.winfo_rootx()
        y_entry = entry_widget.winfo_rooty()
        w_entry = entry_widget.winfo_width()
        h_entry = entry_widget.winfo_height()
        POPUP_WIDTH = 270
        POPUP_HEIGHT = 240
        screen_height = self.winfo_screenheight()
        y_sopra = y_entry - POPUP_HEIGHT
        y_sotto = y_entry + h_entry
        if y_sotto + POPUP_HEIGHT > screen_height and y_sopra > 0:
             final_y = y_sopra
        else:
             final_y = y_sotto
        self.popup_calendario = tk.Toplevel(self)
        self.popup_calendario.withdraw() 
        self.popup_calendario.title("Seleziona Data")
        self.popup_calendario.overrideredirect(True) 
        self.popup_calendario.geometry(f"{POPUP_WIDTH}x{POPUP_HEIGHT}+{x_entry}+{final_y}")
        self.popup_calendario.configure(bg=self.cal_bg)
        cal = Calendar(
            self.popup_calendario,
            selectmode='day',
            locale="it_IT",
            date_pattern="dd-mm-yyyy",
            font=("Arial", 10),
            cursor="hand2",
            background=self.cal_header_bg,
            foreground=self.cal_header_fg,
            headersbackground=self.cal_header_bg,
            headersforeground=self.cal_header_fg,
            normalbackground=self.cal_bg,
            normalforeground=self.cal_fg,
            weekendbackground=self.cal_weekend_bg,
            weekendforeground=self.cal_weekend_fg,
            selectbackground=self.cal_select_bg,
            selectforeground=self.cal_select_fg,
            bordercolor=self.cal_bg,
            showothermonthdays=False
        )
        cal.pack(fill="both", expand=True, padx=1, pady=1)
        oggi = datetime.date.today()
        cal.calevent_create(oggi, "Oggi", "today")
        cal.tag_config("today", background=self.cal_select_bg, foreground=self.cal_select_fg) 
        def chiudi_popup():
            if hasattr(self, 'popup_calendario') and self.popup_calendario:
                try:
                    self.popup_calendario.destroy() 
                except:
                    pass
                self.popup_calendario = None
        def on_date_select(event):
            data_sel = cal.selection_get()
            var_data.set(data_sel.strftime("%d-%m-%Y"))
            chiudi_popup()
        def check_click_outside(event):
            if not self.popup_calendario or not self.popup_calendario.winfo_exists():
                return
            x, y = self.popup_calendario.winfo_pointerxy()
            widget_sotto = self.popup_calendario.winfo_containing(x, y)
            if widget_sotto is None or str(widget_sotto).find(str(self.popup_calendario)) == -1:
                if widget_sotto != entry_widget:
                    chiudi_popup()
        cal.bind("<<CalendarSelected>>", on_date_select)
        self.bind_all('<Button-1>', check_click_outside)
        self.popup_calendario.deiconify()
        cal.focus_set()

    # Gestore Popup Calendario Selettore Data
    def mostra_calendario_popup(self, entry_widget, var_data):
        if hasattr(self, "popup_calendario") and self.popup_calendario and self.popup_calendario.winfo_exists():
            self.popup_calendario.destroy()
            self.popup_calendario = None
            self.unbind_all('<Button-1>')
            return
        entry_widget.update_idletasks()
        x_entry = entry_widget.winfo_rootx()
        y_entry = entry_widget.winfo_rooty()
        h_entry = entry_widget.winfo_height()
        POPUP_WIDTH, POPUP_HEIGHT = 270, 240
        final_y = y_entry - POPUP_HEIGHT if (y_entry + h_entry + POPUP_HEIGHT > self.winfo_screenheight()) else y_entry + h_entry
        self.popup_calendario = tk.Toplevel(self)
        self.popup_calendario.withdraw() 
        self.popup_calendario.overrideredirect(True) 
        self.popup_calendario.geometry(f"{POPUP_WIDTH}x{POPUP_HEIGHT}+{x_entry}+{final_y}")
        self.popup_calendario.configure(bg=self.cal_bg)
        cal = Calendar(
            self.popup_calendario,
            selectmode='day',
            locale="it_IT",
            date_pattern="dd-mm-yyyy",
            font=("Arial", 10),
            cursor="hand2",
            showothermonthdays=False,
            background=self.cal_header_bg,
            foreground=self.cal_header_fg,
            headersbackground=self.cal_header_bg,
            headersforeground=self.cal_header_fg,
            normalbackground=self.cal_bg,
            normalforeground=self.cal_fg,
            weekendbackground=self.cal_weekend_bg,
            weekendforeground=self.cal_weekend_fg,
            selectbackground=self.cal_select_bg,
            selectforeground=self.cal_select_fg,
            bordercolor=self.cal_bg,
            tooltipdelay=999999
        )
        cal.pack(fill="both", expand=True)
        cal.tag_config("verde", background=self.COLOR_LIGHTGREEN, foreground=self.COLOR_BLACK)
        cal.tag_config("rosso", background=self.COLOR_LIGHTCORAL, foreground=self.COLOR_BLACK)
        cal.tag_config("misto", background=self.COLOR_KHAKI, foreground=self.COLOR_BLACK)
        cal.tag_config("today", background=self.COLOR_YELLOW, foreground=self.COLOR_BLACK)
        try:
            if hasattr(self, 'spese') and self.spese:
                for d_str, entries in self.spese.items():
                    d_obj = datetime.datetime.strptime(d_str, "%d-%m-%Y").date() if isinstance(d_str, str) else d_str
                    txt, e_sum, u_sum = "", 0, 0
                    for e in entries:
                        segno = "+" if str(e[3]).lower() == "entrata" else "-"
                        txt += f"{segno} {e[0]}: {float(e[2]):.2f}\n"
                        if segno == "+": e_sum += 1
                        else: u_sum += 1
                    tag = "misto" if e_sum > 0 and u_sum > 0 else ("verde" if e_sum > 0 else "rosso")
                    cal.calevent_create(d_obj, txt.strip(), tag)
            cal._draw_calendar()
        except: pass 
        def chiudi_popup():
            if hasattr(self, 'tw') and self.tw and self.tw.winfo_exists(): self.tw.destroy()
            if hasattr(self, 'popup_calendario') and self.popup_calendario:
                try: self.popup_calendario.destroy()
                except: pass
                self.popup_calendario = None
                self.unbind_all('<Button-1>')
        def on_date_select(event):
            data_sel = cal.selection_get()
            var_data.set(data_sel.strftime("%d-%m-%Y"))
            chiudi_popup()
        def check_click_outside(event):
            if not self.popup_calendario or not self.popup_calendario.winfo_exists(): return
            x, y = self.popup_calendario.winfo_pointerxy()
            widget_sotto = self.popup_calendario.winfo_containing(x, y)
            if widget_sotto is None or str(widget_sotto).find(str(self.popup_calendario)) == -1:
                if widget_sotto != entry_widget: chiudi_popup()
        def gestisci_tooltip(event):
            if hasattr(self, 'tooltip_timer') and self.tooltip_timer:
                self.after_cancel(self.tooltip_timer)
                self.tooltip_timer = None
            if hasattr(self, 'tw') and self.tw and self.tw.winfo_exists():
                self.tw.withdraw()
            def mostra_reale():
                try:
                    x_m, y_m = self.popup_calendario.winfo_pointerxy()
                    widget = self.popup_calendario.winfo_containing(x_m, y_m)
                    if widget and "label" in str(widget) and widget.cget("text").isdigit():
                        giorno = int(widget.cget("text"))
                        mese, anno = cal.get_displayed_month()
                        data_h = datetime.date(anno, mese, giorno)
                        evs = cal.get_calevents(data_h)
                        righe_raw = [cal.calevent_cget(i, "text") for i in evs if cal.calevent_cget(i, "text") != "Oggi"]
                        if righe_raw or data_h == datetime.date.today():
                            if not hasattr(self, 'tw') or not self.tw.winfo_exists():
                                self.tw = tk.Toplevel(self.popup_calendario)
                                self.tw.overrideredirect(True)
                                self.tw.attributes("-topmost", True)
                            self.tw.withdraw()
                            for c in self.tw.winfo_children(): c.destroy()
                            self.tw.minsize(180, 0)
                            main_f = tk.Frame(self.tw, bg=self.COLOR_TOOLTIP, relief="solid", borderwidth=1)
                            main_f.pack(fill="both", expand=True)
                            entrate, uscite = [], []
                            tot_e, tot_u = 0.0, 0.0
                            for blocco in righe_raw:
                                for r in blocco.split('\n'):
                                    if not r.strip(): continue
                                    try:
                                        parti = r.split(':')
                                        desc = parti[0].replace("+ ", "").replace("- ", "").strip()
                                        valore = float(parti[1].strip().replace(',', '.'))
                                        r_data = (desc, f"{valore:.2f}")
                                        if "+" in r:
                                            entrate.append(r_data); tot_e += valore
                                        elif "-" in r:
                                            uscite.append(r_data); tot_u += valore
                                    except: pass
                            def crea_riga(parent, sx, dx, col, bold=False):
                                f = tk.Frame(parent, bg=self.COLOR_TOOLTIP)
                                f.pack(fill="x", padx=10, pady=1)
                                fnt = ("Arial", 9, "bold")
                                lbl_sx = tk.Label(f, text=sx, fg=col, bg=self.COLOR_TOOLTIP, font=fnt, anchor="w")
                                lbl_sx.pack(side="left", fill="x", expand=True)
                                testo_dx = f"‚Ç¨ {dx}" if bold else dx
                                lbl_dx = tk.Label(f, text=testo_dx, fg=col, bg=self.COLOR_TOOLTIP, font=fnt, anchor="e")
                                lbl_dx.pack(side="right")
                            if entrate:
                                crea_riga(main_f, "‚ñ≤ SALDO (+):", f"{tot_e:.2f}", self.COLOR_GREEN_SMOOTH, True)
                                for d, v in entrate: crea_riga(main_f, d, v, self.COLOR_TEXT_TOOLTIP)
                            if uscite:
                                if entrate: tk.Frame(main_f, height=1, bg="gray").pack(fill="x", padx=5, pady=2)
                                crea_riga(main_f, "‚ñº SALDO (-):", f"{tot_u:.2f}", self.COLOR_RED_SMOOTH, True)
                                for d, v in uscite: crea_riga(main_f, d, v, self.COLOR_TEXT_TOOLTIP)
                            if not entrate and not uscite:
                                tk.Label(main_f, text="Oggi", fg=self.COLOR_TEXT_TOOLTIP, bg=self.COLOR_TOOLTIP,
                                         font=("Arial", 9, "bold"), padx=10).pack(anchor="w")
                            self.tw.update_idletasks()
                            tw_w, tw_h = self.tw.winfo_reqwidth(), self.tw.winfo_reqheight()
                            scr_w, scr_h = self.winfo_screenwidth(), self.winfo_screenheight()
                            px, py = x_m + 15, y_m + 10
                            if px + tw_w > scr_w: px = x_m - tw_w - 15
                            if py + tw_h > scr_h: py = y_m - tw_h - 10
                            self.tw.geometry(f"{tw_w}x{tw_h}+{max(0, px)}+{max(0, py)}")
                            self.tw.deiconify()
                            self.tw.lift()
                except:
                    if hasattr(self, 'tw') and self.tw.winfo_exists():
                        self.tw.withdraw()
            self.tooltip_timer = self.after(1000, mostra_reale)
            
        def applica_ricorsivo(w):
            w.bind("<Motion>", gestisci_tooltip, add="+")
            w.bind("<Leave>", lambda e: self.tw.withdraw() if hasattr(self, 'tw') else None, add="+")
            for child in w.winfo_children():
                applica_ricorsivo(child)
        if CAL_TOOLTIPS:
            applica_ricorsivo(cal)
            cal.bind("<Motion>", gestisci_tooltip, add="+")
            cal.bind("<Leave>", lambda e: self.tw.withdraw() if hasattr(self, 'tw') else None, add="+")
        else:
            cal.configure(tooltipdelay=999999)
        cal.bind("<<CalendarSelected>>", on_date_select)
        self.bind_all('<Button-1>', check_click_outside)
        self.popup_calendario.deiconify()
        cal.focus_set()

    # Anteprima e Stampa Diretta File Testo (.txt)
    def anteprima_e_stampa_txt(self):
        now = datetime.date.today()
        default_dir = EXPORT_FILES
        default_filename = ""
        path = filedialog.askopenfilename(
               filetypes=[("File txt", "*.txt")],
               initialdir=default_dir,
               initialfile=default_filename,
               title="Stampa Testi"
               )
        if not path:
            return

        with open(path, "r", encoding="utf-8") as f:
            contenuto = f.read()
        anteprima = tk.Toplevel(bg=self.COLOR_TOPLEVEL)
        anteprima.withdraw()
        anteprima.title(f"Anteprima stampa: {os.path.basename(path)}")
        anteprima.resizable(False, False)  
        larghezza_finestra = 1300
        altezza_finestra = 600
        def centra_finestra():
            larghezza_schermo = anteprima.winfo_screenwidth()
            altezza_schermo = anteprima.winfo_screenheight()
            x = (larghezza_schermo // 2) - (larghezza_finestra // 2)
            y = (altezza_schermo // 2) - (altezza_finestra // 2)
            anteprima.geometry(f"{larghezza_finestra}x{altezza_finestra}+{x}+{y}")
            anteprima.deiconify()
            anteprima.lift()
            anteprima.focus_force()
        anteprima.after(0, centra_finestra)
        txt = tk.Text(anteprima, wrap="word", font=("Courier new", 10))
        txt.insert("1.0", contenuto)
        txt.config(state="disabled")
        txt.pack(padx=10, pady=10, fill="both", expand=True)
        def stampa():
            try:
                sistema = platform.system()
                if not os.path.exists(path):
                    raise FileNotFoundError("File non trovato per la stampa")
                if sistema == "Windows":
                    import win32print # type: ignore
                    import win32ui    # type: ignore
                    import win32con   # type: ignore
                    printer_name = win32print.GetDefaultPrinter()
                    hprinter = win32print.OpenPrinter(printer_name)
                    properties = win32print.GetPrinter(hprinter, 2)
                    devmode = properties["pDevMode"]
                    devmode.Orientation = 2  # 2 = Landscape
                    win32print.ClosePrinter(hprinter)
                    pdc = win32ui.CreateDC()
                    pdc.CreatePrinterDC(printer_name)
                    pdc.SetMapMode(win32con.MM_TEXT)
                    if hasattr(pdc, "ResetDC"):
                          pdc.ResetDC(devmode)
                    else:
                          print("‚ö†Ô∏è Attenzione: ResetDC non disponibile su questo oggetto DC")                                       
                    HORZRES = pdc.GetDeviceCaps(win32con.HORZRES)  
                    VERTRES = pdc.GetDeviceCaps(win32con.VERTRES)  
                    font = win32ui.CreateFont({
                         "name": "Courier New",     
                         "height": -int(VERTRES / 60),  
                         "width": int(HORZRES / 160),  
                    })
                    pdc.SelectObject(font)
                    pdc.StartDoc("Stampa compatibile")
                    pdc.StartPage()
                    margin_x = 100  # Margine sinistro
                    margin_y = 100  # Margine superiore
                    line_height = int(VERTRES / 70)     #60 righe circa dal fondo def.
                    with open(path, "r", encoding="utf-8") as file:
                        y = margin_y
                        for line in file:
                            pdc.TextOut(margin_x, y, line.rstrip())
                            y += line_height
                            if y + line_height > VERTRES:
                        
                                   pdc.EndPage()
                                   pdc.StartPage()
                                   y = margin_y
                    pdc.EndPage()
                    pdc.EndDoc()
                    pdc.DeleteDC()
                elif sistema in ["Linux", "Darwin"]:
                    subprocess.run([
                        "lp",
                        "-o", "orientation-requested=4",
                        "-o", "fit-to-page",
                        "-o", "cpi=17",
                        "-o", "lpi=8",
                        path
                    ], check=True)
                else:
                    raise OSError(f"Sistema non supportato: {sistema}")
                self.show_custom_warning("Stampa Avviata", f"Inviato alla stampante predefinita ({sistema})")
            except subprocess.CalledProcessError as e:
                self.show_custom_warning("Stampa Errore", f"Errore di stampa: {e}")
            except Exception as ex:
                self.show_custom_warning("Errore imprevisto", str(ex))
        frame_bottoni = tk.Frame(anteprima, bg=self.COLOR_TOPLEVEL)
        frame_bottoni.pack(pady=10, fill="x")
        ttk.Button(frame_bottoni, text="üìÑ Stampa", style="Blu.TButton", command=stampa).pack(side="left", padx=20)
        ttk.Button(frame_bottoni, text="‚ùå Chiudi", style="Giallo.TButton", command=anteprima.destroy).pack(side="right", padx=20)

    # Funzione di Utilit√† per la Stampa Diretta Cross-Platform
    def _stampa_lista_diretta(self, testo_da_stampare, show_warning_func):
        temp_file_path = ""
        try:
            with tempfile.NamedTemporaryFile(mode='w', delete=False, encoding="utf-8", suffix=".txt") as tmp_file:
                tmp_file.write(testo_da_stampare)
                temp_file_path = tmp_file.name
            path = temp_file_path
            sistema = platform.system()
            if sistema == "Windows":
                import win32print # type: ignore
                import win32ui    # type: ignore
                import win32con   # type: ignore
                printer_name = win32print.GetDefaultPrinter()
                hprinter = win32print.OpenPrinter(printer_name)
                properties = win32print.GetPrinter(hprinter, 2)
                devmode = properties["pDevMode"]
                devmode.Orientation = 2 # 2 = Landscape
                win32print.ClosePrinter(hprinter)
                pdc = win32ui.CreateDC()
                pdc.CreatePrinterDC(printer_name)
                pdc.SetMapMode(win32con.MM_TEXT)
                if hasattr(pdc, "ResetDC"):
                     pdc.ResetDC(devmode) # Applica le modifiche di orientamento
                HORZRES = pdc.GetDeviceCaps(win32con.HORZRES)
                VERTRES = pdc.GetDeviceCaps(win32con.VERTRES)
                font = win32ui.CreateFont({
                     "name": "Courier New",
                     "height": -int(VERTRES / 70), 
                     "width": int(HORZRES / 160),
                })
                pdc.SelectObject(font)
                pdc.StartDoc(f"Stampa {os.path.basename(path)}")
                pdc.StartPage()
                margin_x = 100
                margin_y = 100
                line_height = int(VERTRES / 70) 
                with open(path, "r", encoding="utf-8") as file:
                    y = margin_y
                    for line in file:
                        try:
                            pdc.TextOut(margin_x, y, line.rstrip())
                        except Exception:
                            pdc.TextOut(margin_x, y, line.encode('ascii', 'ignore').decode('ascii').rstrip())
                        
                        y += line_height
                        
                        if y + line_height > VERTRES:
                            pdc.EndPage()
                            pdc.StartPage()
                            y = margin_y
                pdc.EndPage()
                pdc.EndDoc()
                pdc.DeleteDC()
                show_warning_func("Stampa Avviata", f"Inviato alla stampante predefinita (Windows).")
            elif sistema in ["Linux", "Darwin"]:
                subprocess.run([
                    "lp",
                    "-o", "orientation-requested=4", # Landscape
                    "-o", "fit-to-page",
                    "-o", "cpi=17",
                    "-o", "lpi=8", 
                    path
                ], check=True)
                show_warning_func("Stampa Avviata", f"Inviato alla stampante predefinita ({sistema}).")
            else:
                show_warning_func("Stampa Fallita", f"Sistema operativo '{sistema}' non supportato per la stampa diretta.")
                return
        except subprocess.CalledProcessError as e:
            show_warning_func("Stampa Errore", f"Errore del comando di stampa: {e}.")
        except Exception as ex:
            show_warning_func("Errore imprevisto", f"Impossibile completare la stampa: {str(ex)}")
        finally:
            if temp_file_path and os.path.exists(temp_file_path):
                try:
                    os.remove(temp_file_path)
                except Exception as e:
                    show_warning_func("Attenzione", f"Impossibile cancellare il file temporaneo: {e}")

    # Analisi di Gruppo Personalizzato per Categorie (Report Spese)
    def gruppo_categorie(self):
        popup = tk.Toplevel(self, bg=self.COLOR_TOPLEVEL )
        popup.title("üìÇ Analisi per categorie selezionate")
        popup.geometry("800x650") 
        popup.withdraw() 
        self.update_idletasks()
        main_x = self.winfo_x()
        main_y = self.winfo_y()
        main_width = self.winfo_width()
        main_height = self.winfo_height()
        popup_width = 800
        popup_height = 650
        center_x = main_x + (main_width // 2) - (popup_width // 2)
        center_y = main_y + (main_height // 2) - (popup_height // 2)
        popup.geometry(f"{popup_width}x{popup_height}+{center_x}+{center_y}")
        popup.transient(self)
        popup.update_idletasks()
        popup.deiconify()
        popup.update()  
        main_frame = ttk.Frame(popup, padding=10)
        main_frame.pack(fill="both", expand=True)
        bottom_buttons = ttk.Frame(popup)
        bottom_buttons.pack(fill="x", pady=10)
        today = datetime.date.today()
        mesi = ["Tutti"] + ["Gennaio", "Febbraio", "Marzo", "Aprile", "Maggio", "Giugno",
                        "Luglio", "Agosto", "Settembre", "Ottobre", "Novembre", "Dicembre"]
        mese_var = tk.StringVar(value="Tutti")
        anno_var = tk.StringVar(value=str(today.year))
        mostra_future_var = tk.BooleanVar(value=True)
        top_bar = ttk.Frame(main_frame)
        top_bar.pack(fill="x", pady=(0, 10))
        ttk.Label(top_bar, text="Mese:").pack(side="left", padx=(0, 5))
        ttk.Combobox(top_bar, values=mesi, textvariable=mese_var, style="Border.TCombobox", state="readonly", width=12).pack(side="left")
        anni = sorted({
            d.year if not isinstance(d, str) else datetime.datetime.strptime(d, "%d-%m-%Y").year
            for d in self.spese
        }, reverse=True)
        ttk.Label(top_bar, text="Anno:").pack(side="left", padx=(10, 5))
        ttk.Combobox(top_bar, values=[str(a) for a in anni], textvariable=anno_var, style="Border.TCombobox", state="readonly", width=8).pack(side="left")
        ttk.Button(top_bar,text="üîô", style="Yellow.TButton", command=lambda: [mese_var.set("Tutti"),anno_var.set(str(today.year))]).pack(side="left", padx=(10, 0))
        ttk.Checkbutton(
            top_bar,
            text="Includi movimenti futuri nei totali",
            variable=mostra_future_var
        ).pack(side="left", padx=(20,0))
        valori_combo = ["‚Äî Nessuna ‚Äî"] + sorted(list(self.categorie_tipi.keys()))
        selettori_box = ttk.LabelFrame(main_frame, text="üéØ Seleziona fino a 10 categorie da analizzare")
        selettori_box.pack(fill="x", pady=(5, 15))
        sx = ttk.Frame(selettori_box)
        dx = ttk.Frame(selettori_box)
        sx.pack(side="left", fill="both", expand=True, padx=(0, 10))
        dx.pack(side="right", fill="both", expand=True)
        combo_vars = []
        for i in range(10):
            var = tk.StringVar(value="‚Äî Nessuna ‚Äî")
            cb = ttk.Combobox(sx if i < 5 else dx, values=valori_combo, textvariable=var, style="Border.TCombobox", state="readonly", width=35, height=15)
            cb.pack(anchor="w", pady=2)
            combo_vars.append(var)
        ttk.Label(main_frame, text="üìä Risultato:", font=("Arial", 10, "bold")).pack(anchor="w")

        text_output = tk.Text(main_frame, height=15, wrap="word", 
                             font=("Courier New", 10),
                             bg=self.COLOR_WIDGET_BG,
                             fg=self.TEXT_COLOR,
                             insertbackground=self.TEXT_COLOR,
                             padx=10, pady=10,
                             borderwidth=1,
                             relief="flat",
                             highlightthickness=1,
                             highlightbackground=self.COLOR_BUTTON_BG)
        scroll = ttk.Scrollbar(main_frame, command=text_output.yview, style="Vertical.TScrollbar")
        text_output.config(yscrollcommand=scroll.set)
        text_output.pack(side="left", fill="both", expand=True, pady=(5, 10))
        scroll.pack(side="right", fill="y")
        def analizza():
            text_output.delete("1.0", "end")
            try:
                anno = int(anno_var.get())
            except:
                self.show_custom_warning("Errore", "Anno non valido.")
                return
            selezionato = mese_var.get()
            if selezionato not in mesi:
                self.show_custom_warning("Errore", "Mese non valido.")
                return
            scelte = {v.get().strip().title() for v in combo_vars if v.get() != "‚Äî Nessuna ‚Äî"}
            risultato = {}
            oggi = datetime.date.today()
            for d, sp in self.spese.items():
                if isinstance(d, str):
                    d = datetime.datetime.strptime(d, "%d-%m-%Y").date()
                if not mostra_future_var.get() and d > oggi:
                    continue
                if d.year == anno and (selezionato == "Tutti" or d.month == mesi.index(selezionato)):
                    for voce in sp:
                        if len(voce) >= 4:
                            cat = voce[0].strip().title()
                            imp = voce[2]
                            tipo = voce[3]
                            if cat in scelte:
                                if cat not in risultato:
                                    risultato[cat] = {"num": 0, "uscite": 0.0, "entrate": 0.0}
                                risultato[cat]["num"] += 1
                                if tipo == "Uscita":
                                    risultato[cat]["uscite"] += imp
                                elif tipo == "Entrata":
                                    risultato[cat]["entrate"] += imp
            righe = [f"üìÖ Analisi categorie ‚Äì {mese_var.get()} {anno}\n"]
            righe.append(f"{'Categoria':<30} {'Num':>4}   {'Uscite (‚Ç¨)':>12}   {'Entrate (‚Ç¨)':>12}   {'Saldo (‚Ç¨)':>12}")
            righe.append("-" * 80)
            totale = 0.0
            for cat, dati in sorted(risultato.items(), key=lambda x: -(x[1]["entrate"] - x[1]["uscite"])):
                saldo = dati["entrate"] - dati["uscite"]
                righe.append(f"{cat:<30} {dati['num']:>4}   {dati['uscite']:>12.2f}   {dati['entrate']:>12.2f}   {saldo:>12.2f}")
                totale += saldo
            righe.append("-" * 80)
            righe.append(f"üí∞ Totale gruppo categorie (Entrate - Uscite): {totale:.2f} ‚Ç¨")
            text_output.insert("1.0", "\n".join(righe))
        def reset_campi():
            mese_var.set("Tutti")
            anno_var.set(str(today.year))
            mostra_future_var.set(True)
            for var in combo_vars:
                var.set("‚Äî Nessuna ‚Äî")
            text_output.delete("1.0", "end")
        def salva():
            contenuto = text_output.get("1.0", "end").strip()
            if not contenuto:
                self.show_custom_warning("Nessun dato", "Nessun risultato da salvare.")
                return
            now = datetime.date.today()
            nome_file = f"Analisi_Categorie_{now:%d_%m_%Y}.txt"
            file = filedialog.asksaveasfilename(
                defaultextension=".txt",
                filetypes=[("File di testo", "*.txt")],
                initialfile=nome_file,
                initialdir=EXPORT_FILES,
                title="Esporta risultati",
                confirmoverwrite=False,
                parent=popup
            )
            if file:
                if os.path.exists(file):
                    conferma = self.show_custom_askyesno(
                        "Sovrascrivere file?",
                        f"Il file '{os.path.basename(file)}' \nesiste gi√†. Vuoi sovrascriverlo?"
                    )
                    if not conferma:
                        return
                with open(file, "w", encoding="utf-8") as f:
                    f.write(contenuto)
                self.show_custom_warning("Esportazione completata", f"File salvato:\n{file}")
        mostra_future_var.trace_add("write", lambda *a: analizza())
        bottom_buttons = tk.Frame(popup, bg=self.COLOR_TOPLEVEL ) 
        bottom_buttons.pack(fill="x", pady=10)
        ttk.Button(bottom_buttons, text="üì• Analizza", command=analizza, style="Verde.TButton").pack(side="left", padx=10)
        ttk.Button(bottom_buttons, text="üíæ Esporta", command=salva, style="Arancio.TButton").pack(side="left", padx=10)
        ttk.Button(bottom_buttons, text="üü® Reset campi", command=reset_campi, style="Giallo.TButton").pack(side="left", padx=10)
        ttk.Button(bottom_buttons, text="‚ùå Chiudi", command=popup.destroy, style="Giallo.TButton").pack(side="right", padx=10)
        popup.bind("<Escape>", lambda e: popup.destroy())

    # Analisi di Cadenza e Ricorrenza Movimenti per Categoria
    def calcola_mancanti(self):
        from datetime import datetime, timedelta
        if hasattr(self, '_mancanti_popup') and self._mancanti_popup and self._mancanti_popup.winfo_exists():
            self._mancanti_popup.lift()
            return  
        def on_mancanti_close():
            popup.destroy()
            self._mancanti_popup = None
        popup = tk.Toplevel(bg=self.COLOR_TOPLEVEL)
        self._mancanti_popup = popup
        popup.protocol("WM_DELETE_WINDOW", on_mancanti_close)
        popup.bind("<Escape>", lambda e: on_mancanti_close())
        popup.withdraw()
        popup.title("üìã Controllo Categorie Ricorrenti")
        w, h = 950, 600
        x = (popup.winfo_screenwidth() // 2) - (w // 2)
        y = (popup.winfo_screenheight() // 2) - (h // 2)
        popup.geometry(f"{w}x{h}+{x}+{y}")
        popup.resizable(True, True)
        popup.deiconify()
        mesi = ["Gen", "Feb", "Mar", "Apr", "Mag", "Giu",
                "Lug", "Ago", "Set", "Ott", "Nov", "Dic"]
        oggi = datetime.today().date()
        def converti_data(d):
            if isinstance(d, str):
                try:
                    return datetime.strptime(d, "%d-%m-%Y").date()
                except:
                    return None
            elif isinstance(d, datetime):
                return d.date()
            return d
        anni_disponibili = sorted({
            converti_data(d).year for d in self.spese
            if converti_data(d)
        }, reverse=True)
        anno_var = tk.StringVar(value=str(oggi.year))
        top_bar = ttk.Frame(popup, padding=10)
        top_bar.pack(fill="x")
        ttk.Label(top_bar, text="Anno di Analisi:").pack(side="left", padx=6)
        anno_combo = ttk.Combobox(top_bar, textvariable=anno_var,
                                 values=[str(a) for a in anni_disponibili], style="Border.TCombobox", state="readonly", width=6)
        anno_combo.pack(side="left", padx=6)
        anno_combo.bind("<<ComboboxSelected>>", lambda event: analizza())
        ttk.Button(
            top_bar,
            text="üîô",
            style='Yellow.TButton',
            command=lambda: [
                anno_var.set(str(oggi.year)),
                analizza() 
            ]
        ).pack(side="left", padx=2)
        ttk.Label(top_bar, text="Clicca sull'intestazione per ordinare. ‚úî/‚úñ = Mese con/senza Movimenti.").pack(side="right", padx=6)
        tree_container = tk.Frame(popup, bg=self.COLOR_TOPLEVEL)
        tree_container.pack(fill="both", expand=True, padx=10, pady=(0,8))
        cols = ["Categoria", "Totale (‚Ç¨)", "Media (‚Ç¨)", "Cadenza"] + mesi
        self.tree = ttk.Treeview(tree_container, columns=cols, show='headings', selectmode='browse')
        scrollbar = ttk.Scrollbar(tree_container, orient="vertical", command=self.tree.yview)
        self.tree.configure(yscrollcommand=scrollbar.set)
        scrollbar.pack(side="right", fill="y")
        self.tree.pack(side="left", fill="both", expand=True)
        for col in cols:
            self.tree.heading(col, 
                              text=col.replace(" (‚Ç¨)", ""), 
                              anchor="center", 
                              command=lambda c=col: self.treeview_sort_column(self.tree, c, False))
            if col == "Categoria":
                width_val = 150
            elif col == "Totale (‚Ç¨)":
                width_val = 75
            elif col == "Media (‚Ç¨)":
                width_val = 75
            elif col == "Cadenza":
                width_val = 100 
            else:
                width_val = 35 
            if col == "Categoria":
                anchor_data = "w"  
            elif col in ("Totale (‚Ç¨)", "Media (‚Ç¨)"):
                anchor_data = "e"     
            else:
                anchor_data = "center"                  
            self.tree.column(col, width=width_val, anchor=anchor_data)
        self.tree.tag_configure("mese_presente", foreground="green", font=("Arial", 8, "bold"))
        self.tree.tag_configure("mese_assente", foreground="red")
        self.tree.tag_configure("cadenza_mensile", background="#E6FFE6", foreground="#004C00")
        self.tree.tag_configure("cadenza_regolare", background="#F0FFF0", foreground="#333333")
        self.tree.tag_configure("cadenza_bimestrale", background="#FFFFE0", foreground="#CC9900")
        self.tree.tag_configure("cadenza_trimestrale", background="#FFF0E0", foreground="#FF6600")
        self.tree.tag_configure("cadenza_irregolare", background="#FFEEEE", foreground="#CC0000")
        self.tree.tag_configure("intestazione", background="#CCCCCC", foreground="black", font=("Arial", 10, "bold"))
        def analizza():
            dati_mensili = {} 
            for i in self.tree.get_children():
                self.tree.delete(i)
            try:
                anno = int(anno_var.get())
            except ValueError:
                self.show_custom_warning("Errore", "Anno non valido.")
                return
            risultati = {}
            importi_categoria = {}
            conteggio_categoria = {}
            for d, sp in self.spese.items():
                dd = converti_data(d)
                if not dd or dd.year != anno:
                    continue
                mese = dd.month
                for voce in sp:
                    if len(voce) < 1 or not voce[0].strip():
                        continue
                    cat = voce[0].strip().title()
                    importo = voce[2] if len(voce) > 2 and isinstance(voce[2], (int, float)) else 0
                    tipo = voce[3].strip().title() if len(voce) > 3 else "Uscita"
                    importi_categoria[cat] = importi_categoria.get(cat, 0) + importo
                    conteggio_categoria[cat] = conteggio_categoria.get(cat, 0) + 1
                    risultati.setdefault(cat, set()).add(mese)
                    dati_mensili.setdefault(cat, {}).setdefault(mese, {"Entrata": 0, "Uscita": 0})
                    if tipo == "Entrata":
                        dati_mensili[cat][mese]["Entrata"] += importo
                    else:
                        dati_mensili[cat][mese]["Uscita"] += importo
            count = 0
            soglia_presenza = 1 if anno == oggi.year else 2
            for cat, mesi_presenti in sorted(risultati.items()):
                if len(mesi_presenti) < soglia_presenza: 
                    continue
                spesa_totale = importi_categoria.get(cat, 0)
                n_elementi = conteggio_categoria.get(cat, 1)
                media_spesa = spesa_totale / n_elementi
                sorted_months = sorted(list(mesi_presenti))
                avg_interval = 0
                if len(sorted_months) > 1:
                    intervals = [(sorted_months[i] - sorted_months[i-1]) for i in range(1, len(sorted_months))]
                    avg_interval = sum(intervals) / len(intervals)
                if len(mesi_presenti) == 12:
                    cadenza = "Mensile"
                    tag_riga = "cadenza_mensile" 
                elif 0.8 <= avg_interval <= 1.2:
                    cadenza = "Mensile Reg."
                    tag_riga = "cadenza_regolare" 
                elif 1.5 <= avg_interval <= 2.5:
                    cadenza = "Bimestrale"
                    tag_riga = "cadenza_bimestrale" 
                elif 2.5 < avg_interval <= 3.5:
                    cadenza = "Trimestrale"
                    tag_riga = "cadenza_trimestrale" 
                else:
                    cadenza = "Irregolare"
                    tag_riga = "cadenza_irregolare"
                valori_riga = [cat, f"‚Ç¨{spesa_totale:.2f}", f"‚Ç¨{media_spesa:.2f}", cadenza]
                for mese_idx in range(1, 13):
                    simbolo = "‚úî" if mese_idx in mesi_presenti else "‚úñ"
                    if mese_idx == oggi.month and anno == oggi.year:
                        simbolo = f"[{simbolo}]" 
                    valori_riga.append(simbolo)
                self.tree.insert("", "end", iid=cat, values=valori_riga, tags=(tag_riga,))
                count += 1
            if count == 0:
                self.tree.insert("", "end", values=("Nessuna categoria ricorrente trovata.", "", "", ""), tags=("intestazione",))
        def on_tree_select(event):
            selected_item = self.tree.focus()
            if not selected_item:
                return
            valori = self.tree.item(selected_item, 'values')
            categoria_selezionata = valori[0]
            if categoria_selezionata.startswith("Nessuna"):
                return
            anno_selezionato = anno_var.get()
            data_filter = {
                "anno": anno_selezionato,
                "mese": None, 
                "categoria": categoria_selezionata,
                "tipo": None
            }
            title = f"Movimenti Ricorrenti: {categoria_selezionata} ({anno_selezionato})"
            self.mostra_transazioni_popup(data_filter, title)
        self.tree.bind("<Double-1>", on_tree_select)
        legenda_frame = ttk.Frame(popup, padding=(10, 5, 10, 5))
        legenda_frame.pack(fill="x")        
        ttk.Label(legenda_frame, text="Legenda Cadenza: ", font=("Arial", 8, "bold")).pack(side="left", padx=(0, 10))
        voci = [
            ("Mensile", "mensile"),
            ("Regolare", "regolare"),
            ("Bimestrale", "bimestrale"),
            ("Trimestrale", "trimestrale"),
            ("Irregolare", "irregolare")
        ]
        for testo, alias in voci:
            ttk.Label(
                legenda_frame, 
                text=testo, 
                style=f"Legenda.{alias}.TLabel"
            ).pack(side="left", padx=5)
        ttk.Label(legenda_frame, text=" | Simboli Mese: ", font=("Arial", 8, "bold")).pack(side="left", padx=(10, 10))
        ttk.Label(legenda_frame, text="‚úî Presente", foreground="green", font=("Arial", 8, "bold")).pack(side="left", padx=5)
        ttk.Label(legenda_frame, text="‚úñ Assente", foreground="red").pack(side="left", padx=5)
        ttk.Label(legenda_frame, text="[ ] Mese Corrente", foreground="#555555").pack(side="left", padx=5)
        bottom_buttons = tk.Frame(popup, bg=self.COLOR_TOPLEVEL)
        bottom_buttons.pack(pady=8)
        ttk.Button(bottom_buttons, text="‚úñ Chiudi", command=popup.destroy, style="Giallo.TButton").pack(side="right", padx=10)
        popup.bind("<Escape>", lambda e: popup.destroy())
        analizza()

    # Time Machine: Simulazione di Risparmio per Categoria
    def time_machine(self):
        popup = tk.Toplevel()
        popup.title("üï∞Ô∏è Time Machine ‚Äì Simulazione per categoria")
        popup.geometry("880x650")
        popup.withdraw()
        self.update_idletasks()
        main_x = self.winfo_x()
        main_y = self.winfo_y()
        main_width = self.winfo_width()
        main_height = self.winfo_height()
        popup_width = 880
        popup_height = 650
        center_x = main_x + (main_width // 2) - (popup_width // 2)
        center_y = main_y + (main_height // 2) - (popup_height // 2)
        popup.geometry(f"{popup_width}x{popup_height}+{center_x}+{center_y}")
        popup.transient(self)
        popup.update_idletasks()
        popup.deiconify()
        popup.update()
        main = ttk.Frame(popup, padding=10)
        main.pack(fill="both", expand=True)
        anni_disponibili = sorted({datetime.datetime.strptime(str(d), "%d-%m-%Y").year
                                   if isinstance(d, str) else d.year for d in self.spese}, reverse=True)
        anno_var = tk.IntVar(value=datetime.date.today().year)
        mostra_future_var = tk.BooleanVar(value=True)
        top_bar = ttk.Frame(main)
        top_bar.pack(fill="x", pady=(0, 10))
        ttk.Label(top_bar, text="Anno:", font=("Arial", 10)).pack(side="left", padx=(0, 5))
        anno_combo = ttk.Combobox(top_bar, textvariable=anno_var, values=anni_disponibili, style="Border.TCombobox", state="readonly", width=8)
        anno_combo.pack(side="left")
        ttk.Button(
            top_bar,
            text="üîô",
            style='Yellow.TButton',
            command=lambda: [anno_var.set(datetime.date.today().year)]
        ).pack(side="left", padx=(5, 0))
        ttk.Checkbutton(
            top_bar,
            text="Includi movimenti futuri nei totali",
            variable=mostra_future_var
        ).pack(side="left", padx=(30, 0))
        colonne = ttk.Frame(main)
        colonne.pack(fill="x", padx=5)
        sinistra = ttk.Frame(colonne)
        destra = tk.Frame(colonne, bg=self.COLOR_TOPLEVEL)
        sinistra.pack(side="left", fill="both", expand=True, padx=(0, 40))
        destra.pack(side="right", fill="both", expand=True)
        ttk.Label(sinistra, text="üéØ Selezione manuale", font=("Arial", 10, "bold")).pack(anchor="w", pady=(0, 6))
        destra_label = tk.Label(destra, bg=self.COLOR_TOPLEVEL ,fg=self.TEXT_COLOR, text="üìä Top 10 categorie per risparmio", font=("Arial", 10, "bold"))
        destra_label.pack(anchor="w", pady=(0, 6))
        combo_vars = []
        combo_widgets = []
        for _ in range(10):
            var = tk.StringVar()
            cbx = ttk.Combobox(sinistra, textvariable=var, style="Border.TCombobox", state="readonly", width=30)
            cbx.set("‚Äî Nessuna ‚Äî")
            cbx.pack(pady=2, anchor="w")
            combo_vars.append(var)
            combo_widgets.append(cbx)
        selezioni = {}
        ttk.Separator(main, orient="horizontal").pack(fill="x", pady=14)
        ttk.Label(main, text="üí° Risultato della simulazione:", font=("Arial", 10, "bold")).pack(anchor="w", padx=5)
        text_frame = ttk.Frame(main)
        text_frame.pack(fill="both", expand=True, padx=5, pady=(0, 10))
        text_frame.columnconfigure(0, weight=1)
        text_frame.rowconfigure(0, weight=1)
        scroll_y = ttk.Scrollbar(text_frame, orient=tk.VERTICAL, style="Vertical.TScrollbar")
        scroll_y.grid(row=0, column=1, sticky="ns")
        text_output = tk.Text(
            text_frame, 
            height=10, 
            wrap="word",
            yscrollcommand=scroll_y.set
        )
        text_output.configure(font=("Courier New", 10), bg=self.COLOR_TOPLEVEL, fg=self.TEXT_COLOR)
        text_output.grid(row=0, column=0, sticky="nsew")
        scroll_y.config(command=text_output.yview) 
        def aggiorna_categorie():
            anno = anno_var.get()
            contatori = {}
            oggi = datetime.date.today()
            for d, sp in self.spese.items():
                try:
                    if isinstance(d, str):
                        d_conv = datetime.datetime.strptime(d, "%d-%m-%Y").date()
                    else:
                        d_conv = d
                except:
                    continue
                if not mostra_future_var.get() and d_conv > oggi:
                    continue
                if d_conv.year != anno:
                    continue
                for voce in sp:
                    if len(voce) < 4:
                        continue
                    cat, _, imp, tipo = voce[:4]
                    key = cat.strip().lower()
                    if key not in contatori:
                        contatori[key] = {"count": 0, "uscite": 0.0, "entrate": 0.0}
                    contatori[key]["count"] += 1
                    if tipo == "Uscita":
                        contatori[key]["uscite"] += imp
                    elif tipo == "Entrata":
                        contatori[key]["entrate"] += imp
            for key in contatori:
                contatori[key]["risparmio"] = contatori[key]["uscite"] - contatori[key]["entrate"]
            return contatori
        def aggiorna_interfaccia(*_):
            contatori = aggiorna_categorie()
            tutte_categorie_da_spese = [k.lower() for k in contatori.keys()]
            tutte_categorie_principali = [k.lower() for k in self.categorie_tipi.keys()]
            tutte_categorie = sorted(list(set(tutte_categorie_da_spese) | set(tutte_categorie_principali)))
            valori_combo = ["‚Äî Nessuna ‚Äî"] + tutte_categorie
            for var, cb in zip(combo_vars, combo_widgets):
                cb["values"] = valori_combo
                if var.get().strip().lower() not in tutte_categorie:
                    var.set("‚Äî Nessuna ‚Äî")
            for w in destra.winfo_children():
                if w != destra_label:
                    w.destroy()
            top_cat = sorted(contatori.items(), key=lambda x: -x[1]["risparmio"])[:10]
            selezioni.clear()
            for cat, dati in top_cat:
                var = tk.BooleanVar(value=False)
                selezioni[cat] = (var, dati)
                txt = f"{cat.title()} ‚Äì {dati['count']}√ó, Risparmio: {dati['risparmio']:.2f} ‚Ç¨ (Uscite: {dati['uscite']:.2f} - Entrate: {dati['entrate']:.2f})"
                chk = tk.Checkbutton(
                    destra, 
                    text=txt, 
                    variable=var,
                    bg=self.COLOR_TOPLEVEL, 
                    fg=self.TEXT_COLOR,     
                    selectcolor=self.COLOR_TOPLEVEL,
                    activebackground=self.COLOR_TOPLEVEL,
                    highlightthickness=0 
                )
                chk.pack(anchor="w", pady=2)
        def esegui_simulazione():
            contatori = aggiorna_categorie()
            text_output.delete("1.0", tk.END)
            lines = [f"üï∞Ô∏è Time Machine ‚Äì Anno {anno_var.get()}\n"]
            totale = 0.0
            scelte = set()
            for cat, (var, _) in selezioni.items():
                if var.get():
                    scelte.add(cat)
            for var in combo_vars:
                val = var.get().strip().lower()
                if val and val != "‚Äî nessuna ‚Äî" and val in contatori:
                    scelte.add(val)
            risultati = []
            for cat in scelte:
                dati = contatori.get(cat)
                if dati:
                    risultati.append((cat, dati["count"], dati["uscite"], dati["entrate"], dati["risparmio"]))
            risultati.sort(key=lambda x: -x[4])
            lines.append(f"üí≠ Proiezione del risparmio ottenibile nel {anno_var.get()}, escludendo le categorie selezionate: ‚û§\n")
            lines.append(f"{'Categoria':<25} {'Num':>4}   {'Uscite (‚Ç¨)':>12}   {'Entrate (‚Ç¨)':>12}   {'Risparmio (‚Ç¨)':>14}")
            lines.append("-" * 77)
            for cat, n, usc, ent, risp in risultati:
                lines.append(f"{cat.title():<25} {n:>4}   {usc:>12.2f}   {ent:>12.2f}   {risp:>14.2f}")
                totale += risp
            lines.append("-" * 77)
            lines.append(f"\nüí∞ Risparmio totale teorico: {totale:.2f} ‚Ç¨ (Uscite - Entrate delle categorie selezionate)")
            text_output.insert("1.0", "\n".join(lines))
        def reset_tutto():
            anno_var.set(datetime.date.today().year)
            mostra_future_var.set(True)
            for var in combo_vars:
                var.set("‚Äî Nessuna ‚Äî")
            for var, _ in selezioni.values():
                var.set(False)
            text_output.delete("1.0", tk.END)
            aggiorna_interfaccia()
        def salva_file():
            content = text_output.get("1.0", "end").strip()
            if not content:
                self.show_custom_warning("Nessun dato", "Non c'√® nessuna simulazione da salvare.")
                return
            now = datetime.date.today()
            default_filename = f"Time_Machine_{now.day:02d}_{now.month:02d}_{now.year}.txt"
            file = filedialog.asksaveasfilename(
                defaultextension=".txt",
                filetypes=[("File txt", "*.txt")],
                initialdir=EXPORT_FILES,
                initialfile=default_filename,
                title="Esporta risultato simulazione",
                confirmoverwrite=False,
                parent=popup)
            if file:
                if os.path.exists(file):
                    conferma = self.show_custom_askyesno(
                        "Sovrascrivere file?",
                        f"Il file '{os.path.basename(file)}' \nesiste gi√†. Vuoi sovrascriverlo?"
                    )
                    if not conferma:
                        return
                with open(file, "w", encoding="utf-8") as f:
                    f.write(content)
                self.show_custom_warning("Esportazione completata", f"Simulazione salvata in:\n{file}")
        anno_combo.bind("<<ComboboxSelected>>", lambda e: aggiorna_interfaccia())
        mostra_future_var.trace_add("write", lambda *a: aggiorna_interfaccia())
        aggiorna_interfaccia()
        pulsanti = ttk.Frame(main)
        pulsanti.pack(pady=5)
        ttk.Button(pulsanti, text="üü• Simula Risparmio", command=esegui_simulazione, style="Verde.TButton").pack(side="left", padx=10)
        ttk.Button(pulsanti, text="üíæ Esporta", command=salva_file, style="Arancio.TButton").pack(side="left", padx=10)
        ttk.Button(pulsanti, text="üîÑ Reset campi", command=reset_tutto, style="Giallo.TButton").pack(side="left", padx=10)
        ttk.Button(pulsanti, text="‚úñ Chiudi", command=popup.destroy, style="Giallo.TButton").pack(side="left", padx=10)
        popup.bind("<Escape>", lambda e: popup.destroy())
        
    # Gestore Doppio Click su Movimento Mensile (Navigazione Giornaliera)
    def on_spese_mese_tree_double_click(self, event):
        self.mostra_treeview_statistiche()
        self.after(0, self.imp_entry.focus_set)
        item_id = self.spese_mese_tree.identify_row(event.y)
        if not item_id:
            return
        values = self.spese_mese_tree.item(item_id, "values")
        if not values:
            return
        data_str = str(values[0]).strip()
        try:
            giorno = datetime.datetime.strptime(data_str, "%d-%m-%Y").date()
        except Exception:
            try:
                giorno = datetime.datetime.strptime(data_str, "%d/%m/%Y").date()
            except Exception:
                return
        self.set_stats_mode("giorno")
        if hasattr(self, "cal"):
            self.cal.selection_set(giorno)
            self.cal._sel_date = giorno
        self.update_stats()
        self.stats_label.config(text=f"Riepilogo Giornaliero - {giorno.strftime('%d-%m-%Y')}", foreground="purple",
    font=("Arial", 10, "bold"))

    # Visualizzazione Dettagliata per Categoria (Doppio Click sul Riepilogo)
    def on_stats_table_double_click(self, event):
        MESI_NOME_COMPLETO = {
            1: "Gennaio", 2: "Febbraio", 3: "Marzo", 4: "Aprile", 
            5: "Maggio", 6: "Giugno", 7: "Luglio", 8: "Agosto", 
            9: "Settembre", 10: "Ottobre", 11: "Novembre", 12: "Dicembre"
        }
        mode = self.stats_mode.get()
        item_id = self.stats_table.identify_row(event.y)
        if not item_id:
            return
        values = self.stats_table.item(item_id, "values")
        if not values or len(values) < 1:
            return
        categoria = str(values[0]).strip()
        categoria_selezionata = str(values[1]).strip()
        spese_categoria = []
        if mode == "giorno":
            try:
                from datetime import datetime
                stringa_giorno = str(values[0]).strip()
                solo_numero_giorno = "".join(filter(str.isdigit, stringa_giorno))[:2].zfill(2)
                ref = self.stats_refdate
                mese_corretto = f"{ref.month:02d}"
                anno_corretto = f"{ref.year}"
                data_estratta = f"{solo_numero_giorno}-{mese_corretto}-{anno_corretto}"
                def pulisci_importo(testo):
                    if not testo: return 0.0
                    t = str(testo).replace('‚Ç¨', '').replace(' ', '').strip()
                    if '.' in t and ',' in t:
                        t = t.replace('.', '').replace(',', '.')
                    elif ',' in t:
                        t = t.replace(',', '.')
                    try:
                        return float(t)
                    except:
                        return 0.0
                categoria_da_tabella = str(values[1]).strip() if len(values) > 1 else "Generica"
                descrizione_reale = str(values[2]).strip() if len(values) > 2 else ""
                val_imp = pulisci_importo(values[3]) if len(values) > 3 else 0.0
                importo_finale = f"{abs(val_imp):,.2f}".replace(',', 'X').replace('.', ',').replace('X', '.')
                tipo_movimento = str(values[4]).strip() if len(values) > 4 else "Uscita"
                self.after(500, lambda: self.gestisci_archivi_pdf(
                    categoria_iniziale=categoria_da_tabella, 
                    data_iniziale=data_estratta,
                    importo_iniziale=importo_finale,
                    tipo_iniziale=tipo_movimento,
                    descrizione_iniziale=descrizione_reale
                ))
                return
            except Exception as e:
                print(f"Errore estrazione dati: {e}")

        if mode == "mese":
            ref = self.stats_refdate
            mese, anno = ref.month, ref.year
            nome_mese = MESI_NOME_COMPLETO.get(mese, f"{mese:02d}")
            for d, sp in self.spese.items():
                if d.month == mese and d.year == anno:
                    for entry in sp:
                        cat, desc, imp, tipo = entry[:4]
                        if cat.strip() == categoria: 
                            spese_categoria.append((d, desc, imp, tipo))
            titolo_periodo = f"{nome_mese} {anno}"
            testo_periodo = f"il mese di {nome_mese} {anno}"
            
        elif mode == "anno":
            ref = self.stats_refdate
            anno = ref.year
            for d, sp in self.spese.items():
                if d.year == anno:
                    for entry in sp:
                        cat, desc, imp, tipo = entry[:4]
                        if cat.strip() == categoria:
                            spese_categoria.append((d, desc, imp, tipo))
            titolo_periodo = f"{anno}"
            testo_periodo = f"l'anno {anno}"
        elif mode == "totali":
            for d, sp in self.spese.items():
                for entry in sp:
                    cat, desc, imp, tipo = entry[:4]
                    if cat.strip() == categoria:
                        spese_categoria.append((d, desc, imp, tipo))
            titolo_periodo = "Tutte le annualit√†"
            testo_periodo = "tutti gli anni"
        if not spese_categoria:
            self.show_custom_info("Nessuna spesa", f"Nessuna spesa per la categoria '{categoria}' nel periodo selezionato.")
            return
        popup = tk.Toplevel(self, bg=self.COLOR_TOPLEVEL)
        popup.title(f"Dettaglio Movimenti - {categoria} ({titolo_periodo})")
        popup.geometry("650x410")
        popup.withdraw()
        self.update_idletasks()
        main_x = self.winfo_x()
        main_y = self.winfo_y()
        main_width = self.winfo_width()
        main_height = self.winfo_height()
        popup_width = 650
        popup_height = 410
        center_x = main_x + (main_width // 2) - (popup_width // 2)
        center_y = main_y + (main_height // 2) - (popup_height // 2)
        popup.geometry(f"{popup_width}x{popup_height}+{center_x}+{center_y}")
        popup.transient(self)
        popup.update_idletasks()
        popup.deiconify()
        popup.update()
        popup.grab_set()
        label = tk.Label(
            popup,
            text=f"Movimenti Categoria '{categoria}' per {testo_periodo}",
            font=("Arial", 11),
            bg=self.COLOR_TOPLEVEL,
            fg=self.TEXT_COLOR
        )
        label.pack(pady=8)
        tree_frame = ttk.Frame(popup)
        tree_frame.pack(fill="both", expand=True, padx=10, pady=6)
        vsb = ttk.Scrollbar(tree_frame, orient="vertical", style="Vertical.TScrollbar")
        vsb.pack(side="right", fill="y")
        columns = ("Data", "Descrizione", "Importo", "Tipo")
        tree = ttk.Treeview(
            tree_frame, 
            columns=columns, 
            show="headings", 
            height=10,
            yscrollcommand=vsb.set
        )
        tree.pack(fill="both", expand=True, side="left")
        vsb.config(command=tree.yview)
        def ordina_colonna(treeview, colonna, inverti):
            dati = [(treeview.set(k, colonna), k) for k in treeview.get_children("")]
            try:
                if colonna == "Data":
                    dati.sort(
                        key=lambda t: datetime.datetime.strptime(t[0], "%d-%m-%Y"),
                        reverse=inverti
                    )
                elif colonna == "Importo":
                    dati.sort(
                        key=lambda t: float(t[0].replace(" ‚Ç¨", "").replace(".", "").replace(",", ".")),
                        reverse=inverti
                    )
                else:
                    dati.sort(key=lambda t: t[0].lower(), reverse=inverti)
            except Exception as e:
                print("Errore ordinamento:", e)
            for index, (_, k) in enumerate(dati):
                treeview.move(k, "", index)
            treeview.heading(colonna, command=lambda: ordina_colonna(treeview, colonna, not inverti))
        for col, w in zip(columns, (90, 230, 100, 80)):
            anchor = "w" if col == "Descrizione" else "center"
            tree.heading(col, text=col, command=lambda c=col: ordina_colonna(tree, c, False))
            tree.column(col, width=w, anchor=anchor)
        tot_entrate = tot_uscite = 0.0
        for d, desc, imp, tipo in sorted(spese_categoria, key=lambda x: x[0], reverse=True):
            imp_formattato_it = f"{imp:,.2f}".replace(',', 'X').replace('.', ',').replace('X', '.')
            tag_name = f"row_{d.strftime('%Y%m%d%H%M%S')}_{len(tree.get_children(''))}"
            tree.insert("", "end", values=(d.strftime("%d-%m-%Y"), desc, f"{imp_formattato_it} ‚Ç¨", tipo), tags=(tag_name,))
            if tipo == "Entrata":
                tree.tag_configure(tag_name, foreground="green")
                tot_entrate += imp
            else:
                tree.tag_configure(tag_name, foreground="red")
                tot_uscite += imp
        saldo = tot_entrate - tot_uscite
        lbl = tk.Text(
            popup, 
            bg=self.COLOR_TOPLEVEL, 
            fg=self.TEXT_COLOR, 
            height=1, 
            borderwidth=0, 
            font=("Arial", 10, "bold"), 
            wrap="none", 
            background=popup.cget("background"),
            highlightthickness=0,
            relief="flat"
        )
        lbl.pack(pady=7)
        lbl.tag_config("entrate_color", foreground="green")
        lbl.tag_config("uscite_color", foreground="red")
        lbl.tag_config("saldo_pos_color", foreground="green")
        lbl.tag_config("saldo_neg_color", foreground="red")
        def formatta_italiano(valore):
            return f"{valore:,.2f}".replace(',', 'X').replace('.', ',').replace('X', '.')
        entrate_str_num = formatta_italiano(tot_entrate)
        uscite_str_num = formatta_italiano(tot_uscite)
        saldo_str_num = formatta_italiano(saldo)
        text_full = f"Totale entrate: {entrate_str_num} ‚Ç¨  Totale uscite: {uscite_str_num} ‚Ç¨  Saldo: {saldo_str_num} ‚Ç¨"
        lbl.config(state="normal")
        lbl.insert("end", text_full)
        entrate_start = text_full.find(entrate_str_num)
        entrate_end = entrate_start + len(entrate_str_num)
        lbl.tag_add("entrate_color", f"1.{entrate_start}", f"1.{entrate_end}")
        uscite_start = text_full.find(uscite_str_num, entrate_end)
        uscite_end = uscite_start + len(uscite_str_num)
        lbl.tag_add("uscite_color", f"1.{uscite_start}", f"1.{uscite_end}")
        saldo_start = text_full.find(saldo_str_num, uscite_end)
        saldo_end = saldo_start + len(saldo_str_num)
        if saldo >= 0:
            lbl.tag_add("saldo_pos_color", f"1.{saldo_start}", f"1.{saldo_end}")
        else:
            lbl.tag_add("saldo_neg_color", f"1.{saldo_start}", f"1.{saldo_end}")
        lbl.config(state="disabled")
        tree.bind("<Double-1>", lambda evt: self.goto_day_from_popup(tree, popup))
        ttk.Button(popup, text="‚úñ Chiudi", style="Giallo.TButton", command=popup.destroy).pack(pady=4)

    # Navigazione al Giorno (Da Finestra di Dettaglio)
    def goto_day_from_popup(self, tree, popup):
        if self.stats_view_mode.get() != "tabella":
                self.mostra_treeview_statistiche()
        item_id = tree.focus()
        if not item_id:
                return
        vals = tree.item(item_id, "values")
        if not vals or len(vals) < 1:
                return
        data_str = vals[0]
        try:
                giorno = datetime.datetime.strptime(data_str, "%d-%m-%Y").date()
        except Exception:
                return
        self.set_stats_mode("giorno")
        if hasattr(self, "cal"):
                self.cal.selection_set(giorno)
                self.cal._sel_date = giorno
        self.stats_refdate = giorno
        self.estratto_month_var.set(f"{giorno.month:02d}")
        self.estratto_year_var.set(str(giorno.year))
        self.stats_label.config(text=f"Riepilogo Giornaliero - {giorno.strftime('%d-%m-%Y')}", 
                                foreground="purple", font=("Arial", 10, "bold"))
        def chiudi_e_aggiorna():
            try:
                popup.destroy()
            except Exception:
                pass
            if hasattr(self, 'grafico_analisi_popup') and self.grafico_analisi_popup is not None:
                try:
                    self.grafico_analisi_popup.destroy()
                    self.grafico_analisi_popup = None
                except Exception:
                    pass
            if hasattr(self, 'popup_grafico') and self.popup_grafico and self.popup_grafico.winfo_exists():
                self.popup_grafico.destroy()
                del self.popup_grafico
            self.update_stats() 
            self.after_idle(lambda: self.forza_scroll_e_pulizia_selezione() if hasattr(self, 'forza_scroll_e_pulizia_selezione') else None)
        self.after(50, chiudi_e_aggiorna)
        
    # Gestore Cambio Stato Blocco Data
    def on_blocca_data_changed(self):
        if not self.blocca_data_var.get():
            self.data_spesa_var.set(datetime.date.today().strftime("%d-%m-%Y"))
            
    # Gestore Login Locale
    def gestione_login(self):
        def hash_pw(pw):
            return hashlib.sha256(pw.encode()).hexdigest()
        def salva_hash(pw):
            with open(PW_FILE, "w") as f:
                json.dump({"hash": hash_pw(pw)}, f)
        def leggi_hash():
            if not os.path.exists(PW_FILE): return None
            try:
                with open(PW_FILE) as f: 
                    return json.load(f).get("hash")
            except: return None
        login_riuscito = [False]
        args = sys.argv
        salvata = leggi_hash()
        def crea_campo_password_moderno(parent, etichetta=""):
            if etichetta:
                tk.Label(parent, text=etichetta, bg="#1e1e1e", fg="#61AFEF", 
                         font=("Segoe UI", 9, "bold")).pack(pady=(10, 2), anchor="w", padx=50)
            frame_container = tk.Frame(parent, bg="#333333", bd=1, relief="flat")
            frame_container.pack(pady=5, padx=50, fill="x")
            visibile = tk.BooleanVar(value=False)
            entry_pw = tk.Entry(frame_container, show="*", bg="#333333", fg="white", 
                                insertbackground="white", font=("Segoe UI", 11), relief="flat", borderwidth=7)
            entry_pw.pack(side="left", padx=5, fill="x", expand=True)
            def toggle_visibilita():
                if visibile.get():
                    entry_pw.config(show="*")
                    lbl_occhio.config(text="üëÅÔ∏è", fg="#777777")
                else:
                    entry_pw.config(show="")
                    lbl_occhio.config(text="üï∂Ô∏è", fg="#61AFEF")
                visibile.set(not visibile.get())
            lbl_occhio = tk.Label(frame_container, text="üëÅÔ∏è", font=("Arial", 12), bg="#333333", 
                                  fg="#777777", cursor="hand2")
            lbl_occhio.pack(side="right", padx=5)
            lbl_occhio.bind("<Button-1>", lambda e: toggle_visibilita())
            entry_pw.bind("<FocusIn>", lambda e: frame_container.config(bg="#61AFEF"))
            entry_pw.bind("<FocusOut>", lambda e: frame_container.config(bg="#333333"))
            return entry_pw
        def cambia_password(parent_login):
            parent_login.withdraw()
            win = tk.Toplevel(self) 
            win.title(f"Password - {NAME} v{VERSION}")
            win.configure(bg="#1e1e1e")
            win.resizable(False, False)
            w_win, h_win = 350, 380
            x_win = self.winfo_screenwidth() // 2 - w_win // 2
            y_win = self.winfo_screenheight() // 2 - h_win // 2
            win.geometry(f"{w_win}x{h_win}+{x_win}+{y_win}")
            def on_close_cambio():
                win.destroy()
                parent_login.deiconify()
            win.protocol("WM_DELETE_WINDOW", on_close_cambio)
            win.grab_set()
            tk.Label(win, text="üîÑ", font=("Arial", 20), bg="#1e1e1e", fg="#61AFEF").pack(pady=(2, 0))
            tk.Label(win, text="CAMBIO PASSWORD", font=("Segoe UI", 10, "bold"), 
                     bg="#1e1e1e", fg="red").pack(pady=(0, 2))
            mess = tk.Label(win, text="", fg="#E06C75", bg="#1e1e1e", font=("Segoe UI", 9))
            entry_attuale = crea_campo_password_moderno(win, "Password Vecchia")
            entry_nuova = crea_campo_password_moderno(win, "Nuova Password (vuota per disattivare.)")
            entry_conferma = crea_campo_password_moderno(win, "Conferma Nuova")
            win.update_idletasks()
            win.after(200, lambda: entry_attuale.focus_force())
            mess.pack(pady=0)
            def esegui_conferma_cambio(event=None):
                attuale = entry_attuale.get()
                nuova = entry_nuova.get()
                conferma = entry_conferma.get()
                if hash_pw(attuale) != leggi_hash():
                    mess.config(text="‚ùå Password attuale errata!", fg="#E06C75")
                    return
                if not nuova:
                    salva_hash("")
                    mess.config(text="‚úì Protezione Password disattivata!", fg="#98C379")
                    win.after(1200, lambda: [win.destroy(), parent_login.deiconify()])
                    return
                if nuova != conferma:
                    mess.config(text="‚ùå Le password non corrispondono!", fg="#E06C75")
                    return
                salva_hash(nuova)
                mess.config(text="‚úì Password Aggiornata!", fg="#98C379")
                win.after(1200, lambda: [win.destroy(), parent_login.deiconify()])
            for entry in [entry_attuale, entry_nuova, entry_conferma]:
                entry.bind("<Return>", esegui_conferma_cambio)
                entry.bind("<KP_Enter>", esegui_conferma_cambio)
            frame_btn = tk.Frame(win, bg="#1e1e1e")
            frame_btn.pack(pady=(0, 0), fill="x", padx=50)
            btn_annulla = tk.Button(frame_btn, text="ANNULLA", command=on_close_cambio,
                                    bg="#61AFEF", fg="black", font=("Segoe UI", 9, "bold"),
                                    relief="flat", cursor="hand2", padx=8, pady=3)
            btn_annulla.pack(side="left")
            btn_conferma = tk.Button(frame_btn, text="CONFERMA", command=esegui_conferma_cambio,
                                     bg="#61AFEF", fg="black", font=("Segoe UI", 9, "bold"),
                                     relief="flat", cursor="hand2", padx=8, pady=3)
            btn_conferma.pack(side="right")

        def mostra_finestra_login():
            tentativi_falliti = 0
            MAX_TENTATIVI = 3
            is_primo_accesso = not os.path.exists(PW_FILE)
            ultimo_login_str = "Nessun accesso precedente"
            if os.path.exists(LOGIN_LCL):
                try:
                    with open(LOGIN_LCL, "r") as f:
                        ultimo_login_str = json.load(f).get("ultimo_login", "N/D")
                except: pass
            login = tk.Toplevel(self)
            self.set_app_icon()
            login.title(f"Accesso {NAME} Pro v.{VERSION}")
            login.configure(bg="#1e1e1e")
            login.resizable(False, False)
            def chiusura():
                self._on_close_lock()
                os._exit(0)
            login.protocol("WM_DELETE_WINDOW", chiusura)
            w, h = 350, 380
            x = self.winfo_screenwidth() // 2 - w // 2
            y = self.winfo_screenheight() // 2 - h // 2
            login.geometry(f"{w}x{h}+{x}+{y}")
            login.grab_set()
            tk.Label(login, text="üîí", font=("Arial", 30), bg="#1e1e1e", fg="white").pack(pady=(10, 0))
            if is_primo_accesso:
                tk.Label(login, text="BENVENUTO!", font=("Segoe UI", 16, "bold"), bg="#1e1e1e", fg="#98C379").pack(pady=(10, 0))
                tk.Label(login, text="Configurazione Iniziale:\nImposta una password per proteggere i tuoi dati,\no premi INVIO per continuare senza protezione.", 
                         font=("Segoe UI", 10), bg="#1e1e1e", fg="#abb2bf", justify="center").pack(pady=5)
            else:
                tk.Label(login, text="AREA RISERVATA", font=("Segoe UI", 16, "bold"), bg="#1e1e1e", fg="red").pack(pady=(10, 0))
                tk.Label(login, text=f"Utente: {current_folder}", font=("Segoe UI", 11), bg="#1e1e1e", fg="#555555").pack()
                tk.Label(login, text=f"Ultimo accesso: {ultimo_login_str}", font=("Segoe UI", 9, "italic"), 
                         bg="#1e1e1e", fg="#D19A66").pack(pady=5)
                tk.Label(login, text=f"S-ID: {self.SESSION_ID}", font=("Segoe UI", 8), 
                     bg="#1e1e1e", fg="#D19A66").place(x=290, y=20)
            entry_pw = crea_campo_password_moderno(login, "Inserisci Password")            
            login.update_idletasks()
            login.after(200, lambda: entry_pw.focus_force())            
            messaggio_errore = tk.Label(login, text="", fg="#E06C75", font=("Segoe UI", 9), bg="#1e1e1e")
            messaggio_errore.pack(pady=5)
            
            testo_da_mostrare = "‚ö†Ô∏è AVVISO LEGALE L'accesso non autorizzato a questo sistema √® perseguibile ai sensi dell'Art. 615-ter del Codice Penale. Ogni tentativo di intrusione sar√† perseguito nei termini di legge a tutela della riservatezza dei dati contenuti. "
            frame_marquee = tk.Frame(login, bg="#1e1e1e", width=250, height=20)
            frame_marquee.pack_propagate(False)
            frame_marquee.place(x=50, y=2)
            lbl_scroll = tk.Label(frame_marquee, text=testo_da_mostrare + "          " + testo_da_mostrare, 
                                 font=("Courier new", 8, "bold"), bg="#1e1e1e", fg="orange")
            lbl_scroll.place(x=0, y=0)
            login.update_idletasks()
            larghezza_testo_singolo = lbl_scroll.winfo_reqwidth() // 2
            self.x_pos = 0
            def anima_fluida():
                if not login.winfo_exists(): return
                self.x_pos -= 1
                if abs(self.x_pos) >= larghezza_testo_singolo:
                    self.x_pos = 0
                lbl_scroll.place(x=self.x_pos, y=0)
                login.after(30, anima_fluida)
            anima_fluida()
            
            def esegui_conferma_login(event=None):
                nonlocal tentativi_falliti
                inserita = entry_pw.get()
                salvata = leggi_hash()
                adesso = datetime.datetime.now().strftime("%d/%m/%Y %H:%M")
                if salvata is None:
                    salva_hash(inserita)
                    try:
                        with open(LOGIN_LCL, "w") as f:
                            json.dump({"ultimo_login": adesso}, f)
                    except: pass
                    login_riuscito[0] = True
                    login.destroy()
                    return
                if hash_pw(inserita) == salvata:
                    try:
                        with open(LOGIN_LCL, "w") as f:
                            json.dump({"ultimo_login": adesso}, f)
                    except: pass
                    login_riuscito[0] = True
                    login.destroy()
                else:
                    tentativi_falliti += 1
                    entry_pw.delete(0, tk.END)
                    if tentativi_falliti >= MAX_TENTATIVI: chiusura()
                    messaggio_errore.config(text=f"Password Errata ({tentativi_falliti}/{MAX_TENTATIVI})")
            entry_pw.bind("<Return>", esegui_conferma_login)
            entry_pw.bind("<KP_Enter>", esegui_conferma_login)
            frame_login_btn = tk.Frame(login, bg="#1e1e1e")
            frame_login_btn.pack(pady=(1, 0), fill="x", padx=40)
            tk.Button(frame_login_btn, text="CHIUDI", command=chiusura, bg="#E06C75", fg="black",
                      font=("Segoe UI", 9, "bold"), relief="flat", cursor="hand2", width=8, pady=3).pack(side="right")
            tk.Button(frame_login_btn, text="ENTRA", command=esegui_conferma_login, bg="#98C379", fg="black",
                      font=("Segoe UI", 9, "bold"), relief="flat", cursor="hand2", width=8, pady=3).pack(side="left")
            if not is_primo_accesso:
                    tk.Button(login, text="Cambio Password", command=lambda: cambia_password(login),
                      bg="#1e1e1e", fg="#61AFEF", font=("Segoe UI", 8, "underline"),
                      relief="flat", cursor="hand2").pack(pady=(30, 0))
            login.wait_window()
            
        # Logica di avvio bypass
        if "auto" in args:
            index = args.index("auto")
            arg_pw = args[index + 1] if len(args) > index + 1 else ""
            if salvata and hash_pw(arg_pw) == salvata:
                login_riuscito[0] = True
                print("‚úì Login automatico da CLI riuscito.")
        elif AUTO_ICONIZE_STARTUP and (salvata == hash_pw("") or not salvata):
            login_riuscito[0] = True
            print("‚úì Login bypassato (Password vuota).")
        if not login_riuscito[0]:
            mostra_finestra_login()
        if login_riuscito[0]:
            if ("noweb" not in args) and ABILITA_WEBSERVER:
                threading.Thread(target=self.start_web_server, daemon=True).start()
                print("üåê Server web avviato.")
            if "auto" in args or AUTO_ICONIZE_STARTUP:
                self.after(500, self._iconizza_finestra_startup)
            return True
        return False
    
    # Importa da Estratti Bancari
    def apri_finestra_importa(self):
        win = tk.Toplevel(self)
        win.title("Importa Spese")
        larghezza, altezza = 300, 160
        x = (win.winfo_screenwidth() // 2) - (larghezza // 2)
        y = (win.winfo_screenheight() // 2) - (altezza // 2)
        win.geometry(f"{larghezza}x{altezza}+{x}+{y}")
        win.resizable(False, False)
        win.grab_set()
        win.configure(bg="#F9F9D1") 
        tk.Label(win, text="Seleziona la banca:", font=("Arial", 10), bg="#F9F9D1").pack(pady=(10, 4))
        banca_var = tk.StringVar()
        banca_combo = ttk.Combobox(win, textvariable=banca_var, style="Border.TCombobox", state="readonly", values=["-- Nessuna --", "UniCredit", "Intesa", "Fineco", "Altra..."])
        banca_combo.set("-- Nessuna --")  
        banca_combo.pack()
        frame_bottoni = tk.Frame(win, bg="#F9F9D1")
        frame_bottoni.pack(pady=10)
        btn_icc = ttk.Button(frame_bottoni, text="üí≥ ICC", width=10, style="Verde.TButton", command=lambda: [win.destroy(), self.importa_spese_csv_unicredit()])
        btn_ccv = ttk.Button(frame_bottoni, text="üè¶ CCV", width=10, style="Verde.TButton", command=lambda: [win.destroy(), self.importa_spese_cc_csv_unicredit()])
        btn_icc.pack(side="left", padx=8)
        btn_ccv.pack(side="right", padx=8)
        btn_icc.pack_forget()
        btn_ccv.pack_forget()
        messaggio_var = tk.StringVar()
        label_messaggio = tk.Label(win, textvariable=messaggio_var, font=("Arial", 9), bg="#F9F9D1", fg="gray25")
        label_messaggio.pack(pady=(6, 2))
        def mostra_bottoni(event=None):
            banca = banca_var.get()
            if banca == "UniCredit":
                messaggio_var.set("‚úì Importazione disponibile per UniCredit:")
                btn_icc.pack(side="left", padx=8)
                btn_ccv.pack(side="right", padx=8)
            else:
                btn_icc.pack_forget()
                btn_ccv.pack_forget()
                messaggio_var.set(f"‚ö†Ô∏è Importazione da {banca} non ancora disponibile.")
        banca_combo.bind("<<ComboboxSelected>>", mostra_bottoni)
    def importa_spese_csv_unicredit(self):
        from datetime import datetime
        path = filedialog.askopenfilename(
            title="Seleziona Estratto CARTA UNICREDIT",
            filetypes=[("File CSV", "*.csv")]
        )
        if not path:
            return
        movimenti = []
        try:
            with open(path, newline="", encoding="utf-8") as f:
                reader = csv.DictReader(f, delimiter=";")
                for row in reader:
                    try:
                        data = datetime.strptime(row["Data Registrazione"], "%d/%m/%Y").date()
                        descrizione = row["Descrizione"].strip()
                        importo = float(row["Importo"].replace(",", "."))
                        movimenti.append({"data": data, "descrizione": descrizione, "importo": importo})
                    except Exception as e:
                        print("Errore riga:", row, "‚Üí", e)
        except Exception as e:
            self.show_custom_warning("Errore apertura CSV", str(e))
            return
        if not movimenti:
            self.show_custom_warning("Importazione", "Nessuna spesa valida trovata.")
            return
        movimenti.sort(key=lambda m: m["data"])
        if not hasattr(self, "memoria_descrizioni_categoria"):
            self.memoria_descrizioni_categoria = {}
        memoria = self.memoria_descrizioni_categoria
        win = tk.Toplevel(self)
        win.resizable(False, False)
        win.title("Importa da Unicredit Credit Card")
        larghezza, altezza = 820, 600
        x = (win.winfo_screenwidth() // 2) - (larghezza // 2)
        y = (win.winfo_screenheight() // 2) - (altezza // 2)
        win.geometry(f"{larghezza}x{altezza}+{x}+{y}")
        win.update_idletasks()
        win.grab_set()
        contenitore = tk.Frame(win)
        contenitore.pack(fill="both", expand=True)
        canvas = tk.Canvas(contenitore, highlightthickness=0)
        scrollbar = ttk.Scrollbar(contenitore, orient="vertical", command=canvas.yview, style="Vertical.TScrollbar")
        canvas.configure(yscrollcommand=scrollbar.set)
        canvas.pack(side="left", fill="both", expand=True)
        scrollbar.pack(side="right", fill="y")
        area_dati = tk.Frame(canvas)
        canvas.create_window((0, 0), window=area_dati, anchor="nw")
        area_dati.bind("<Configure>", lambda e: canvas.configure(scrollregion=canvas.bbox("all")))
        pannello_aggiungi_cat = tk.Frame(area_dati)
        pannello_aggiungi_cat.pack(anchor="w", pady=(6, 6), padx=4)
        tk.Label(pannello_aggiungi_cat, text="‚ûï Nuova categoria:", foreground="green").pack(side="left", padx=(0, 4))
        var_nuova_cat = tk.StringVar()
        entry_nuova_cat = ttk.Entry(pannello_aggiungi_cat, textvariable=var_nuova_cat, width=20)
        entry_nuova_cat.pack(side="left")
        def aggiungi_categoria_csv():
            nome = var_nuova_cat.get().strip()
            if not nome:
                self.show_custom_warning("Attenzione", "Il nome categoria √® vuoto.")
                return
            if nome in self.categorie:
                self.show_custom_warning("Attenzione", "Categoria gi√† esistente.")
                return
            self.categorie.append(nome)
            self.categorie_tipi[nome] = "Uscita"
            memoria[nome.strip().upper()] = nome
            var_nuova_cat.set("")
            for _, _, combo in righe:
                combo["values"] = self.categorie
            self.aggiorna_combobox_categorie()
            self.show_custom_info("Categoria creata", f"Categoria '{nome}' aggiunta.")
        btn_aggiungi_cat = ttk.Button(
            pannello_aggiungi_cat,
            text="Aggiungi",
            command=aggiungi_categoria_csv,
            style="Verde.TButton"
        )
        btn_aggiungi_cat.pack(side="left", padx=6)
        entry_nuova_cat.bind("<Return>", lambda e: aggiungi_categoria_csv())
        entry_nuova_cat.bind("<KP_Enter>", lambda e: aggiungi_categoria_csv())
        righe = []
        seleziona_tutti_var = tk.BooleanVar(value=True)
        def toggle_tutti():
            for _, var_check, _ in righe:
                var_check.set(seleziona_tutti_var.get())
        tk.Checkbutton(area_dati, text="‚úî Seleziona tutto", variable=seleziona_tutti_var, command=toggle_tutti).pack(anchor="w", pady=(5, 2))
        header = tk.Frame(area_dati)
        header.pack(anchor="w")
        tk.Label(header, text="‚úî", width=2).grid(row=0, column=0)
        tk.Label(header, text="Data", width=10).grid(row=0, column=1)
        tk.Label(header, text="Descrizione", width=40, anchor="w").grid(row=0, column=2)
        tk.Label(header, text="Importo", width=12, anchor="e").grid(row=0, column=3)
        tk.Label(header, text="Categoria", width=20).grid(row=0, column=4)
        for mov in movimenti:
            riga = tk.Frame(area_dati)
            riga.pack(anchor="w", pady=1)
            var = tk.BooleanVar(value=True)
            tk.Checkbutton(riga, variable=var).grid(row=0, column=0)
            tk.Label(riga, text=mov["data"].strftime("%d/%m/%Y"), width=10).grid(row=0, column=1)
            tk.Label(riga, text=mov["descrizione"], width=40, anchor="w").grid(row=0, column=2)
            tk.Label(riga, text=f"{mov['importo']:.2f} ‚Ç¨", width=12, anchor="e").grid(row=0, column=3)
            chiave = mov["descrizione"].strip().upper()
            categoria = memoria.get(chiave, "Generica")
            combo = ttk.Combobox(riga, values=self.categorie, style="Border.TCombobox", state="readonly", width=20)
            combo.set(categoria)
            combo.grid(row=0, column=4, padx=4)
            righe.append((mov, var, combo))
        bottoni = tk.Frame(win)
        bottoni.pack(pady=10)
        def salva():
            count = 0
            duplicati = 0
            for mov, var, combo in righe:
                if var.get():
                    giorno = mov["data"]
                    descr = mov["descrizione"]
                    imp = abs(mov["importo"])
                    tipo = "Entrata" if mov["importo"] >= 0 else "Uscita"
                    cat = combo.get() or "Generica"
                    voce = (cat, descr, imp, tipo)
                    gia_presente = None
                    for voce_esistente in self.spese.get(giorno, []):
                        cat_es, desc_es, imp_es, tipo_es = voce_esistente
                        if (
                            cat_es == cat and
                            tipo_es == tipo and
                            round(imp_es) == round(imp)
                        ):
                            gia_presente = voce_esistente
                            break
                    if gia_presente:
                        if self.conferma_sostituzione_spesa(giorno, cat, imp_es, imp):
                                self.spese[giorno].remove(gia_presente)
                        else:
                                duplicati += 1
                                continue
                    self.spese.setdefault(giorno, []).append(voce)
                    memoria[descr.strip().upper()] = cat
                    count += 1
            self.save_db()
            self.refresh_gui()
            messaggio = f"{count} Movimenti importati/salvati."
            if duplicati > 0:
                messaggio += f"\n‚ö†Ô∏è {duplicati} duplicate/ignorate."
            self.show_custom_warning("Completato", messaggio)
        def chiudi():
            win.destroy()
            self.show_custom_warning("Annullato", "Importazione interrotta.")     
        ttk.Button(bottoni, text="üíæ Salva", style="Verde.TButton", width=12, command=salva).pack(side="left", padx=10)
        ttk.Button(bottoni, text="‚úñ Chiudi", style="Giallo.TButton", width=12, command=chiudi).pack(side="right", padx=10)
    def importa_spese_cc_csv_unicredit(self):
        from datetime import datetime
        path = filedialog.askopenfilename(
            title="Seleziona Estratto Conto UNICREDIT",
            filetypes=[("File CSV", "*.csv")]
        )
        if not path:
            return
        movimenti = []
        try:
            with open(path, newline="", encoding="utf-8") as f:
                reader = csv.DictReader(f, delimiter=";")
                for row in reader:
                    try:
                        data_str = row["Data Registrazione"].strip()
                        try:
                            data = datetime.strptime(data_str, "%d/%m/%Y").date()
                        except ValueError:
                            data = datetime.strptime(data_str, "%d.%m.%Y").date()
                        descrizione = row["Descrizione"].strip()
                        importo_str = row["Importo (EUR)"].strip().replace(".", "").replace(",", ".")
                        importo = float(importo_str)
                        movimenti.append({"data": data, "descrizione": descrizione, "importo": importo})
                    except Exception as e:
                        print("Errore riga:", row, "‚Üí", e)
        except Exception as e:
            self.show_custom_warning("Errore apertura CSV", str(e))
            return
        if not movimenti:
            self.show_custom_warning("Importazione", "Nessuna spesa valida trovata.")
            return
        movimenti.sort(key=lambda m: m["data"])
        if not hasattr(self, "memoria_descrizioni_categoria"):
            self.memoria_descrizioni_categoria = {}
        memoria = self.memoria_descrizioni_categoria
        win = tk.Toplevel(self)
        win.resizable(False, False)
        win.title("Importa da Unicredit C/C")
        larghezza, altezza = 820, 600
        x = (win.winfo_screenwidth() // 2) - (larghezza // 2)
        y = (win.winfo_screenheight() // 2) - (altezza // 2)
        win.geometry(f"{larghezza}x{altezza}+{x}+{y}")
        win.update_idletasks()
        win.grab_set()
        contenitore = tk.Frame(win)
        contenitore.pack(fill="both", expand=True)
        canvas = tk.Canvas(contenitore, highlightthickness=0)
        scrollbar = ttk.Scrollbar(contenitore, orient="vertical", command=canvas.yview, style="Vertical.TScrollbar")
        canvas.configure(yscrollcommand=scrollbar.set)
        canvas.pack(side="left", fill="both", expand=True)
        scrollbar.pack(side="right", fill="y")
        area_dati = tk.Frame(canvas)
        canvas.create_window((0, 0), window=area_dati, anchor="nw")
        area_dati.bind("<Configure>", lambda e: canvas.configure(scrollregion=canvas.bbox("all")))
        pannello_aggiungi_cat = tk.Frame(area_dati)
        pannello_aggiungi_cat.pack(anchor="w", pady=(6, 6), padx=4)
        tk.Label(pannello_aggiungi_cat, text="‚ûï Nuova categoria:", foreground="green").pack(side="left", padx=(0, 4))
        var_nuova_cat = tk.StringVar()
        entry_nuova_cat = ttk.Entry(pannello_aggiungi_cat, textvariable=var_nuova_cat, width=20)
        entry_nuova_cat.pack(side="left")
        def aggiungi_categoria_csv():
            nome = var_nuova_cat.get().strip()
            if not nome:
                self.show_custom_warning("Attenzione", "Il nome categoria √® vuoto.")
                return
            if nome in self.categorie:
                self.show_custom_warning("Attenzione", "Categoria gi√† esistente.")
                return
            self.categorie.append(nome)
            self.categorie_tipi[nome] = "Uscita"
            memoria[nome.strip().upper()] = nome
            var_nuova_cat.set("")
            for _, _, combo in righe:
                combo["values"] = self.categorie
            self.aggiorna_combobox_categorie()
            self.show_custom_info("Categoria creata", f"Categoria '{nome}' aggiunta.")
        btn_aggiungi_cat = ttk.Button(
            pannello_aggiungi_cat,
            text="Aggiungi",
            command=aggiungi_categoria_csv,
            style="Verde.TButton"
        )
        btn_aggiungi_cat.pack(side="left", padx=6)
        entry_nuova_cat.bind("<Return>", lambda e: aggiungi_categoria_csv())
        entry_nuova_cat.bind("<KP_Enter>", lambda e: aggiungi_categoria_csv())
        righe = []
        seleziona_tutti_var = tk.BooleanVar(value=True)
        def toggle_tutti():
            for _, var_check, _ in righe:
                var_check.set(seleziona_tutti_var.get())
        tk.Checkbutton(area_dati, text="‚úî Seleziona tutto", variable=seleziona_tutti_var, command=toggle_tutti).pack(anchor="w", pady=(5, 2))
        intest = tk.Frame(area_dati)
        intest.pack(anchor="w")
        tk.Label(intest, text="‚úî", width=2).grid(row=0, column=0)
        tk.Label(intest, text="Data", width=10).grid(row=0, column=1)
        tk.Label(intest, text="Descrizione", width=40, anchor="w").grid(row=0, column=2)
        tk.Label(intest, text="Importo", width=12, anchor="e").grid(row=0, column=3)
        tk.Label(intest, text="Categoria", width=20).grid(row=0, column=4)
        for mov in movimenti:
            riga = tk.Frame(area_dati)
            riga.pack(anchor="w", pady=1)
            var = tk.BooleanVar(value=True)
            tk.Checkbutton(riga, variable=var).grid(row=0, column=0)
            tk.Label(riga, text=mov["data"].strftime("%d/%m/%Y"), width=10).grid(row=0, column=1)
            tk.Label(riga, text=mov["descrizione"], width=40, anchor="w").grid(row=0, column=2)
            tk.Label(riga, text=f"{mov['importo']:.2f} ‚Ç¨", width=12, anchor="e").grid(row=0, column=3)
            chiave = mov["descrizione"].strip().upper()
            categoria = memoria.get(chiave, "Generica")
            combo = ttk.Combobox(riga, values=self.categorie, style="Border.TCombobox", state="readonly", width=20)
            combo.set(categoria)
            combo.grid(row=0, column=4, padx=4)
            righe.append((mov, var, combo))
        bottoni = tk.Frame(win)
        bottoni.pack(pady=10)
        def salva():
            count = 0
            duplicati = 0
            for mov, var, combo in righe:
                if var.get():
                    giorno = mov["data"]
                    descr = mov["descrizione"]
                    imp = abs(mov["importo"])
                    tipo = "Entrata" if mov["importo"] >= 0 else "Uscita"
                    cat = combo.get() or "Generica"
                    voce = (cat, descr, imp, tipo)
                    if voce in self.spese.get(giorno, []):
                        duplicati += 1
                        continue
                    self.spese.setdefault(giorno, []).append(voce)
                    memoria[descr.strip().upper()] = cat
                    count += 1
            self.save_db()
            self.refresh_gui()
            try:
                with open("memoria_categorie.json", "w", encoding="utf-8") as f:
                    json.dump(memoria, f, ensure_ascii=False, indent=2)
            except Exception as e:
                print("‚ö†Ô∏è Impossibile salvare memoria categorie:", e)
            messaggio = f"{count} Movimenti importati/salvati."
            if duplicati > 0:
                messaggio += f"\n‚ö†Ô∏è {duplicati} duplicate/ignorate."
            self.show_custom_warning("Completato", messaggio)
        def chiudi():
            win.destroy()
            self.show_custom_warning("Annullato", "Importazione interrotta.")
        ttk.Button(bottoni, text="üíæ Salva", style="Verde.TButton", command=salva).pack(side="left", padx=10)
        ttk.Button(bottoni, text="‚ùå Chiudi", style="Giallo.TButton", command=chiudi).pack(side="right", padx=10)
    def conferma_sostituzione_spesa(self, giorno, categoria, imp_esistente, imp_nuovo):
        popup = tk.Toplevel(self)
        popup.title("Sostituisci spesa?")
        popup.resizable(False, False)
        width, height = 400, 160
        popup.withdraw()
        popup.update_idletasks()
        x = self.winfo_rootx() + (self.winfo_width() // 2) - (width // 2)
        y = self.winfo_rooty() + (self.winfo_height() // 2) - (height // 2)
        popup.geometry(f"{width}x{height}+{x}+{y}")
        popup.configure(bg="#FFFACD")
        popup.deiconify()
        popup.grab_set()
        msg = (
            f"Esiste gi√† una spesa nella categoria ‚Äú{categoria}‚Äù il {giorno.strftime('%d/%m/%Y')} "
            f"da ‚Ç¨{imp_esistente:.2f}.\n\nVuoi sostituirla con la nuova da ‚Ç¨{imp_nuovo:.2f}?"
        )
        label = tk.Label(
            popup,
            text=msg,
            font=("Arial", 10),
            justify="center",
            wraplength=360,
            bg="#FFFACD"
        )
        label.pack(pady=12, padx=16)
        frame = tk.Frame(popup, bg="#FFFACD")
        frame.pack(pady=4)
        result = {"ok": False}
        def conferma():
            result["ok"] = True
            popup.destroy()
        def annulla():
            popup.destroy()
        ttk.Button(frame, text="Sostituisci", style="Verde.TButton", width=12, command=conferma).pack(side="left", padx=10)
        ttk.Button(frame, text="Annulla", style="Giallo.TButton", width=12, command=annulla).pack(side="right", padx=10)
        self.wait_window(popup)
        return result["ok"]

    # Proiezione Annuale e Confronto Spese Storiche
    def calcola_statistiche_annuali(self):
        from datetime import date
        import calendar
        oggi = date.today()
        anno_corr = oggi.year
        anno_prec = anno_corr - 1
        mese_corr = oggi.month
        tot_mese_corr, tot_mese_prec = 0.0, 0.0
        tot_anno_corr_parz, tot_anno_prec_parz = 0.0, 0.0
        tot_anno_prec_totale = 0.0
        for giorno, voci in self.spese.items():
            if giorno.year not in [anno_corr, anno_prec]:
                continue
            for voce in voci:
                if len(voce) < 4 or voce[3] != "Uscita":
                    continue
                importo = voce[2]
                if giorno.year == anno_corr:
                    if giorno <= oggi:
                        tot_anno_corr_parz += importo
                    if giorno.month == mese_corr:
                        tot_mese_corr += importo
                elif giorno.year == anno_prec:
                    tot_anno_prec_totale += importo
                    if giorno.month == mese_corr:
                        tot_mese_prec += importo
                    if (giorno.month, giorno.day) <= (oggi.month, oggi.day):
                        tot_anno_prec_parz += importo
        giorni_tot_anno = 366 if calendar.isleap(anno_corr) else 365
        giorni_passati = (oggi - date(anno_corr, 1, 1)).days + 1
        perc_corr = giorni_passati / giorni_tot_anno
        proiezione_corr = tot_anno_corr_parz / perc_corr if perc_corr else 0.0
        var_mese_pct = (tot_mese_corr - tot_mese_prec) / tot_mese_prec * 100 if tot_mese_prec else 0.0
        differenza = tot_anno_prec_totale - proiezione_corr
        report = f"""
    üìä BILANCIO PROIEZIONE SPESE ‚Äì {oggi.strftime('%d/%m/%Y')}
    
    ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    üìÖ Mese corrente: {mese_corr:02}/{anno_corr}
    ‚ñ∏ Uscite attuali {anno_corr}      : ‚Ç¨ {tot_mese_corr:>10,.2f}
    ‚ñ∏ Stesso mese {anno_prec}          : ‚Ç¨ {tot_mese_prec:>10,.2f}
    
    ‚ñ∏ Variazione rispetto a {mese_corr:02}/{anno_prec} : {var_mese_pct:+.1f}%
    
    ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    üìÜ Da inizio anno (01/01 ‚Üí oggi)
    ‚ñ∏ Totale uscite {anno_corr}        : ‚Ç¨ {tot_anno_corr_parz:>10,.2f}
    ‚ñ∏ Stesso periodo {anno_prec}       : ‚Ç¨ {tot_anno_prec_parz:>10,.2f}

    ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    üìà Spesa a confronto annuale
    ‚ñ∏ Spesa effettiva {anno_prec}      : ‚Ç¨ {tot_anno_prec_totale:>10,.2f}
    ‚ñ∏ Proiezione {anno_corr}           : ‚Ç¨ {proiezione_corr:>10,.2f}
      (Basata su {perc_corr:.1%} dell‚Äôanno trascorso)

    ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    """
        if differenza > 0:
            report += f"\nüìâ Risparmio previsto: ‚Ç¨ {differenza:,.2f} se mantieni l‚Äôandamento attuale ‚ú®üí∞‚ú®"
        else:
            report += f"\n‚ö†Ô∏è Spesa stimata superiore di ‚Ç¨ {abs(differenza):,.2f} rispetto al {anno_prec} üìâü™ô"
        self.mostra_report_popup(report.strip())
    def mostra_report_popup(self, testo):
        if not hasattr(self, '_report_popup'):
            self._report_popup = None
        if self._report_popup and self._report_popup.winfo_exists():
            self._report_popup.lift()
            return
        preview = tk.Toplevel(self)
        self._report_popup = preview

        def on_report_close():
            preview.destroy()
            self._report_popup = None
        preview.withdraw()
        preview.title("üìä Bilancio Proiezione Annuale")
        width, height = 860, 580
        self.update_idletasks()
        x = self.winfo_rootx() + (self.winfo_width() - width) // 2
        y = self.winfo_rooty() + (self.winfo_height() - height) // 2
        preview.geometry(f"{width}x{height}+{x}+{y}")
        preview.transient(self)
        preview.configure(bg=self.COLOR_WIDGET_BG)
        foglio_bianco = tk.Frame(preview, bg="white", relief="flat", bd=0)
        foglio_bianco.pack(fill="both", expand=True, padx=30, pady=(30, 0))
        text_area = tk.Text(foglio_bianco, 
                            font=("Courier new", 10), 
                            bg="white", 
                            fg="#333333", 
                            insertbackground="black",
                            wrap="word", 
                            relief="flat",
                            borderwidth=0,
                            highlightthickness=0,
                            padx=30, 
                            pady=30)
        text_area.insert("1.0", testo)
        text_area.config(state="disabled")
        text_area.pack(fill="both", expand=True)
        def save_file():
            try:
                initial_dir = EXPORT_FILES
            except NameError:
                initial_dir = os.path.expanduser("~")
            import datetime
            now = datetime.date.today()
            fname = f"Report_Export_{now.day:02d}-{now.month:02d}-{now.year}.txt"
            file = filedialog.asksaveasfilename(
                defaultextension=".txt", 
                filetypes=[("File txt", "*.txt")], 
                initialdir=initial_dir, 
                initialfile=fname, 
                title="Salva Report", 
                confirmoverwrite=False, 
                parent=preview
            )
            if file:
                if os.path.exists(file):
                    if not self.show_custom_askyesno("Sovrascrivere file?", f"Il file '{os.path.basename(file)}' \nesiste gi√†. Sovrascrivere?"):
                        return
                with open(file, "w", encoding="utf-8") as f:
                    f.write(testo)
                on_report_close()
                self.show_custom_warning("Esportazione completata", f"Bilancio esportato in:\n{file}")
        preview.deiconify()
        preview.protocol("WM_DELETE_WINDOW", on_report_close)
        preview.bind("<Escape>", lambda e: on_report_close())
        frame_bottoni = tk.Frame(preview, bg=self.COLOR_WIDGET_BG)
        frame_bottoni.pack(fill="x", padx=30, pady=20)
        ttk.Button(frame_bottoni, text="üìÑ Esporta", style="Arancio.TButton", command=save_file).pack(side="left")
        ttk.Button(frame_bottoni, text="‚ùå Chiudi", style="Giallo.TButton", command=on_report_close).pack(side="right")

    # Finestra di Cancellazione Multipla Categorie
    def apri_cancella_multiplo(self):
        popup = tk.Toplevel(self,bg=self.COLOR_TOPLEVEL)
        popup.title("Cancella Categorie")
        popup.resizable(True, True)
        larghezza, altezza = 400, 500
        x = self.winfo_x() + (self.winfo_width() // 2) - (larghezza // 2)
        y = self.winfo_y() + (self.winfo_height() // 2) - (altezza // 2)
        popup.geometry(f"{larghezza}x{altezza}+{x}+{y}")
        popup.grab_set()
        tk.Label(
            popup,
            text="Seleziona le categorie da cancellare:",
            bg=self.COLOR_TOPLEVEL,
            fg=self.TEXT_COLOR,
            font=("Arial", 10, "bold")
        ).pack(pady=(10, 5))
        self.elimina_spese_var = tk.BooleanVar()
        tk.Checkbutton(
            popup,
            text="Elimina anche Movimenti associati",
            variable=self.elimina_spese_var,
            anchor="w",
            bg="yellow",       
            activebackground="gold"  
        ).pack(fill="x", padx=15, pady=(5, 0))
        contenitore = tk.Frame(popup, bg=self.COLOR_TOPLEVEL)
        contenitore.pack(fill="both", expand=True, padx=10, pady=5)
        canvas = tk.Canvas(contenitore, bg=self.COLOR_TOPLEVEL)
        scrollbar = ttk.Scrollbar(contenitore, orient="vertical", command=canvas.yview, style="Vertical.TScrollbar")
        canvas.configure(yscrollcommand=scrollbar.set)
        scrollbar.pack(side="right", fill="y")
        canvas.pack(side="left", fill="both", expand=True)
        scroll_frame = tk.Frame(canvas, bg=self.COLOR_TOPLEVEL)
        window_id = canvas.create_window((0, 0), window=scroll_frame, anchor="nw")
        def resize_scroll_frame(event):
            canvas.itemconfig(window_id, width=event.width)
        canvas.bind("<Configure>", resize_scroll_frame)
        def aggiorna_scroll(event):
             canvas.configure(scrollregion=canvas.bbox("all"))
        scroll_frame.bind("<Configure>", aggiorna_scroll)
        def aggiorna_scroll(event):
            canvas.configure(scrollregion=canvas.bbox("all"))
        scroll_frame.bind("<Configure>", aggiorna_scroll)
        self.checkbox_vars = {}
        for cat in sorted(set(self.categorie), key=lambda c: c.lower()):
            if cat not in ("Generica", self.CATEGORIA_RIMOSSA):
                var = tk.BooleanVar()
                chk = tk.Checkbutton(
                    scroll_frame,
                    text=cat, 
                    variable=var, 
                    anchor="w",
                    bg=self.COLOR_TOPLEVEL,
                    fg=self.TEXT_COLOR,
                    activebackground=self.COLOR_TOPLEVEL,
                    activeforeground=self.TEXT_COLOR,
                    selectcolor=self.COLOR_TOPLEVEL,
                    highlightthickness=0
                )
                chk.pack(fill="x", padx=5, pady=2)
                self.checkbox_vars[cat] = var
        btn_frame = tk.Frame(popup, bg=self.COLOR_TOPLEVEL)
        btn_frame.pack(pady=10)
        ttk.Button(
            btn_frame,
            text="Elimina Selezionate",
            style="Rosso.TButton",
            command=lambda: self.cancella_categorie_checkbox(popup)
        ).pack(side="left", padx=5)
        ttk.Button(
            btn_frame,
            text="‚ùå Chiudi",
            style="Giallo.TButton",
            command=popup.destroy
        ).pack(side="left", padx=5)
    def cancella_categorie_checkbox(self, popup):
        selezionate = [cat for cat, var in self.checkbox_vars.items() if var.get()]
        if not selezionate:
            self.show_custom_warning("Attenzione", "Seleziona almeno una categoria da cancellare.")
            return
        testo_conferma = f"Sei sicuro di voler cancellare le seguenti categorie?\n\n"
        conferma = self.show_custom_askyesno("Elimina", testo_conferma)
        if not conferma:
            return
        for cat in selezionate:
            if cat in self.categorie:
                self.categorie.remove(cat)
            if cat in self.categorie_tipi:
                del self.categorie_tipi[cat]
            for giorno in list(self.spese.keys()):
                nuove_spese = []
                for voce in self.spese[giorno]:
                    voce_cat = voce[0]
                    if voce_cat == cat:
                         if not self.elimina_spese_var.get():
                             nuove_spese.append((self.CATEGORIA_RIMOSSA,) + voce[1:])
                    else:
                        nuove_spese.append(voce)
                self.spese[giorno] = nuove_spese
        self.show_custom_warning("Rimosse", f"‚úì {len(selezionate)} categorie sono state cancellate.")
        popup.destroy()
        self.save_db()
        self.refresh_gui()
        self.aggiorna_combobox_categorie()
    
    # Finestra Aggiunta Categorie Suggerite
    def apri_categorie_suggerite(self):
        CATEGORIE_SUGGERITE = [
            # üè† Casa & Famiglia
            "üè† Casa",
            "üè† Affitto Immobile",
            "üè† Mutuo Immobile",
            "üè° Manutenzione casa",
            "üí° Utenze (Luce)",
            "üî• Utenze (Gas)",
            "üöø Utenze (Acqua)",
            "‚ô®Ô∏è Caldaia",
            "üå∞ Pellet",
            "üìÑ Tassa Rifiuti",
            "üè† Pulizie domestiche",
            "üõãÔ∏è Arredamento",
            "üêæ Animali domestici",
            "üè† Assicurazione Immobile",
            # üçΩÔ∏è Alimentari & Consumi
            "üçΩÔ∏è Alimentari & Consumi",
            "üõí Spesa supermercato",
            "üçû Spesa Discount",
            "‚òï Colazioni / Caff√® fuori",
            "üçΩÔ∏è Pranzi / Ristoranti",
            "üçï Asporto / Fast food",
            # üöó Veicoli & Trasporti
            "üöó Veicoli & Trasporti",
            "‚õΩ Carburante",
            "üõ†Ô∏è Manutenzione auto",
            "üìÖ Bollo auto",
            "üè• Assicurazione veicoli",
            "üöá Trasporti pubblici",
            "üöï Taxi / Car sharing",
            # üí° Bollette & Abbonamenti
            "üí° Bollette & Abbonamenti",
            "üì± Telefonia / Internet",
            "üì± Telefonia / Cellulari",
            "üíª Streaming (Netflix, Prime...)",
            "üîê Servizi cloud / backup",
            "üéÆ Abbonamenti digitali",
            # ü©∫ Salute & Benessere
            "ü©∫ Salute & Benessere",
            "üíä Farmaci",
            "üë®‚Äç‚öïÔ∏è Visite mediche",
            "üè• Dentista",
            "üßò‚Äç‚ôÇÔ∏è Wellness / Spa",
            "üèãÔ∏è‚Äç‚ôÄÔ∏è Palestra / Fitness",
            # üéì Istruzione & Lavoro
            "üéì Istruzione & Lavoro",
            "üìö Libri / Materiali",
            "üßë‚Äçüè´ Corsi / Formazione",
            "üíª Software",
            "üóÇÔ∏è Utenze professionali / Partita IVA",
            # üéâ Tempo libero & Spese personali
            "üéâ Tempo libero & Spese personali",
            "üéÅ Regali",
            "üé¨ Cinema / Eventi",
            "üéÆ Videogiochi",
            "üéÆ Computer",
            "üß• Abbigliamento",
            "üéÅ Tabacchi",
            "üíá Parrucchiere / Estetica",
            "‚úàÔ∏è Viaggi / Hotel",
            # üí∏ Finanza & Risparmio
            "üí∏ Stipendio",
            "üí∏ Pensione",
            "üí∏ Entrate Extra",
            "üí∏ Finanza & Risparmio",
            "üè¶ Conto corrente",
            "üí≥ Rate / Finanziamenti",
            "üí∞ Commercialista",
            # üì§ Uscite straordinarie
            "üì§ Uscite straordinarie",
            "üè• Emergenze",
            "üõ†Ô∏è Riparazioni impreviste",
            "üì¶ Spese non ricorrenti"
        ]
        TIPO_SUGGERITI = {
            "Casa": "Uscita",
            "Affitto Immobile": "Uscita",
            "Mutuo Immobile": "Uscita",
            "Manutenzione casa": "Uscita",
            "Utenze (Luce)": "Uscita",
            "Utenze (Gas)": "Uscita",
            "Utenze (Acqua)": "Uscita",
            "Caldaia": "Uscita",
            "Pellet": "Uscita",
            "Tassa Rifiuti": "Uscita",
            "Pulizie domestiche": "Uscita",
            "Arredamento": "Uscita",
            "Animali domestici": "Uscita",
            "Assicurazione Immobile": "Uscita",
            "Alimentari & Consumi": "Uscita",
            "Spesa supermercato": "Uscita",
            "Spesa Discount": "Uscita",
            "Colazioni / Caff√® fuori": "Uscita",
            "Pranzi / Ristoranti": "Uscita",
            "Asporto / Fast food": "Uscita",
            "Veicoli & Trasporti": "Uscita",
            "Carburante": "Uscita",
            "Manutenzione auto": "Uscita",
            "Bollo auto": "Uscita",
            "Assicurazione veicoli": "Uscita",
            "Trasporti pubblici": "Uscita",
            "Taxi / Car sharing": "Uscita",
            "Bollette & Abbonamenti": "Uscita",
            "Telefonia / Internet": "Uscita",
            "Telefonia / Cellulari": "Uscita",
            "Streaming (Netflix, Prime...)": "Uscita",
            "Servizi cloud / backup": "Uscita",
            "Abbonamenti digitali": "Uscita",
            "Salute & Benessere": "Uscita",
            "Farmaci": "Uscita",
            "Visite mediche": "Uscita",
            "Dentista": "Uscita",
            "Wellness / Spa": "Uscita",
            "Palestra / Fitness": "Uscita",
            "Istruzione & Lavoro": "Uscita",
            "Libri / Materiali": "Uscita",
            "Corsi / Formazione": "Uscita",
            "Software": "Uscita",
            "Utenze professionali / Partita IVA": "Uscita",
            "Tempo libero & Spese personali": "Uscita",
            "Regali": "Uscita",
            "Cinema / Eventi": "Uscita",
            "Videogiochi": "Uscita",
            "Computer": "Uscita",
            "Abbigliamento": "Uscita",
            "Tabacchi": "Uscita",
            "Parrucchiere / Estetica": "Uscita",
            "Viaggi / Hotel": "Uscita",
            "Stipendio": "Entrata",
            "Pensione": "Entrata",
            "Entrate Extra": "Entrata",
            "Finanza & Risparmio": "Uscita",
            "Conto corrente": "Uscita",
            "Rate / Finanziamenti": "Uscita",
            "Commercialista": "Uscita",
            "Uscite straordinarie": "Uscita",
            "Emergenze": "Uscita",
            "Riparazioni impreviste": "Uscita",
            "Spese non ricorrenti": "Uscita"
        }
        finestra = tk.Toplevel(self, bg=self.COLOR_TOPLEVEL)
        finestra.title("Categorie suggerite")
        finestra.bind("<Escape>", lambda e: finestra.destroy())
        finestra.geometry("500x480") 
        larghezza, altezza = 500, 480
        x = (finestra.winfo_screenwidth() // 2) - (larghezza // 2)
        y = (finestra.winfo_screenheight() // 2) - (altezza // 2)
        finestra.geometry(f"{larghezza}x{altezza}+{x}+{y}")
        finestra.grab_set()
        finestra.focus_force()
        tk.Label(
            finestra,
            text="‚ú® Scegli categorie da aggiungere:", bg=self.COLOR_TOPLEVEL , fg=self.TEXT_COLOR, font=("Arial", 10, "bold")
        ).pack(pady=(10, 5))
        container = tk.Frame(finestra, bg="white")
        container.pack(padx=10, pady=(0, 10), fill="both", expand=True)
        canvas = tk.Canvas(container, bg=self.COLOR_TOPLEVEL, highlightthickness=0)
        scrollbar = ttk.Scrollbar(container, orient="vertical", command=canvas.yview, style="Vertical.TScrollbar")
        canvas.configure(yscrollcommand=scrollbar.set)
        scrollbar.pack(side="right", fill="y")
        canvas.pack(side="left", fill="both", expand=True)
        scroll_frame = tk.Frame(canvas, bg=self.COLOR_TOPLEVEL)
        canvas_window = canvas.create_window((0, 0), window=scroll_frame, anchor="nw")
        def aggiorna_scroll_region(event):
            canvas.configure(scrollregion=canvas.bbox("all"))
        canvas.bind("<Configure>", lambda event: canvas.itemconfig(canvas_window, width=event.width))
        scroll_frame.bind("<Configure>", aggiorna_scroll_region)
        selezioni = {}
        toggle_var = tk.BooleanVar(value=False)
        def seleziona_tutto():
            stato = toggle_var.get()
            for var in selezioni.values():
                var.set(stato)
        toggle_chk = tk.Checkbutton(
            scroll_frame,
            text="‚úîÔ∏è Seleziona Tutte / Nessuna",
            variable=toggle_var,
            command=seleziona_tutto,
            bg=self.COLOR_TOPLEVEL,
            fg=self.TEXT_COLOR,
            selectcolor=self.COLOR_TOPLEVEL,
            activebackground=self.COLOR_TOPLEVEL,
            highlightthickness=0,
            anchor="w",
            font=("Arial", 9, "bold")
        )
        toggle_chk.pack(anchor="w", pady=(6, 6), padx=4)
        for nome in CATEGORIE_SUGGERITE:
            var = tk.BooleanVar()
            nome_pulito = nome.split(" ", 1)[1] if " " in nome else nome
            tipo = TIPO_SUGGERITI.get(nome_pulito, "Uscita")
            etichetta = f"{nome} [{tipo}]"
            chk = tk.Checkbutton(
                scroll_frame,
                text=etichetta,
                variable=var,
                bg=self.COLOR_TOPLEVEL,
                fg=self.TEXT_COLOR,
                selectcolor=self.COLOR_TOPLEVEL,
                activebackground=self.COLOR_TOPLEVEL,
                highlightthickness=0,
                anchor="w"
            )
            chk.pack(anchor="w", pady=2, padx=4)
            selezioni[nome] = var
        def aggiungi_categorie_scelte():
            nuove = [nome for nome, var in selezioni.items() if var.get()]
            pulite = [nome.split(" ", 1)[1] if " " in nome else nome for nome in nuove]
            if not pulite:
               self.show_custom_warning("Nessuna selezione", "‚ö†Ô∏è Seleziona almeno una categoria da aggiungere.")
               return
            for cat in pulite:
                tipo = TIPO_SUGGERITI.get(cat, "Uscita")
                if cat not in self.categorie:
                    self.categorie.append(cat)
                self.categorie_tipi[cat] = tipo
            self.categorie.sort()
            self.aggiorna_combobox_categorie()
            self.save_db()
            self.show_custom_warning("Aggiunta completata", "‚ö†Ô∏è Categorie aggiunte correttamente..")
            finestra.destroy()
        btn_frame = tk.Frame(finestra, bg=self.COLOR_TOPLEVEL)
        btn_frame.pack(pady=(0, 12))
        ttk.Button(btn_frame, text="‚ûï Aggiungi", style="Verde.TButton", command=aggiungi_categorie_scelte).pack(side="left", padx=8)
        ttk.Button(btn_frame, text="‚ùå Chiudi", style="Giallo.TButton", command=finestra.destroy).pack(side="left", padx=8)

    # Scarica e Apri Manuale Utente (PDF)
    def scarica_manuale(self):
        try:
            response = requests.get(URL_PDF)
            response.raise_for_status()
            temp_path = os.path.join(tempfile.gettempdir(), "manuale_casa_facile.pdf")
            with open(temp_path, "wb") as f:
                f.write(response.content)
            webbrowser.open(f"file://{temp_path}")
        except Exception as e:
            print("Errore nel download del manuale:", e)
            self.show_custom_warning("Attenzione", "‚ùå Download NON completato ! \n\n Sembra ci sia stato un problema. üòï")

   # Scarica e Apri Tabella Consumi (PDF)
    def scarica_tabella(self):
        try:
            response = requests.get(URL_PDF_CONSUMI)
            response.raise_for_status()
            temp_path = os.path.join(tempfile.gettempdir(), "Tabella_Contatori.pdf")
            with open(temp_path, "wb") as f:
                f.write(response.content)
            webbrowser.open(f"file://{temp_path}")
        except Exception as e:
            print("Errore nel download della Tabella Consumi:", e)
            self.show_custom_warning("Attenzione", "‚ùå Download NON completato ! \n\n Sembra ci sia stato un problema. üòï")

    # Apri WebServer nel Browser   
    def apri_webserver(self):
        IP = self.get_ip_locale()
        webbrowser.open(f"http://{IP}:{PORTA}")

    # Recupera Indirizzo IP Locale
    def get_ip_locale(self):
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        try:
            s.connect(("8.8.8.8", 80))
            IP = s.getsockname()[0]
        except Exception:
            IP = "127.0.0.1"
        finally:
            s.close()
        return IP
   
    # Avvio Server Web Locale (Interfaccia HTTP)
    def start_web_server(self):
        global PORTA
        try:
            server = HTTPServer(('0.0.0.0', PORTA), CasaFacileWebHandler)
        except OSError:
            nuova_porta = PORTA + 1
            print(f"‚ö†Ô∏è Porta {PORTA} occupata, provo su {nuova_porta}...")
            try:
                server = HTTPServer(('0.0.0.0', nuova_porta), CasaFacileWebHandler)
            except Exception as e:
                print(f"‚ùå Impossibile avviare il server web: {e}")
                return
        server.app = self
        server.allow_reuse_address = True
        print(f"üåê Web server pronto su http://localhost:{server.server_port}")
        server.serve_forever()

    # HTML Login
    def html_login(self, path):
        SESSION_ID=self.SESSION_ID
        ultimo_login = "Benvenuto nel tuo spazio sicuro"
        if os.path.exists(LOGIN_WEB):
            try:
                with open(LOGIN_WEB, "r", encoding="utf-8") as f:
                    logs = json.load(f)
                    if logs:
                        ultimo_login = f"Ultimo accesso: {logs[0]['data_ora']}"
            except: pass
            
        folder = os.path.basename(os.getcwd())
        try:
            query = path.split("?", 1)[1]
            params = parse_qs(query)
            errore = "error" in params
        except:
            errore = False
        return f"""
        <!DOCTYPE html>
        <html lang="it">
        <head>
            <meta charset="utf-8">
            <title>üîì Login</title>
            <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
            <style>
                body {{
                    font-family: 'Segoe UI', Roboto, sans-serif;
                    background-color: #f0f2f5;
                    margin: 0;
                    display: flex;
                    flex-direction: column;
                    align-items: center;
                    min-height: 100vh;
                    color: #202124;
                }}
                .main-container {{
                    width: 100%;
                    max-width: 450px; 
                    background-color: #ffffff;
                    min-height: 100vh;
                    display: flex;
                    flex-direction: column;
                    box-shadow: 0 0 20px rgba(0,0,0,0.05);
                    border-radius: 20px; 
                    overflow: hidden;    
                    margin: 20px 0; 
                    min-height: calc(100vh - 40px);
                }}
                .brand-header {{ 
                    padding: 30px 25px 5px 25px;
                }}
                .brand-header h1 {{
                    font-size: 22px;
                    font-weight: 800;
                    margin: 0;
                    color: #1a73e8;
                }}
                .tagline {{
                    font-size: 13px;
                    color: #5f6368;
                    margin-top: 5px;
                    line-height: 1.4;
                }}
                .last-login-info {{
                    font-size: 12px;
                    color: #80868b;
                    background: #f8f9fa;
                    padding: 8px 12px;
                    border-radius: 8px;
                    margin-bottom: 25px;
                    display: flex;
                    align-items: center;
                    gap: 8px;
                    border: 1px inset #f1f3f4;
                }}
                .login-content {{
                    padding: 0px 25px;
                    flex: 1;
                }}
                .icon-bar {{
                    display: flex;
                    justify-content: space-between;
                    margin-top: 10px;
                    padding: 5px 0;
                    border-top: none;
                }}
                .icon-item {{
                    display: flex;
                    flex-direction: column;
                    align-items: center;
                    gap: 5px;
                }}
                .icon-item span {{
                    font-size: 18px;
                }}
                .icon-label {{
                    font-size: 9px;
                    color: #999;
                    text-transform: uppercase;
                    font-weight: 700;
                    letter-spacing: 0.5px;
                }}
                .label {{
                    font-size: 11px;
                    font-weight: 700;
                    color: #999;
                    text-transform: uppercase;
                    display: block;
                    margin-top: 10px;
                }}
                .user-static {{
                    font-size: 19px;
                    font-weight: 500;
                    padding: 8px 0;
                }}
                .input-field {{
                    position: relative;
                    border-bottom: 2px solid #1a73e8;
                    margin-bottom: 30px;
                }}
                input[type="password"], input[type="text"] {{
                    width: calc(100% - 40px);
                    border: none;
                    padding: 12px 0;
                    font-size: 18px;
                    outline: none;
                    background: transparent;
                    color: #202124;
                }}
                input.error-state {{
                    color: #d93025 !important;
                    font-weight: bold;
                }}
                .toggle-pass {{
                    position: absolute;
                    right: 0;
                    top: 12px;
                    cursor: pointer;
                    font-size: 20px;
                }}
                .btn-material {{
                    width: 100%;
                    background-color: #1a73e8;
                    color: white;
                    border: none;
                    padding: 16px;
                    border-radius: 8px;
                    font-size: 16px;
                    font-weight: bold;
                    cursor: pointer;
                }}
                .footer-link {{
                    display: block;
                    margin-top: 25px;
                    font-size: 13px;
                    color: #000000;
                    text-decoration: none;
                    font-weight: 500;
                }}
                .footer-link span {{ 
                    color: #1a73e8; 
                    text-decoration: underline; 
                    font-weight: bold; 
                }}
            </style>
        </head>
        <body>
            <div class="main-container">
                <div class="brand-header" style="padding: 15px 25px 5px 25px;">
                    <h1>üè† Casa Facile Pro</h1>
                    <p class="tagline">La tua finanza domestica, in perfetto ordine.</p>                
                    <div class="icon-bar">
                        <div class="icon-item"><span>üìà</span><div class="icon-label">Finanza</div></div>
                        <div class="icon-item"><span>üí∞</span><div class="icon-label">Risparmio</div></div>
                        <div class="icon-item"><span>üõí</span><div class="icon-label">Spesa</div></div>
                        <div class="icon-item"><span>‚ö°</span><div class="icon-label">Utenze</div></div>
                        <div class="icon-item"><span>üìÇ</span><div class="icon-label">Documenti</div></div>
                    </div>                
                </div>
                <div class="login-content">
                    <form method="post" action="/check_login" id="loginForm">
                        <span class="label">Profilo Attivo üîì {ultimo_login}</span>
                        <div class="user-static">{folder}</div>
                        <span class="label">Chiave di accesso</span>
                        <div class="input-field">
                            <input type="password" name="password" id="pass" autofocus autocomplete="off">
                            <span class="toggle-pass" onclick="togglePassword()">üëÅÔ∏è</span>
                        </div>
                        <button type="submit" class="btn-material">ACCEDI üîì</button>
                    </form>
                    <a href="mailto:helpcasafacilepro@gmail.com" class="footer-link">
                        v{VERSION} S-ID: {SESSION_ID} ‚Äî Supporto: <span>helpcasafacilepro@gmail.com</span>
                    </a>
                    <div style="margin-top: 25px; padding: 15px; border-top: 1px solid #eee; text-align: center;">
                        <div style="font-family: 'Segoe UI', sans-serif; font-size: 13px; color: #000; line-height: 1.5;">
                            <strong style="color: #d93025; display: block; margin-bottom: 5px;">‚ö†Ô∏è AVVISO LEGALE</strong>
                            L'accesso non autorizzato a questo sistema √® perseguibile ai sensi dell'<strong>Art. 615-ter del Codice Penale</strong>. 
                            Ogni tentativo di intrusione sar√† perseguito nei termini di legge a tutela della riservatezza dei dati contenuti.
                        </div>
                        
                        <div style="font-family: 'Segoe UI', sans-serif; font-size: 12px; color: #555; line-height: 1.4; background: #f9f9f9; padding: 10px; border-radius: 5px;">
                                <strong style="color: #2c3e50; display: block; margin-bottom: 3px;">üõ°Ô∏è SICUREZZA SESSIONE</strong>
                                Accesso protetto da <strong>Token Dinamico</strong> 
                                <br><strong>Gli accessi sono monitorati e archiviati per fini di sicurezza.</strong>
                                </span>
                            </div>
                        
                        
                    </div>
                </div>
                <div class="keyboard-spacer"></div>
            </div>
            <script>
                function togglePassword() {{
                    var x = document.getElementById("pass");
                    x.type = (x.type === "password") ? "text" : "password";
                }}
                window.onload = function() {{
                    const urlParams = new URLSearchParams(window.location.search);
                    if (urlParams.has('error')) {{
                        const passInput = document.getElementById("pass");
                        passInput.type = "text";
                        passInput.value = "‚õàÔ∏è Password errata!";
                        passInput.classList.add("error-state");
                        setTimeout(() => {{
                            passInput.value = "";
                            passInput.type = "password";
                            passInput.classList.remove("error-state");
                            passInput.focus();
                        }}, 2000);
                    }}
                }};
            </script>
        </body>
        </html>
        """
    def leggi_hash(self):
        if not os.path.exists(PW_FILE):
            return None
        try:
            with open(PW_FILE, "r", encoding="utf-8") as f:
                return json.load(f).get("hash")
        except:
            return None
    def verifica_password(self, password):
        salvato = self.leggi_hash()
        if salvato is None:
            return False  
        inserito = hashlib.sha256(password.encode()).hexdigest()
        return salvato == inserito

    # Movimenti Mese Web
    def pagina_risultati_avanzati(self, params):
        from datetime import datetime
        from collections import defaultdict 
        categoria = params.get("categoria", [""])[0].strip().lower()
        anno = params.get("anno", [""])[0].strip()
        mese = params.get("mese", [""])[0].strip()
        tipo = params.get("tipo", [""])[0].strip().lower()
        min_importo = float(params.get("min_importo", ["0"])[0] or 0)
        max_importo = float(params.get("max_importo", ["999999"])[0] or 999999)
        query = params.get("q", [""])[0].strip().lower()
        risultati_categorizzati = defaultdict(list)
        for data in sorted(self.spese.keys(), reverse=True):
            if anno and str(data.year) != anno:
                continue
            if mese and f"{data.month:02d}" != mese:
                continue
            for idx_voce, voce in enumerate(self.spese[data]):
                if len(voce) < 4:
                    continue
                cat, descrizione, importo, tipo_voce = voce[:4]
                if categoria and cat.strip().lower() != categoria:
                    continue
                if tipo and tipo_voce.strip().lower() != tipo:
                    continue
                if not (min_importo <= importo <= max_importo):
                    continue
                if query and not (
                    query in descrizione.lower()
                    or query in tipo_voce.lower()
                    or query in cat.lower()
                    or query in str(importo)
                ):
                    continue
                risultati_categorizzati[cat].append(
                    (
                        data.strftime("%d-%m-%Y"),
                        html_escape.escape(descrizione),
                        float(importo),
                        tipo_voce.strip(),
                        idx_voce,
                    )
                )
        entrate_totali = sum(
            v[2]
            for vlist in risultati_categorizzati.values()
            for v in vlist
            if v[3].lower() == "entrata"
        )
        uscite_totali = sum(
            v[2]
            for vlist in risultati_categorizzati.values()
            for v in vlist
            if v[3].lower() != "entrata"
        )
        saldo = entrate_totali - uscite_totali
        colore = "#3c763d" if saldo >= 0 else "#a94442"
        anno_corrente = datetime.now().year
        schede_html = ""
        for idx_cat, (cat, voci) in enumerate(sorted(risultati_categorizzati.items())):
            totale_cat = sum(
                imp if tipo_voce.lower() == "entrata" else -imp
                for _, _, imp, tipo_voce, _ in voci
            )
            voce_html = ""
            for data, descrizione, importo, tipo_voce, idx_voce in voci:
                simbolo = "+" if tipo_voce.lower() == "entrata" else "‚àí"
                colore_tipo = "#007E33" if tipo_voce.lower() == "entrata" else "#D8000C"
                voce_html += f"""
                <li>
                    <form method="get" action="/modifica" style="display:inline;">
                        <input type="hidden" name="data" value="{data}">
                        <input type="hidden" name="idx" value="{idx_voce}">
                        <input type="hidden" name="from" value="/cerca_avanzata"> 
                        <button type="submit" style="margin-right:4px;" title="Modifica">‚úèÔ∏è</button>
                    </form>
                    <form onsubmit="
                        event.preventDefault();
                            fetch('/cancella', {{
                                method: 'POST',
                                headers: {{ 'Content-Type': 'application/x-www-form-urlencoded' }},
                                body: 'data={data}&idx={idx_voce}'
                            }}).then(function() {{ window.location.reload(); }});
                    " style="display:inline;">
                        <button type="submit" style="margin-right:8px;color:#D8000C;" title="Cancella">‚ùå</button>
                    </form>
                    {data} ‚Ä¢ {descrizione} 
                    <span style='color:#000; font-weight:bold;'>{simbolo}‚Ç¨{importo:.2f}</span>
                    <strong style='color:{colore_tipo};'>[{tipo_voce}]</strong>
                </li>
                """
            simbolo_totale = "‚ûï" if totale_cat >= 0 else "‚ûñ"
            colore_totale = "#007E33" if totale_cat >= 0 else "#D8000C"
            schede_html += f"""
            <div class="categoria-blocco">
                <button class="toggle-btn" onclick="toggleCategoria(this)">
                    <span class="freccia">‚û§</span> <span class="etichetta">{html_escape.escape(cat)}</span>
                </button>

                <div class="riepilogo-riga" style="color:{colore_totale};">
                    {simbolo_totale} Totale: <strong>‚Ç¨{totale_cat:.2f}</strong> ‚Ä¢ Voci: <strong>{len(voci)}</strong>
                </div>
                <div class="categoria-contenuto" style="display:none;">
                    <ul>{voce_html}</ul>
                </div>
            </div>
            """
        html = f"""
        <!DOCTYPE html>
        <html>
        <head>
            <meta charset="utf-8">
            <title>üìä Risultati Avanzati</title>
            <meta name="viewport" content="width=device-width, initial-scale=1">
            <style>
                body {{
                    font-family: 'Segoe UI', sans-serif;
                    background-color: #f4f4f4;
                    padding: 20px;
                    margin: 0;
                }}
                header {{
                    background: transparent;
                    color: black;
                    padding: 20px 0;
                    position: relative;
                }}
                .header-title {{
                   font-size: 18px;
                   font-weight: 800;
                   color: #000000;
                   margin: 0;
                   white-space: nowrap;
                   text-align: center;
                }}
                .menu-button {{ 
                  position: absolute; 
                  top: -5px !important;
                  left: -5px !important;
                  font-size: 1.6em; 
                  line-height: 1;
                  background: none; 
                  border: none; 
                  color: black; 
                  cursor: pointer; 
                  padding: 0;
                  margin: 0;
                  z-index: 1000;
                }}
                .nav-dropdown {{ 
                    position: absolute; 
                    top: 55px; 
                    left: 10px; 
                    background: white; 
                    box-shadow: 0 4px 15px rgba(0,0,0,0.2); 
                    border-radius: 8px; 
                    display: none; 
                    z-index: 1000; 
                    width: 260px;
                    text-align: left;
                }}
                .nav-dropdown a {{ 
                    display: block; 
                    padding: 12px 18px; 
                    text-decoration: none; 
                    color: #333;
                    border-bottom: 1px solid #eee; 
                    font-size: 0.95em; 
                    font-family: 'Segoe UI', sans-serif;
                    font-weight: normal; 
                }}
                .nav-dropdown a:last-child {{
                    border-bottom: none;
                }}
                .nav-dropdown a:hover {{ 
                    background-color: #f8f9fa; 
                    color: #0078D4;
                }}
                h2 {{
                    text-align: center;
                    font-size: 1.5em;
                    color: #333;
                    margin-bottom: 20px;
                }}
                .categoria-blocco {{
                    background: #fff;
                    border-radius: 8px;
                    box-shadow: 0 0 6px rgba(0,0,0,0.1);
                    margin: 20px auto;
                    max-width: 600px;
                    padding: 10px;
                }}
                .toggle-btn {{
                    background: none;
                    border: none;
                    font-size: 1.1em;
                    font-weight: bold;
                    width: 100%;
                    text-align: left;
                    cursor: pointer;
                    padding: 8px 0;
                    color: #0078D4;
                }}
                .categoria-contenuto ul {{
                    list-style: none;
                    padding-left: 0;
                    margin-top: 10px;
                }}
                .categoria-contenuto li {{
                    font-size: 1em;
                    margin: 8px 0;
                }}
                ul.totali {{
                    background: #fff;
                    padding: 16px;
                    border-radius: 8px;
                    box-shadow: 0 0 8px rgba(0,0,0,0.1);
                    max-width: 600px;
                    margin: 0 auto 30px auto;
                    list-style: none;
                }}
                ul.totali li {{
                    font-size: 1.1em;
                    margin: 8px 0;
                }}
                .back {{
                    display: block;
                    text-align: center;
                    font-size: 1em;
                    text-decoration: none;
                    background: #0078D4;
                    color: white;
                    padding: 10px;
                    border-radius: 4px;
                    max-width: 100%;
                    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
                    margin-top: 20px;
                }}
                .back:hover {{
                    background-color: #005ea6;
                }}
                .riepilogo-riga {{
                    font-size: 0.95em;
                    color: #555;
                    margin-top: 6px;
                    margin-bottom: 10px;
                    text-align: left;
                    padding-left: 4px;
                }}
                .pulsanti-finali {{
                    max-width: 600px;
                    margin: 30px auto 0 auto;
                }}
            </style>
            <script>
                function toggleMenu() {{
                    const menu = document.getElementById("extraMenu");
                    menu.style.display = (menu.style.display === "block") ? "none" : "block";
                }}
                document.addEventListener("click", function(event) {{
                    const menu = document.getElementById("extraMenu");
                    const isClickInside = event.target.closest(".menu-button, #extraMenu");
                    if (!isClickInside) {{
                        menu.style.display = "none";
                    }}
                }});
                function toggleCategoria(btn) {{
                    const riepilogo = btn.nextElementSibling;
                    const content = riepilogo.nextElementSibling;
                    const isVisible = content.style.display === "block";
                    content.style.display = isVisible ? "none" : "block";
                    const freccia = btn.querySelector(".freccia");
                    freccia.textContent = isVisible ? "‚û§" : "‚ñº";
                }}
            </script>
        </head>
        <body>
            <header>
                <button class="menu-button" onclick="toggleMenu()">üõ†Ô∏è</button>
                <div id="extraMenu" class="nav-dropdown">
                    <a href="/">üè† Aggiungi Operazione</a>
                    <a href="/lista">üìà Gestione Movimenti Mese</a>
                    <a href="/stats">üìä Bilancio Mese</a>
                    <a href="/report_annuo">‚öñÔ∏è Report Annuale</a>
                    <a href="/grafici_web">üìÖ Grafici e Statistiche</a>
                    <a href="/menu_esplora">üîç Esplora</a>
                    <a href="/gestione_categorie">‚öôÔ∏è Gestione Categorie</a>
                    <a href="/utenze?anno={anno_corrente}">üíß Utenze</a>
                    <a href="/documenti_pdf_web">üóÑÔ∏è Documenti PDF</a>
                    <a href="/consultazione_supermercati">üõí Gestione Supermercati</a>
                    <a href="/info_sys_web">üì° Monitor Server</a>
                    <a href="/logoff">üîì Logout</a>
                </div>
                <div class="header-title">üîç Risultati</div>
            </header>
            <h2>üìä Totali Esplorazione</h2>
            <ul class="totali">
                <li><strong>Entrate totali:</strong> ‚Ç¨{entrate_totali:.2f}</li>
                <li><strong>Uscite totali:</strong> ‚Ç¨{uscite_totali:.2f}</li>
                <li><strong style="color:{colore};">Saldo:</strong> ‚Ç¨{saldo:.2f}</li>
            </ul>
            <h2>üîé Risultati per Categoria</h2>
            {schede_html if schede_html else "<p style='text-align:center;'>Nessuna voce trovata per questi criteri.</p>"}
            <div class="pulsanti-finali">
                <form method="get" action="/menu_esplora">
                    <input type="submit" value="üîô Torna al Menu Esplora"
                    style="background-color: #0078D4; color: white; border: none;
                    font-size: 1.1em; padding: 12px; border-radius: 6px;
                    cursor: pointer; width: 100%; margin-bottom: 10px;">
                </form>
                <form method="get" action="/">
                    <input type="submit" value="üè† Torna alla Home"
                    style="background-color: #0078D4; color: white; border: none;
                    font-size: 1.1em; padding: 12px; border-radius: 6px;
                    cursor: pointer; width: 100%;">
                </form>
            </div>
        </body>
        </html>
        """
        return html

    def html_info_sys(self):
        import shutil, sys, multiprocessing, datetime, platform, os, json
        folder = os.path.basename(os.getcwd()).upper()
        sistema = platform.system()
        os_name = "Windows" if sistema == "Windows" else "Linux" if sistema == "Linux" else "Mac" if sistema == "Darwin" else sistema
        arch = platform.machine()
        nome_pc = platform.node().upper() 
        python_v = platform.python_version()
        ora_server = datetime.datetime.now().strftime("%H:%M - %d/%m/%Y")
        anno_corrente = datetime.datetime.now().year
        ram_info = "N/D"
        try:
            if sistema == "Windows":
                import ctypes
                class MEMORYSTATUSEX(ctypes.Structure):
                    _fields_ = [("dwLength", ctypes.c_ulong), ("dwMemoryLoad", ctypes.c_ulong),
                                ("ullTotalPhys", ctypes.c_ulonglong), ("ullAvailPhys", ctypes.c_ulonglong),
                                ("ullTotalPageFile", ctypes.c_ulonglong), ("ullAvailPageFile", ctypes.c_ulonglong),
                                ("ullTotalVirtual", ctypes.c_ulonglong), ("ullAvailVirtual", ctypes.c_ulonglong),
                                ("sullAvailExtendedPhys", ctypes.c_ulonglong)]
                stat = MEMORYSTATUSEX()
                stat.dwLength = ctypes.sizeof(stat)
                ctypes.windll.kernel32.GlobalMemoryStatusEx(ctypes.byref(stat))
                ram_info = f"{round(stat.ullAvailPhys/1024**3, 1)}GB liberi / {round(stat.ullTotalPhys/1024**3, 1)}GB"
            else:
                with open('/proc/meminfo', 'r') as f:
                    m = {l.split(':')[0]: int(l.split()[1]) for l in f.readlines()[:3]}
                ram_info = f"{round(m.get('MemAvailable', m.get('MemFree'))/1024**2, 1)}GB liberi / {round(m['MemTotal']/1024**2, 1)}GB"
        except: pass
        try:
            t, u, f = shutil.disk_usage("/")
            disco = f"{f // (2**30)}GB liberi ({ (u/t)*100:.0f}% uso)"
            peso_db = f"{os.path.getsize(DB_FILE) / (1024**2):.1f}MB" if os.path.exists(DB_FILE) else "0MB"
        except: disco = peso_db = "N/D"
        ultimo_log = "Primo accesso"
        if os.path.exists(LOGIN_WEB):
            try:
                with open(LOGIN_WEB, "r", encoding="utf-8") as f:
                    logs = json.load(f)
                    ultimo_log = logs[1]['data_ora'] if len(logs)>1 else ultimo_log
            except: pass
        import socket
        try:
            s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM); s.connect(('10.254.254.254', 1))
            ip = s.getsockname()[0]; s.close()
        except: ip = "127.0.0.1"
        porta = globals().get('PORT', "8080")
        return f"""
        <!DOCTYPE html>
        <html>
        <head>
            <meta charset="utf-8">
            <title>üì° Monitor Server</title>
            <meta name="viewport" content="width=device-width, initial-scale=1">
            <style>
             body {{
                 font-family: 'Segoe UI', sans-serif;
                 background-color: #f4f4f4;
                 padding: 10px;
                 margin: 0;
             }}
             header {{
                 background: transparent;
                 padding: 10px 0;
                 display: flex;
                 align-items: center;
                 justify-content: center;
                 position: relative;
                 min-height: 40px;
             }}
             .header-title {{
                 font-size: 17px;
                 font-weight: 800;
                 color: #000;
             }}
             .menu-button {{
                 position: absolute;
                 top: -5px !important;
                 left: 0px !important;
                 font-size: 1.6em;
                 background: none;
                 border: none;
                 cursor: pointer;
                 z-index: 1000;
                 padding: 5px;
             }}
             .nav-dropdown {{
                 position: absolute;
                 top: 45px;
                 left: 0;
                 background: white;
                 box-shadow: 0 4px 15px rgba(0,0,0,0.2);
                 border-radius: 8px;
                 display: none;
                 z-index: 1000;
                 width: 240px;
             }}
             .nav-dropdown a {{
                 display: block;
                 padding: 10px 15px;
                 text-decoration: none;
                 color: #333;
                 border-bottom: 1px solid #eee;
                 font-size: 0.9em;
             }}
             .categoria-blocco {{
                 background: #fff;
                 border-radius: 12px;
                 box-shadow: 0 0 5px rgba(0,0,0,0.1);
                 margin: 10px auto;
                 max-width: 500px;
                 padding: 12px;
             }}
             .info-title {{
                 font-size: 0.95em;
                font-weight: bold;
                 color: #0078D4;
                 border-bottom: 1px solid #eee;
                 padding-bottom: 5px;
                 margin-bottom: 8px;
                 text-transform: uppercase;
             }}
             .row {{
                 display: flex;
                 justify-content: space-between;
                 padding: 5px 0;
                 border-bottom: 1px solid #f9f9f9;
                 font-size: 0.9em;
             }}
             .row span {{
                 color: #666;
             }}
             .row b {{
                 color: #111;
             }}
             .log-box {{
                 background: #fff9c4;
                 padding: 10px;
                 border-radius: 8px;
                 border-left: 5px solid #fbc02d;
                 font-size: 0.85em;
             }}
             .links {{
                 display: flex;
                 justify-content: space-around;
                 margin-top: 15px;
                 border-top: 1px solid #eee;
                 padding-top: 10px;
             }}
             .links a {{
                 text-decoration: none;
                 font-size: 1.3em;
             }}
             .back-btn {{
                 display: block;
                 text-align: center;
                 background: #0078D4;
                 color: white;
                 padding: 10px;
                 border-radius: 8px;
                 text-decoration: none;
                 font-weight: bold;
                 margin-top: 15px;
             }}
            </style>
            <script>
                function toggleMenu() {{
                    const menu = document.getElementById("extraMenu");
                    menu.style.display = (menu.style.display === "block") ? "none" : "block";
                }}
                document.addEventListener("click", function(e) {{
                    const menu = document.getElementById("extraMenu");
                    const btn = document.querySelector(".menu-button");
                    if (menu.style.display === "block" && !menu.contains(e.target) && e.target !== btn) {{
                        menu.style.display = "none";
                    }}
                }});
            </script>
        </head>
        <body>
            <header>
                <button class="menu-button" onclick="toggleMenu()">üõ†Ô∏è</button>
                <div id="extraMenu" class="nav-dropdown">
                    <a href="/">üè† Aggiungi Operazione</a>
                    <a href="/lista">üìà Gestione Movimenti Mese</a>
                    <a href="/stats">üìä Bilancio Mese</a>
                    <a href="/report_annuo">‚öñÔ∏è Report Annuale</a>
                    <a href="/grafici_web">üìÖ Grafici e Statistiche</a>
                    <a href="/menu_esplora">üîç Esplora</a>
                    <a href="/gestione_categorie">‚öôÔ∏è Gestione Categorie</a>
                    <a href="/utenze?anno={anno_corrente}">üíß Utenze</a>
                    <a href="/documenti_pdf_web">üóÑÔ∏è Documenti PDF</a>
                    <a href="/consultazione_supermercati">üõí Gestione Supermercati</a>
                    <a href="/info_sys_web">üì° Monitor Server</a>
                    <a href="/logoff">üîì Logout</a>
                </div>
                <div class="header-title">üíª Monitor Server</div>
            </header>

            <div class="categoria-blocco">
                <div class="info-title">üñ•Ô∏è Hardware: {nome_pc}</div>
                <div class="row"><span>RAM</span><b>{ram_info}</b></div>
                <div class="row"><span>CPU</span><b>{multiprocessing.cpu_count()} Core ({arch})</b></div>
                <div class="row"><span>Disco</span><b>{disco}</b></div>
                <div class="row"><span>Database</span><b>{peso_db}</b></div>
            </div>

            <div class="categoria-blocco">
                <div class="info-title">‚öôÔ∏è Software</div>
                <div class="row"><span>Casa Facile Pro</span><b>v{VERSION}</b></div>
                <div class="row"><span>Python</span><b>v{python_v}</b></div>
                <div class="row"><span>OS</span><b>{os_name}</b></div>
                <div class="row"><span>IP</span><b>{ip}:{porta}</b></div>
            </div>

            <div class="categoria-blocco">
                <div class="log-box">
                    <b>üìÅ {folder}</b><br>
                    üïí Ultimo Accesso: {ultimo_log}
                </div>
                
                <div class="links">
                    <a href="https://github.com/Renato-4132/Casa-Facile/blob/main/" target="_blank" title="GitHub">üêô</a>
                    <a href="mailto:helpcasafacilepro@gmail.com" title="Email">‚úâÔ∏è</a>
                </div>

                <div style="text-align:center; font-size:0.7em; color:#aaa; margin-top:10px;">{ora_server}</div>
                <a href="/" class="back-btn">üè† Torna alla Home</a>
            </div>
        </body>
        </html>
        """

    # Pagina Principale Web
    def html_form(self):
        folder = os.path.basename(os.getcwd())
        ultimo_log_str = "Primo accesso"
        if os.path.exists(LOGIN_WEB):
            try:
                with open(LOGIN_WEB, "r", encoding="utf-8") as f:
                    logs = json.load(f)
                    if len(logs) > 1:
                        prec = logs[1]
                        ultimo_log_str = prec['data_ora']
                    elif len(logs) == 1:
                        ultimo_log_str = "Primo accesso!"
            except:
                pass
        oggi = datetime.date.today()
        un_anno_fa = oggi - datetime.timedelta(days=365)
        frequenze = {}
        spese_valide = []
        for d, lista in self.spese.items():
            if d < un_anno_fa: 
                continue
            for voce in lista:
                try:
                    cat, _, imp, tipo = voce[:4]
                    frequenze[cat] = frequenze.get(cat, 0) + 1
                    spese_valide.append({"cat": cat, "imp": float(imp), "tipo": tipo})
                except: 
                    continue
        smart_data_json = json.dumps({"spese": spese_valide, "frequenze": frequenze})
        dati_cat = {} 
        entrate_mese = 0.0
        uscite_mese = 0.0
        for d, lista in self.spese.items():
            if d.month == oggi.month and d.year == oggi.year:
                for voce in lista:
                    cat, _, importo, tipo = voce[:4]
                    if cat not in dati_cat: 
                        dati_cat[cat] = {"Entrata": 0.0, "Uscita": 0.0}
                    dati_cat[cat][tipo] += importo
                    if tipo == "Entrata": entrate_mese += importo
                    else: uscite_mese += importo
        incidenza_html = ""
        for cat in sorted(dati_cat.keys()):
            val = dati_cat[cat]
            tot = val["Entrata"] + val["Uscita"]
            if tot > 0:
                p_ent = (val["Entrata"] / tot) * 100
                p_usc = (val["Uscita"] / tot) * 100
                incidenza_html += f"""
                <div style='margin-bottom:12px;'>
                    <div style='display:flex; justify-content:space-between; font-size:0.9em;'>
                        <b>{cat}</b> <span>‚Ç¨{tot:.2f}</span>
                    </div>
                    <div style='display:flex; height:8px; border-radius:4px; overflow:hidden; background:#eee; margin:4px 0;'>
                        <div style='width:{p_ent}%; background:#3c763d;'></div>
                        <div style='width:{p_usc}%; background:#c43b2e;'></div>
                    </div>
                    <div style='display:flex; justify-content:space-between; font-size:0.75em; color:#666;'>
                        <span>E: {p_ent:.0f}%</span> <span>U: {p_usc:.0f}%</span>
                    </div>
                </div>"""
        today = oggi.isoformat()
        anno_corrente = oggi.year
        categorie_options = "\n".join(f"<option value='{c}'>{c}</option>" for c in self.categorie if c != "Generica")
        saldo_mese = entrate_mese - uscite_mese
        if saldo_mese >= 0:
            icona_saldo = "‚òÄÔ∏è"
            saldo_colore = "#3c763d"
        else:
            icona_saldo = "‚õàÔ∏è"
            saldo_colore = "#c43b2e"
        return f"""
        <!DOCTYPE html>
        <html>
        <head>
            <meta charset="utf-8">
            <title>üí∞ Aggiungi Movimento</title>
            <meta name="viewport" content="width=device-width, initial-scale=1">
            <style>
            body {{ 
                margin: 0; 
                font-family: 'Segoe UI', sans-serif; 
                background-color: #f0f2f5; 
                color: #333; 
            }}
            header {{ 
                background: transparent; 
                color: #000; 
                padding: 15px 0; 
                text-align: center; 
                position: relative;
                min-height: 40px;
                display: flex;
                align-items: center;
                justify-content: center;
            }}
            .menu-btn {{ 
                  position: absolute; 
                  top: 15px !important;
                  left: 15px !important;
                  font-size: 1.6em !important; 
                  line-height: 1;
                  background: none; 
                  border: none; 
                  color: black; 
                  cursor: pointer; 
                  padding: 0;
                  margin: 0;
                  z-index: 1000;
                }}
            .nav-dropdown {{ 
                position: absolute; 
                top: 55px; 
                left: 10px; 
                background: white; 
                box-shadow: 0 4px 15px rgba(0,0,0,0.2); 
                border-radius: 8px; 
                display: none; 
                z-index: 1000; 
                width: 260px; 
                text-align: left; 
            }}
            .nav-dropdown a {{ 
                display: block; 
                padding: 12px 18px; 
                text-decoration: none; 
                color: #333; 
                border-bottom: 1px solid #eee; 
                font-size: 0.95em; 
            }}
            main {{ 
                padding: 15px; 
                max-width: 500px; 
                margin: auto; 
            }}
            .card {{ 
                background: white; 
                border-radius: 10px; 
                box-shadow: 0 2px 8px rgba(0,0,0,0.08); 
                margin-bottom: 20px; 
            }}
            .card-header {{ 
                padding: 15px; 
                cursor: pointer; 
                display: flex; 
                justify-content: space-between; 
                align-items: center; 
                font-weight: bold; 
                color: #0078D4; 
            }}
            .card-content {{ 
                max-height: 0; 
                padding: 0 15px; 
                transition: max-height 0.4s ease; 
                overflow: hidden; 
            }}
            .card-content.open {{ 
                max-height: 1000px; 
                padding: 15px; 
                border-top: 1px solid #eee; 
            }}
            .arrow {{ 
                border: solid #0078D4; 
                border-width: 0 2px 2px 0; 
                display: inline-block; 
                padding: 4px; 
                transform: rotate(45deg); 
                transition: 0.3s; 
            }}
            .arrow.up {{ 
                transform: rotate(-135deg); 
            }}
            form {{ 
                background: white; 
                padding: 25px; 
                border-radius: 10px; 
                box-shadow: 0 2px 8px rgba(0,0,0,0.08); 
            }}
            label {{ 
                display: block; 
                margin-top: 15px; 
                font-weight: 600; 
                font-size: 0.9em; 
            }}
            input, select {{ 
                width: 100%; 
                padding: 12px; 
                margin-top: 5px; 
                border: 1px solid #ced4da; 
                border-radius: 6px; 
                box-sizing: border-box; 
                font-size: 16px; 
            }}
            input::-webkit-outer-spin-button,
            input::-webkit-inner-spin-button {{
                -webkit-appearance: none;
                margin: 0;
            }}
            input[type=number] {{
                -moz-appearance: textfield;
            }}
            .smartcat-label {{ 
                font-size: 0.85em; 
                margin-bottom: 5px; 
                font-weight: bold; 
            }}
            .error-msg-internal {{
                display: none;
                position: absolute;
                left: 50%;
                top: 50%;
                transform: translate(-50%, -50%);
                color: #c43b2e;
                font-size: 0.85em;
                font-weight: bold;
                pointer-events: none;
                white-space: nowrap;
                z-index: 10;
            }}
            .highlight-smart {{ 
                border: 2px solid #28a745 !important; 
                background-color: #f0fff4 !important; 
                transition: 0.3s; 
            }}
            input[type="submit"] {{ 
                background: #0078D4; 
                color: white; 
                border: none; 
                cursor: pointer; 
                font-weight: bold; 
                padding: 16px; 
                border-radius: 8px; 
                width: 100%; 
                margin-top: 25px; 
            }}
        </style>
        </head>
        <body>
            <header>
                <button class="menu-btn" onclick="toggleMenu()">üõ†Ô∏è</button>
                <div id="extraMenu" class="nav-dropdown">
                    <a href="/">üè† Aggiungi Operazione</a>
                    <a href="/lista">üìà Gestione Movimenti Mese</a>
                    <a href="/stats">üìä Bilancio Mese</a>
                    <a href="/report_annuo">‚öñÔ∏è Report Annuale</a>
                    <a href="/grafici_web">üìÖ Grafici e Statistiche</a>
                    <a href="/menu_esplora">üîç Esplora</a>
                    <a href="/gestione_categorie">‚öôÔ∏è Gestione Categorie</a>
                    <a href="/utenze?anno={anno_corrente}">üíß Utenze</a>
                    <a href="/documenti_pdf_web">üóÑÔ∏è Documenti PDF</a>
                    <a href="/consultazione_supermercati">üõí Gestione Supermercati</a>
                    <a href="/info_sys_web">üì° Monitor Server</a>
                    <a href="/logoff">üîì Logout</a>
                </div>
                <div style="font-size: 1.4em; font-weight: bold;">
                    üè† Inserisci Operazione<br>
                    <div style="height: 15px; overflow: hidden;"> <span id="user-badge" onclick="mostraLog()" 
                              style="font-size: 0.52em; color: #666; font-weight: 500; cursor: pointer; display: block; text-transform: uppercase; letter-spacing: 1px; transition: all 0.3s;">
                            üë§ {folder}
                        </span>
                    </div>
                </div>
            </header>
            <main>
                <div class="card" style="margin-top: -20px;">
                        <div class="card-header" onclick="toggleSection('summaryContent', 'summaryArrow')" style="display:flex; justify-content:space-between; cursor:pointer; padding:15px; background:#fff; border-radius:8px;">
                            <span>üìä Saldo Mensile {icona_saldo}</span>
                            <span id="summaryArrow">‚ñº</span>
                        </div>        
                        <div id="summaryContent" style="display:none; padding: 15px; border-top: 1px solid #eee;">
                            <div style="display:flex; justify-content:space-between; text-align:center; margin-bottom:15px;">
                                <div><small>Entrate</small><br><b style="color:#3c763d">‚Ç¨{entrate_mese:.2f}</b></div>
                                <div><small>Uscite</small><br><b style="color:#c43b2e">‚Ç¨{uscite_mese:.2f}</b></div>
                                <div><small>Saldo</small><br><b style="color:{saldo_colore}">‚Ç¨{saldo_mese:.2f}</b></div>
                            </div>
                            <div style="margin-top: 15px; border: 1px solid #eee; border-radius: 8px;">
                                <div class="card-header" onclick="event.stopPropagation(); toggleSection('incidenzaContent', 'incidenzaArrow')" style="display:flex; justify-content:space-between; background: #fcfcfc; padding: 10px; cursor: pointer;">
                                    <span style="font-size: 0.9em;">üìâ Dettaglio Incidenze</span>
                                    <span id="incidenzaArrow" style="font-size: 0.8em;">‚ñº</span>
                                </div>
                                <div id="incidenzaContent" style="display:none; padding: 10px; background: #fff; border-top: 1px solid #eee;">
                                    {incidenza_html}
                                </div>
                            </div>
                        </div>
                    </div>
                <form method="post" action="/" onsubmit="return validaForm(event)">
                    <div id="smartcat_lbl" class="smartcat-label" style="color:gray;">üõ†Ô∏è SmartCat in attesa...</div>                    
                    <label>Importo (‚Ç¨):</label>
                    <div style="position: relative; width: 100%;">
                        <input name="importo" id="importo_input" type="number" step="0.01" placeholder="0.00" 
                               autofocus
                               oninput="aggiornaSmartCat(this.value)" style="padding-right: 140px;">
                        <span id="local_error" 
                              style="display: none; position: absolute; right: 12px; top: 50%; transform: translateY(-50%); 
                                     color: #c43b2e; font-size: 0.75em; font-weight: bold; pointer-events: none;">
                              ‚ö†Ô∏è Inserisci un importo valido!
                        </span>
                    </div>
                    <select name="categoria" id="categoria_select">
                        <option value="Generica">Generica</option>
                        {categorie_options}
                    </select>
                    <label>Tipo:</label>
                    <select name="tipo" id="tipo_select">
                        <option value="Uscita">Uscita</option>
                        <option value="Entrata">Entrata</option>
                    </select>
                    <label>Descrizione:</label>
                    <input name="descrizione" placeholder="Es: Pizza, Colazione, Fattura, Regali">
                    <label>Data:</label>
                    <input name="data" type="date" value="{today}">
                    <input type="submit" value="‚ûï Aggiungi Movimento">
                </form>
            </main>
            <script>
                const dbSmart = {smart_data_json};
                function toggleSection(contentId, arrowId) {{
                    var content = document.getElementById(contentId);
                    var arrow = document.getElementById(arrowId);
                    if (content.style.display === "none" || content.style.display === "") {{
                        content.style.display = "block";
                        if (arrow) {{
                            arrow.innerHTML = "‚ñ≤"; // Indica SU (aperto)
                        }}
                    }} else {{
                        content.style.display = "none";
                        if (arrow) {{
                            arrow.innerHTML = "‚ñº"; // Indica GI√ô (chiuso)
                        }}
                    }}
                }}
                function toggleMenu() {{ 
                    const m = document.getElementById("extraMenu");
                    m.style.display = (m.style.display === "block") ? "none" : "block"; 
                }}
                function toggleSummary() {{ 
                    document.getElementById("summaryContent").classList.toggle("open"); 
                    document.getElementById("summaryArrow").classList.toggle("up"); 
                }}
                function aggiornaSmartCat(valore) {{
                    const sc = document.getElementById("categoria_select");
                    const st = document.getElementById("tipo_select");
                    const lbl = document.getElementById("smartcat_lbl");
                    const inp = document.getElementById("importo_input");
                    inp.style.border = "1px solid #ced4da";
                    document.getElementById("local_error").style.display = "none";
                    if (!valore || valore.trim() === "") {{
                        sc.value = "Generica"; st.value = "Uscita";
                        lbl.innerText = "üõ†Ô∏è SmartCat in attesa..."; lbl.style.color = "gray";
                        return;
                    }}
                    const impCorrente = parseFloat(valore);
                    if (isNaN(impCorrente)) return;
                    let migliorPunteggio = Infinity;
                    let categoriaMigliore = null;
                    let tipoMigliore = "Uscita";
                    let categorieValutate = new Set();
                    dbSmart.spese.forEach(spesa => {{
                        if (categorieValutate.has(spesa.cat)) return;
                        categorieValutate.add(spesa.cat);
                        const diff = Math.abs(spesa.imp - impCorrente);
                        const freq = dbSmart.frequenze[spesa.cat] || 1;
                        const bonusFrequenza = Math.log(freq) * 0.5;
                        const punteggio = diff - bonusFrequenza;
                        if (punteggio < migliorPunteggio) {{
                            migliorPunteggio = punteggio;
                            categoriaMigliore = spesa.cat;
                            tipoMigliore = spesa.tipo;
                        }}
                    }});
                    if (categoriaMigliore) {{
                        if (sc.value !== categoriaMigliore || st.value !== tipoMigliore) {{
                            sc.value = categoriaMigliore;
                            st.value = tipoMigliore;
                            sc.classList.add("highlight-smart");
                            setTimeout(() => sc.classList.remove("highlight-smart"), 500);
                        }}
                        lbl.innerText = "üí° SmartCat attiva"; lbl.style.color = "red";
                    }}
                }}
                function validaForm(e) {{
                    const inp = document.getElementById("importo_input");
                    const errorMsg = document.getElementById("local_error");
                    const valore = parseFloat(inp.value);
                    if (!inp.value || isNaN(valore) || valore <= 0) {{
                        e.preventDefault();
                        inp.value = ""; 
                        inp.style.border = "2px solid #c43b2e";
                        inp.style.backgroundColor = "#fff5f5";
                        errorMsg.style.display = "block";
                        setTimeout(() => {{
                            errorMsg.style.display = "none";
                            inp.style.border = "1px solid #ced4da";
                            inp.style.backgroundColor = "white";
                            inp.placeholder = "0.00"; 
                        }}, 2000);
                        return false;
                    }}
                    return true;
                }}
                window.addEventListener('load', function() {{
                    const inp = document.getElementById("importo_input");
                    if (inp) inp.focus();
                    const p = new URLSearchParams(window.location.search);
                    if (p.get('salvato') === '1' && inp) {{
                        const t = document.createElement("div");
                        t.innerText = "Salvato ‚úì";
                        Object.assign(t.style, {{
                            position: "absolute",
                            right: "10px",
                            top: "50%",
                            transform: "translateY(-50%)",
                            backgroundColor: "#28a745",
                            color: "white",
                            padding: "4px 10px",
                            borderRadius: "4px",
                            fontSize: "11px",
                            fontWeight: "bold",
                            zIndex: "5",
                            pointerEvents: "none",
                            boxShadow: "0 1px 3px rgba(0,0,0,0.2)"
                        }});
                        inp.parentElement.appendChild(t);
                        window.history.replaceState({{}}, document.title, window.location.pathname);
                        setTimeout(() => {{
                            t.style.transition = "opacity 0.6s";
                            t.style.opacity = "0";
                            setTimeout(() => t.remove(), 600);
                        }}, 1200);
                    }}
                }});
                window.onclick = function(event) {{
                    if (!event.target.matches('.menu-btn')) {{
                        const dropdowns = document.getElementsByClassName("nav-dropdown");
                        for (let i = 0; i < dropdowns.length; i++) {{
                            if (dropdowns[i].style.display === "block") dropdowns[i].style.display = "none";
                        }}
                    }}
                }}
                function mostraLog() {{
                    const badge = document.getElementById('user-badge');
                    const originale = "üë§ {folder}";
                    const dataLog = "üïí {ultimo_log_str}";
                    if (badge.innerText.includes("{folder}".toUpperCase()) || badge.innerText.includes("{folder}")) {{
                        badge.style.opacity = "0";
                        setTimeout(() => {{
                            badge.innerText = dataLog;
                            badge.style.color = "#1a73e8";
                            badge.style.opacity = "1";
                        }}, 200);
                        setTimeout(() => {{
                            badge.style.opacity = "0";
                            setTimeout(() => {{
                                badge.innerText = originale;
                                badge.style.color = "#666";
                                badge.style.opacity = "1";
                            }}, 200);
                        }}, 3000);
                    }}
                }}
            </script>
        </body>
        </html>
        """
    
    def registra_accesso(self):
        from datetime import datetime
        nuovo_log = {
            "data_ora": datetime.now().strftime("%d/%m/%Y %H:%M:%S"),
        }
        logs = []
        if os.path.exists(LOGIN_WEB):
            try:
                with open(LOGIN_WEB, "r", encoding="utf-8") as f:
                    logs = json.load(f)
            except:
                logs = []
        logs.insert(0, nuovo_log)
        logs = logs[:10]
        with open(LOGIN_WEB, "w", encoding="utf-8") as f:
            json.dump(logs, f, indent=4)
            
    # Gestione Documenti Web
    def documenti_pdf_web(self):
        import datetime
        from datetime import datetime as dt
        import os
        oggi = datetime.date.today()
        def bytes_to_human(byte_count):
            if byte_count is None: return "0 B"
            byte_count = int(byte_count)
            if byte_count < 1024: return f"{byte_count} B"
            elif byte_count < 1024 ** 2: return f"{byte_count / 1024:.2f} KB"
            else: return f"{byte_count / (1024 ** 2):.2f} MB"
        registry_file_path = os.path.join("db", "documenti_archiviati.json")
        doc_dir = os.path.join("db", "documenti")
        dati_json = getattr(self, 'archivi_pdf', {})
        if not dati_json and os.path.exists(registry_file_path):
            try:
                with open(registry_file_path, "r", encoding="utf-8") as f:
                    dati_json = json.load(f)
            except:
                dati_json = {}
        archivi_dati_strutturati = []
        for nome_file, dettagli in dati_json.items():
            percorso_fisico_check = os.path.join(doc_dir, nome_file)
            if not os.path.exists(percorso_fisico_check):
                continue
            try:
                data_raw = dettagli.get("data_raw")
                data_obj = dt.strptime(data_raw, "%d%m%Y").date() if data_raw else datetime.date.today()
            except:
                data_obj = datetime.date.today()
            archivi_dati_strutturati.append({
                "nome_file": nome_file,
                "data_caricamento": data_obj,
                "descrizione": dettagli.get('descrizione_esatta', 'N/D'),
                "categoria": dettagli.get('categoria_esatta', 'Generico'),
                "importo": f"{dettagli.get('importo_raw', 0) / 100:.2f} ‚Ç¨" if isinstance(dettagli.get('importo_raw'), (int, float)) else "N/D",
                "dimensione": os.path.getsize(percorso_fisico_check)
            })
        archivi_ordinati = sorted(archivi_dati_strutturati, key=lambda x: x["data_caricamento"], reverse=True)
        archivi_list_html = ""
        for archivio in archivi_ordinati:
            n_file = archivio["nome_file"]
            d_str = archivio["data_caricamento"].strftime("%d/%m/%Y")
            link_pdf = f"/get_pdf?file={n_file}"
            dim_h = bytes_to_human(archivio["dimensione"])            
            search_data = f"{d_str} {archivio['descrizione']} {archivio['categoria']} {archivio['importo']}".lower()
            archivi_list_html += f"""
            <tr data-search="{search_data}">
                <td data-label="Data:"><div>{d_str}</div></td>
                <td data-label="Dettagli">
                    <div data-label="Categoria:">
                        <a href="{link_pdf}" target="_blank" style="color:#0078D4; text-decoration:none; font-weight:bold;">
                            {archivio['categoria']}
                        </a>
                    </div>
                    <div data-label="Descrizione:">{archivio['descrizione']}</div>
                    <div data-label="Importo:">{archivio['importo']}</div>
                    <div data-label="Dimensione:">{dim_h}</div>
                </td>
                <td data-label="Azioni">
                    <a href="{link_pdf}" download="{n_file}" style="text-decoration:none; font-size:1.2em;">‚¨áÔ∏è</a>
                </td>
            </tr>
            """
        anno_corrente = datetime.date.today().year
        return f"""
        <!DOCTYPE html>
        <html>
        <head>
            <meta charset="utf-8">
            <title>üóÑÔ∏è Archivio PDF</title>
            <meta name="viewport" content="width=device-width, initial-scale=1">
            <style>
                body {{ font-family: 'Segoe UI', sans-serif; background-color: #f4f4f4; margin: 0; padding: 0; }}
                header {{ 
                  background: transparent; 
                  color: #000; 
                  padding: 15px 0; 
                  text-align: center; 
                  position: relative;
                  min-height: 40px;
                  display: flex;
                  align-items: center;
                  justify-content: center;
                }}
                .header-title {{
                    font-size: 18px;
                    font-weight: 800;
                    color: #000000;
                    margin: 0;
                    white-space: nowrap;
                    text-align: center;
                }}
                .menu-button {{ 
                  position: absolute; 
                  top: 15px !important;
                  left: 15px !important;
                  font-size: 1.6em; 
                  line-height: 1;
                  background: none; 
                  border: none; 
                  color: black; 
                  cursor: pointer; 
                  padding: 0;
                  margin: 0;
                  z-index: 1000;
                }}
                .nav-dropdown {{ 
                    position: absolute; 
                    top: 55px; 
                    left: 10px; 
                    background: white; 
                    box-shadow: 0 4px 15px rgba(0,0,0,0.2); 
                    border-radius: 8px; 
                    display: none; 
                    z-index: 1000; 
                    width: 260px;
                    text-align: left;
                }}
                .nav-dropdown a {{ 
                    display: block; 
                    padding: 12px 18px; 
                    text-decoration: none; 
                    color: #333;
                    border-bottom: 1px solid #eee; 
                    font-size: 0.95em; 
                    font-family: 'Segoe UI', sans-serif;
                    font-weight: normal; 
                            }}
                .nav-dropdown a:last-child {{
                    border-bottom: none;
                }}
                .nav-dropdown a:hover {{ 
                    background-color: #f8f9fa; 
                    color: #0078D4;
                }}
                main {{ padding: 15px; max-width: 800px; margin: auto; }}
                .search-box {{ width: 100%; padding: 12px; margin-bottom: 20px; border: 1px solid #ccc; border-radius: 6px; font-size: 1em; box-sizing: border-box; }}
                .table-container {{ background: white; padding: 10px; border-radius: 8px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); margin-bottom: 20px; }}
                table {{ width: 100%; border-collapse: collapse; }}
                th {{ background: #e6f2ff; color: #005ea6; padding: 12px; text-align: left; }}
                td {{ padding: 12px; border-bottom: 1px solid #eee; }}                
                .home-btn-container {{ text-align: center; margin-top: 20px; padding-bottom: 40px; }}
                .home-btn {{ 
                    display: inline-block; 
                    padding: 12px 25px; 
                    background-color: #0078D4; 
                    color: white; 
                    text-decoration: none; 
                    border-radius: 6px; 
                    font-weight: bold; 
                    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
                }}                
                @media (max-width: 600px) {{
                    th {{ display: none; }}
                    td {{ display: block; width: 100%; border-bottom: 1px solid #ccc; padding: 10px 5px; box-sizing: border-box; }}
                    td div {{ 
                        display: flex; 
                        justify-content: flex-start; 
                        padding: 6px 0; 
                        text-align: left;
                    }}
                    td div[data-label]::before {{ 
                        content: attr(data-label); 
                        font-weight: bold; 
                        color: #0078D4; 
                        min-width: 100px; 
                        display: inline-block;
                    }}
                    td:last-child {{ text-align: center; border-bottom: none; }}
                }}
            </style>
            <script>
                function toggleMenu() {{
                    const m = document.getElementById("extraMenu");
                    m.style.display = (m.style.display === "block") ? "none" : "block";
                }}
                function filtra() {{
                    const val = document.getElementById("searchInput").value.toLowerCase();
                    const rows = document.querySelectorAll("#pdfTableBody tr");
                    rows.forEach(r => {{
                        r.style.display = r.getAttribute("data-search").includes(val) ? "" : "none";
                    }});
                }}
                document.addEventListener("click", function(e) {{
                    const menu = document.getElementById("extraMenu");
                    const btn = document.querySelector(".menu-button");
                    if (menu.style.display === "block" && !menu.contains(e.target) && e.target !== btn) {{
                        menu.style.display = "none";
                    }}
                }});
            </script>
        </head>
        <body>
            <header>
                <button class="menu-button" onclick="toggleMenu()">üõ†Ô∏è</button>
                <div id="extraMenu" class="nav-dropdown">
                    <a href="/">üè† Aggiungi Operazione</a>
                    <a href="/lista">üìà Gestione Movimenti Mese</a>
                    <a href="/stats">üìä Bilancio Mese</a>
                    <a href="/report_annuo">‚öñÔ∏è Report Annuale</a>
                    <a href="/grafici_web">üìÖ Grafici e Statistiche</a>
                    <a href="/menu_esplora">üîç Esplora</a>
                    <a href="/gestione_categorie">‚öôÔ∏è Gestione Categorie</a>
                    <a href="/utenze?anno={anno_corrente}">üíß Utenze</a>
                    <a href="/documenti_pdf_web">üóÑÔ∏è Documenti PDF</a>
                    <a href="/consultazione_supermercati">üõí Gestione Supermercati</a>
                    <a href="/info_sys_web">üì° Monitor Server</a>
                    <a href="/logoff">üîì Logout</a>
                </div>
                <div class="header-title">üóÑÔ∏è Archivio PDF</div>
            </header>
            <main>
                <input type="text" id="searchInput" class="search-box" onkeyup="filtra()" placeholder="Cerca...">
                <div class="table-container">
                    <table>
                        <thead>
                            <tr><th>Data</th><th>Dettagli</th><th>Azioni</th></tr>
                        </thead>
                        <tbody id="pdfTableBody">
                            {archivi_list_html if archivi_list_html else '<tr><td colspan="3" style="text-align:center;">Nessun file trovato</td></tr>'}
                        </tbody>
                    </table>
                </div>
                <div class="home-btn-container">
                    <a href="/" class="home-btn">üè† Torna alla Home</a>
                </div>
            </main>
        </body>
        </html>
        """

    # Visualizza Utenze Web
    def genera_html_utenze(self, percorso_db, anno):
        from datetime import datetime
        utenze = ["Acqua", "Luce", "Gas"]
        if not os.path.exists(percorso_db):
            return """
            <!DOCTYPE html>
            <html>
            <head><title>Errore DB</title><meta charset="utf-8"></head>
            <body style='font-family:Arial; background:#fff; padding:20px;'>
              <h2 style='color:#b00;'>‚ùå Errore database</h2>
              <p style='font-size:3.2em;'>‚ö†Ô∏è Il file <strong>UTENZE_DB</strong> non esiste o √® vuoto.</p>
              <a href='/' style='display:inline-block; margin-top:20px; font-size:3em; text-decoration:none; color:#0078D4;'>üè† Torna alla Home</a>
            </body>
            </html>
            """
        try:
            with open(percorso_db, "r", encoding="utf-8") as f:
                contenuto = f.read().strip()
                if not contenuto:
                    return "<p style='font-size: 3.3em; font-weight: bold; color: #C00;'>‚ö†Ô∏è Il file database √® vuoto.</p>"
                data = json.loads(contenuto)
        except Exception as e:
            return f"<p>‚ùå Errore nel file JSON: {e}</p>"
        letture = data.get("letture_salvate", {})
        anno_corrente = datetime.now().year
        anni_disponibili = [str(anno_corrente - i) for i in range(6)]
        select_html = "<form><label for='anno'>üóìÔ∏è Scegli anno:</label> "
        select_html += "<select id='anno' onchange=\"location.href='/utenze?anno=' + this.value\">"
        for a in anni_disponibili:
            selected = " selected" if a == str(anno) else ""
            select_html += f"<option value='{a}'{selected}>{a}</option>"
        select_html += "</select></form>"
        oggi = datetime.now()
        html = f"""<!DOCTYPE html>
    <html lang="it">
    <head>
      <meta charset="utf-8">
      <title>üíß Utenze ‚Äî {anno}</title>
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <style>
        body {{
          margin: 0;
          font-family: 'Segoe UI', sans-serif;
          background-color: #f4f4f4;
        }}
        header {{ 
            background: transparent; 
            color: #000; 
            padding: 15px 0; 
            text-align: center; 
            position: relative;
            min-height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
        }}
        .header-title {{
          font-size: 18px;
          font-weight: 800;
          color: #000000;
          margin: 0;
          white-space: nowrap;
          text-align: center;
        }}
        .menu-button {{ 
          position: absolute; 
          top: 15px !important;
          left: 15px !important;
          font-size: 1.6em; 
          line-height: 1;
          background: none; 
          border: none; 
          color: black; 
          cursor: pointer; 
          padding: 0;
          margin: 0;
          z-index: 1000;
        }}
        .nav-dropdown {{ 
            position: absolute; 
            top: 55px; 
            left: 10px; 
            background: white; 
            box-shadow: 0 4px 15px rgba(0,0,0,0.2); 
            border-radius: 8px; 
            display: none; 
            z-index: 1000; 
            width: 260px;
            text-align: left;
        }}
        .nav-dropdown a {{ 
            display: block; 
            padding: 12px 18px; 
            text-decoration: none; 
            color: #333;
            border-bottom: 1px solid #eee; 
            font-size: 0.95em; 
            font-family: 'Segoe UI', sans-serif;
            font-weight: normal; 
        }}
        .nav-dropdown a:last-child {{
            border-bottom: none;
        }}
        .nav-dropdown a:hover {{ 
            background-color: #f8f9fa; 
            color: #0078D4;
        }}
        main {{
          padding: 20px;
          max-width: 600px;
          margin: auto;
        }}
        .utenza-title {{
          cursor: pointer;
          padding: 10px;
          background: #0078D4;
          color: white;
          border-radius: 4px;
          margin-top: 20px;
        }}
        .utenza-content {{
          display: none;
          background: white;
          padding: 10px;
          border-radius: 6px;
          box-shadow: 0 0 4px rgba(0,0,0,0.05);
          margin-bottom: 20px;
        }}
        table {{
          width: 100%;
          border-collapse: collapse;
          font-size: 0.9em;
        }}
        th, td {{
          border: 1px solid #ccc;
          padding: 8px;
          text-align: center;
        }}
        th {{
          background: #0078D4;
          color: white;
        }}
        .teardown {{
          background: #f9f9f9;
          margin-top: 10px;
          font-size: 0.9em;
          padding: 8px;
          border-radius: 4px;
        }}
        .back {{
          display: block;
          text-align: center;
          font-size: 1em;
          text-decoration: none;
          background: #0078D4;
          color: white;
          padding: 10px;
          border-radius: 4px;
          box-shadow: 0 2px 5px rgba(0,0,0,0.1);
          margin: 20px auto;
          width: 200px;
        }}
        .back:hover {{
          background-color: #005ea6;
        }}
      </style>
      <script>
        function toggleMenu() {{
          const menu = document.getElementById("extraMenu");
          menu.style.display = (menu.style.display === "block") ? "none" : "block";
        }}
        function toggle(id) {{
          const el = document.getElementById(id);
          if (el.style.display === "block") {{
            el.style.display = "none";
          }} else {{
            el.style.display = "block";
          }}
        }}
        document.addEventListener("click", function(event) {{
          const menu = document.getElementById("extraMenu");
          if (!event.target.closest(".menu-button, #extraMenu")) {{
            menu.style.display = "none";
          }}
        }});
      </script>
    </head>
    <body>
      <header>
        <button class="menu-button" onclick="toggleMenu()">üõ†Ô∏è</button>
        <div id="extraMenu" class="nav-dropdown">
          <a href="/">üè† Aggiungi Operazione</a>
          <a href="/lista">üìà Gestione Movimenti Mese</a>
          <a href="/stats">üìä Bilancio Mese</a>
          <a href="/report_annuo">‚öñÔ∏è Report Annuale</a>
          <a href="/grafici_web">üìÖ Grafici e Statistiche</a>
          <a href="/menu_esplora">üîç Esplora</a>
          <a href="/gestione_categorie">‚öôÔ∏è Gestione Categorie</a>
          <a href="/utenze?anno={anno_corrente}">üíß Utenze</a>
          <a href="/documenti_pdf_web">üóÑÔ∏è Documenti PDF</a>
          <a href="/consultazione_supermercati">üõí Gestione Supermercati</a>
          <a href="/info_sys_web">üì° Monitor Server</a>
          <a href="/logoff">üîì Logout</a>
        </div>
        <div class="header-title">üíß Utenze ‚Äî Anno {anno}</div>
      </header>
      <main>
        {select_html}
    """

        for utenza in utenze:
            righe = letture.get(utenza, {}).get(str(anno), [])
            uid = f"utenza_{utenza.lower()}"
            html += f"<div class='utenza-title' onclick=\"toggle('{uid}')\">‚ñ∂Ô∏è {utenza}</div><div id='{uid}' class='utenza-content'>"
            if righe:
                total = 0.0
                consumi = []
                html += "<table><tr><th>Mese</th><th>Prec</th><th>Att</th><th>Consumo</th></tr>"
                for riga in righe:
                    try:
                        mese, prec, att, cons = riga
                        prec, att, cons = float(prec), float(att), float(cons)
                        total += cons
                        consumi.append(cons)
                        html += f"<tr><td>{mese}</td><td>{prec:.2f}</td><td>{att:.2f}</td><td>{cons:.2f}</td></tr>"
                    except:
                        html += f"<tr><td colspan='4'>‚ö†Ô∏è Errore dati: {riga}</td></tr>"
                media = total / len(consumi) if consumi else 0
                variazioni = [consumi[i] - consumi[i - 1] for i in range(1, len(consumi))]
                ultima = variazioni[-1] if variazioni else 0
                html += "</table>"
                html += f"""
    <div class='teardown'>
    üî¢ Totale: <strong>{total:.2f}</strong><br>
    üìä Media mensile: <strong>{media:.2f}</strong><br>
    üìà Ultima variazione: <strong>{ultima:+.2f}</strong><br>
    üìÖ Mesi registrati: <strong>{len(consumi)}</strong>
    </div>
    """
            else:
                html += "<p><i>Nessun dato disponibile.</i></p>"
            html += "</div>"

        html += f"""
        <a href="/" class="back">üè† Torna alla Home</a>
      </main>
    </body>
    </html>
    """
        return html

    # Lista Spesa Supermarket e Prezzi Promo
    def genera_html_consultazione(self, file_selezionato=None):
        anno_corrente = datetime.datetime.now().year
        def inizializza_db_file(percorso_db, contenuto_iniziale="{}"):
            dir_path = os.path.dirname(percorso_db)
            if dir_path and not os.path.exists(dir_path):
                os.makedirs(dir_path) 
            if not os.path.exists(percorso_db):
                try:
                    with open(percorso_db, "w", encoding="utf-8") as f:
                        f.write(contenuto_iniziale)
                    return True
                except Exception as e:
                    print(f"Errore nella creazione automatica di {percorso_db}: {e}")
                    return False
            return True
        def get_file_list_internal():
            directory_esportazione = EXPORT_FILES
            if not os.path.isdir(directory_esportazione):
                try:
                    os.makedirs(directory_esportazione)
                except Exception:
                    pass
                return []
            list_files = os.listdir(directory_esportazione)
            lista_spesa_files = [f for f in list_files if f.startswith("Lista_Spesa_") and f.endswith(".txt")]
            try:
                lista_spesa_files.sort(key=lambda f: os.path.getmtime(os.path.join(directory_esportazione, f)), reverse=True)
            except Exception:
                pass
            return lista_spesa_files
        def leggi_lista_spesa_internal(nome_file):
            directory_esportazione = EXPORT_FILES
            file_path = os.path.join(directory_esportazione, nome_file)
            if not os.path.exists(file_path):
                return []
            try:
                with open(file_path, 'r', encoding='utf-8') as f:
                    content = f.read()
            except Exception as e:
                print(f"Errore lettura file {nome_file}: {e}")
                return []
            return [{"raw_content": content}]
        lista_file_disponibili = get_file_list_internal() 
        file_visualizzato = lista_file_disponibili[0] if lista_file_disponibili else "Nessuna Lista Trovata"
        ultima_spesa_data = []
        if file_visualizzato != "Nessuna Lista Trovata":
            ultima_spesa_data = leggi_lista_spesa_internal(file_visualizzato)
        is_raw_content = ultima_spesa_data and 'raw_content' in ultima_spesa_data[0]
        percorso_db = SUPERMERCATI_DB
        dati_supermercati = {}
        if not inizializza_db_file(percorso_db):
             return f"""<!DOCTYPE html><html><head><title>Errore database</title><meta charset="utf-8"></head><body style='font-family:Arial; background:#fff; padding:20px;'><h2 style='color:#b00;'>‚ùå Errore database</h2><p style='font-size:1.5em;'>‚ö†Ô∏è Impossibile creare il file <strong>{percorso_db}</strong>.</p><a href='/' style='display:inline-block; margin-top:20px; font-size:1.5em; text-decoration:none; color:#0078D4;'>üè† Torna alla Home</a></body></html>"""
        try:
            with open(percorso_db, "r", encoding="utf-8") as f:
                contenuto = f.read().strip()
                dati_supermercati = json.loads(contenuto) if contenuto else {}
        except Exception as e:
            return f"""<!DOCTYPE html><html><head><title>Errore JSON</title><meta charset="utf-8"></head><body style='font-family:Arial; background:#fff; padding:20px;'><h2 style='color:#b00;'>‚ùå Errore JSON</h2><p style='font-size:1.5em;'>Errore lettura database supermercati: {e}</p><a href='/' style='display:inline-block; margin-top:20px; font-size:1.5em; text-decoration:none; color:#0078D4;'>üîô Torna alla Home</a></body></html>"""
        supermercati = sorted(dati_supermercati.keys())
        page_title = "üîç Gestione Supermarket"
        header_text = "Gestione Supermarket"
        emoji = ""
        html = f"""<!DOCTYPE html>
        <html lang="it">
        <head>
          <meta charset="utf-8">
          <title>{emoji} {page_title}</title>
          <meta name="viewport" content="width=device-width, initial-scale=1">
          <style>
            body {{ 
                margin: 0; 
                font-family: 'Segoe UI', sans-serif; 
                background-color: #f4f4f4; 
                color: #333; 
            }}
            header {{ 
                background: transparent; 
                color: #000; 
                padding: 15px 0; 
                text-align: center; 
                position: relative;
                min-height: 40px;
                display: flex;
                align-items: center;
                justify-content: center;
            }}
            .header-title {{
                font-size: 18px;
                font-weight: 800;
                color: #000000;
                margin: 0;
                white-space: nowrap;
                text-align: center;
            }}
            .menu-button {{ 
                  position: absolute; 
                  top: 15px !important;
                  left: 15px !important;
                  font-size: 1.6em; 
                  line-height: 1;
                  background: none; 
                  border: none; 
                  color: black; 
                  cursor: pointer; 
                  padding: 0;
                  margin: 0;
                  z-index: 1000;
            }}
            .nav-dropdown {{ 
                position: absolute; 
                top: 55px; 
                left: 10px; 
                background: white; 
                box-shadow: 0 4px 15px rgba(0,0,0,0.2); 
                border-radius: 8px; 
                display: none; 
                z-index: 1000; 
                width: 260px;
                text-align: left;
            }}
            .nav-dropdown a {{ 
                display: block; 
                padding: 12px 18px; 
                text-decoration: none; 
                color: #333;
                border-bottom: 1px solid #eee; 
                font-size: 0.95em; 
                font-family: 'Segoe UI', sans-serif;
                font-weight: normal; 
                            }}
            .nav-dropdown a:last-child {{
                border-bottom: none;
            }}
            .nav-dropdown a:hover {{ 
                background-color: #f8f9fa; 
                color: #0078D4;
            }}
            .section-title {{ 
                cursor: pointer; 
                padding: 12px; 
                background: #0078D4; 
                color: white; 
                border-radius: 8px; 
                font-weight: bold; 
                display: flex; 
                justify-content: space-between; 
                align-items: center; 
                box-sizing: border-box; 
                width: 85%; 
                max-width: 450px; 
                margin: 20px auto 0 auto; 
            }}
            .section-content {{ 
                background: white; 
                padding: 15px; 
                border-radius: 0 0 8px 8px; 
                box-shadow: 0 4px 8px rgba(0,0,0,0.1); 
                box-sizing: border-box;
                width: 85%; 
                max-width: 450px; 
                margin: 0 auto 20px auto; 
                display: none;
            }}
            table {{ 
                width: 100%; 
                border-collapse: collapse; 
                font-size: 0.7em; 
                table-layout: auto;
            }}
            th, td {{ 
                border: 1px solid #ddd; 
                padding: 6px 4px;
                text-align: left; 
                word-break: break-word; 
                overflow-wrap: break-word;
                white-space: normal;
            }}
            th {{ 
                background: #0078D4; 
                color: white; 
                text-align: center;
            }}
            .promo {{ color: #d32f2f; font-weight: bold; }}
            .prezzo {{ text-align: right; }}
            .back {{ 
                display: block; 
                text-align: center; 
                text-decoration: none; 
                background: #0078D4; 
                color: white; 
                padding: 12px; 
                border-radius: 8px; 
                margin: 30px auto; 
                width: 180px; 
            }}
            pre {{ 
                white-space: pre-wrap; 
                word-wrap: break-word; 
                background:#fff3e0; 
                padding: 10px; 
                border-left: 5px solid #ff9800; 
                font-size: 0.8em;
                margin: 0;
            }}
          </style>
          <script>
            function toggleMenu() {{
              const menu = document.getElementById("extraMenu");
              menu.style.display = (menu.style.display === "block") ? "none" : "block";
            }}
            function toggle(id) {{
              const el = document.getElementById(id);
              const icon = document.getElementById('icon_' + id);
              if (el.style.display === "none" || el.style.display === "") {{
                el.style.display = "block";
                icon.textContent = "‚ñº";
              }} else {{
                el.style.display = "none";
                icon.textContent = "‚ñ∂";
              }}
            }}
            document.addEventListener("click", function(event) {{
              const menu = document.getElementById("extraMenu");
              if (!event.target.closest(".menu-button, #extraMenu")) {{
                menu.style.display = "none";
              }}
            }});
          </script>
        </head>
        <body>
          <header>
            <button class="menu-button" onclick="toggleMenu()">üõ†Ô∏è</button>
            <div id="extraMenu" class="nav-dropdown">
              <a href="/">üè† Aggiungi Operazione</a>
              <a href="/lista">üìà Gestione Movimenti Mese</a>
              <a href="/stats">üìä Bilancio Mese</a>
              <a href="/report_annuo">‚öñÔ∏è Report Annuale</a>
              <a href="/grafici_web">üìÖ Grafici e Statistiche</a>
              <a href="/menu_esplora">üîç Esplora</a>
              <a href="/gestione_categorie">‚öôÔ∏è Gestione Categorie</a>
              <a href="/utenze?anno={anno_corrente}">üíß Utenze</a>
              <a href="/documenti_pdf_web">üóÑÔ∏è Documenti PDF</a>
              <a href="/consultazione_supermercati">üõí Gestione Supermercati</a>
              <a href="/info_sys_web">üì° Monitor Server</a>
              <a href="/logoff">üîì Logout</a>
            </div>
            <div class="header-title">{emoji} {header_text}</div>
          </header>
          <main>
        """
        lista_id = "lista_spesa_contenuto"
        html += f"""
        <div class='section-title' style='margin-top: 0;' onclick="toggle('{lista_id}')">
            üìã ULTIMA LISTA: {file_visualizzato}
            <span id='icon_{lista_id}'>‚ñ∂</span>
        </div>
        """
        html += f"""
        <div id='{lista_id}' class='section-content' style='display: none;'>
        """
        if is_raw_content:
            raw_text = ultima_spesa_data[0]['raw_content']
            raw_text_safe = raw_text.replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;')
            html += f"""
            <pre>{raw_text_safe}</pre>
            """
        else:
            html += f"""
            <p>‚ùå <strong>Impossibile visualizzare la lista spesa.</strong></p>
            <p>Assicurati che ci sia almeno un file 'Lista_Spesa_....txt' nella cartella 'export'.</p>
            """
        html += "</div>"
        html += f"<div class='section-title' onclick=\"toggle('cataloghi_sezione')\">üõí Consultazione Cataloghi ({len(supermercati)}) <span id='icon_cataloghi_sezione'>‚ñ∂</span></div><div id='cataloghi_sezione' class='section-content' style='display: none;'>"

        if supermercati:
            for superm in supermercati:
                articoli = dati_supermercati.get(superm, [])
                superm_id = f"catalogo_{superm.lower().replace(' ', '_')}"
                html += f"""
                <div class='section-title' style='margin-top:10px;' onclick=\"toggle('{superm_id}')\">
                    {superm} ({len(articoli)} articoli) 
                    <span id='icon_{superm_id}'>‚ñ∂</span>
                </div>
                <div id='{superm_id}' class='section-content' style='padding:0; display: none;'>
                """ 
                if articoli:
                    #articoli_ordinati = sorted(articoli, key=lambda x: (x.get('categoria', ''), x.get('nome', '')))
                    articoli_ordinati = sorted(articoli, key=lambda x: x.get('nome', ''))
                    html += "<table><tr><th>Articolo</th><th>Descrizione</th><th>Categoria</th><th>Prezzo Normale (‚Ç¨)</th><th>Promo Attiva/Valore (‚Ç¨)</th></tr>"
                    for articolo in articoli_ordinati:
                        nome = articolo.get("nome", "N/D")
                        descrizione = articolo.get("descrizione", "N/D")
                        categoria = articolo.get("categoria", "Varie") 
                        prezzo_str = articolo.get("prezzo", "0.0")
                        prezzo_promo_str = articolo.get("prezzo_promo", "0.0")
                        promo_attiva = articolo.get("promo", False) 
                        try:
                            prezzo = float(prezzo_str)
                            prezzo_normale_fmt = f"{prezzo:.2f}"
                        except ValueError:
                            prezzo_normale_fmt = prezzo_str
                        try:
                            prezzo_promo = float(prezzo_promo_str)
                            prezzo_promo_fmt = f"{prezzo_promo:.2f}"
                        except ValueError:
                            prezzo_promo_fmt = prezzo_promo_str
                        prezzo_normale_colonna = prezzo_normale_fmt
                        promo_colonna = 'No'
                        if promo_attiva and prezzo_promo is not None and prezzo_promo > 0:
                            promo_colonna = f"<span class='promo'>{prezzo_promo_fmt}</span>"
                        html += f"""
                        <tr>
                            <td>{nome}</td>
                            <td>{descrizione}</td>
                            <td class='categoria'>{categoria}</td>
                            <td class='prezzo'>{prezzo_normale_colonna}</td>
                            <td class='prezzo'>{promo_colonna}</td>
                        </tr>
                        """
                    html += "</table>"
                else:
                    html += "<p style='padding:15px;'><i>Nessun articolo registrato per questo supermercato.</i></p>"
                html += "</div>"  
        else:
            html += "<p>‚ö†Ô∏è Il database dei cataloghi √® vuoto o non contiene supermercati registrati.</p>"
        html += "</div>" 
        html += f"""
            <a href="/" class="back">üè† Torna alla Home</a>
          </main>
        </body>
        </html>
        """
        return html
    
    # Ricerca Globale Web
    def pagina_menu_esplora(self):
        mesi_it_map = {
            "01": "Gennaio", "02": "Febbraio", "03": "Marzo",
            "04": "Aprile", "05": "Maggio", "06": "Giugno",
            "07": "Luglio", "08": "Agosto", "09": "Settembre",
            "10": "Ottobre", "11": "Novembre", "12": "Dicembre"
        }
        mesi = [f"{m:02d} - {mesi_it_map[f'{m:02d}']}" for m in range(1, 13)]
        categorie = sorted(set(self.categorie))
        anno_corrente = datetime.date.today().year
        anni = [str(anno) for anno in range(anno_corrente, anno_corrente - 6, -1)] 
        html_code = f"""
        <!DOCTYPE html>
        <html lang="it">
        <head>
            <meta charset='utf-8'>
            <title>üîé Esplorazione Avanzata</title>
            <meta name="viewport" content="width=device-width, initial-scale=1">
            <style>
                body {{
                    font-family: 'Segoe UI', sans-serif;
                    background-color: #f4f4f4;
                    padding: 0;
                    margin: 0;
                }}
                header {{ 
                    background: transparent; 
                    color: #000; 
                    padding: 15px 0; 
                    text-align: center; 
                    position: relative;
                    min-height: 40px;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                }}
                .header-title {{
                  font-size: 18px;
                  font-weight: 800;
                  color: #000000;
                  margin: 0;
                  white-space: nowrap;
                  text-align: center;
                }}
                .menu-button {{ 
                  position: absolute; 
                  top: 15px !important;
                  left: 15px !important;
                  font-size: 1.6em; 
                  line-height: 1;
                  background: none; 
                  border: none; 
                  color: black; 
                  cursor: pointer; 
                  padding: 0;
                  margin: 0;
                  z-index: 1000;
                }}
                .nav-dropdown {{ 
                    position: absolute; 
                    top: 55px; 
                    left: 10px; 
                    background: white; 
                    box-shadow: 0 4px 15px rgba(0,0,0,0.2); 
                    border-radius: 8px; 
                    display: none; 
                    z-index: 1000; 
                    width: 260px;
                    text-align: left;
                }}
                .nav-dropdown a {{ 
                    display: block; 
                    padding: 12px 18px; 
                    text-decoration: none; 
                    color: #333;
                    border-bottom: 1px solid #eee; 
                    font-size: 0.95em; 
                    font-family: 'Segoe UI', sans-serif;
                    font-weight: normal; 
                }}
                .nav-dropdown a:last-child {{
                    border-bottom: none;
                }}
                .nav-dropdown a:hover {{ 
                    background-color: #f8f9fa; 
                    color: #0078D4;
                }}
                main {{
                    padding: 20px;
                    max-width: 600px;
                    margin: auto;
                }}
                form {{
                    background: white;
                    padding: 20px;
                    border-radius: 10px;
                    box-shadow: 0 0 10px rgba(0,0,0,0.08);
                }}
                label {{
                    font-weight: bold;
                    display: block;
                    margin-top: 15px;
                    margin-bottom: 8px;
                    color: #333;
                    font-size: 0.95em;
                }}
                input[type="text"], input[type="number"], select {{
                    width: 100%;
                    padding: 12px; 
                    font-size: 1em;
                    border: 1px solid #ccc;
                    border-radius: 6px; 
                    box-sizing: border-box;
                    background-color: #fff;
                    transition: border-color 0.2s ease, box-shadow 0.2s ease;
                }}
                input[type="text"]:focus, input[type="number"]:focus, select:focus {{
                    outline: none;
                    border-color: #0078D4;
                    box-shadow: 0 0 0 2px rgba(0,120,212,0.2);
                }}
                button[type="submit"] {{
                    margin-top: 30px; 
                    width: 100%;
                    background: #0078D4;
                    color: white;
                    padding: 15px; 
                    font-size: 1.1em;
                    border: none;
                    border-radius: 8px; 
                    cursor: pointer;
                    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
                    transition: background-color 0.2s ease, box-shadow 0.2s ease;
                }}
                button[type="submit"]:hover {{
                    background: #005ea6;
                    box-shadow: 0 4px 10px rgba(0,0,0,0.15);
                }}
                .collapsible-container {{ 
                    margin-top: 25px;
                    border-top: 1px solid #eee; 
                    padding-top: 15px;
                }}
                .collapsible-toggle {{
                    background: none;
                    border: none;
                    font-size: 1.05em; 
                    color: #0078D4;
                    display: flex;
                    align-items: center;
                    gap: 8px; 
                    font-weight: bold;
                    cursor: pointer;
                    width: 100%; 
                    padding: 10px 0; 
                    box-sizing: border-box;
                    text-align: left;
                }}
                .collapsible-toggle:hover {{
                    color: #005ea6;
                }}
                .arrow {{
                    transition: transform 0.3s ease;
                }}
                .collapsible-open .arrow {{
                    transform: rotate(90deg);
                }}
                .collapsible-content {{
                    display: none;
                    margin-top: 10px;
                    padding-top: 10px;
                }}
                .collapsible-open .collapsible-content {{
                    display: block;
                }}
                .back-button {{ 
                    display: block;
                    text-align: center;
                    font-size: 1em;
                    text-decoration: none;
                    background: #0078D4;
                    color: white;
                    padding: 12px;
                    border-radius: 8px;
                    box-shadow: 0 4px 8px rgba(0,0,0,0.1);
                    margin: 20px auto 0 auto; 
                    width: 200px;
                    transition: background-color 0.2s ease, box-shadow 0.2s ease;
                }}
                .back-button:hover {{
                    background-color: #005ea6;
                    box-shadow: 0 6px 12px rgba(0,0,0,0.15);
                }}
                @media (max-width: 600px) {{
                    header {{
                        padding: 20px 0;
                    }}
                    .header-title {{
                        font-size: 1.3em;
                    }}
                    main {{
                        padding: 15px;
                    }}
                    form {{
                        padding: 15px;
                    }}
                    label {{
                        font-size: 0.9em;
                        margin-bottom: 5px;
                    }}
                    input, select, button {{
                        padding: 10px;
                        font-size: 0.95em;
                    }}
                    button[type="submit"] {{
                        margin-top: 25px;
                    }}
                    .back-button {{
                        width: 180px;
                        padding: 10px;
                        font-size: 0.95em;
                    }}
                    .collapsible-toggle {{
                        font-size: 1em;
                    }}
                }}
            </style>
            <script>
                function toggleMenu() {{
                    const menu = document.getElementById("extraMenu");
                    menu.style.display = (menu.style.display === "block") ? "none" : "block";
                }}
                document.addEventListener("click", function(event) {{
                    const menu = document.getElementById("extraMenu");
                    const isClickInside = event.target.closest(".menu-button, #extraMenu");
                    if (!isClickInside) {{
                        menu.style.display = "none";
                    }}
                }});
                function toggleCollapsible(button) {{
                    const container = button.parentNode;
                    container.classList.toggle('collapsible-open');
                }}
            </script>
        </head>
        <body>
            <header>
                <button class="menu-button" onclick="toggleMenu()">üõ†Ô∏è</button>
                <div id="extraMenu" class="nav-dropdown">
                    <a href="/">üè† Aggiungi Operazione</a>
                    <a href="/lista">üìà Gestione Movimenti Mese</a>
                    <a href="/stats">üìä Bilancio Mese</a>
                    <a href="/report_annuo">‚öñÔ∏è Report Annuale</a>
                    <a href="/grafici_web">üìÖ Grafici e Statistiche</a>
                    <a href="/menu_esplora">üîç Esplora</a>
                    <a href="/gestione_categorie">‚öôÔ∏è Gestione Categorie</a>
                    <a href="/utenze?anno={datetime.date.today().year}">üíß Utenze</a>
                    <a href="/documenti_pdf_web">üóÑÔ∏è Documenti PDF</a>
                    <a href="/consultazione_supermercati">üõí Gestione Supermercati</a>
                    <a href="/info_sys_web">üì° Monitor Server</a>
                    <a href="/logoff">üîì Logout</a>
                </div>
                <div class="header-title">üîé Esplorazione Avanzata</div>
            </header>
            <main>
                <form method='get' action='/cerca_avanzata'>
                    <label for='categoria'>Categoria:</label>
                    <select name='categoria'>
                        <option value=''>-- Qualsiasi --</option>
                        {''.join(f"<option value='{html.escape(str(cat))}'>{html.escape(str(cat))}</option>" for cat in categorie)}
                    </select>
                    <label for='tipo'>Tipo:</label>
                    <select name='tipo'>
                        <option value=''>-- Qualsiasi --</option>
                        <option value='Entrata'>Entrata</option>
                        <option value='Uscita'>Uscita</option>
                    </select>
                    <label for='anno'>Anno:</label>
                    <select name='anno'>
                        <option value=''>-- Tutti --</option>
                        {''.join(f"<option value='{html.escape(a)}'>{html.escape(a)}</option>" for a in anni)}
                    </select>
                    <label for='mese'>Mese:</label>
                    <select name='mese'>
                        <option value=''>-- Tutti --</option>
                        {''.join(f"<option value='{m.split(' - ')[0]}'>{m}</option>" for m in mesi)}
                    </select>
                    <div class="collapsible-container">
                        <button type="button" class="collapsible-toggle" onclick="toggleCollapsible(this)">
                            <span class="arrow">‚ñ∂Ô∏è</span> Filtri aggiuntivi
                        </button>
                        <div class="collapsible-content">
                            <label for='min_importo'>Importo minimo (‚Ç¨):</label>
                            <input type='number' name='min_importo' step='0.01' placeholder='es: 10.50'>
                            <label for='max_importo'>Importo massimo (‚Ç¨):</label>
                            <input type='number' name='max_importo' step='0.01' placeholder='es: 100.00'>
                            <label for='q'>Testo libero (descrizione):</label>
                            <input type='text' name='q' placeholder='es: pane, bolletta, abbonamento'>
                        </div>
                    </div>
                    <button type='submit'>üîç Avvia Esplorazione</button>
                </form>
                <a href="/" class="back-button">üè† Torna alla Home</a>
            </main>
        </body>
        </html>
        """
        return html_code
    
    # Gestione Categorie Web
    def add_categoria_web(self, params):
        nome = params.get("nome_categoria", [""])[0].strip()
        tipo = params.get("tipo_categoria", ["Uscita"])[0]
        if not nome or nome in self.categorie or nome == self.CATEGORIA_RIMOSSA:
            print(f"Errore: Categoria '{nome}' gi√† esistente o non valida.")
            return self.html_gestione_categorie()
        self.categorie.append(nome)
        self.categorie_tipi[nome] = tipo
        self.categorie.sort()
        self.save_db()
        self.refresh_categorie_web()
    def modifica_categoria_web(self, params):
        old_nome = params.get("categoria_selezionata", [""])[0]
        new_nome = params.get("nuovo_nome", [""])[0].strip()
        nuovo_tipo = params.get("nuovo_tipo", ["Uscita"])[0]
        if not old_nome or old_nome == "Generica":
            return
        if new_nome == old_nome:
            self.categorie_tipi[new_nome] = nuovo_tipo
        else:
            if not new_nome or new_nome in self.categorie:
                return 
            idx = self.categorie.index(old_nome)
            self.categorie[idx] = new_nome
            self.categorie_tipi[new_nome] = nuovo_tipo
            self.categorie_tipi.pop(old_nome, None)
            for d in self.spese:
                new_entries = []
                for entry in self.spese[d]:
                    if entry[0] == old_nome:
                        entry = (new_nome,) + entry[1:]
                    new_entries.append(entry)
                self.spese[d] = new_entries
            self.categorie.sort()
        self.save_db()
        self.refresh_categorie_web()

    def cancella_categoria_web(self, params):
        cat_da_cancellare = params.get("categoria_selezionata", [""])[0]
        if not cat_da_cancellare or cat_da_cancellare not in self.categorie or cat_da_cancellare == "Generica":
            return
        self.categorie.remove(cat_da_cancellare)
        self.categorie_tipi.pop(cat_da_cancellare, None)
        for d in self.spese:
            new_entries = []
            for entry in self.spese[d]:
                if entry[0] == cat_da_cancellare:
                    entry = (self.CATEGORIA_RIMOSSA,) + entry[1:]
                new_entries.append(entry)
            self.spese[d] = new_entries
        self.save_db()
        self.refresh_categorie_web()

    def refresh_categorie_web(self):
        self.after(100, self._esegui_aggiornamento_gui)
                        
    def _esegui_aggiornamento_gui(self):
        try:
            self.load_db()
            if hasattr(self, 'aggiorna_combobox_categorie'):
                try:
                    self.aggiorna_combobox_categorie()
                except Exception:
                    pass
            if hasattr(self, 'carica_voci_treeview'):
                try:
                    self.carica_voci_treeview()
                except Exception:
                    pass
            if hasattr(self, 'ricorrenza_popup') and self.ricorrenza_popup.winfo_exists():
                if hasattr(self, 'ric_cat_menu'):
                    self.ric_cat_menu['values'] = sorted(self.categorie)
            if hasattr(self, 'refresh_gui'):
                try:
                    self.refresh_gui()
                except Exception:
                    pass
            print("üîÑ GUI: Aggiornamento completato (anche in background).")
        except Exception as e:
            print(f"‚ö†Ô∏è Nota: Aggiornamento grafico parziale (app iconizzata o occupata): {e}")
                 
    def html_gestione_categorie(self):
        import datetime
        categorie_tipi_js = str(self.categorie_tipi).replace("'", '"')
        categorie_options = "".join(
            f"<option value='{cat}'>{cat}</option>" 
            for cat in sorted(self.categorie, key=lambda x: x.strip().lower())
        )
        anno_corrente = datetime.datetime.now().year
        html = f"""
        <!DOCTYPE html>
        <html>
        <head>
            <meta charset="utf-8">
            <title>üìù Gestione Categorie</title>
            <meta name="viewport" content="width=device-width, initial-scale=1">
            <style>
                body {{
                    margin: 0;
                    font-family: 'Segoe UI', sans-serif;
                    background-color: #f4f4f4;
                }}
                header {{ 
                    background: transparent; 
                    color: #000; 
                    padding: 15px 0; 
                    text-align: center; 
                    position: relative;
                    min-height: 40px;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                }}
                .header-title {{
                  font-size: 18px;
                  font-weight: 800;
                  color: #000000;
                  margin: 0;
                  white-space: nowrap;
                  text-align: center;
                }}
                .menu-button {{ 
                  position: absolute; 
                  top: 15px !important;
                  left: 15px !important;
                  font-size: 1.6em; 
                  line-height: 1;
                  background: none; 
                  border: none; 
                  color: black; 
                  cursor: pointer; 
                  padding: 0;
                  margin: 0;
                  z-index: 1000;
                }}
                .nav-dropdown {{ 
                    position: absolute; 
                    top: 55px; 
                    left: 10px; 
                    background: white; 
                    box-shadow: 0 4px 15px rgba(0,0,0,0.2); 
                    border-radius: 8px; 
                    display: none; 
                    z-index: 1000; 
                    width: 260px;
                    text-align: left;
                }}
                .nav-dropdown a {{ 
                    display: block; 
                    padding: 12px 18px; 
                    text-decoration: none; 
                    color: #333;
                    border-bottom: 1px solid #eee; 
                    font-size: 0.95em; 
                    font-family: 'Segoe UI', sans-serif;
                    font-weight: normal; 
                }}
                .nav-dropdown a:last-child {{
                    border-bottom: none;
                }}
                .nav-dropdown a:hover {{ 
                    background-color: #f8f9fa; 
                    color: #0078D4;
                }}
                main {{
                    padding: 10px;
                    max-width: 400px;
                    margin: auto;
                }}
                .category-box {{
                    background: white;
                    padding: 15px 20px;
                    margin-bottom: 15px;
                    border-radius: 8px;
                    box-shadow: 0 0 8px rgba(0,0,0,0.05);
                }}
                details summary {{
                    cursor: pointer;
                    list-style: none;
                    padding: 5px 0;
                }}
                details summary::-webkit-details-marker {{
                    display: none;
                }}
                details summary:before {{
                    content: '‚ñ∂Ô∏è'; 
                    margin-right: 10px;
                    transition: transform 0.2s;
                }}
                details[open] summary:before {{
                    content: 'üîΩ'; 
                    transform: rotate(90deg);
                }}
                label {{
                    display: block;
                    margin-top: 10px;
                    font-weight: bold;
                    font-size: 0.9em;
                }}
                input[type="text"], select {{
                    width: 100%;
                    padding: 8px;
                    margin-top: 5px;
                    margin-bottom: 12px;
                    border: 1px solid #ccc;
                    border-radius: 4px;
                    box-sizing: border-box;
                    font-size: 0.9em;
                }}
                button[type="submit"] {{
                    background-color: #0078D4;
                    color: white;
                    border: none;
                    cursor: pointer;
                    font-size: 0.9em;
                    border-radius: 6px;
                    padding: 10px;
                    margin-top: 10px;
                    display: inline-block;
                    width: auto;
                }}
                button[type="submit"]:hover {{
                    background-color: #005ea6;
                }}
                .delete-button {{
                    background-color: #c43b2e;
                }}
                .delete-button:hover {{
                    background-color: #9c2e25;
                }}
            </style>
            <script>
                const CategorieTipi = {categorie_tipi_js};

                function toggleMenu() {{
                    const menu = document.getElementById("extraMenu");
                    menu.style.display = (menu.style.display === "block") ? "none" : "block";
                }}
                function aggiornaTipoCategoria() {{
                    const selector = document.getElementById("categoria_modifica");
                    const tipoSelect = document.getElementById("nuovo_tipo");
                    const selectedCat = selector.value;
                    
                    if (selectedCat && CategorieTipi[selectedCat]) {{
                        const tipoCorrente = CategorieTipi[selectedCat];
                        tipoSelect.value = tipoCorrente;
                    }} else {{
                        tipoSelect.value = 'Uscita';
                    }}
                }}
                document.addEventListener("click", function(event) {{
                    const menu = document.getElementById("extraMenu");
                    const isClickInside = event.target.closest(".menu-button, #extraMenu");
                    if (!isClickInside) {{
                        menu.style.display = "none";
                    }}
                }});
                document.addEventListener("DOMContentLoaded", function() {{
                    const categoriaModifica = document.getElementById("categoria_modifica");
                    if (categoriaModifica) {{
                        categoriaModifica.addEventListener("change", aggiornaTipoCategoria);
                        if (categoriaModifica.value) {{ 
                           aggiornaTipoCategoria();
                        }}
                    }}
                }});
            </script>
        </head>
        <body>
            <header>
                <button class="menu-button" onclick="toggleMenu()">üõ†Ô∏è</button>
                <div id="extraMenu" class="nav-dropdown">
                    <a href="/">üè† Aggiungi Operazione</a>
                    <a href="/lista">üìà Gestione Movimenti Mese</a>
                    <a href="/stats">üìä Bilancio Mese</a>
                    <a href="/report_annuo">‚öñÔ∏è Report Annuale</a>
                    <a href="/grafici_web">üìÖ Grafici e Statistiche</a>
                    <a href="/menu_esplora">üîç Esplora</a>
                    <a href="/gestione_categorie">‚öôÔ∏è Gestione Categorie</a>
                    <a href="/utenze?anno={anno_corrente}">üíß Utenze</a>
                    <a href="/documenti_pdf_web">üóÑÔ∏è Documenti PDF</a>
                    <a href="/consultazione_supermercati">üõí Gestione Supermercati</a>
                    <a href="/info_sys_web">üì° Monitor Server</a>
                    <a href="/logoff">üîì Logout</a>
                </div>
                <div class="header-title">‚öôÔ∏è Gestione Categorie</div>
            </header>
            <main>
                <details class="category-box">
                    <summary style="font-size: 1.1em; font-weight: bold; color: #0078D4;">
                        ‚ûï Aggiungi Categoria
                    </summary>
                    <form action="/salva_categoria" method="POST">
                        <input type="hidden" name="operazione" value="aggiungi">
                        <label for="nome_categoria">Nome:</label>
                        <input type="text" name="nome_categoria" required>
                        <label for="tipo_categoria">Tipo:</label>
                        <select name="tipo_categoria">
                            <option value="Uscita">Uscita</option>
                            <option value="Entrata">Entrata</option>
                        </select>
                        <button type="submit">‚ûï Aggiungi</button>
                    </form>
                </details>
                <details class="category-box">
                    <summary style="font-size: 1.1em; font-weight: bold; color: #0078D4;">
                        ‚öôÔ∏è Modifica Categoria
                    </summary>
                    <form action="/salva_categoria" method="POST">
                        <input type="hidden" name="operazione" value="modifica">
                        <label for="categoria_selezionata">Seleziona:</label>
                        <select 
                            name="categoria_selezionata" 
                            id="categoria_modifica" 
                            required
                        >
                            {categorie_options} 
                        </select>
                        <label for="nuovo_nome">Nuovo Nome:</label>
                        <input type="text" name="nuovo_nome" placeholder="Lascia vuoto per modificare solo il tipo">
                        <label for="nuovo_tipo">Nuovo Tipo:</label>
                        <select name="nuovo_tipo" id="nuovo_tipo">
                            <option value="Uscita">Uscita</option>
                            <option value="Entrata">Entrata</option>
                        </select>
                        <button type="submit">‚öôÔ∏è Modifica</button>
                    </form>
                </details>
                <details class="category-box" style="border: 1px solid #c43b2e;">
                    <summary style="font-size: 1.1em; font-weight: bold; color: #c43b2e;">
                        ‚ùå Cancella Categoria
                    </summary>
                    <form/utenzerm action="/cancella_categoria" method="POST">
                        <label for="categoria_selezionata">Seleziona:</label>
                        <select name="categoria_selezionata" required>
                            {categorie_options}
                        </select>
                        <button type="submit" class="delete-button">‚ùå Cancella</button>
                    </form>
                </details>
                <div style="background-color: #0078D4; text-align: center; margin-top: 20px; padding: 10px; border-radius: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.1);">
                    <a href='/' style='font-size:0.9em; text-decoration:none; color:white; display: block; font-weight: bold;'>
                        üè† Torna alla Home
                    </a>
                </div>
            </main>
        </body>
        </html>
        """
        return html

    # Grafici Web
    def get_dati_entrate_uscite_tutti_gli_anni_json(self):
        totali_annuali = {}
        for giorno, voci in self.spese.items():
            try:
                anno = giorno.year
            except AttributeError:
                continue 
            if anno not in totali_annuali:
                totali_annuali[anno] = {'Entrate': 0.0, 'Uscite': 0.0}
            for voce in voci:
                if len(voce) < 4: continue
                raw_importo = voce[2]
                tipo = voce[3] 
                try:
                    importo_str = str(raw_importo).strip().replace(',', '.')
                    importo = float(importo_str)
                except (TypeError, ValueError):
                    continue 
                if tipo == "Entrata":
                    totali_annuali[anno]['Entrate'] += importo
                elif tipo == "Uscita":
                    totali_annuali[anno]['Uscite'] += importo
        anni_ordinati = sorted(totali_annuali.keys()) 
        data_entrate = [totali_annuali[anno]['Entrate'] for anno in anni_ordinati]
        data_uscite = [totali_annuali[anno]['Uscite'] for anno in anni_ordinati]
        dati_json = {
            "labels": [str(anno) for anno in anni_ordinati],
            "datasets": [
                {
                    "label": "Entrate",
                    "data": data_entrate,
                    "backgroundColor": "rgba(40, 167, 69, 0.7)"
                },
                {
                    "label": "Uscite",
                    "data": data_uscite,
                    "backgroundColor": "rgba(220, 53, 69, 0.7)"
                }
            ]
        }
        return json.dumps(dati_json)

    def pagina_statistiche_annuali_web(self):
        oggi = datetime.date.today()
        anno_corrente = oggi.year
        anno_corrente_int = anno_corrente
        oggi_formattata = oggi.strftime('%d/%m/%Y')
        anno_corrente_format = str(anno_corrente)
        try:
            raw = self.calcola_statistiche_annuali_pura().strip()
            report_content = raw.replace("\n", "<br>")
            report_content = report_content.replace("üîπ Mese corrente", "<strong><span style='color:#c43b2e;'>üóìÔ∏è Mese corrente</span></strong>")
            report_content = report_content.replace("üîπ Da inizio anno", "<strong><span style='color:#d48300;'>üìÜ Da inizio anno</span></strong>")
            report_content = report_content.replace("üîπ Proiezione fine anno", "<strong><span style='color:#0078D4;'>üìä Proiezione fine anno</span></strong>")
            report_content = report_content.replace("‚úì Risparmio previsto", "<strong><span style='color:green;'>üí∞ Risparmio previsto</span></strong>")
            report_content = report_content.replace("‚ö†Ô∏è Possibile extra spesa", "<strong><span style='color:red;'>üìâ Possibile extra spesa</span></strong>")
        except Exception as e:
            report_content = f"‚ö† Errore nel caricamento dei dati: {str(e)}"
        html_template = f"""
        <!DOCTYPE html>
        <html>
        <head>
            <meta charset="utf-8">
            <title>üìä Bilancio Previsionale ‚Äî {oggi_formattata}</title>
            <meta name="viewport" content="width=device-width, initial-scale=1">
            <style>
                body {{ margin: 0; font-family: 'Segoe UI', Tahoma, sans-serif; background-color: #f4f4f4; color: #333; }}
                header {{ 
                    background: transparent; 
                    color: #000; 
                    padding: 15px 0; 
                    text-align: center; 
                    position: relative;
                    min-height: 40px;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                }}
                .header-title {{
                  font-size: 18px;
                  font-weight: 800;
                  color: #000000;
                  margin: 0;
                  white-space: nowrap;
                  text-align: center;
                }}
                .menu-button {{ 
                  position: absolute; 
                  top: 15px !important;
                  left: 15px !important;
                  font-size: 1.6em !important; 
                  line-height: 1;
                  background: none; 
                  border: none; 
                  color: black; 
                  cursor: pointer; 
                  padding: 0;
                  margin: 0;
                  z-index: 1000;
                }}
                .nav-dropdown {{ 
                    position: absolute; 
                    top: 55px; 
                    left: 10px; 
                    background: white; 
                    box-shadow: 0 4px 15px rgba(0,0,0,0.2); 
                    border-radius: 8px; 
                    display: none; 
                    z-index: 1000; 
                    width: 260px;
                    text-align: left;
                }}
                .nav-dropdown a {{ 
                    display: block; 
                    padding: 12px 18px; 
                    text-decoration: none; 
                    color: #333;
                    border-bottom: 1px solid #eee; 
                    font-size: 0.95em; 
                    font-family: 'Segoe UI', sans-serif;
                    font-weight: normal; 
                }}
                .nav-dropdown a:last-child {{
                    border-bottom: none;
                }}
                .nav-dropdown a:hover {{ 
                    background-color: #f8f9fa; 
                    color: #0078D4;
                }}
                main {{ padding: 20px; max-width: 600px; margin: auto; }}
                .report-box {{ 
                    background: white; 
                    padding: 20px; 
                    border-radius: 12px; 
                    box-shadow: 0 2px 10px rgba(0,0,0,0.1); 
                    line-height: 1.5; 
                    font-size: 0.95em;
                    color: #444;
                    white-space: pre-wrap;
                }}
                .back-btn {{ 
                    display: block; text-align: center; background: #0078D4; 
                    color: white; padding: 12px; border-radius: 6px; 
                    text-decoration: none; margin: 20px auto; width: 200px; font-weight: bold; 
                }}
            </style>
            <script>
                function toggleMenu() {{
                    const menu = document.getElementById("extraMenu");
                    menu.style.display = (menu.style.display === "block") ? "none" : "block";
                }}
                document.addEventListener("click", function(event) {{
                    const menu = document.getElementById("extraMenu");
                    const btn = document.querySelector(".menu-button");
                    if (menu.style.display === "block" && !menu.contains(event.target) && event.target !== btn) {{
                        menu.style.display = "none";
                    }}
                }});
            </script>
        </head>
        <body>
            <header>
                <button class="menu-button" onclick="toggleMenu()">üõ†Ô∏è</button>
                <div id="extraMenu" class="nav-dropdown">
                    <a href="/">üè† Aggiungi Operazione</a>
                    <a href="/lista">üìà Gestione Movimenti Mese</a>
                    <a href="/stats">üìä Bilancio Mese</a>
                    <a href="/report_annuo">‚öñÔ∏è Report Annuale</a>
                    <a href="/grafici_web">üìÖ Grafici e Statistiche</a>
                    <a href="/menu_esplora">üîç Esplora</a>
                    <a href="/gestione_categorie">‚öôÔ∏è Gestione Categorie</a>
                    <a href="/utenze?anno={anno_corrente}">üíß Utenze</a>
                    <a href="/documenti_pdf_web">üóÑÔ∏è Documenti PDF</a>
                    <a href="/consultazione_supermercati">üõí Gestione Supermercati</a>
                    <a href="/info_sys_web">üì° Monitor Server</a>
                    <a href="/logoff">üîì Logout</a>
                </div>
                <div class="header-title">üìä Report del {oggi_formattata}</div>
            </header>
            <main>
                <div class="report-box">{report_content}</div>
                <a href="/" class="back-btn">üè† Torna alla Home</a>
            </main>
        </body>
        </html>
        """
        return html_template

    def pagina_grafici_web(self):
        oggi = datetime.date.today()
        anno_corrente = oggi.year
        anno_corrente_int = anno_corrente
        oggi_formattata = oggi.strftime('%d/%m/%Y')
        anno_corrente_format = str(anno_corrente)
        report_content = "" 
        report_summary_html = ""
        totale_entrate = None
        totale_uscite = None
        fallback_storico = '{"labels": ["N/D"], "datasets": [{"label": "Dati non caricati", "data": [0], "backgroundColor": ["#ccc"]}]}'
        fallback_mensile = '{"labels": ["N/D"], "datasets": [{"label": "Dati non caricati", "data": [0], "backgroundColor": ["#ccc"]}]}'
        fallback_cat = '{"labels": ["N/D"], "datasets": [{"data": [1], "backgroundColor": ["#ccc"], "label": "Dati non caricati"}]}'
        fallback_saldo = '{"labels": ["N/D"], "datasets": [{"label": "Dati non caricati", "data": [0], "borderColor": "#ccc"}]}'
        fallback_cat_storico = '{"labels": ["N/D"], "datasets": [{"data": [1], "backgroundColor": ["#ccc"], "label": "Dati non caricati"}]}'
        fallback_saldo_annuale = '{"labels": ["N/D"], "datasets": [{"label": "Dati non caricati", "data": [0], "borderColor": "#ccc", "backgroundColor": ["#ccc"]}]}'
        try:
            dati_entrate_uscite_storici = self.get_dati_entrate_uscite_tutti_gli_anni_json()
        except Exception:
            dati_entrate_uscite_storici = fallback_storico
        try:
            dati_entrate_uscite_mensili = self.get_dati_entrate_uscite_json()
        except Exception:
            dati_entrate_uscite_mensili = fallback_mensile
        try:
            dati_categorie = self.get_dati_categorie_json()
        except Exception:
            dati_categorie = fallback_cat
        try:
            dati_saldo = self.get_dati_saldo_json()
        except Exception:
            dati_saldo = fallback_saldo
        try:
            dati_categorie_storiche = self.get_dati_categorie_storiche_json()
        except Exception as e:
            dati_categorie_storiche = fallback_cat_storico
        try:
            dati_saldo_annuale = self.get_dati_saldo_annuale_json()
        except Exception:
            dati_saldo_annuale = fallback_saldo_annuale
        try:
            data_storico = json.loads(dati_entrate_uscite_storici)
            totale_eu_storico_str = "Dati Non Trovati"
            if data_storico.get("datasets") and len(data_storico["datasets"]) == 2:
                entrate_storiche = sum(data_storico["datasets"][0].get("data", [0]))
                uscite_storiche = sum(data_storico["datasets"][1].get("data", [0]))
                saldo_storico = entrate_storiche - uscite_storiche
                totale_eu_storico_str = f"Entrate: {entrate_storiche:,.2f} | Uscite: {uscite_storiche:,.2f} | Saldo: {saldo_storico:,.2f}"
        except:
            totale_eu_storico_str = "Errore di calcolo"
        try:
            data_mensile = json.loads(dati_entrate_uscite_mensili)
            totale_eu_mensile_str = "Dati Non Trovati"
            if data_mensile.get("datasets") and len(data_mensile["datasets"]) == 2:
                entrate_mensili = sum(data_mensile["datasets"][0].get("data", [0]))
                uscite_mensili = sum(data_mensile["datasets"][1].get("data", [0]))
                saldo_mensile = entrate_mensili - uscite_mensili
                totale_eu_mensile_str = f"Entrate: {entrate_mensili:,.2f} | Uscite: {uscite_mensili:,.2f} | Saldo: {saldo_mensile:,.2f}"
        except:
            totale_eu_mensile_str = "Errore di calcolo"
        try:
            data_saldo = json.loads(dati_saldo)
            saldo_finale_str = "Dati Non Trovati"
            if data_saldo.get("datasets") and data_saldo["datasets"][0].get("data"):
                saldo_finale = data_saldo["datasets"][0]["data"][-1]
                saldo_finale_str = f"Saldo Finale: {saldo_finale:,.2f}"
        except:
            saldo_finale_str = "Errore di calcolo"
        try:
            data_saldo_annuale = json.loads(dati_saldo_annuale)
            totale_saldo_annuale_str = "Dati Non Trovati"
            if data_saldo_annuale.get("datasets") and data_saldo_annuale["datasets"][0].get("data"):
                somma_saldi = sum(data_saldo_annuale["datasets"][0]["data"])
                totale_saldo_annuale_str = f"Saldo Cumulativo: {somma_saldi:,.2f}"
        except:
            totale_saldo_annuale_str = "Errore di calcolo"
        html_template = f"""
        <!DOCTYPE html>
        <html>
        <head>
            <meta charset="utf-8">
            <title>üìä Grafici e Statistiche</title>
            <meta name="viewport" content="width=device-width, initial-scale=1">
            <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
            <style>
                body {{
                    margin: 0;
                    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                    background-color: #f4f4f4;
                    font-size: 0.9em;
                }}
                header {{ 
                    background: transparent; 
                    color: #000; 
                    padding: 15px 0; 
                    text-align: center; 
                    position: relative;
                    min-height: 40px;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                }}
                .header-title {{
                  font-size: 18px;
                  font-weight: 800;
                  color: #000000;
                  margin: 0;
                  white-space: nowrap;
                  text-align: center;
                }}
                .menu-button {{ 
                  position: absolute; 
                  top: 15px !important;
                  left: 15px !important;
                  font-size: 1.8em !important; 
                  line-height: 1;
                  background: none; 
                  border: none; 
                  color: black; 
                  cursor: pointer; 
                  padding: 0;
                  margin: 0;
                  z-index: 1000;
                }}
                .nav-dropdown {{ 
                    position: absolute; 
                    top: 55px; 
                    left: 10px; 
                    background: white; 
                    box-shadow: 0 4px 15px rgba(0,0,0,0.2); 
                    border-radius: 8px; 
                    display: none; 
                    z-index: 1000; 
                    width: 260px;
                    text-align: left;
                }}
                .nav-dropdown a {{ 
                    display: block; 
                    padding: 12px 18px; 
                    text-decoration: none; 
                    color: #333;
                    border-bottom: 1px solid #eee; 
                    font-size: 0.95em; 
                    font-family: 'Segoe UI', sans-serif;
                    font-weight: normal; 
                }}
                .nav-dropdown a:last-child {{
                    border-bottom: none;
                }}
                .nav-dropdown a:hover {{ 
                    background-color: #f8f9fa; 
                    color: #0078D4;
                }}
                main {{
                   padding-top: 0 !important;
                   margin-top: 0 !important;
               }}
                .report-box {{ background: white; padding: 20px; border-radius: 8px; box-shadow: 0 0 8px rgba(0,0,0,0.1); white-space: pre-wrap; word-break: break-word; font-size: 1em; line-height: 1.5em; font-weight: bold; }}
                .back {{ display: block; text-align: center; font-size: 1em; text-decoration: none; background: #0078D4; color: white; padding: 10px; border-radius: 4px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); margin: 20px auto; width: 200px; }}
                .back:hover {{ background-color: #005ea6; }}
                .accordion-header {{ 
                    background: #0078D4;
                    color: white;
                    padding: 15px; 
                    border-radius: 6px; 
                    cursor: pointer; 
                    margin-top: 20px; 
                    display: flex; 
                    justify-content: space-between; 
                    align-items: center; 
                    font-size: 1.1em; 
                    font-weight: bold; 
                }}
                .accordion-header:hover {{ 
                    background: #005ea6;
                }}
                .arrow {{ 
                    transition: transform 0.3s ease; 
                    font-size: 1.2em; 
                    color: white;
                }} 
                .accordion-header.active .arrow {{ transform: rotate(90deg); }}
                .accordion-content {{
                    padding: 0 15px;
                    border: 1px solid #ddd;
                    border-top: none;
                    border-radius: 0 0 8px 8px;
                    background: white;
                }}
                .tab-pane {{ padding-top: 15px; display: none; }}
                .tab-pane.active {{ display: block; }}
                .tab-container {{ 
                    display: flex; 
                    flex-wrap: wrap;
                    justify-content: center;
                    padding: 0;
                }}
                .tab-button {{ 
                    padding: 8px 10px;
                    cursor: pointer; 
                    font-weight: bold; 
                    color: #555; 
                    border: none; 
                    background: #f0f0f0; 
                    border-radius: 5px 5px 0 0; 
                    margin-right: 2px; 
                    margin-bottom: 5px;
                    font-size: 0.9em;
                }}
                .tab-button.active {{ background: #0078D4; color: white; }}
                .chart-container {{
                    position: relative;
                    width: 100%;
                    margin: auto;
                }}
                .bar-chart-container {{
                    min-height: 500px; 
                    height: 50vh; 
                    max-height: 600px;
                }}
                #tabCategorie .chart-container,
                #tabStoricoCat .chart-container {{
                    height: 650px; 
                    max-height: 90vh; 
                    display: flex; 
                    flex-direction: column;
                    padding-top: 0px;
                }}
                .chart-container canvas {{
                    max-width: 95%; 
                    height: auto !important; 
                    display: block;
                    margin: 0 auto;
                    flex-grow: 1;
                }}
           </style>
            <script>
                const currentYear = {anno_corrente_int};
                const chartInstances = {{}}; 
                window.CATEGORIE_DATA = null;
                window.CATEGORIE_STORICHE_DATA = null;
                window.DATA_SALDO_ANNUALE = JSON.parse('{dati_saldo_annuale}');
        
                const TOTALI = {{
                    STORICO_EU: "{totale_eu_storico_str}",
                    MENSILE_EU: "{totale_eu_mensile_str}",
                    SALDO: "{saldo_finale_str}",
                    SALDO_ANNUALE: "{totale_saldo_annuale_str}"
                }};

                function createChart(id, type, data, options) {{
                    if (chartInstances[id] && typeof chartInstances[id].destroy === 'function') {{
                        chartInstances[id].destroy(); 
                    }}
                    const ctx = document.getElementById(id);
                    if (ctx) {{
                        chartInstances[id] = new Chart(ctx, {{ type, data, options }});
                        return true;
                    }}
                    return false;
                }}
                function drawCharts() {{
                    const dataCategorie = JSON.parse('{dati_categorie}');
                    if (dataCategorie && dataCategorie.labels && dataCategorie.datasets && dataCategorie.datasets.length > 0) {{
                        const combinedData = dataCategorie.labels.map((label, index) => ({{
                            label: label,
                            data: dataCategorie.datasets[0].data[index],
                            backgroundColor: dataCategorie.datasets[0].backgroundColor[index]
                        }}));
                        combinedData.sort((a, b) => a.label.localeCompare(b.label));
                        dataCategorie.labels = combinedData.map(item => item.label);
                        dataCategorie.datasets[0].data = combinedData.map(item => item.data);
                        dataCategorie.datasets[0].backgroundColor = combinedData.map(item => item.backgroundColor);
                        dataCategorie.total = combinedData.reduce((sum, item) => sum + item.data, 0);
                    }}
                    window.CATEGORIE_DATA = dataCategorie; 
                    const dataCategorieStoriche = JSON.parse('{dati_categorie_storiche}');
                    if (dataCategorieStoriche && dataCategorieStoriche.labels && dataCategorieStoriche.datasets &&         dataCategorieStoriche.datasets.length > 0) {{
                        const combinedData = dataCategorieStoriche.labels.map((label, index) => ({{
                            label: label,
                            data: dataCategorieStoriche.datasets[0].data[index],
                            backgroundColor: dataCategorieStoriche.datasets[0].backgroundColor[index]
                        }}));
                        dataCategorieStoriche.total = combinedData.reduce((sum, item) => sum + item.data, 0);
                    }}
                    window.CATEGORIE_STORICHE_DATA = dataCategorieStoriche;
                }}
                function toggleMenu() {{
                    const menu = document.getElementById("extraMenu");
                    menu.style.display = (menu.style.display === "block") ? "none" : "block";
                }}
        
                document.addEventListener("click", function(event) {{
                    const menu = document.getElementById("extraMenu");
                    if (!event.target.closest(".menu-button, #extraMenu")) {{
                        menu.style.display = "none";
                    }}
                }});
                function toggleAccordion(header) {{
                    header.classList.toggle("active");
                    const content = header.nextElementSibling;
                    const isOpening = content.style.display === "none" || content.style.display === "";
                    content.style.display = isOpening ? "block" : "none";
                    if (isOpening) {{
                        const activeTabButton = document.querySelector('.tab-button.active');
                        if (activeTabButton) {{
                            const tabName = activeTabButton.getAttribute('onclick').match(/'([^']+)'/)[1];
                            drawSpecificChart(tabName);
                        }}
                    }}
               }}
                function openTab(tabName, button) {{
                    document.querySelectorAll(".tab-pane").forEach(el => el.classList.remove("active"));
                    document.querySelectorAll(".tab-button").forEach(el => el.classList.remove("active"));
                    document.getElementById(tabName).classList.add("active");
                    button.classList.add("active");
                    drawSpecificChart(tabName);
                }}
                function drawSpecificChart(tabName) {{
                    const dataEntrateUsciteStorici = JSON.parse('{dati_entrate_uscite_storici}');
                    const dataEntrateUsciteMensili = JSON.parse('{dati_entrate_uscite_mensili}');
                    const dataSaldo = JSON.parse('{dati_saldo}');
                    const dataCategorie = window.CATEGORIE_DATA;
                    const dataCategorieStoriche = window.CATEGORIE_STORICHE_DATA;
                    const dataSaldoAnnuale = window.DATA_SALDO_ANNUALE;
                    let success = false;
                    const formatCurrency = (amount) => amount.toLocaleString('it-IT', {{ style: 'currency', currency: 'EUR' }});
                    const barOptions = {{
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {{
                            title: {{ display: true }}
                        }},
                        barPercentage: 0.9,      
                        categoryPercentage: 0.9  
                    }};
                    const pieOptions = {{
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {{
                            title: {{ display: true }}, 
                            legend: {{ 
                                display: true, 
                                position: 'bottom', 
                                align: 'start', 
                                labels: {{ usePointStyle: false, boxWidth: 20, padding: 5 }},
                                onClick: (e, legendItem, legend) => {{
                                    const chart = legend.chart;
                                    chart.toggleDataVisibility(legendItem.index);
                                    const meta = chart.getDatasetMeta(0);
                                    let newTotal = 0;
                                    meta.data.forEach((element, index) => {{
                                        if (chart.getDataVisibility(index)) {{ 
                                            newTotal += chart.data.datasets[0].data[index];
                                        }}
                                    }});
                                    const newTitleText = 'Totale: ' + formatCurrency(newTotal);
                                    let mainTitle = chart.options.plugins.title.text[0];
                                    chart.options.plugins.title.text = [mainTitle, newTitleText];
                                    chart.update(); 
                                }} 
                            }}
                        }}
                    }};
                    switch(tabName) {{
                        case 'tabStoricoEU':
                            success = createChart('entrateUsciteStoricheChart', 'bar', dataEntrateUsciteStorici, {{ 
                                ...barOptions, 
                                plugins: {{ ...barOptions.plugins, title: {{ display: true, text: ['Entrate e Uscite Storiche per Anno', 'Totali: ' + TOTALI.STORICO_EU] }} }} 
                            }});
                            break;
                        case 'tabMensileEU':
                            success = createChart('entrateUsciteMensiliChart', 'bar', dataEntrateUsciteMensili, {{ 
                                ...barOptions, 
                                plugins: {{ ...barOptions.plugins, title: {{ display: true, text: ['Entrate e Uscite Mensili (' + currentYear + ')', 'Totali: ' + TOTALI.MENSILE_EU] }} }} 
                            }});
                            break;
                        case 'tabCategorie':
                            const totalCat = dataCategorie.total !== undefined ? formatCurrency(dataCategorie.total) : 'N/D';
                            success = createChart('categorieChart', 'doughnut', dataCategorie, {{ 
                                ...pieOptions, 
                                plugins: {{ ...pieOptions.plugins, title: {{ display: true, text: ['Spese per Categoria (Anno Corrente)', 'Totale: ' + totalCat] }} }} 
                            }});
                            break;
                        case 'tabStoricoCat':
                            const totalStoricoCat = dataCategorieStoriche.total !== undefined ? formatCurrency(dataCategorieStoriche.total) : 'N/D';
                            success = createChart('storicoCategorieChart', 'doughnut', dataCategorieStoriche, {{ 
                                ...pieOptions, 
                                plugins: {{ ...pieOptions.plugins, title: {{ display: true, text: ['Spese Storiche per Categoria (Tutti gli anni)', 'Totale: ' + totalStoricoCat] }} }} 
                            }});
                            break;
                        case 'tabSaldo':
                            success = createChart('saldoChart', 'line', dataSaldo, {{ 
                                responsive: true, 
                                maintainAspectRatio: false, 
                                plugins: {{ title: {{ display: true, text: ['Saldo Progressivo Mensile', TOTALI.SALDO] }} }} 
                            }});
                            break;
                        case 'tabSaldoAnnuale':
                            success = createChart('saldoAnnualeChart', 'bar', dataSaldoAnnuale, {{ 
                                ...barOptions, 
                                scales: {{ y: {{ beginAtZero: false }} }},
                                plugins: {{ ...barOptions.plugins, title: {{ display: true, text: ['Saldo Netto Annuale per Anno', TOTALI.SALDO_ANNUALE] }} }} 
                            }});
                            break;
                    }}
                    if (success) {{
                        chartInstances[tabName] = true; 
                    }}
                }}

                document.addEventListener("DOMContentLoaded", () => {{
                    drawCharts();
                    const firstTabButton = document.querySelector('.tab-container .tab-button');
                    if(firstTabButton) {{
                        const tabName = firstTabButton.getAttribute('onclick').match(/'([^']+)'/)[1];
                        openTab(tabName, firstTabButton);
                    }}
                    const accordionContent = document.getElementById("accordionContent");
                    accordionContent.style.display = "none";
                }});
            </script>
        </head>
        <body>
            <header>
                <button class="menu-button" onclick="toggleMenu()">üõ†Ô∏è</button>
                <div id="extraMenu" class="nav-dropdown">
                    <a href="/">üè† Aggiungi Operazione</a>
                    <a href="/lista">üìà Gestione Movimenti Mese</a>
                    <a href="/stats">üìä Bilancio Mese</a>
                    <a href="/report_annuo">‚öñÔ∏è Report Annuale</a>
                    <a href="/grafici_web">üìÖ Grafici e Statistiche</a>
                    <a href="/menu_esplora">üîç Esplora</a>
                    <a href="/gestione_categorie">‚öôÔ∏è Gestione Categorie</a>
                    <a href="/utenze?anno={anno_corrente_format}">üíß Utenze</a>
                    <a href="/documenti_pdf_web">üóÑÔ∏è Documenti PDF</a>
                    <a href="/consultazione_supermercati">üõí Gestione Supermercati</a>
                    <a href="/info_sys_web">üì° Monitor Server</a>
                    <a href="/logoff">üîì Logout</a>
                </div>
               <div class="header-title">üìä Bilancio del {oggi_formattata}</div>
            </header>
            <main>
                    <div class="tab-content-wrapper">
                        <div class="tab-container">
                            <button class="tab-button" onclick="openTab('tabStoricoEU', this)">Storico</button>
                            <button class="tab-button" onclick="openTab('tabMensileEU', this)">Mensile</button>
                            <button class="tab-button" onclick="openTab('tabSaldo', this)">Saldo Mese</button>
                            <button class="tab-button" onclick="openTab('tabSaldoAnnuale', this)">Saldo Annuale</button> <button class="tab-button" onclick="openTab('tabCategorie', this)">Uscite</button>
                            <button class="tab-button" onclick="openTab('tabStoricoCat', this)">Uscite Storiche</button>
                        </div>
                        <div class="tab-content">
                            <div id="tabStoricoEU" class="tab-pane">
                                <div class="chart-container bar-chart-container">
                                    <canvas id="entrateUsciteStoricheChart"></canvas>
                                </div>
                            </div>
                            <div id="tabMensileEU" class="tab-pane">
                                <div class="chart-container bar-chart-container">
                                    <canvas id="entrateUsciteMensiliChart"></canvas>
                                </div>
                            </div>
                            <div id="tabCategorie" class="tab-pane">
                                <div class="chart-container">
                                    <canvas id="categorieChart"></canvas>
                                </div>
                            </div>
                            <div id="tabStoricoCat" class="tab-pane">
                                <div class="chart-container">
                                    <canvas id="storicoCategorieChart"></canvas>
                                </div>
                            </div>
                            <div id="tabSaldo" class="tab-pane">
                                <div class="chart-container bar-chart-container">
                                    <canvas id="saldoChart"></canvas>
                                </div>
                            </div>
                            <div id="tabSaldoAnnuale" class="tab-pane"> 
                                <div class="chart-container bar-chart-container">
                                    <canvas id="saldoAnnualeChart"></canvas>
                                </div>
                            </div>
                    
                        </div>
                    </div>
                </div>
                <a href="/" class="back">üè† Torna alla Home</a>
            </main>
        </body>
        </html>
        """
        return html_template

    def get_dati_saldo_annuale_json(self):
        saldo_per_anno = {} 
        for d, voci in self.spese.items():
            anno = d.year
            if anno not in saldo_per_anno:
                saldo_per_anno[anno] = 0.0
            for voce in voci:
                importo = float(voce[2]) 
                tipo = voce[3].strip().lower()
                if tipo == "entrata":
                    saldo_per_anno[anno] += importo
                elif tipo == "uscita":
                    saldo_per_anno[anno] -= importo
        anni_ordinati = sorted(saldo_per_anno.keys())
        dati_json = {
            "labels": [str(anno) for anno in anni_ordinati],
            "datasets": [{
                "label": "Saldo Netto Annuale",
                "data": [saldo_per_anno[anno] for anno in anni_ordinati],
                "backgroundColor": ["#228B22" if saldo_per_anno[anno] >= 0 else "#c43b2e" for anno in anni_ordinati]
            }]
        }
        return json.dumps(dati_json)

    def get_dati_categorie_storiche_json(self):
        spese_per_categoria = {}
        for giorno, voci in self.spese.items():
                for voce in voci:
                        if len(voce) >= 4 and voce[3] == "Uscita":
                                categoria, _, importo, _ = voce[:4]
                                spese_per_categoria[categoria] = spese_per_categoria.get(categoria, 0.0) + importo
        if not spese_per_categoria:
                return '{"labels": ["N/D"], "datasets": [{"data": [1], "backgroundColor": ["#ccc"], "label": "Dati non disponibili"}]}'
        sorted_categorie = sorted(spese_per_categoria.keys())
        labels = sorted_categorie
        data = [spese_per_categoria[cat] for cat in sorted_categorie]
        colori_predefiniti = [
                "#3e95cd", "#8e5ea2", "#3cba9f", "#e8c3b9", "#c45850",
                "#ff6384", "#36a2eb", "#ffce56", "#4bc0c0", "#9966ff",
                "#ff9f40", "#ff6384", "#63b5ff", "#c9cbcf", "#e7e9ed"
        ]
        background_colors = [colori_predefiniti[i % len(colori_predefiniti)] for i in range(len(labels))]
        chart_data = {
                "labels": labels,
                "datasets": [{
                        "data": data,
                        "backgroundColor": background_colors,
                        "label": "Spese Storiche"
                }]
        }
        return json.dumps(chart_data)

    # Saldo fine anno
    def calcola_statistiche_annuali_pura(self):
        from datetime import date
        oggi = date.today()
        anno_corr = oggi.year
        anno_prec = anno_corr - 1
        mese_corr = oggi.month
        tot_mese_corr = tot_mese_prec = 0.0
        tot_anno_corr = tot_anno_prec = 0.0
        stima_anno_prec = 0.0
        for giorno, voci in self.spese.items():
            for voce in voci:
                if len(voce) < 4:
                    continue
                categoria, descrizione, importo, tipo = voce[:4]
                if tipo != "Uscita":
                    continue
                if giorno.year == anno_corr and giorno.month == mese_corr:
                    tot_mese_corr += importo
                if giorno.year == anno_prec and giorno.month == mese_corr:
                    tot_mese_prec += importo
                if giorno.year == anno_corr and giorno <= oggi:
                    tot_anno_corr += importo
                if giorno.year == anno_prec and giorno <= oggi.replace(year=anno_prec):
                    tot_anno_prec += importo
                if giorno.year == anno_prec:
                    stima_anno_prec += importo
        giorni_passati = (oggi - date(anno_corr, 1, 1)).days + 1
        giorni_totali = 365
        perc_anno = giorni_passati / giorni_totali
        stima_anno_corr = tot_anno_corr / perc_anno if perc_anno else tot_anno_corr
        variazione_mese_pct = (
            (tot_mese_corr - tot_mese_prec) / tot_mese_prec * 100
            if tot_mese_prec else 0.0
        )
        differenza = stima_anno_prec - stima_anno_corr
        report = f"""üìä Bilancio dinamico Previsionale
        
 Analisi delle spese attuali e stima
 fino a fine {anno_corr}
  üîπ Mese corrente ({mese_corr:02}/{anno_corr})
  ‚Ä¢ Spese {anno_corr}:  ‚Ç¨ {tot_mese_corr:,.2f}
  ‚Ä¢ Spese {anno_prec}:  ‚Ç¨ {tot_mese_prec:,.2f}
  ‚Ä¢ Variazione mensile: {variazione_mese_pct:+.1f}%
 üîπ Da inizio anno (01/01 ‚Üí oggi)
  ‚Ä¢ Totale {anno_corr}:  ‚Ç¨ {tot_anno_corr:,.2f}
  ‚Ä¢ Totale {anno_prec}:  ‚Ç¨ {tot_anno_prec:,.2f}
 üîπ Proiezione fine anno
  ‚Ä¢ Spesa stimata {anno_corr}: ‚Ç¨ {stima_anno_corr:,.2f}  
  ‚Ä¢ (‚è≥ {perc_anno:.1%} dell‚Äôanno trascorso)
  ‚Ä¢ Spesa effettiva {anno_prec}: ‚Ç¨ {stima_anno_prec:,.2f}
    """
        if differenza > 0:
            report += f"\n‚úì Risparmio previsto: ‚Ç¨ {differenza:,.2f} \n   se mantieni questo ritmo üí∞"
        else:
            report += f"\n‚ö†Ô∏è Possibile extra spesa: ‚Ç¨ {abs(differenza):,.2f}\n   rispetto al {anno_prec} ü™ô"
        return report.strip()

    def stats_mensili_html(self):
        mesi_it = {
            "January": "gennaio", "February": "febbraio", "March": "marzo",
            "April": "aprile", "May": "aprile", "June": "giugno",
            "July": "luglio", "August": "agosto", "September": "settembre",
            "October": "ottobre", "November": "novembre", "December": "dicembre"
        }
        oggi = datetime.date.today()
        mese_en = oggi.strftime('%B')
        mese_it_corrente = mesi_it.get(mese_en, mese_en)
        titolo_mese = f"{mese_it_corrente.capitalize()} {oggi.year}"
        entrate = 0.0
        uscite = 0.0
        entrate_categorie = {}
        uscite_categorie = {}
        raw_entrate_dettaglio = {}
        raw_uscite_dettaglio = {}
        entrate_count = {}
        uscite_count = {}
        for d, voci in self.spese.items():
            if d.month == oggi.month and d.year == oggi.year:
                for voce in voci:
                    categoria, descrizione, importo, tipo = voce[:4]
                    if tipo == "Entrata":
                        entrate += importo
                        entrate_categorie[categoria] = entrate_categorie.get(categoria, 0.0) + importo
                        raw_entrate_dettaglio.setdefault(categoria, []).append((d, descrizione, importo))
                        entrate_count[categoria] = entrate_count.get(categoria, 0) + 1 
                    else:
                        uscite += importo
                        uscite_categorie[categoria] = uscite_categorie.get(categoria, 0.0) + importo
                        raw_uscite_dettaglio.setdefault(categoria, []).append((d, descrizione, importo))
                        uscite_count[categoria] = uscite_count.get(categoria, 0) + 1 
        saldo = entrate - uscite
        saldo_colore = "#3c763d" if saldo >= 0 else "#c43b2e" 
        meteo_saldo = "‚òÄÔ∏è" if saldo >= 0 else "üåßÔ∏è"
        
        def genera_html_categorie(categorie_totals, raw_dettaglio, prefix, counts_dict):
            html_content = ""
            if not categorie_totals:
                return f"<p class='no-data-msg'>Nessuna {prefix} per categoria da mostrare.</p>"
            html_content += "<ul class='category-list'>"
            for cat, totale in sorted(categorie_totals.items()):
                voci_dettaglio = raw_dettaglio.get(cat, [])
                
                dettagli_id = f"{prefix}_{''.join(filter(str.isalnum, cat))}"
                
                arrow_button_html = ''
                if voci_dettaglio:
                    arrow_button_html = f"""
                        <button type="button" class="category-arrow-button" onclick="toggleVisibility('{dettagli_id}', this)" aria-expanded="false" aria-controls="{dettagli_id}">
                            <span class="category-arrow">‚ñ∂Ô∏è</span>
                        </button>
                    """

                color_class = "detail-income" if prefix == "entrate" else "detail-expense"
                dettaglio_items_html = ''.join(
                    f'<li class="detail-item"><span class="detail-text">{data.strftime("%d-%m-%Y")}{" ‚Äî " + desc if desc else ""}</span><span class="detail-amount {color_class}">‚Ç¨{imp:.2f}</span></li>'
                    for data, desc, imp, *_ in voci_dettaglio
                )
                if not dettaglio_items_html:
                    dettaglio_items_html = '<li>Nessun dettaglio disponibile.</li>'
                num_operations = counts_dict.get(cat, 0)
                category_name_html = f'<strong class="category-name">{cat} ({num_operations}):</strong>'
                html_content += f"""
                <li class="category-item">
                    <div class="category-summary">
                        {arrow_button_html}
                        {category_name_html}
                        <span class="category-total">‚Ç¨{totale:.2f}</span>
                    </div>
                    <ul id="{dettagli_id}" class="hidden category-details">
                        {dettaglio_items_html}
                    </ul>
                </li>
                """
            html_content += "</ul>"
            return html_content
        categorie_uscite_html = genera_html_categorie(uscite_categorie, raw_uscite_dettaglio, "uscite", uscite_count)
        categorie_entrate_html = genera_html_categorie(entrate_categorie, raw_entrate_dettaglio, "entrate", entrate_count)
        return f"""
        <!DOCTYPE html>
        <html>
        <head>
            <meta charset="utf-8">
            <title>üìä Bilancio Mese</title>
            <meta name="viewport" content="width=device-width, initial-scale=1">
            <style>
                body {{
                    font-family: 'Segoe UI', sans-serif;
                    background-color: #f4f4f4;
                    margin: 0;
                    padding: 0;
                    box-sizing: border-box;
                }}
                header {{ 
                    background: transparent; 
                    color: #000; 
                    padding: 15px 0; 
                    text-align: center; 
                    position: relative;
                    min-height: 40px;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                }}
                .header-title {{
                  font-size: 18px;
                  font-weight: 800;
                  color: #000000;
                  margin: 0;
                  white-space: nowrap;
                  text-align: center;
                }}
                .menu-button {{ 
                  position: absolute; 
                  top: 15px !important;
                  left: 15px !important;
                  font-size: 1.6em; 
                  line-height: 1;
                  background: none; 
                  border: none; 
                  color: black; 
                  cursor: pointer; 
                  padding: 0;
                  margin: 0;
                  z-index: 1000;
                }}
                .nav-dropdown {{ 
                    position: absolute; 
                    top: 55px; 
                    left: 10px; 
                    background: white; 
                    box-shadow: 0 4px 15px rgba(0,0,0,0.2); 
                    border-radius: 8px; 
                    display: none; 
                    z-index: 1000; 
                    width: 260px;
                    text-align: left;
                }}
                .nav-dropdown a {{ 
                    display: block; 
                    padding: 12px 18px; 
                    text-decoration: none; 
                    color: #333;
                    border-bottom: 1px solid #eee; 
                    font-size: 0.95em; 
                    font-family: 'Segoe UI', sans-serif;
                    font-weight: normal; 
                }}
                .nav-dropdown a:last-child {{
                    border-bottom: none;
                }}
                .nav-dropdown a:hover {{ 
                    background-color: #f8f9fa; 
                    color: #0078D4;
                }}
                main {{
                    padding: 15px;
                    max-width: 600px;
                    margin: auto;
                }}
                h2 {{
                    color: #333;
                    text-align: center;
                    font-size: 1.4em;
                    margin: 0 0 15px 0;
                    padding: 10px 0;
                    border-bottom: 1px solid #eee;
                }}
                .main-stats {{
                    list-style-type: none;
                    padding: 15px;
                    background: #fff;
                    border-radius: 8px;
                    box-shadow: 0 0 8px rgba(0,0,0,0.1);
                    max-width: 100%;
                    margin-bottom: 15px;
                    box-sizing: border-box;
                }}
                .main-stats li {{
                    font-size: 1.1em;
                    margin: 8px 0;
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                }}
                .income-color {{ color: #3c763d; }}
                .expense-color {{ color: #c43b2e; }}
                .category-list {{ list-style-type: none; padding: 0; margin: 0; }}
                .category-item {{
                    font-size: 1em;
                    margin: 8px 0;
                    display: flex;
                    flex-direction: column;
                    background-color: #fcfcfc;
                    padding: 10px;
                    border-radius: 6px;
                    border: 1px solid #eee;
                    box-shadow: 0 1px 3px rgba(0,0,0,0.05);
                }}
                .category-summary {{ display: flex; align-items: center; justify-content: space-between; width: 100%; }}
                .category-name {{ flex-grow: 1; }}
                .category-total {{ text-align: right; font-weight: bold; flex-shrink: 0; margin-left: 10px; }}
                .category-arrow-button {{ background: none; border: none; font-size: 1em; cursor: pointer; padding: 0; margin-right: 5px; display: flex; align-items: center; justify-content: center; }}
                .category-arrow {{ transition: transform 0.3s ease; font-size: 0.8em; }}
                .category-arrow.rotated {{ transform: rotate(90deg); }}
                ul.category-details {{
                    list-style-type: none;
                    background: #f0f0f0;
                    padding: 10px 15px;
                    border-radius: 4px;
                    margin-top: 8px;
                    font-size: 0.9em;
                    width: 100%;
                    box-sizing: border-box;
                }}
                .detail-item {{ display: flex; justify-content: space-between; align-items: baseline; margin: 5px 0; padding-left: 10px; position: relative; }}
                .detail-item::before {{ content: '‚Ä¢'; position: absolute; left: 0; color: #0078D4; }}
                
                .section-toggle-button {{
                    display: flex; justify-content: space-between; align-items: center; width: 100%; padding: 12px;
                    background-color: #0078D4; color: white; border: none; border-radius: 6px; font-weight: bold;
                    cursor: pointer; margin-top: 20px; margin-bottom: 10px;
                }}
                .arrow {{ transition: transform 0.3s ease; }}
                .arrow.rotated {{ transform: rotate(90deg); }}
                .collapsible-content {{ display: none; width: 100%; box-sizing: border-box; }}
                .collapsible-content.active {{ display: block; }}
                .hidden {{ display: none; }}

                .back {{
                    display: block; text-align: center; text-decoration: none; background: #0078D4; color: white;
                    padding: 12px; border-radius: 8px; margin: 30px auto; width: 200px;
                }}
            </style>
            <script>
                function toggleMenu() {{
                    const menu = document.getElementById("extraMenu");
                    menu.style.display = (menu.style.display === "block") ? "none" : "block";
                }}
                document.addEventListener("click", function(event) {{
                    const menu = document.getElementById("extraMenu");
                    if (!event.target.closest(".menu-button, #extraMenu")) menu.style.display = "none";
                }});

                function toggleVisibility(contentId, buttonElement) {{
                    const content = document.getElementById(contentId);
                    const arrow = buttonElement.querySelector('.category-arrow') || buttonElement.querySelector('.arrow');
                    let isExpanded = content.classList.contains('collapsible-content') ? content.classList.contains('active') : !content.classList.contains('hidden');
                    if (isExpanded) {{
                        if (content.classList.contains('collapsible-content')) content.classList.remove('active');
                        else content.classList.add('hidden');
                        if (arrow) arrow.classList.remove('rotated');
                    }} else {{
                        if (content.classList.contains('collapsible-content')) content.classList.add('active');
                        else content.classList.remove('hidden');
                        if (arrow) arrow.classList.add('rotated');
                    }}
                }}
            </script>
        </head>
        <body>
            <header>
                <button class="menu-button" onclick="toggleMenu()">üõ†Ô∏è</button>
                <div id="extraMenu" class="nav-dropdown">
                    <a href="/">üè† Aggiungi Operazione</a>
                    <a href="/lista">üìà Gestione Movimenti Mese</a>
                    <a href="/stats">üìä Bilancio Mese</a>
                    <a href="/report_annuo">‚öñÔ∏è Report Annuale</a>
                    <a href="/grafici_web">üìÖ Grafici e Statistiche</a>
                    <a href="/menu_esplora">üîç Esplora</a>
                    <a href="/gestione_categorie">‚öôÔ∏è Gestione Categorie</a>
                    <a href="/utenze?anno={datetime.date.today().year}">üíß Utenze</a>
                    <a href="/documenti_pdf_web">üóÑÔ∏è Documenti PDF</a>
                    <a href="/consultazione_supermercati">üõí Gestione Supermercati</a>
                    <a href="/info_sys_web">üì° Monitor Server</a>
                    <a href="/logoff">üîì Logout</a>
                </div>
                <div class="header-title">‚öñÔ∏è Andamento Mensile</div>
            </header>
            <main>
                <div class="main-stats">
                    <h2>üìä Statistiche di {titolo_mese} {meteo_saldo}</h2>
                    <ul style="list-style:none; padding:0; margin:0;">
                        <li><strong>Entrate Totali:</strong> <span class="income-color">‚Ç¨{entrate:.2f}</span></li>
                        <li><strong>Uscite Totali:</strong> <span class="expense-color">‚Ç¨{uscite:.2f}</span></li>
                        <li><strong style="color:{saldo_colore};">Saldo:</strong> <span style="color:{saldo_colore};">‚Ç¨{saldo:.2f}</span></li>
                    </ul>
                </div>

                <button type="button" class="section-toggle-button" onclick="toggleVisibility('usciteCategorieContent', this)">
                    <span>üßÆ Uscite per Categoria</span>
                    <span class="arrow">‚ñ∂Ô∏è</span>
                </button>
                <div id="usciteCategorieContent" class="collapsible-content">
                    {categorie_uscite_html}
                </div>
                <button type="button" class="section-toggle-button" onclick="toggleVisibility('entrateCategorieContent', this)">
                    <span>üì• Entrate per Categoria</span>
                    <span class="arrow">‚ñ∂Ô∏è</span>
                </button>
                <div id="entrateCategorieContent" class="collapsible-content">
                    {categorie_entrate_html}
                </div>
                <a href="/" class="back">üè† Torna alla Home</a>
            </main>
        </body>
        </html>
        """
        
    def html_lista_spese_mensili(self):
        import datetime
        mesi_it = {
            "January": "gennaio", "February": "febbraio", "March": "marzo",
            "April": "aprile", "May": "maggio", "June": "giugno",
            "July": "luglio", "August": "agosto", "September": "settembre",
            "October": "ottobre", "November": "novembre", "December": "dicembre"
        }
        oggi = datetime.date.today()
        mese_en = oggi.strftime('%B')
        mese_it_corrente = mesi_it.get(mese_en, mese_en)
        titolo_mese = f"{mese_it_corrente.capitalize()} {oggi.year}"
        current_month_expenses = []
        tot_entrate = 0.0
        tot_uscite = 0.0
        for d, voci in self.spese.items():
            if d.month == oggi.month and d.year == oggi.year:
                for idx, voce in enumerate(voci):
                    current_month_expenses.append((d, idx, voce))
                    try:
                        imp = float(voce[2])
                        tipo = voce[3].strip().lower()
                        if tipo == "entrata": 
                            tot_entrate += imp
                        else: 
                            tot_uscite += imp
                    except: 
                        continue
        saldo_mese = tot_entrate - tot_uscite
        icona_meteo = "‚òÄÔ∏è" if saldo_mese >= 0 else "‚õàÔ∏è"
        colore_saldo = "#228B22" if saldo_mese >= 0 else "#c43b2e"
        current_month_expenses.sort(key=lambda x: x[0], reverse=True)        
        schede_html = ""
        if not current_month_expenses:
            schede_html = "<p style='text-align:center; color:#888; padding:20px;'>Nessun movimento registrato.</p>"
        else:
            for d, idx, voce in current_month_expenses:
                categoria, descrizione, importo, tipo = voce[:4]
                data_str = d.strftime('%d-%m-%Y')
                details_id = f"details_{d.strftime('%Y%m%d')}_{idx}"
                colore_imp = "#228B22" if tipo.strip().lower() == "entrata" else "#c43b2e"
                segno = "+" if tipo.strip().lower() == "entrata" else "-"                
                schede_html += f"""
                <div class="expense-item">
                    <div class="expense-summary" onclick="toggleVisibility('{details_id}', this)">
                        <span class="arrow">‚ñ∂Ô∏è</span>
                        <span class="date">{data_str}</span>
                        <span class="cat">{categoria}</span>
                        <span class="amount" style="color:{colore_imp};">{segno}‚Ç¨{importo:.2f}</span>
                    </div>
                    <div id="{details_id}" class="collapsible-content">
                        <div class="row-detail"><span class="label">Tipo:</span> <span>{tipo}</span></div>
                        <div class="row-detail"><span class="label">Dettaglio:</span> <span>{descrizione}</span></div>
                        <div class="row-detail actions">
                            <form method="get" action="/modifica" style="display:inline;">
                                <input type="hidden" name="data" value="{data_str}">
                                <input type="hidden" name="idx" value="{idx}">
                                <button type="submit" class="details-button">‚úèÔ∏è Modifica</button>
                            </form>
                            <form onsubmit="cancellaVoce(event, '{data_str}', '{idx}')" style="display:inline;">
                                <button type="submit" class="details-button danger">‚ùå Cancella</button>
                            </form>
                        </div>
                    </div>
                </div>
                """
        return f"""
        <!DOCTYPE html>
        <html>
        <head>
            <meta charset="utf-8">
            <title>üìä Movimenti Mese</title>
            <meta name="viewport" content="width=device-width, initial-scale=1">
            <style>
                body {{
                    font-family: 'Segoe UI', sans-serif;
                    background-color: #f0f2f5;
                    margin: 0;
                    padding: 0;
                }}
                header {{ 
                  background: transparent; 
                  color: #000; 
                  padding: 15px 0; 
                  text-align: center; 
                  position: relative;
                  min-height: 40px;
                  display: flex;
                  align-items: center;
                  justify-content: center;
                }}
                .header-title {{
                    font-size: 18px;
                    font-weight: 800;
                    color: #000000;
                    margin: 0;
                    white-space: nowrap;
                    text-align: center;
                }}
                .menu-button {{ 
                  position: absolute; 
                  top: 15px !important;
                  left: 15px !important;
                  font-size: 1.6em; 
                  line-height: 1;
                  background: none; 
                  border: none; 
                  color: black; 
                  cursor: pointer; 
                  padding: 0;
                  margin: 0;
                  z-index: 1000;
                }}
                .nav-dropdown {{ 
                    position: absolute; 
                    top: 55px; 
                    left: 10px; 
                    background: white; 
                    box-shadow: 0 4px 15px rgba(0,0,0,0.2); 
                    border-radius: 8px; 
                    display: none; 
                    z-index: 1000; 
                    width: 260px;
                    text-align: left;
                }}
                .nav-dropdown a {{ 
                    display: block; 
                    padding: 12px 18px; 
                    text-decoration: none; 
                    color: #333;
                    border-bottom: 1px solid #eee; 
                    font-size: 0.95em; 
                    font-family: 'Segoe UI', sans-serif;
                    font-weight: normal; 
                            }}
                .nav-dropdown a:last-child {{
                    border-bottom: none;
                }}
                .nav-dropdown a:hover {{ 
                    background-color: #f8f9fa; 
                    color: #0078D4;
                }}
                main {{
                    padding: 15px;
                    max-width: 600px;
                    margin: 0 auto;
                }}
                .titolo-riquadro {{
                    border: 1px solid #ddd;
                    border-radius: 12px;
                    padding: 18px;
                    text-align: center;
                    margin-bottom: 20px;
                    background: #fff;
                    box-shadow: 0 2px 8px rgba(0,0,0,0.06);
                }}
                .stats-grid {{
                    display: grid;
                    grid-template-columns: 1fr 1fr;
                    gap: 10px;
                    margin-top: 12px;
                    padding-top: 12px;
                    border-top: 1px solid #eee;
                }}
                .stat-box {{
                    font-size: 0.9em;
                    display: flex;
                    flex-direction: column;
                }}
                .stat-label {{
                    color: #888;
                    font-size: 0.85em;
                    text-transform: uppercase;
                }}
                .stat-val {{
                    font-weight: bold;
                    font-size: 1.05em;
                }}
                .expense-item {{
                    background: white;
                    border-radius: 8px;
                    margin-bottom: 8px;
                    border: 1px solid #ddd;
                    overflow: hidden;
                }}
                .expense-summary {{
                    display: flex;
                    align-items: center;
                    padding: 12px;
                    cursor: pointer;
                    gap: 10px;
                }}
                .date {{
                    color: #888;
                    font-size: 0.8em;
                    width: 75px;
                }}
                .cat {{
                    font-weight: bold;
                    flex: 1;
                    overflow: hidden;
                    text-overflow: ellipsis;
                    white-space: nowrap;
                    font-size: 0.9em;
                }}
                .amount {{
                    font-weight: bold;
                    width: 90px;
                    text-align: right;
                }}
                .arrow {{
                    transition: transform 0.2s;
                    color: #ccc;
                    font-size: 0.8em;
                }}
                .collapsible-content {{
                    display: none;
                    padding: 12px;
                    background: #fafafa;
                    border-top: 1px solid #eee;
                }}
                .collapsible-content.active {{
                    display: block;
                }}
                .row-detail {{
                    margin-bottom: 8px;
                    font-size: 0.9em;
                    display: flex;
                }}
                .row-detail .label {{
                    font-weight: bold;
                    color: #0078D4;
                    width: 85px;
                }}
                .actions {{
                    margin-top: 10px;
                    display: flex;
                    gap: 10px;
                }}
                .details-button {{
                    padding: 10px;
                    border-radius: 6px;
                    border: 1px solid #0078D4;
                    background: white;
                    color: #0078D4;
                    cursor: pointer;
                    flex: 1;
                    font-size: 0.85em;
                    text-align: center;
                }}
                .details-button.danger {{
                    border-color: #c43b2e;
                    color: #c43b2e;
                }}
                .back-btn {{
                    display: block;
                    background: #0078D4;
                    color: white;
                    text-align: center;
                    padding: 12px;
                    border-radius: 8px;
                    text-decoration: none;
                    margin: 20px auto;
                    font-weight: bold;
                    width: 80%;
                    max-width: 200px;
                }}
            </style>
        </head>
        <body>
            <header>
                <button class="menu-button" onclick="toggleMenu(event)">üõ†Ô∏è</button>
                <div id="extraMenu" class="nav-dropdown">
                    <a href="/">üè† Aggiungi Operazione</a>
                    <a href="/lista">üìà Gestione Movimenti Mese</a>
                    <a href="/stats">üìä Bilancio Mese</a>
                    <a href="/report_annuo">‚öñÔ∏è Report Annuale</a>
                    <a href="/grafici_web">üìÖ Grafici e Statistiche</a>
                    <a href="/menu_esplora">üîç Esplora</a>
                    <a href="/gestione_categorie">‚öôÔ∏è Gestione Categorie</a>
                    <a href="/utenze?anno={oggi.year}">üíß Utenze</a>
                    <a href="/documenti_pdf_web">üóÑÔ∏è Documenti PDF</a>
                    <a href="/consultazione_supermercati">üõí Supermercati</a>
                    <a href="/info_sys_web">üì° Monitor Server</a>
                    <a href="/logoff">üîì Logout</a>
                </div>
                <div style="font-size: 1.1em; font-weight: bold;"> ‚öñÔ∏è Gestione Movimenti Mese</div>
            </header>
            <main>
                <div class="titolo-riquadro">
                    <div style="font-size: 1.25em; font-weight: bold;">{titolo_mese} {icona_meteo}</div>
                    <div class="stats-grid">
                        <div class="stat-box">
                            <span class="stat-label">Entrate</span>
                            <span class="stat-val" style="color: #228B22;">+‚Ç¨{tot_entrate:.2f}</span>
                        </div>
                        <div class="stat-box">
                            <span class="stat-label">Uscite</span>
                            <span class="stat-val" style="color: #c43b2e;">-‚Ç¨{tot_uscite:.2f}</span>
                        </div>
                    </div>
                    <div style="margin-top: 12px; padding-top: 10px; border-top: 2px solid #f0f2f5;">
                        <span style="color: #666; font-size: 0.9em;">SALDO ATTUALE</span><br>
                        <span style="font-size: 1.4em; color: {colore_saldo}; font-weight: 800;">‚Ç¨{saldo_mese:.2f}</span>
                    </div>
                </div>
                {schede_html}
                <a href="/" class="back-btn">üè† Torna alla Home</a>
            </main>
            <script>
                function toggleMenu(e) {{ 
                    e.stopPropagation(); 
                    const m = document.getElementById("extraMenu"); 
                    m.style.display = (m.style.display === "block") ? "none" : "block"; 
                }}
                document.addEventListener("click", function(e) {{ 
                    const m = document.getElementById("extraMenu"); 
                    if (m && m.style.display === "block" && !m.contains(e.target)) m.style.display = "none"; 
                }});
                function toggleVisibility(id, el) {{
                    const c = document.getElementById(id);
                    const a = el.querySelector(".arrow");
                    c.classList.toggle("active");
                    if (a) a.style.transform = c.classList.contains("active") ? "rotate(90deg)" : "rotate(0deg)";
                }}
                function cancellaVoce(e, d, i) {{
                    e.preventDefault();
                    fetch('/cancella', {{ 
                        method: 'POST', 
                        headers: {{ 'Content-Type': 'application/x-www-form-urlencoded' }}, 
                        body: 'data=' + d + '&idx=' + i 
                    }})
                    .then(() => {{ window.location.reload(); }});
                }}
            </script>
        </body>
        </html>
        """

    def modifica_voce_form(self, params):
        from datetime import datetime
        data_str = params.get("data", [""])[0]
        idx = int(params.get("idx", ["0"])[0])
        provenienza = params.get("from", ["/lista"])[0] 
        d_obj = datetime.strptime(data_str, "%d-%m-%Y").date()
        data_html = d_obj.strftime("%Y-%m-%d")
        voce = self.spese[d_obj][idx]
        categoria_corrente, descrizione, importo, tipo = voce[:4]
        categorie_options = "\n".join(
            f"<option value='{c}' {'selected' if c == categoria_corrente else ''}>{c}</option>"
            for c in sorted(self.categorie)
        )
        return f"""
        <html><head><meta charset="utf-8"><title>Modifica</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <style>
            body {{ font-family: Segoe UI, sans-serif; padding: 20px; background: #f4f4f4; margin: 0; }}
            .container {{ max-width: 500px; margin: auto; background: white; padding: 20px; border-radius: 8px; box-shadow: 0 0 8px rgba(0,0,0,0.1); }}
            label {{ display: block; margin: 12px 0 4px; font-weight: bold; }}
            input, select {{ width: 100%; padding: 8px; font-size: 1em; margin-bottom: 12px; box-sizing: border-box; }}
            button {{ background: #0078D4; color: white; border: none; padding: 10px; font-size: 1em; border-radius: 6px; width: 100%; cursor: pointer; }}
            .back-link {{ display: block; margin-top: 20px; text-align: center; text-decoration: none; color: #fff; background: #666; padding: 10px; border-radius: 6px; }}
        </style>
        </head>
        <body>
            <div class="container">
                <h2 style="text-align:center;">‚úèÔ∏è Modifica voce</h2>
                <form method="post" action="/salva_modifica">
                    <input type="hidden" name="vecchia_data" value="{data_str}">
                    <input type="hidden" name="vecchio_idx" value="{idx}">
                    <input type="hidden" name="provenienza" value="{provenienza}">
                    <label>Data</label>
                    <input name="nuova_data" type="date" value="{data_html}" required>
                    <label>Categoria</label>
                    <select name="categoria" required>{categorie_options}</select>
                    <label>Descrizione</label>
                    <input name="descrizione" value="{descrizione}">
                    <label>Importo (‚Ç¨)</label>
                    <input name="importo" type="number" step="0.01" value="{importo}" required>
                    <label>Tipo</label>
                    <select name="tipo">
                        <option value="Entrata" {"selected" if tipo == "Entrata" else ""}>Entrata</option>
                        <option value="Uscita" {"selected" if tipo != "Entrata" else ""}>Uscita</option>
                    </select>
                    <button type="submit">üíæ Salva Modifiche</button>
                </form>
                <a href="{provenienza}" class="back-link">üîô Annulla</a>
            </div>
        </body></html>
        """
    def salva_modifica_voce(self, params):
        from datetime import datetime
        v_data_str = params.get("vecchia_data", [""])[0]
        v_idx = int(params.get("vecchio_idx", ["0"])[0])
        provenienza = params.get("provenienza", ["/lista"])[0]
        n_data_html = params.get("nuova_data", [""])[0]
        cat = params.get("categoria", [""])[0]
        descr = params.get("descrizione", [""])[0]
        imp = float(params.get("importo", ["0"])[0])
        tipo = params.get("tipo", ["Uscita"])[0]
        d_vecchia_obj = datetime.strptime(v_data_str, "%d-%m-%Y").date()
        d_nuova_obj = datetime.strptime(n_data_html, "%Y-%m-%d").date()
        originale = self.spese[d_vecchia_obj][v_idx]
        nuova_voce = [cat, descr, imp, tipo]
        if len(originale) > 4:
            nuova_voce.extend(originale[4:])
        if d_vecchia_obj == d_nuova_obj:
            self.spese[d_nuova_obj][v_idx] = nuova_voce
        else:
            self.spese[d_vecchia_obj].pop(v_idx)
            if not self.spese[d_vecchia_obj]:
                del self.spese[d_vecchia_obj]
            if d_nuova_obj not in self.spese:
                self.spese[d_nuova_obj] = []
            self.spese[d_nuova_obj].append(nuova_voce)
        self.save_db()
        if hasattr(self, 'refresh_gui'):
            self.refresh_gui()
        return provenienza
        
    def cancella_voce_web(self, giorno_str, idx):
        try:
            data_obj = datetime.datetime.strptime(giorno_str, "%d-%m-%Y").date()
            if data_obj in self.spese:
                if 0 <= idx < len(self.spese[data_obj]):
                    voce_rimossa = self.spese[data_obj].pop(idx)
                    if not self.spese[data_obj]:
                        del self.spese[data_obj]
                    self.save_db()
                    self.carica_db_web()
                    self.refresh_gui() 
                    return True
        except Exception as e:
            print(f"‚ùå Errore dati cancellazione: {e}")
        return False

    def aggiungi_voce_web(self, voce):
        try:
            with open(DB_FILE, "r", encoding="utf-8") as f:
                dati = json.load(f)
        except Exception:
            dati = {"spese": []}
        try:
            d_obj = datetime.datetime.strptime(voce["date"], "%Y-%m-%d").date()
            data_str = d_obj.strftime("%d-%m-%Y")
            voce["date"] = data_str  
        except Exception as e:
            print(f"‚ùå Data non valida: {voce['date']} ‚Üí {e}")
            return
        for giorno in dati["spese"]:
            if giorno["date"] == data_str:
                giorno["entries"].append(voce)
                break
        else:
            dati["spese"].append({
                "date": data_str,
                "entries": [voce]
            })
        with open(DB_FILE, "w", encoding="utf-8") as f:
            json.dump(dati, f, indent=2, ensure_ascii=False)
        self.carica_db_web()
        self.refresh_gui()
 
    def carica_db_web(self):
        try:
            with open(DB_FILE, "r", encoding="utf-8") as f:
                dati = json.load(f)
        except Exception as e:
            print(f"‚ùå Errore lettura DB: {e}")
            return
        self.spese = {}
        for giorno in dati.get("spese", []):
            try:
                d = datetime.datetime.strptime(giorno["date"], "%d-%m-%Y").date()
                entries = []
                for e in giorno["entries"]:
                    voce = (
                        e.get("categoria", ""),
                        e.get("descrizione", ""),
                        float(e.get("importo", 0.0)),
                        e.get("tipo", "Uscita"),
                        *([e["id_ricorrenza"]] if "id_ricorrenza" in e else [])
                    )
                    entries.append(voce)
                self.spese[d] = entries
            except Exception as ex:
                print(f"‚ö†Ô∏è Errore parsing giorno {giorno.get('date')}: {ex}")

    def get_dati_entrate_uscite_json(self):
        oggi = datetime.date.today()
        anno_corrente = oggi.year
        entrate_mensili = [0.0] * 12
        uscite_mensili = [0.0] * 12
        for data, entries in self.spese.items():
            if data.year == anno_corrente:
                mese_indice = data.month - 1  
                for entry in entries:
                    categoria = entry[0]
                    importo = entry[2]
                    tipo = self.categorie_tipi.get(categoria, 'Uscita') 
                    if tipo == 'Entrata':
                        entrate_mensili[mese_indice] += importo
                    else: 
                        uscite_mensili[mese_indice] += importo
        mesi = ['Gen', 'Feb', 'Mar', 'Apr', 'Mag', 'Giu', 'Lug', 'Ago', 'Set', 'Ott', 'Nov', 'Dic']
        
        dati = {
            'labels': mesi,
            'datasets': [
                {'label': 'Entrate (‚Ç¨)', 'data': entrate_mensili, 'borderColor': 'rgba(75, 192, 192, 1)', 'backgroundColor': 'rgba(75, 192, 192, 0.5)'},
                {'label': 'Uscite (‚Ç¨)', 'data': uscite_mensili, 'borderColor': 'rgba(255, 99, 132, 1)', 'backgroundColor': 'rgba(255, 99, 132, 0.5)'}
            ]
        }
        return json.dumps(dati)

    def get_dati_saldo_json(self):
        oggi = datetime.date.today()
        anno_corrente = oggi.year
        saldo_mensile_netto = [0.0] * 12
        for data, entries in self.spese.items():
            if data.year == anno_corrente:
                mese_indice = data.month - 1
                for entry in entries:
                    categoria = entry[0]
                    importo = entry[2]
                    tipo = self.categorie_tipi.get(categoria, 'Uscita')
                    
                    if tipo == 'Entrata':
                        saldo_mensile_netto[mese_indice] += importo
                    else:
                        saldo_mensile_netto[mese_indice] -= importo
        saldo_progressivo = []
        saldo_accumulato = 0.0
        for saldo_netto in saldo_mensile_netto:
            saldo_accumulato += saldo_netto
            saldo_progressivo.append(round(saldo_accumulato, 2))
        mesi = ['Gen', 'Feb', 'Mar', 'Apr', 'Mag', 'Giu', 'Lug', 'Ago', 'Set', 'Ott', 'Nov', 'Dic']
        dati = {
            'labels': mesi,
            'datasets': [{
                'label': 'Saldo Progressivo (‚Ç¨)',
                'data': saldo_progressivo,
                'fill': False,
                'borderColor': 'rgb(75, 192, 192)',
                'tension': 0.1
            }]
        }
        return json.dumps(dati)

    def get_dati_categorie_json(self):
        oggi = datetime.date.today()
        anno_corrente = oggi.year
        spese_per_categoria = {}
        for data, entries in self.spese.items():
            if data.year == anno_corrente:
                for entry in entries:
                    categoria = entry[0]
                    importo = entry[2]
                    tipo = self.categorie_tipi.get(categoria, 'Uscita')
                    if tipo == 'Uscita':
                        spese_per_categoria[categoria] = spese_per_categoria.get(categoria, 0.0) + importo
        labels = list(spese_per_categoria.keys())
        spese = [round(v, 2) for v in spese_per_categoria.values()]
        colori = ['#' + ''.join([random.choice('0123456789ABCDEF') for j in range(6)]) for i in range(len(labels))]
        dati = {
            'labels': labels,
            'datasets': [{
                'data': spese,
                'backgroundColor': colori,
                'hoverOffset': 4
            }]
        }
        return json.dumps(dati)

    def refresh_gui(self):
        try:
            if self.state() == 'iconic':
                return
        except:
            return
        try:
            self.update_stats()
            self.update_totalizzatore_anno_corrente()
            self.update_totalizzatore_mese_corrente()
            self.update_spese_mese_corrente()
            self.colora_giorni_spese()
            self.aggiorna_monitoraggio_budget()
        except Exception:
            pass
        
    def aggiorna_gui_da_db(self):
        self.spese = {}
        for giorno in self.db.get("spese", []):
            try:
                d = datetime.datetime.strptime(giorno["date"], "%d-%m-%Y").date()
                entries = []
                for e in giorno["entries"]:
                    voce = (
                        e.get("categoria", ""),
                        e.get("descrizione", ""),
                        float(e.get("importo", 0.0)),
                        e.get("tipo", "Uscita")
                    )
                    if "id_ricorrenza" in e:
                        voce += (e["id_ricorrenza"],)
                    entries.append(voce)
                self.spese[d] = entries
            except Exception as ex:
                print(f"‚ö†Ô∏è Errore parsing giorno: {giorno.get('date')} ‚Üí {ex}")
                
    # Gestione Spesa Intelligente
    def spesa_supermercato(self):
        self.risultati_finali = []
        try:
            from tkcalendar import DateEntry
        except ImportError:
            DateEntry = None
            if not hasattr(self, '_tkcalendar_warned'):
                print("AVVISO: Libreria 'tkcalendar' non trovata. La data dovr√† essere inserita manualmente (gg-mm-aaaa).")
                self._tkcalendar_warned = True
        DEFAULT_SUPERMERCATI = ["Coop", "Dpiu", "Esselunga", "Eurospin", "Lidl", "Maurys"]
        SUPERMERCATI = []
        lista_spesa_data = defaultdict(lambda: {})
        campi_input_refs = {}
        dati_supermercati = {}
        ricerca_vars_crud = {}
        ricerca_var_confronto = tk.StringVar()
        supermercato_selezionato_var = tk.StringVar()
        filtro_supermercato_confronto_var = tk.StringVar(value="Tutti i supermercati")
        if not hasattr(self, 'risultati_tv_ref'):
            self.risultati_tv_ref = None
        if hasattr(self, '_popup_spesa_active') and self._popup_spesa_active.winfo_exists():
            self._popup_spesa_active.lift()
            return
        def _carica_dati_interno():
            nonlocal SUPERMERCATI, dati_supermercati
            if not os.path.exists(DB_DIR):
                os.makedirs(DB_DIR, exist_ok=True)
            try:
                if not os.path.exists(SUPERMERCATI_DB) or os.stat(SUPERMERCATI_DB).st_size == 0:
                    dati = {s: [] for s in DEFAULT_SUPERMERCATI}
                    SUPERMERCATI = DEFAULT_SUPERMERCATI
                    dati_supermercati = dati
                    _salva_dati_interno(dati)
                    return
                else:
                    with open(SUPERMERCATI_DB, 'r', encoding='utf-8') as f:
                        dati = json.load(f)
                        loaded_supermercati = [k for k, v in dati.items() if isinstance(v, list)]
                        loaded_supermercati.sort()
                        SUPERMERCATI = loaded_supermercati if loaded_supermercati else DEFAULT_SUPERMERCATI
                        dati_supermercati = {s: dati.get(s, []) for s in SUPERMERCATI}
            except (FileNotFoundError, json.JSONDecodeError):
                SUPERMERCATI = DEFAULT_SUPERMERCATI
                dati_supermercati = {s: [] for s in DEFAULT_SUPERMERCATI}
        def _salva_dati_interno(dati_da_salvare):
            try:
                with open(SUPERMERCATI_DB, 'w', encoding='utf-8') as f:
                    dati_filtrati = {}
                    for s in SUPERMERCATI:
                        if s in dati_da_salvare and dati_da_salvare[s]:
                            lista_articoli = dati_da_salvare[s].copy()
                            lista_articoli.sort(key=lambda x: x.get('nome', '').strip().lower()) 
                            dati_filtrati[s] = lista_articoli
                        elif s in dati_da_salvare:
                            dati_filtrati[s] = []
                    json.dump(dati_filtrati, f, indent=4, ensure_ascii=False)
            except Exception as e:
                print(f"Errore durante il salvataggio: {e}")
        def _svuota_campi(refs):
            prima_categoria_default = "Affettati"
            if CATEGORIE_PREDEFINITE and isinstance(CATEGORIE_PREDEFINITE, list):
                prima_categoria_default = CATEGORIE_PREDEFINITE[0]
            refs['nome'].set("")
            refs['descrizione'].set("")
            refs['categoria'].set(prima_categoria_default)
            refs['prezzo'].set("")
            refs['promo_attiva'].set(False)
            refs['prezzo_promo'].set("")
            refs['quantita'].set("")
            refs['data_scadenza'].set("")
            refs['data_inserimento_prezzo'].set("")
            refs['data_inizio_promo'].set("")
        def _controlla_scadenza_promo():
            def _parse_data_per_confronto(data_str):
                if not data_str:
                    return None
                for fmt in ['%d-%m-%Y']:
                    try:
                        return datetime.datetime.strptime(data_str, fmt).date() 
                    except ValueError:
                        continue
                return None
            nonlocal dati_supermercati
            oggi = datetime.datetime.now().date()
            articoli_modificati = False
            for supermercato, articoli in dati_supermercati.items():
                for articolo in articoli:
                    if articolo.get("promo", False) and articolo.get("data_scadenza"):
                        data_scad_str = articolo["data_scadenza"].strip()
                        data_scadenza = _parse_data_per_confronto(data_scad_str)
                        if data_scadenza is None:
                            continue 
                        if data_scadenza <= oggi:
                            articolo["promo"] = False
                            articolo["prezzo_promo"] = ""
                            articolo["data_scadenza"] = ""
                            articolo["data_inizio_promo"] = ""
                            articoli_modificati = True
            if articoli_modificati:
                _salva_dati_interno(dati_supermercati)
                if hasattr(self, 'risultati_tv_ref') and self.risultati_tv_ref:
                    _aggiorna_lista_spesa_intelligente(self.risultati_tv_ref)
                if hasattr(self, 'show_custom_warning'):
                    self.show_custom_warning("Aggiornamento Automatico", "Sono state disattivate alcune promozioni scadute.")
        def _sort_treeview(treeview, col, reverse):
            def convert_value(val):
                if isinstance(val, str):
                    val_clean = val.replace('‚Ç¨', '').replace(',', '.').strip()
                    try:
                        return float(val_clean)
                    except (ValueError, TypeError):
                        return str(val).lower()
                try:
                    return float(val)
                except:
                    return str(val).lower()
            is_hierarchical = treeview.cget('show') == 'tree headings' and col != '#0' and treeview.master.winfo_name() == 'frame_tv_lista'
            if is_hierarchical:
                for parent in treeview.get_children(''):
                    if treeview.tag_has('grand_total', parent): continue
                    children = treeview.get_children(parent)
                    data = [(treeview.set(child, col), child) for child in children if treeview.item(child, 'tags') != ('supermarket',)]
                    data.sort(key=lambda item: convert_value(item[0]), reverse=reverse)
                    for index, (val, child) in enumerate(data):
                        treeview.move(child, parent, index)
            else:
                data = [(treeview.set(child, col), child) for child in treeview.get_children('')]
                data.sort(key=lambda item: convert_value(item[0]), reverse=reverse)
                for index, (val, child) in enumerate(data):
                    treeview.move(child, '', index)
            treeview.heading(col, command=lambda _col=col, t=treeview: _sort_treeview(t, _col, not reverse))
        def _carica_treeview(treeview, supermercato, articoli_filtrati=None):
            from datetime import datetime
            def determina_tag_promo(data_inizio_str, data_scadenza_str, is_promo_flag):
                if not is_promo_flag:
                    return ()
                FORMATO_DATA = '%d-%m-%Y' 
                oggi = datetime.now().date()
                data_inizio = None
                data_scadenza = None
                try:
                    if data_inizio_str:
                        data_inizio = datetime.strptime(data_inizio_str, FORMATO_DATA).date()
                    if data_scadenza_str:
                        data_scadenza = datetime.strptime(data_scadenza_str, FORMATO_DATA).date()
                except (ValueError, TypeError):
                    pass 
                if not data_inizio or not data_scadenza:
                    return ('promo_in_arrivo',) 
                if data_inizio <= oggi <= data_scadenza:
                    return ('promo_attiva',)
                elif oggi < data_inizio:
                    return ('promo_in_arrivo',)
                else:
                    return () 
            treeview.delete(*treeview.get_children())
            articoli_da_mostrare = articoli_filtrati if articoli_filtrati is not None else dati_supermercati.get(supermercato, [])
            articoli_da_mostrare.sort(key=lambda x: x.get('nome', '').lower())
            for i, articolo in enumerate(articoli_da_mostrare):
                promo_attiva_str = "Si" if articolo.get('promo', False) else "No"
                prezzo_promo_raw = articolo.get('prezzo_promo')
                prezzo_promo_val = f"{float(prezzo_promo_raw):.2f}" if prezzo_promo_raw and str(prezzo_promo_raw).replace('.', '', 1).isdigit() else ""
                prezzo_normale_raw = articolo.get('prezzo')
                prezzo_normale_val = f"{float(prezzo_normale_raw):.2f}" if prezzo_normale_raw and str(prezzo_normale_raw).replace('.', '', 1).isdigit() else ""
                data_inizio = articolo.get('data_inizio_promo', '')
                data_scadenza = articolo.get('data_scadenza', '')
                is_promo = articolo.get('promo', False)
                tags_da_applicare = determina_tag_promo(data_inizio, data_scadenza, is_promo) 
                valori_tupla = (
                    articolo.get('nome', ''),
                    articolo.get('descrizione', ''),
                    articolo.get('categoria', ''),
                    prezzo_normale_val,
                    articolo.get('data_inserimento_prezzo', ''),
                    promo_attiva_str,
                    prezzo_promo_val,
                    articolo.get('quantita', ''),
                    articolo.get('data_inizio_promo', ''),
                    articolo.get('data_scadenza', '')
                )
                treeview.insert('', 'end', 
                                        iid=f"item_{supermercato}_{i}", 
                                        values=valori_tupla,
                                        tags=tags_da_applicare 
                                       )
        def calcola_prezzo_minimo_globale(nome_articolo_cercato):
            minimo = float('inf')
            supermercato_migliore = None
            for nome_superm, articoli in dati_supermercati.items():
                for articolo in articoli:
                    if articolo.get('nome', '').lower() == nome_articolo_cercato.lower():
                        try:
                            prezzo_str = articolo.get('prezzo', '9999.0')
                            prezzo = float(prezzo_str.replace(',', '.'))
                        except (ValueError, TypeError):
                            continue
                        if prezzo < minimo:
                            minimo = prezzo
                            supermercato_migliore = nome_superm
            return minimo, supermercato_migliore
        def trova_dettagli_affare_migliore(nome_articolo, superm_migliore, prezzo_minimo):
            articoli_superm = dati_supermercati.get(superm_migliore, [])
            for articolo in articoli_superm:
                nome = articolo.get('nome', '').lower()
                qta_catalogo = articolo.get('qta_catalogo', '1PZ')
                prezzo_str = articolo.get('prezzo', '9999.0')
                try:
                    prezzo = float(prezzo_str.replace(',', '.'))
                except (ValueError, TypeError):
                    continue
                if nome == nome_articolo.lower() and prezzo == prezzo_minimo:
                    return {
                        'supermercato': superm_migliore,
                        'prezzo_un': prezzo,
                        'qta_catalogo': qta_catalogo 
                    }
            raise ValueError(f"Dettagli completi dell'affare non trovati per {nome_articolo}.")
        def _cerca_articoli_crud(supermercato, treeview, ricerca_var):
            testo_ricerca = ricerca_var.get().lower().strip()
            if not treeview: return
            
            if not testo_ricerca:
                self.risultati_finali = dati_supermercati.get(supermercato, []).copy()
                _carica_treeview(treeview, supermercato, articoli_filtrati=None)
                return
            articoli_filtrati = []
            for articolo in dati_supermercati.get(supermercato, []):
                nome = articolo.get("nome", "").lower()
                categoria = articolo.get("categoria", "").lower()
                descrizione = articolo.get("descrizione", "").lower()
                
                if testo_ricerca in nome or testo_ricerca in categoria or testo_ricerca in descrizione:
                    articoli_filtrati.append(articolo)
            self.risultati_finali = articoli_filtrati 
            _carica_treeview(treeview, supermercato, articoli_filtrati=articoli_filtrati)
        def _funzione_crud(azione, supermercato, treeview, frame_input):
            if supermercato not in campi_input_refs:
                self.show_custom_warning("Selezione", "Seleziona un supermercato prima di procedere."); return
            if not treeview: return
            refs = campi_input_refs.get(supermercato)
            if not refs:
                refs = campi_input_refs.get('combo_gestione_super')
            if not refs: return
            data_ins_prezzo_ref = refs.get('data_inserimento_prezzo', tk.StringVar())
            data_inizio_promo_ref = refs.get('data_inizio_promo', tk.StringVar())
            LIMITI_CARATTERI = {
                'nome': 27,
                'descrizione': 35,
                'categoria': 24,
                'quantita': 18,
                'prezzo': 7,
                'prezzo_promo': 7
            }
            def _valida_lunghezza_campi_locale(refs):
                errori = []
                prezzo = refs['prezzo'].get().strip().replace(',', '.')
                prezzo_promo = refs['prezzo_promo'].get().strip().replace(',', '.')
                data_scadenza = refs['data_scadenza'].get().strip()
                data_ins_prezzo = data_ins_prezzo_ref.get().strip()
                data_inizio_promo = data_inizio_promo_ref.get().strip()
                promo_attiva = refs['promo_attiva'].get()
                if promo_attiva:
                    if not prezzo_promo:
                        errori.append("- Hai attivato la promozione: il 'PREZZO PROMO' √® obbligatorio.")
                    if not data_inizio_promo:
                        errori.append("- Hai attivato la promozione: la 'DATA INIZIO PROMO' √® obbligatoria.")
                    if not data_scadenza:
                        errori.append("- Hai attivato la promozione: la 'DATA SCADENZA PROMO' √® obbligatoria.")
                for key, max_len in LIMITI_CARATTERI.items():
                    if key in refs:
                        current_value = refs[key].get().strip()
                        if len(current_value) > max_len:
                            errori.append(
                                f"- Il campo '{key.upper()}' ha {len(current_value)} caratteri, "
                                f"ma il limite massimo √® {max_len}. Per favore accorcia."
                            )
                campi_prezzo = {
                    'prezzo': prezzo,
                    'prezzo_promo': prezzo_promo
                }
                for key, value in campi_prezzo.items():
                    if value:
                        try:
                            float(value)
                        except ValueError:
                            errore_visuale = value.replace('.', ',')
                            errori.append(f"- Il campo '{key.upper()}' ('{errore_visuale}') deve essere un valore numerico valido (es. 10.50 o 10,50).")
                campi_data_check = {
                    'DATA SCADENZA': data_scadenza,
                    'DATA INSERIMENTO PREZZO': data_ins_prezzo,
                    'DATA INIZIO PROMO': data_inizio_promo
                }
                formati_validi = ['%d-%m-%Y']
                date_oggetti = {}
                for key_name, date_value in campi_data_check.items():
                    if date_value:
                        data_valida = False
                        data_obj = None
                        for formato in formati_validi:
                            try:
                                data_obj = datetime.datetime.strptime(date_value, formato)
                                data_valida = True; break
                            except ValueError: continue
                            
                        if data_valida:
                            date_oggetti[key_name] = data_obj
                        else:
                            errori.append(f"- Il campo '{key_name}' ('{date_value}') non √® nel formato richiesto (GG-MM-AAAA).")
                if (promo_attiva and 'DATA INIZIO PROMO' in date_oggetti and 'DATA SCADENZA' in date_oggetti):
                    data_inizio = date_oggetti['DATA INIZIO PROMO']
                    data_fine = date_oggetti['DATA SCADENZA']
                    if data_inizio >= data_fine:
                        errori.append("- Errore Logico: La 'DATA INIZIO PROMO' deve essere precedente (minore) alla 'DATA SCADENZA PROMO'.")
                nome = refs['nome'].get().strip()
                descrizione = refs['descrizione'].get().strip()
                categoria = refs['categoria'].get().strip()
                quantita = refs['quantita'].get().strip()
                return errori, nome, descrizione, categoria, quantita, prezzo, prezzo_promo, data_ins_prezzo, data_inizio_promo
            selezione = treeview.selection()
            azione_eseguita = False
            ricerca_var_locale = ricerca_vars_crud.get(supermercato, tk.StringVar())
            if azione == 'inserisci':
                errori, nome, descrizione, categoria, quantita, prezzo, prezzo_promo, data_ins_prezzo, data_inizio_promo = _valida_lunghezza_campi_locale(refs)
                data_ins_prezzo = data_ins_prezzo.strip()
                if errori:
                    errore_messaggio = "Impossibile inserire. Si sono verificati i seguenti errori:\n" + "\n".join(errori)
                    self.show_custom_warning("Errore di Validazione", errore_messaggio); return
                promo_attiva = refs['promo_attiva'].get()
                data_scadenza = refs['data_scadenza'].get().strip()
                data_corrente = datetime.datetime.now().strftime("%d-%m-%Y")
                if not data_ins_prezzo:
                    data_ins_prezzo = data_corrente
                    refs['data_inserimento_prezzo'].set(data_corrente)
                if not nome or not prezzo: self.show_custom_warning("Errore di Input", "Nome e Prezzo sono obbligatori."); return
                nuovo_articolo = {
                    "nome": nome, "descrizione": descrizione, "categoria": categoria,
                    "prezzo": prezzo,
                    "promo": promo_attiva,
                    "prezzo_promo": prezzo_promo,
                    "supermercato": supermercato,
                    "quantita": quantita,
                    "data_scadenza": data_scadenza,
                    "data_inserimento_prezzo": data_ins_prezzo,
                    "data_inizio_promo": data_inizio_promo
                }
                dati_supermercati[supermercato].append(nuovo_articolo)
                dati_supermercati[supermercato].sort(key=lambda x: x.get('nome', '').lower())
                _svuota_campi(refs); _salva_dati_interno(dati_supermercati)
                _cerca_articoli_crud(supermercato, treeview, ricerca_var_locale)
                azione_eseguita = True
            elif azione == 'cancella':
                if not selezione: self.show_custom_warning("Selezione", "Selezionare un articolo da cancellare."); return
                if self.show_custom_askyesno("Conferma Cancellazione", "Sei sicuro di voler cancellare l'articolo selezionato?"):
                    iid_da_cancellare = selezione[0]
                    try: idx_cancellare = int(iid_da_cancellare.split('_')[-1])
                    except ValueError: self.show_custom_warning("Errore", "Impossibile identificare l'articolo da cancellare."); return
                    if 0 <= idx_cancellare < len(dati_supermercati[supermercato]):
                        dati_supermercati[supermercato].pop(idx_cancellare)
                        dati_supermercati[supermercato].sort(key=lambda x: x.get('nome', '').lower())
                        _svuota_campi(refs);
                        _salva_dati_interno(dati_supermercati)
                        _cerca_articoli_crud(supermercato, treeview, ricerca_var_locale)
                        azione_eseguita = True
            elif azione == 'modifica':
                if not selezione:
                    self.show_custom_warning("Selezione", "Per modificare, seleziona un articolo dalla lista."); return
                iid_selezionato = selezione[0]; valori_selezionati = treeview.item(iid_selezionato, 'values')
                if len(valori_selezionati) < 10:
                    self.show_custom_warning("Errore Dati", f"Articolo incompleto. Trovati {len(valori_selezionati)} campi, attesi 10."); return
                refs['nome'].set(valori_selezionati[0])
                refs['descrizione'].set(valori_selezionati[1])
                refs['categoria'].set(valori_selezionati[2])
                prezzo_normale_pulito = valori_selezionati[3].replace('‚Ç¨', '').strip()
                refs['prezzo'].set(prezzo_normale_pulito)
                data_ins_prezzo_ref.set(valori_selezionati[4])
                promo_attiva = (valori_selezionati[5] == "Si" or valori_selezionati[5] == "S√¨")
                refs['promo_attiva'].set(promo_attiva)
                prezzo_promo_pulito = valori_selezionati[6].replace('‚Ç¨', '').strip()
                refs['prezzo_promo'].set(prezzo_promo_pulito)
                refs['quantita'].set(valori_selezionati[7])
                refs['data_scadenza'].set(valori_selezionati[9])
                data_inizio_promo_ref.set(valori_selezionati[8])
                setattr(self, 'modifica_iid', iid_selezionato)
            elif azione == 'salva':
                modifica_iid_ref = getattr(self, 'modifica_iid', None) 
                if not selezione or not modifica_iid_ref or modifica_iid_ref not in selezione:
                    self.show_custom_warning("Selezione/Stato", "Nessun articolo selezionato o lo stato di modifica non √® attivo.\nSeleziona un articolo e premi 'Modifica', poi 'Salva'."); return
                errori, nome, descrizione, categoria, quantita, prezzo, prezzo_promo, data_ins_prezzo, data_inizio_promo = _valida_lunghezza_campi_locale(refs)
                if errori:
                    errore_messaggio = "Impossibile salvare. Si sono verificati i seguenti errori:\n" + "\n".join(errori)
                    self.show_custom_warning("Errore di Validazione", errore_messaggio); return
                promo_attiva = refs['promo_attiva'].get()
                data_corrente = datetime.datetime.now().strftime("%d-%m-%Y")
                if not data_ins_prezzo:
                    data_ins_prezzo = data_corrente
                    refs['data_inserimento_prezzo'].set(data_corrente)
                if not promo_attiva:
                    data_inizio_promo = ""
                    refs['data_inizio_promo'].set("")
                    data_scadenza = ""
                    refs['data_scadenza'].set("")
                    prezzo_promo = ""
                    refs['prezzo_promo'].set("")
                data_scadenza = refs['data_scadenza'].get().strip()
                if not nome or not prezzo: self.show_custom_warning("Errore di Input", "Nome e Prezzo sono obbligatori per il salvataggio."); return
                iid_da_salvare = selezione[0]
                try: idx_da_salvare = int(iid_da_salvare.split('_')[-1])
                except ValueError: self.show_custom_warning("Errore", "Impossibile identificare l'articolo da salvare."); return
                if 0 <= idx_da_salvare < len(dati_supermercati[supermercato]):
                    dati_supermercati[supermercato][idx_da_salvare] = {
                        "nome": nome, "descrizione": descrizione, "categoria": categoria,
                        "prezzo": prezzo,
                        "promo": promo_attiva,
                        "prezzo_promo": prezzo_promo,
                        "supermercato": supermercato,
                        "quantita": quantita,
                        "data_scadenza": data_scadenza,
                        "data_inserimento_prezzo": data_ins_prezzo,
                        "data_inizio_promo": data_inizio_promo
                    }
                    dati_supermercati[supermercato].sort(key=lambda x: x.get('nome', '').lower())
                    _salva_dati_interno(dati_supermercati); _svuota_campi(refs);
                    delattr(self, 'modifica_iid')
                    _cerca_articoli_crud(supermercato, treeview, ricerca_var_locale)
                    azione_eseguita = True
            if azione_eseguita and self.risultati_tv_ref:
                _aggiorna_lista_spesa_intelligente(self.risultati_tv_ref)
        def _svuota_supermercato(supermercato, treeview):
            if not supermercato or supermercato == "Seleziona Supermercato":
                self.show_custom_warning("Selezione", "Seleziona un supermercato prima di svuotare."); return
            if self.show_custom_askyesno("Azzeramento Dati", f"‚ö†Ô∏è Sei sicuro di voler cancellare TUTTI gli articoli\n dal supermercato '{supermercato}'?"):
                dati_supermercati[supermercato] = []
                _salva_dati_interno(dati_supermercati)
                _carica_treeview(treeview, supermercato)
                if self.risultati_tv_ref:
                    _aggiorna_lista_spesa_intelligente(self.risultati_tv_ref)
                self.show_custom_warning("Successo", f"Database del supermercato '{supermercato}' azzerato.")
        def _cerca_articoli(testo_ricerca, tv_risultati):
            def _parse_data_per_confronto(data_str):
                if not data_str:
                    return None
                for fmt in ['%d-%m-%Y']:
                    try:
                        return datetime.datetime.strptime(data_str, fmt).date()
                    except ValueError:
                        continue
                return None
            if not tv_risultati: return
            tv_risultati.delete(*tv_risultati.get_children())
            testo_ricerca = testo_ricerca.lower().strip()
            articoli_da_mostrare = []
            filtro_superm_selezionato = filtro_supermercato_confronto_var.get()
            if filtro_superm_selezionato == "Tutti i supermercati" or filtro_superm_selezionato == "Seleziona Supermercato":
                supermercati_da_cercare = dati_supermercati.keys()
                cerca_il_piu_conveniente = True
            else:
                supermercati_da_cercare = [filtro_superm_selezionato]
                cerca_il_piu_conveniente = False
            oggi = datetime.date.today()
            for supermercato in supermercati_da_cercare:
                if supermercato not in dati_supermercati: continue
                articoli = dati_supermercati[supermercato]
                for articolo in articoli:
                    nome = articolo.get("nome", "").strip()
                    categoria = articolo.get("categoria", "").strip()
                    descrizione = articolo.get("descrizione", "").strip()
                    if testo_ricerca and not (testo_ricerca in nome.lower() or testo_ricerca in categoria.lower() or testo_ricerca in descrizione.lower()):
                        continue
                    prezzo_base_str = articolo.get("prezzo", "")
                    prezzo_promo_str = articolo.get("prezzo_promo", "")
                    prezzo_effettivo = prezzo_base_str
                    promozione_valida = False
                    promozione_futura = False
                    status_promo = ""
                    if articolo.get("promo", False) and prezzo_promo_str:
                        data_inizio = _parse_data_per_confronto(articolo.get("data_inizio_promo"))
                        data_fine = _parse_data_per_confronto(articolo.get("data_scadenza"))
                        if data_inizio:
                            if oggi < data_inizio:
                                status_promo = "Promo dal " + articolo.get('data_inizio_promo')
                                promozione_futura = True
                            elif oggi >= data_inizio:
                                if not data_fine or oggi <= data_fine:
                                    promozione_valida = True
                                    status_promo = "Promo Attiva"
                                    prezzo_effettivo = prezzo_promo_str
                                else:
                                    status_promo = "Promo scaduta"
                    if not prezzo_effettivo: continue
                    try:
                        prezzo_float = float(str(prezzo_effettivo).replace(',', '.'))
                        prezzo_base_float = float(str(prezzo_base_str).replace(',', '.')) if prezzo_base_str else None
                        prezzo_base_finale = f"{prezzo_base_float:.2f}" if prezzo_base_float else ""
                        prezzo_finale_formattato = f"{prezzo_float:.2f}"
                        articoli_da_mostrare.append({
                            "nome": nome,
                            "quantita": articolo.get("quantita", ""),
                            "supermercato": supermercato,
                            "descrizione": descrizione,
                            "categoria": categoria,
                            "prezzo_float": prezzo_float,
                            "prezzo_formattato": prezzo_finale_formattato,
                            "dettagli": status_promo,
                            "is_promo_valida": promozione_valida,
                            "is_promo_futura": promozione_futura,
                            "prezzo_base_str": prezzo_base_finale,
                            "data_inizio_promo_str": articolo.get("data_inizio_promo", ""),
                            "data_scadenza_str": articolo.get("data_scadenza", ""),
                        })
                    except (ValueError, TypeError):
                        continue
            articoli_raggruppati_per_nome = defaultdict(list)
            for offerta in articoli_da_mostrare:
                chiave = (offerta['nome'].lower(), offerta['quantita'].lower())
                articoli_raggruppati_per_nome[chiave].append(offerta)
            tutti_gli_articoli_ordinati = sorted(articoli_da_mostrare, key=lambda x: x['nome'].strip().lower())
            articoli_inseriti_set = set()
            for offerta in tutti_gli_articoli_ordinati:
                chiave_comparazione = (offerta['nome'].lower(), offerta['quantita'].lower())
                iid_val = f"{offerta['nome']}|{offerta['quantita']}|{offerta['supermercato']}|{offerta['prezzo_float']}"
                if iid_val in articoli_inseriti_set: continue
                articoli_inseriti_set.add(iid_val)
                indicatore = ""
                is_strictly_cheaper = False
                if cerca_il_piu_conveniente:
                    prezzi_simili = [o['prezzo_float'] for o in articoli_raggruppati_per_nome.get(chiave_comparazione, [])]
                    min_price = min(prezzi_simili) if prezzi_simili else float('inf')
                    is_min_price = (offerta['prezzo_float'] == min_price)
                    count_min_price = sum(1 for p in prezzi_simili if p == min_price)
                    is_strictly_cheaper = (is_min_price and count_min_price < len(prezzi_simili))
                promo_icona = ""
                if offerta.get("is_promo_valida", False):
                    promo_icona = "Promoüî•" 
                elif offerta.get("is_promo_futura", False):
                    promo_icona = "Promoüî•"
                elif offerta['dettagli'] and 'scaduta' in offerta['dettagli'].lower():
                    promo_icona = "Promo‚è≥"
                miglior_prezzo_icona = ""
                if cerca_il_piu_conveniente and is_strictly_cheaper:
                    miglior_prezzo_icona = "Top‚≠ê"
                indicatore_testo = []
                if promo_icona:
                    indicatore_testo.append(promo_icona)
                if miglior_prezzo_icona:
                    indicatore_testo.append(miglior_prezzo_icona)
                if offerta['dettagli'] and 'attiva' not in offerta['dettagli'].lower():
                    indicatore_testo.append(offerta['dettagli'])
                indicatore = " ".join(indicatore_testo).strip()
                tags_list = []
                if offerta.get("is_promo_valida", False):
                    tags_list.append('promo_rossa')
                elif offerta.get("is_promo_futura", False):
                    tags_list.append('promo_gialla')
                if cerca_il_piu_conveniente and is_strictly_cheaper and not tags_list:
                    tags_list.append('piu_conveniente')
                tags_da_applicare = tuple(tags_list)
                values_to_insert = (
                    offerta["nome"],
                    offerta["quantita"],
                    offerta["supermercato"],
                    offerta["descrizione"],
                    offerta["categoria"],
                    f'{offerta["prezzo_formattato"]}',
                    indicatore,
                    offerta["data_inizio_promo_str"],
                    offerta["data_scadenza_str"],
                    f'{offerta["prezzo_base_str"]}'
                )
                tv_risultati.insert(
                    parent='', index='end', iid=iid_val,
                    values=values_to_insert, 
                    tags=tags_da_applicare
                )
            self.risultati_finali = tutti_gli_articoli_ordinati
        def _ricarica_lista_spesa(tv_lista):
            tv_lista.delete(*tv_lista.get_children())
            totale_generale = 0.0
            gruppi_supermercati = defaultdict(lambda: [])
            for chiave, dati in lista_spesa_data.items():
                gruppi_supermercati[dati['supermercato']].append(dati)
            for superm in sorted(gruppi_supermercati.keys()):
                articoli = gruppi_supermercati[superm]
                articoli.sort(key=lambda x: x['nome'])
                totale_super = 0.0
                iid_super = f"group_{superm}"
                tv_lista.insert('', 'end', iid=iid_super, text=f"üõí {superm}", tags=('supermarket',))
                for dati in articoli:
                    totale_articolo = dati['qta_int'] * dati['prezzo_un']
                    totale_super += totale_articolo
                    chiave_lista = f"{dati['nome']}|{superm}"
                    iid_articolo = f"item_{chiave_lista}"
                    tv_lista.insert(
                        iid_super, 'end', iid=iid_articolo, text=dati['nome'],
                        values=(dati['qta_catalogo'], dati['qta_int'], f"{dati['prezzo_un']:.2f}",
                                f"{totale_articolo:.2f}", dati['supermercato'])
                    )
                tv_lista.item(iid_super, values=("", "", "TOTALE PARZIALE:", f"{totale_super:.2f}", ""), tags=('supermarket',))
                totale_generale += totale_super
            tv_lista.insert('', 'end', text="TOTALE GENERALE SPESA:", values=("", "", "", f"{totale_generale:.2f}", ""), tags=('grand_total',))
            tv_lista.tag_configure('grand_total', font=('Arial', 10, 'bold'), background='#E0F7FA')
            tv_lista.tag_configure('supermarket', font=('Arial', 10, 'bold'), foreground='dodgerblue')
        def _aggiungi_a_lista_spesa(event, tv_lista, tv_risultati_ref):
            def mostra_avviso_conferma(title, message):
                root_window = tv_risultati_ref.winfo_toplevel()
                for child in root_window.winfo_children():
                    if isinstance(child, tk.Toplevel):
                        child.destroy()
                TIMEOUT_MS = 10000
                risultato = {"value": 'ANNULLA'}
                dialog = tk.Toplevel(tv_risultati_ref.winfo_toplevel(), bg="orange")
                dialog.withdraw()
                dialog.title(title)
                dialog.resizable(False, False)
                dialog.attributes("-topmost", True)
                dialog.update_idletasks()
                w, h = 480, 160
                x = dialog.winfo_screenwidth() // 2 - w // 2
                y = dialog.winfo_screenheight() // 2 - h // 2
                dialog.geometry(f"{w}x{h}+{x}+{y}")
                dialog.deiconify()
                text_label = tk.Text(
                    dialog, 
                    font=("Arial", 10), 
                    height=5, 
                    width=55, 
                    padx=16, 
                    pady=12, 
                    bg="orange", 
                    relief="flat",
                    borderwidth=0,
                    highlightthickness=0
                )
                text_label.insert(tk.END, message)
                start_index = "1.0"
                while True:
                    start_bold = text_label.search('**', start_index, stopindex=tk.END)
                    if not start_bold: break
                    end_bold = text_label.search('**', f"{start_bold}+2c", stopindex=tk.END)
                    if not end_bold: break
                    text_label.tag_add("bold", f"{start_bold}+2c", end_bold)
                    text_label.delete(start_bold, f"{start_bold}+2c")
                    text_label.delete(end_bold, f"{end_bold}-2c")
                    start_index = end_bold
                text_label.tag_config("bold", font=("Arial", 10, "bold"))
                text_label.config(state=tk.DISABLED)
                text_label.pack()
                btns = tk.Frame(dialog, bg="orange")
                btns.pack(pady=(0,10))
                def aggiungi_selezionato():
                    risultato["value"] = 'SELEZIONATO'
                    dialog.destroy()
                def aggiungi_migliore():
                    risultato["value"] = 'MIGLIORE'
                    dialog.destroy()
                def annulla():
                    risultato["value"] = 'ANNULLA'
                    dialog.destroy()
                dialog.bind('<Escape>', lambda e: annulla())
                b1 = ttk.Button(btns, text="Aggiungi Selezionato", style="Rosso.TButton", command=aggiungi_selezionato)
                b2 = ttk.Button(btns, text="Aggiungi Affare Migliore", style="Verde.TButton", command=aggiungi_migliore)
                b3 = ttk.Button(btns, text="Annulla", style="Giallo.TButton", command=annulla)
                b1.grid(row=0, column=0, padx=8)
                b2.grid(row=0, column=1, padx=8)
                b3.grid(row=0, column=2, padx=8)
                dialog.focus_set()
                dialog.grab_set()
                if TIMEOUT_MS > 0:
                    dialog.after(TIMEOUT_MS, annulla)
                dialog.wait_window()
                return risultato["value"]
            selezione = tv_risultati_ref.selection()
            if not selezione: return
            iid_selezionato = selezione[0]
            try:
                nome, qta_catalogo_base, superm_base, prezzo_str_base = iid_selezionato.split('|')
                prezzo_float_base = float(prezzo_str_base)
                nome = nome.strip()
            except ValueError:
                return
            prezzo_minimo, superm_migliore = calcola_prezzo_minimo_globale(nome)
            azione_richiesta = 'SELEZIONATO'
            if prezzo_minimo < prezzo_float_base and superm_migliore != superm_base:
                titolo_custom = "üö® CONVIENE ALTROVE! üö®"
                messaggio_custom = (
                    f"L'articolo '{nome.upper()}' costa {prezzo_float_base:.2f} da {superm_base}.\n\n"
                    f"Trovato a {prezzo_minimo:.2f} presso {superm_migliore}."
                    f"\n\nQuale articolo vuoi aggiungere alla lista?"
                )
                azione_richiesta = mostra_avviso_conferma(titolo_custom, messaggio_custom)
            if azione_richiesta == 'ANNULLA':
                return
            superm_finale = superm_base
            prezzo_float_finale = prezzo_float_base
            qta_catalogo_finale = qta_catalogo_base
            if azione_richiesta == 'MIGLIORE':
                try:
                    dettagli_migliore = trova_dettagli_affare_migliore(nome, superm_migliore, prezzo_minimo)
                    superm_finale = dettagli_migliore['supermercato']
                    prezzo_float_finale = dettagli_migliore['prezzo_un']
                    qta_catalogo_finale = dettagli_migliore['qta_catalogo']
                except Exception as e:
                    errore_dialog = tk.Toplevel(tv_risultati_ref.winfo_toplevel(), bg="yellow")
                    errore_dialog.title("Errore Dati Critico")
                    tk.Label(errore_dialog, text=f"ERRORE: Impossibile recuperare i dettagli dell'affare migliore.\n{e}", fg="red", bg="yellow").pack(padx=15, pady=10)
                    ttk.Button(errore_dialog, text="OK", command=errore_dialog.destroy).pack(pady=5)
                    errore_dialog.grab_set()
                    return
            chiave_lista = f"{nome}|{superm_finale}"
            quantita_precedente = lista_spesa_data.get(chiave_lista, {}).get('qta_int', 0)
            nuova_quantita_int = quantita_precedente + 1
            if quantita_precedente > 0:
                azione_testo = "Aggiornato"
            else:
                azione_testo = "Aggiunto"
            lista_spesa_data[chiave_lista] = {
                'nome': nome,
                'qta_catalogo': qta_catalogo_finale,
                'qta_int': nuova_quantita_int,
                'prezzo_un': prezzo_float_finale,
                'supermercato': superm_finale
            }
            messaggio_notifica = (
                f"‚úì Articolo {azione_testo} in lista!\n"
                f"'{nome}' ({superm_finale})\n"
                f"Quantit√† Totale: {nuova_quantita_int} pezzi"
            )
            show_temporary_notification(tv_risultati_ref.winfo_toplevel(),
                "Conferma Lista",
                messaggio_notifica)
            _ricarica_lista_spesa(tv_lista)
        def show_temporary_notification(parent, title, message, duration_ms=3000):
            popup_note = tk.Toplevel(parent)
            popup_note.title(title)
            popup_note.overrideredirect(True) 
            popup_note.attributes("-topmost", True)
            popup_note.config(bg="orange")
            popup_note.withdraw() 
            parent.update_idletasks()
            width = 300
            height = 80
            parent_width = parent.winfo_width()
            parent_height = parent.winfo_height()
            parent_x = parent.winfo_x()
            parent_y = parent.winfo_y()
            x = parent_x + (parent_width // 2) - (width // 2)
            y = parent_y + (parent_height // 2) - (height // 2)
            popup_note.geometry(f"{width}x{height}+{x}+{y}")
            label = tk.Label(popup_note, text=message, font=("Arial", 10, "bold"), 
                            justify="center", padx=10, pady=10, bg="orange", fg="black")
            label.pack(expand=True, fill='both')
            popup_note.deiconify() 
            popup_note.after(duration_ms, popup_note.destroy)
        def _rimuovi_articolo_da_lista(tv_lista):
            selezione = tv_lista.selection()
            if not selezione: 
                show_temporary_notification(
                    tv_lista.winfo_toplevel(), 
                    "Attenzione", 
                    "‚ö†Ô∏è Seleziona articolo o gruppo da rimuovere.",
                    duration_ms=1500
                )
                return
            iid_selezionato = selezione[0]
            if iid_selezionato.startswith('item_'):
                try: 
                    chiave_lista = iid_selezionato.split('item_')[1]
                except IndexError: 
                    return
                if chiave_lista in lista_spesa_data:
                    dettagli_articolo = lista_spesa_data[chiave_lista]
                    nome_articolo = dettagli_articolo['nome']
                    superm_articolo = dettagli_articolo['supermercato']
                    qta_articolo = dettagli_articolo['qta_int']
                    del lista_spesa_data[chiave_lista]
                    _ricarica_lista_spesa(tv_lista)
                    messaggio_notifica = (
                        f"üìÑ Articolo Rimosso dalla lista.\n"
                        f"'{nome_articolo}' ({superm_articolo})\n"
                        f"Quantit√†: {qta_articolo} pezzi"
                    )
                    show_temporary_notification(tv_lista.winfo_toplevel(), 
                                                "Conferma Rimozione", 
                                                messaggio_notifica,
                                                duration_ms=2500)
            elif iid_selezionato.startswith('group_'):
                if self.show_custom_askyesno("Conferma", "Sei sicuro di voler rimuovere tutti gli articoli\n di questo supermercato dalla lista?"):
                    superm = iid_selezionato.split('group_')[1]
                    chiavi_da_rimuovere = [k for k, v in lista_spesa_data.items() if v['supermercato'] == superm]
                    if chiavi_da_rimuovere:
                        for chiave in chiavi_da_rimuovere: 
                            del lista_spesa_data[chiave]
                        _ricarica_lista_spesa(tv_lista)
                        messaggio_notifica = f"üìÑ Gruppo Rimosso dalla lista.\nSupermercato: {superm}"
                        show_temporary_notification(tv_lista.winfo_toplevel(), 
                                                    "Conferma Rimozione", 
                                                    messaggio_notifica,
                                                    duration_ms=2500)
        def _svuota_lista_spesa(tv_lista):
            if not lista_spesa_data:
                show_temporary_notification(
                    tv_lista.winfo_toplevel(), 
                    "Attenzione", 
                    "‚ö†Ô∏è La lista della spesa √® gi√† vuota.",
                    duration_ms=2000
                )
                return
            if self.show_custom_askyesno("Conferma", "Sei sicuro di voler rimuovere TUTTI gli articoli\n dalla lista spesa?"):
                tv_lista.delete(*tv_lista.get_children())
                lista_spesa_data.clear()
                _ricarica_lista_spesa(tv_lista)
                show_temporary_notification(
                tv_lista.winfo_toplevel(), 
                "Lista Svuotata", 
                "üìÑ La lista della spesa √® stata svuotata.",
                duration_ms=2000,
            )
        def _on_edit_quantity(event, tv_lista):
            region = tv_lista.identify("region", event.x, event.y)
            col = tv_lista.identify_column(event.x)
            
            if region == "cell" and col == "#2":
                row_id = tv_lista.identify_row(event.y)
                if not row_id.startswith('item_'): return
                try: chiave_lista = row_id.split('item_')[1]
                except: return
                if chiave_lista not in lista_spesa_data: return
                current_value = tv_lista.item(row_id)['values'][1]
                entry_editor = ttk.Entry(tv_lista, width=10)
                entry_editor.insert(0, str(current_value))
                x, y, width, height = tv_lista.bbox(row_id, col)
                entry_editor.place(x=x, y=y, width=width, height=height)
                entry_editor.focus_set()
                def on_entry_confirm(e):
                    try:
                        new_qta = int(entry_editor.get().strip())
                        if new_qta > 0:
                            lista_spesa_data[chiave_lista]['qta_int'] = new_qta
                            _ricarica_lista_spesa(tv_lista)
                        elif new_qta == 0:
                            del lista_spesa_data[chiave_lista]
                            _ricarica_lista_spesa(tv_lista)
                    except ValueError:
                        self.show_custom_warning("Errore", "La quantit√† deve essere un numero intero valido.")
                    finally:
                        entry_editor.destroy()
                entry_editor.bind('<Return>', on_entry_confirm)
                entry_editor.bind('<FocusOut>', on_entry_confirm)
        def _genera_testo_esportazione():
            import datetime
            data_esportazione = datetime.datetime.now().strftime("%d/%m/%Y")
            WIDTH_NOME = 45
            WIDTH_QTA = 4
            WIDTH_PREZZO_BLOCCO = 30
            testo = f"CHECK-OUT: Spesa Ottimizzata ({data_esportazione})\n\n"
            totale_generale = 0.0
            gruppi_supermercati = defaultdict(lambda: [])
            for chiave, dati in lista_spesa_data.items(): gruppi_supermercati[dati['supermercato']].append(dati)
            for superm in sorted(gruppi_supermercati.keys()):
                articoli = gruppi_supermercati[superm]
                articoli.sort(key=lambda x: x['nome'])
                testo += f"[{superm.upper()}]\n"
                totale_super = 0.0
                for dati in articoli:
                    totale_articolo = dati['qta_int'] * dati['prezzo_un']
                    totale_super += totale_articolo
                    linea = "[ ] "
                    nome_completo = f"{dati['nome']} ({dati['qta_catalogo']})"
                    linea += f"{nome_completo:<{WIDTH_NOME}}"
                    qta_comprare = f"x {dati['qta_int']} pz"
                    linea += f"{qta_comprare:<{WIDTH_QTA + 4}}"
                    prezzo_blocco = f"({dati['prezzo_un']:.2f}) - Tot: {totale_articolo:.2f}"
                    linea += f"{prezzo_blocco:>{WIDTH_PREZZO_BLOCCO}}\n"
                    testo += linea
                testo += f"  TOTALE PARZIALE {superm}: {totale_super:.2f}\n\n"
                totale_generale += totale_super
            testo += f"\n"
            testo += f"TOTALE GENERALE STIMATO: {totale_generale:.2f}\n"
            return testo
        def _mostra_anteprima_esportazione():
            anteprima_text = _genera_testo_esportazione()
            preview_popup = tk.Toplevel(popup, bg=self.COLOR_TOPLEVEL)
            preview_popup.title("Anteprima Esportazione Lista Spesa")
            preview_popup.geometry("1050x600")
            screen_width = preview_popup.winfo_screenwidth()
            screen_height = preview_popup.winfo_screenheight()
            x = (screen_width - 1050) // 2
            y = (screen_height - 600) // 2
            preview_popup.geometry(f"1050x600+{x}+{y}")
            preview_popup.after(10, lambda: preview_popup.focus_force())
            preview_popup.bind('<Escape>', lambda e: preview_popup.destroy())
            text_area = tk.Text(preview_popup, wrap='word', font=('Courier', 10), padx=10, pady=10)
            text_area.insert('1.0', anteprima_text)
            text_area.config(state='disabled')
            text_area.pack(fill='both', expand=True, padx=10, pady=10)
            frame_btn = tk.Frame(preview_popup, bg=self.COLOR_TOPLEVEL); frame_btn.pack(pady=(0, 10))
            ttk.Button(frame_btn, text="Chiudi", command=preview_popup.destroy, style='Giallo.TButton').pack(side='right', padx=5)
            ttk.Button(frame_btn, text="Esporta", style='Verde.TButton',
                        command=lambda: _esporta_su_file(anteprima_text, preview_popup)).pack(side='left', padx=5)
            ttk.Button(frame_btn, text="üìÑ Stampa", style='Blu.TButton', command=lambda: self._stampa_lista_diretta(anteprima_text, self.show_custom_warning)).pack(side='left', padx=5)
        def _esporta_su_file(content_text, preview_popup):
            preview_popup.destroy()
            now = datetime.date.today()
            default_filename = f"Lista_Spesa_{now.day:02d}_{now.month:02d}_{now.year}.txt"
            f = filedialog.asksaveasfilename(
                defaultextension=".txt", filetypes=[("File txt", "*.txt")], title="Salva la Lista Spesa su File",
                initialdir=EXPORT_FILES, confirmoverwrite=False, initialfile=default_filename, parent=popup
            )
            if f:
                try:
                    with open(f, 'w', encoding='utf-8') as file_handle: file_handle.write(content_text)
                    self.show_custom_warning("Successo", f"‚úì Lista spesa salvata con successo in:\n{f}")
                except Exception as e:
                    self.show_custom_warning("Errore", f"‚ùå Impossibile salvare il file:\n{e}")
            
        def _aggiorna_lista_spesa_intelligente(tv_risultati):
            if tv_risultati:
                _cerca_articoli(ricerca_var_confronto.get(), tv_risultati)
                if hasattr(self, 'risultati_finali') and self.risultati_finali:
                    self.risultati_finali.sort(key=lambda x: x.get('nome', '').strip().lower())
        def _on_supermercato_change(event, combo, treeview_crud, frame_input, ricerca_var):
            selected_superm = combo.get()
            refs_combo = campi_input_refs.get('combo_gestione_super')
            if selected_superm == "Seleziona Supermercato":
                treeview_crud.delete(*treeview_crud.get_children())
                _svuota_campi(refs_combo) 
                return
            if selected_superm not in campi_input_refs:
                refs = {
                    'nome': tk.StringVar(), 'descrizione': tk.StringVar(), 'categoria': tk.StringVar(),
                    'prezzo': tk.StringVar(), 'promo_attiva': tk.BooleanVar(), 'prezzo_promo': tk.StringVar(),
                    'quantita': tk.StringVar(), 'data_scadenza': tk.StringVar(),
                    'data_inserimento_prezzo': tk.StringVar(),
                    'data_inizio_promo': tk.StringVar()
                }
                campi_input_refs[selected_superm] = refs
            refs_superm = campi_input_refs[selected_superm]
            for key in refs_superm:
                refs_combo[key].set(refs_superm[key].get())
                refs_superm[key] = refs_combo[key] 
            if CATEGORIE_PREDEFINITE:
                if not refs_combo['categoria'].get().strip():
                     refs_combo['categoria'].set(CATEGORIE_PREDEFINITE[0])
            if selected_superm not in ricerca_vars_crud:
                ricerca_vars_crud[selected_superm] = tk.StringVar()
            ricerca_var.set(ricerca_vars_crud[selected_superm].get())
            _cerca_articoli_crud(selected_superm, treeview_crud, ricerca_vars_crud[selected_superm])
        def _esegui_rinomina_supermercato(combo, treeview_crud, ricerca_var):
            nonlocal SUPERMERCATI, dati_supermercati, campi_input_refs
            old_superm = combo.get()
            if old_superm == "Seleziona Supermercato" or not old_superm:
                self.show_custom_warning("Modifica Supermercato", "Seleziona prima un supermercato da rinominare.")
                return
            rinomina_popup = tk.Toplevel(popup, bg=self.COLOR_TOPLEVEL)
            rinomina_popup.title(f"Rinomina {old_superm}")
            rinomina_popup.transient(popup)
            rinomina_popup.grab_set()
            ttk.Label(rinomina_popup, text="Nuovo nome:", style="Popup.TLabel").pack(padx=10, pady=(10, 0))
            new_name_var = tk.StringVar(value=old_superm)
            entry = ttk.Entry(rinomina_popup, textvariable=new_name_var, width=30)
            entry.pack(padx=10, pady=5)
            entry.focus_set()
            def on_confirm(e=None):
                nonlocal SUPERMERCATI
                new_superm = new_name_var.get().strip()
                if not new_superm or new_superm == old_superm:
                    rinomina_popup.destroy(); return                
                if new_superm in dati_supermercati:
                    self.show_custom_warning("Errore", f"Il supermercato '{new_superm}' esiste gi√†."); return
                if old_superm in dati_supermercati:
                    articoli = dati_supermercati.pop(old_superm)
                    dati_supermercati[new_superm] = articoli
                    for articolo in dati_supermercati[new_superm]: 
                        articolo['supermercato'] = new_superm                    
                    try: 
                        index = SUPERMERCATI.index(old_superm)
                        SUPERMERCATI[index] = new_superm
                    except ValueError: pass
                    if old_superm in campi_input_refs: campi_input_refs[new_superm] = campi_input_refs.pop(old_superm)
                    if old_superm in ricerca_vars_crud: ricerca_vars_crud[new_superm] = ricerca_vars_crud.pop(old_superm)
                    combo['values'] = tuple(["Seleziona Supermercato"] + sorted(SUPERMERCATI))
                    combo.set(new_superm)
                    rinomina_popup.destroy()
                    _carica_treeview(treeview_crud, new_superm)
                    _salva_dati_interno(dati_supermercati)
                    if self.risultati_tv_ref: _aggiorna_lista_spesa_intelligente(self.risultati_tv_ref)
                    self.show_custom_warning("Successo", f"Supermercato rinominato in '{new_superm}'.")
            btn_frame = ttk.Frame(rinomina_popup, style="Popup.TFrame")
            btn_frame.pack(pady=(10, 10))
            ttk.Button(btn_frame, text="Annulla", command=rinomina_popup.destroy, style='Giallo.TButton').pack(side='left', padx=5)
            ttk.Button(btn_frame, text="Salva", command=on_confirm, style='Verde.TButton').pack(side='left', padx=5)
            entry.bind("<Return>", on_confirm)
            rinomina_popup.update_idletasks()
            w, h = rinomina_popup.winfo_reqwidth(), rinomina_popup.winfo_reqheight()
            x = popup.winfo_rootx() + (popup.winfo_width() // 2) - (w // 2)
            y = popup.winfo_rooty() + (popup.winfo_height() // 2) - (h // 2)
            rinomina_popup.geometry(f'+{x}+{y}')

        def import_supermercati_db():
            popup.lift() 
            popup.focus_force() 
            SUPERMERCATI_DB = os.path.join(DB_DIR, "supermercati.json")
            file = filedialog.askopenfilename(
                parent=popup,
                title="Importa Database Supermercati",
                defaultextension=".json",
                initialdir=EXP_DB,
                filetypes=[("File JSON", "*supermercati.json"), ("Tutti i file", "*.*")]
            )
            if file:
                if not self.show_custom_askyesno("Conferma Ripristino", "\nSovrascrivere il database attuale dei supermercati?\n"):
                    return
                try:
                    with open(file, "r", encoding="utf-8") as fsrc:
                        dati_importati = json.load(fsrc) 
                    with open(SUPERMERCATI_DB, "w", encoding="utf-8") as fdst:
                        json.dump(dati_importati, fdst, indent=4, ensure_ascii=False) 
                    _carica_dati_interno()
                    self.after(200, _controlla_scadenza_promo)
                    if popup.winfo_exists():
                        popup.destroy()
                        self.deiconify()
                        self.after(0, self.imp_entry.focus_set)
                        self.spesa_supermercato()
                    self.show_custom_warning("Importazione completata", f"\nDatabase Supermercati ripristinato da:\n\n {file}\n")
                except json.JSONDecodeError:
                    self.show_custom_warning("Errore", f"Errore di lettura JSON. Il file selezionato non √® un file di database valido.")
                except Exception as e:
                    self.show_custom_warning("Errore", f"Errore durante il ripristino: {e}")
        def export_supermercati_db():
            popup.lift() 
            popup.focus_force() 
            SUPERMERCATI_DB = os.path.join(DB_DIR, "supermercati.json")
            now = datetime.date.today()
            default_dir = EXP_DB
            default_filename = f"{now.day:02d}-{now.month:02d}-{now.year}-supermercati.json"
            file = filedialog.asksaveasfilename(
                parent=popup,
                title="Esporta Database Supermercati",
                defaultextension=".json",
                initialdir=default_dir,
                initialfile=default_filename,
                confirmoverwrite=False,
                filetypes=[("File JSON", "*supermercati.json"), ("Tutti i file", "*.*")]
            )
            if file:
                try:
                    with open(SUPERMERCATI_DB, "r", encoding="utf-8") as fsrc:
                        dbdata = fsrc.read()
                    with open(file, "w", encoding="utf-8") as fdst:
                        fdst.write(dbdata)
                    self.show_custom_warning("Esportazione completata", f"Database Supermercati esportato in {file}")
                except FileNotFoundError:
                    self.show_custom_warning("Errore", "Impossibile trovare il database sorgente dei supermercati.")
                except Exception as e:
                    self.show_custom_warning("Errore", f"Errore durante l'esportazione: {e}")

        def info_popup():
            popup = tk.Toplevel(frame_gestione, width=550) 
            popup.title("Informazioni sull'Importazione")
            popup.withdraw() 
            popup.transient(frame_gestione)
            messaggio = (
                "Questo programma gestisce i prezzi dei supermercati. üìä\n\n"
                
                "Non √® indispensabile inserire tutti i prezzi a mano. \nIl database "
                "prevede l'importazione tramite scontrini digitali.\n\n"
            )
            frame_contenuto = ttk.Frame(popup, padding="2")
            frame_contenuto.pack(expand=True, fill='both')
            ttk.Label(
                frame_contenuto, 
                text=messaggio, 
                wraplength=400,
                justify='left'
            ).pack(pady=10)
            ttk.Button(frame_contenuto, text="OK", command=popup.destroy, style="Giallo.TButton").pack(pady=10)
            frame_gestione.update_idletasks()
            popup.update_idletasks() 
            width = popup.winfo_width()
            height = popup.winfo_height()
            MIN_W = 450 
            MIN_H = 200
            if width < MIN_W or height < MIN_H:
                 width = max(width, MIN_W)
                 height = max(height, MIN_H)
            parent_x = frame_gestione.winfo_rootx() 
            parent_y = frame_gestione.winfo_rooty()
            parent_width = frame_gestione.winfo_width()
            parent_height = frame_gestione.winfo_height()
            x = parent_x + (parent_width // 2) - (width // 2)
            y = parent_y + (parent_height // 2) - (height // 2)
            popup.geometry(f'{width}x{height}+{x}+{y}') 
            popup.deiconify() 
            popup.grab_set() 
            popup.bind("<Escape>", lambda e: popup.destroy())
            
        _carica_dati_interno()
        self.after(200, _controlla_scadenza_promo)
        popup = tk.Toplevel(self.master, bg=self.COLOR_TOPLEVEL)
        barra_menu_popup = tk.Menu(popup, bg=self.MENU_BG_DARK, fg=self.MENU_FG_LIGHT, activebackground=self.MENU_ACT_BG_COLOR, activeforeground=self.MENU_ACT_FG_COLOR)
        barra_menu_popup.config(bg=self.MENU_BG_DARK, fg=self.MENU_FG_LIGHT)
        popup.config(menu=barra_menu_popup) 
        menu_db = tk.Menu(barra_menu_popup, tearoff=0,bg=self.MENU_BG, fg=self.MENU_FG_LIGHT, activebackground=self.MENU_ACT_BG_COLOR, activeforeground=self.MENU_ACT_FG_COLOR)
        barra_menu_popup.add_cascade(label="üíæ Database", menu=menu_db)       
        menu_db.add_command(label="üì§ Esporta Supermercati", command=export_supermercati_db)
        menu_db.add_command(label="üì• Importa Supermercati", command=import_supermercati_db)
        menu_db.add_separator()
        menu_db.add_command(label="‚¨áÔ∏è Controlla Aggiornamento Editor Scontrini", command=self.check_supermarket_update_manuale)
        menu_db.add_command(label="‚¨áÔ∏è Forza Aggiornamento Editor Scontrini", command=self._scarica_editor_esterno)
        menu_db.add_command(label="‚¨áÔ∏è Rimuovi Completamente Editor Scontrini", command=self._rimuovi_editor_esterno)
        menu_db.add_separator()
        menu_db.add_command(label="‚ùå Chiudi (ESC)", command=lambda: (self.deiconify(), self.after(0, self.imp_entry.focus_set), popup.destroy()))
        self._popup_spesa_active = popup
        popup.title("Gestione e Confronto Spesa")
        popup.geometry("1200x630")
        screen_width = popup.winfo_screenwidth()
        screen_height = popup.winfo_screenheight()
        x = (screen_width - 1200) // 2
        y = (screen_height - 630) // 2
        popup.geometry(f"1200x630+{x}+{y}")
        popup.after(10, lambda: popup.focus_force())
        popup.bind("<Escape>", lambda e: (self.deiconify(), self.after(0, self.imp_entry.focus_set), popup.destroy()))
        self.withdraw()
        self.after(1000, self.check_supermarket_update)
        def on_popup_close():
            _salva_dati_interno(dati_supermercati)
            try:
                self.popup_calendario.destroy() 
            except:
                pass
            self.popup_calendario = None
            popup.destroy()
            self.deiconify()
            self.after(0, self.imp_entry.focus_set)
        popup.protocol("WM_DELETE_WINDOW", on_popup_close)
        notebook = ttk.Notebook(popup)
        notebook.pack(expand=True, fill='both', padx=10, pady=10)
        frame_lista = ttk.Frame(notebook, padding="10", name='frame_lista')
        notebook.add(frame_lista, text="Lista Spesa Intelligente")
        frame_lista.grid_rowconfigure(1, weight=1)
        frame_lista.grid_rowconfigure(3, weight=2)
        frame_lista.grid_columnconfigure(0, weight=1)
        frame_ricerca_input = ttk.Frame(frame_lista)
        frame_ricerca_input.grid(row=0, column=0, sticky='ew', pady=5)
        frame_ricerca_input.grid_columnconfigure(3, weight=1) 
        ttk.Label(frame_ricerca_input, text="Filtra Supermercato:").grid(row=0, column=0, padx=(5,0), sticky='w')
        combo_filtro_confronto = ttk.Combobox(
            frame_ricerca_input,
            textvariable=filtro_supermercato_confronto_var,
            values=tuple(["Tutti i supermercati"] + sorted(SUPERMERCATI)),
            style="Border.TCombobox",
            state='readonly',
            width=30
        )
        combo_filtro_confronto.grid(row=0, column=1, padx=5, sticky='w')
        ttk.Label(frame_ricerca_input, text="Cerca Articolo (Testo):").grid(row=0, column=2, padx=(15, 0), sticky='w')
        entry_ricerca = ttk.Entry(frame_ricerca_input, textvariable=ricerca_var_confronto)
        entry_ricerca.grid(row=0, column=3, padx=5, sticky='ew')
        ttk.Button(frame_ricerca_input, text="üîô",
                   style='Yellow.TButton', 
                   command=lambda: (ricerca_var_confronto.set(""), _aggiorna_lista_spesa_intelligente(risultati_tv)), 
                   width=2
                   ).grid(row=0, column=4, padx=(5, 5), sticky='w')
        ttk.Button(frame_ricerca_input, text="Cerca/Aggiorna Confronto", style='Verde.TButton',
                   command=lambda: _aggiorna_lista_spesa_intelligente(risultati_tv)).grid(row=0, column=5, padx=(10, 5), sticky='e')
        ttk.Button(frame_ricerca_input, text="?", style='Yellow.TButton', width=2,
           command=lambda: self.mostra_help_supermercati()).grid(row=0, column=6, padx=(5, 5), sticky='w')
        combo_filtro_confronto.bind('<<ComboboxSelected>>', lambda e: _aggiorna_lista_spesa_intelligente(risultati_tv))
        cols_risultati = ("Nome Articolo", "Qt√† Catalogo", "Supermercato", "Descrizione", "Categoria", "Prezzo", "Confronto",
    "Data Inizio Promo", "Data Scadenza Promo", "Prezzo Intero")
        frame_tv_risultati = ttk.Frame(frame_lista)
        frame_tv_risultati.grid(row=1, column=0, sticky='nsew', pady=5)
        risultati_tv = ttk.Treeview(frame_tv_risultati, columns=cols_risultati, show='headings')
        self.risultati_tv_ref = risultati_tv
        risultati_tv.tag_configure('promo_rossa', foreground='red')
        risultati_tv.tag_configure('piu_conveniente', foreground='green')
        risultati_tv.tag_configure('promo_gialla', foreground='darkorange')
        vbar_res = ttk.Scrollbar(frame_tv_risultati, orient="vertical", command=risultati_tv.yview, style="Vertical.TScrollbar")
        hbar_res = ttk.Scrollbar(frame_tv_risultati, orient="horizontal", command=risultati_tv.xview, style="Horizontal.TScrollbar")
        risultati_tv.configure(yscrollcommand=vbar_res.set, xscrollcommand=hbar_res.set)
        vbar_res.pack(side="right", fill="y")
        hbar_res.pack(side="bottom", fill="x")
        risultati_tv.pack(side="left", fill='both', expand=True)
        risultati_tv.heading("Nome Articolo", text="Articolo"); 
        risultati_tv.heading("Qt√† Catalogo", text="Qt√† Cat."); 
        risultati_tv.heading("Supermercato", text="Supermercato"); 
        risultati_tv.heading("Prezzo", text="Prezzo")
        risultati_tv.heading("Confronto", text="Confronto")
        risultati_tv.heading("Descrizione", text="Descrizione")
        risultati_tv.heading("Categoria", text="Categoria")
        risultati_tv.column("Descrizione", width=150, stretch=True)
        risultati_tv.column("Categoria", width=130, stretch=False)
        risultati_tv.column("Qt√† Catalogo", width=60, anchor='center', stretch=True)
        risultati_tv.column("Prezzo", width=70, anchor='e', stretch=False)
        risultati_tv.column("Confronto", width=80, anchor='center')
        risultati_tv.column("Nome Articolo", width=140, anchor='w', stretch=True)
        risultati_tv.column("Supermercato", width=100, anchor='w', stretch=False)
        risultati_tv.column("Prezzo Intero", width=70, anchor='e', stretch=False)
        risultati_tv.column("Data Inizio Promo", width=80, anchor='center', stretch=False)
        risultati_tv.column("Data Scadenza Promo", width=80, anchor='center', stretch=False)
        for col in cols_risultati:
            text_to_show = {
                "Nome Articolo": "Articolo", 
                "Qt√† Catalogo": "Qt√† Cat.", 
                "Supermercato": "Supermercato",
                "Descrizione": "Descrizione",
                "Categoria": "Categoria",
                "Prezzo": "Prezzo",
                "Confronto": "Confronto",
                "Prezzo Intero": "Prezzo üî•", 
                "Data Inizio Promo": "Inizio", 
                "Data Scadenza Promo": "Scadenza"
            }.get(col, col)
            risultati_tv.heading(col, text=text_to_show, command=lambda _col=col, t=risultati_tv: _sort_treeview(t, _col, False))
        frame_legenda = ttk.Frame(frame_lista)
        frame_legenda.grid(row=2, column=0, pady=5, sticky='ew')
        frame_legenda.columnconfigure(0, weight=1)
        frame_riga_unica = ttk.Frame(frame_legenda)
        frame_riga_unica.grid(row=0, column=0)
        ttk.Label(
                frame_riga_unica, 
                text="Doppio Click su Qt√† per Modificare | Promoüî•: ", 
                font=('Arial', 8, 'bold')
        ).grid(row=0, column=0)
        ttk.Label(
                frame_riga_unica, 
                text="‚ñ† Attiva", 
                foreground="red", 
                font=('Arial', 8, 'bold')
        ).grid(row=0, column=1)
        ttk.Label(frame_riga_unica, text=" | ", font=('Arial', 10, 'bold')).grid(row=0, column=2)
        ttk.Label(
                frame_riga_unica, 
                text="‚ñ† Futura", 
                foreground="darkorange", 
                font=('Arial', 8, 'bold')
        ).grid(row=0, column=3)
        ttk.Label(frame_riga_unica, text=" | Miglior Prezzo‚≠ê: ", font=('Arial', 10, 'bold')).grid(row=0, column=4)
        ttk.Label(
                frame_riga_unica, 
                text="‚ñ† Assoluto", 
                foreground="green", 
                font=('Arial', 8, 'bold')
        ).grid(row=0, column=5)
        cols_lista_spesa = ("Qt√† Catalogo", "Qt√† da Comprare", "Prezzo Un. (‚Ç¨)", "Totale (‚Ç¨)", "Supermercato")
        frame_tv_lista = ttk.Frame(frame_lista, name='frame_tv_lista')
        frame_tv_lista.grid(row=3, column=0, sticky='nsew')
        tv_lista_spesa = ttk.Treeview(frame_tv_lista, columns=cols_lista_spesa, show='tree headings')
        vbar_list = ttk.Scrollbar(frame_tv_lista, orient="vertical", command=tv_lista_spesa.yview, style="Vertical.TScrollbar")
        hbar_list = ttk.Scrollbar(frame_tv_lista, orient="horizontal", command=tv_lista_spesa.xview, style="Horizontal.TScrollbar")
        tv_lista_spesa.configure(yscrollcommand=vbar_list.set, xscrollcommand=hbar_list.set)
        vbar_list.pack(side="right", fill="y")
        hbar_list.pack(side="bottom", fill="x")
        tv_lista_spesa.pack(side="left", fill='both', expand=True)
        tv_lista_spesa.heading("#0", text="Articolo/Gruppo")
        heading_map = {
            "Qt√† Catalogo": "Qt√† Cat.",
            "Qt√† da Comprare": "Qt√† Ordine",
            "Prezzo Un. (‚Ç¨)": "Prezzo Un. (‚Ç¨)",
            "Totale (‚Ç¨)": "Totale (‚Ç¨)",      
            "Supermercato": "Supermercato"
        }
        for col in cols_lista_spesa: 
            tv_lista_spesa.heading(col, text=heading_map.get(col, col))
        tv_lista_spesa.column("#0", width=180, anchor='w', stretch=True)
        tv_lista_spesa.column("Qt√† Catalogo", width=80, anchor='center', stretch=False)
        tv_lista_spesa.column("Qt√† da Comprare", width=120, anchor='center', stretch=False)
        tv_lista_spesa.column("Prezzo Un. (‚Ç¨)", width=140, anchor='e', stretch=False)
        tv_lista_spesa.column("Totale (‚Ç¨)", width=100, anchor='e', stretch=False)
        tv_lista_spesa.column("Supermercato", width=120, anchor='center')
        for col in cols_lista_spesa:
            tv_lista_spesa.heading(col, command=lambda _col=col, t=tv_lista_spesa: _sort_treeview(t, _col, False))
        risultati_tv.bind('<Double-1>', lambda e, tv_list=tv_lista_spesa, tv_res=risultati_tv: _aggiungi_a_lista_spesa(e, tv_list, tv_res))
        entry_ricerca.bind('<KeyRelease>', lambda e, tv=risultati_tv: _cerca_articoli(ricerca_var_confronto.get(), tv))
        tv_lista_spesa.bind('<Button-1>', lambda e, tv=tv_lista_spesa: _on_edit_quantity(e, tv))
        frame_pulsanti_lista = ttk.Frame(frame_lista)
        frame_pulsanti_lista.grid(row=4, column=0, sticky='ew', pady=5)
        ttk.Button(frame_pulsanti_lista, text="‚ùå Rimuovi Selezionato", style='Rosso.TButton',
                   command=lambda tv=tv_lista_spesa: _rimuovi_articolo_da_lista(tv)).pack(side='left', padx=5)
        ttk.Button(frame_pulsanti_lista, text="üìÑ Svuota Lista", style='Rosso.TButton',
                   command=lambda tv=tv_lista_spesa: _svuota_lista_spesa(tv)).pack(side='left', padx=5)
        ttk.Button(frame_pulsanti_lista, text="üö™ Chiudi", style='Giallo.TButton',
                   command=lambda: on_popup_close()).pack(side='right', padx=5)
        ttk.Button(frame_pulsanti_lista, text="üìÑ Esporta Lista", style='Verde.TButton',
                   command=_mostra_anteprima_esportazione).pack(side='right', padx=5)
        frame_gestione = ttk.Frame(notebook, padding="10")
        notebook.add(frame_gestione, text="Gestione Supermercati")
        frame_gestione.grid_columnconfigure(0, weight=1)
        frame_gestione.grid_rowconfigure(3, weight=1)
        self.label_conteggio_db = ttk.Label(
            frame_gestione, 
            text="üõí", 
            font=('Arial', 12, 'bold'), 
            foreground='#3f51b5'
        )
        self.label_conteggio_db.bind("<Button-1>", lambda event: info_popup())
        self.label_conteggio_db.grid(row=0, column=1, sticky='e', padx=5, pady=5)
        frame_selezione = ttk.Frame(frame_gestione)
        frame_selezione.grid(row=0, column=0, sticky='ew', pady=(0, 10))
        ttk.Label(frame_selezione, text="Seleziona Supermercato da Gestire:").pack(side='left', padx=5)
        combo_supermercato = ttk.Combobox(frame_selezione, textvariable=supermercato_selezionato_var,
                                          values=tuple(["Seleziona Supermercato"] + sorted(SUPERMERCATI)),
                                          style="Border.TCombobox",
                                          state='readonly', width=30, name='combo_gestione_super')
        combo_supermercato.pack(side='left', padx=5)
        supermercato_selezionato_var.set("Seleziona Supermercato")
        ttk.Button(frame_selezione, text="üßπ Rinomina Selezionato", style='Giallo.TButton',
                   command=lambda c=combo_supermercato, t=None, r=None: _esegui_rinomina_supermercato(c, tree_super_crud, ricerca_vars_crud.get(supermercato_selezionato_var.get(), tk.StringVar()))).pack(side='left', padx=15)
        if 'combo_gestione_super' not in campi_input_refs:
            campi_input_refs['combo_gestione_super'] = {
                'nome': tk.StringVar(), 'descrizione': tk.StringVar(), 'categoria': tk.StringVar(),
                'prezzo': tk.StringVar(), 'promo_attiva': tk.BooleanVar(), 'prezzo_promo': tk.StringVar(),
                'quantita': tk.StringVar(), 'data_scadenza': tk.StringVar(),
                'data_inserimento_prezzo': tk.StringVar(),
                'data_inizio_promo': tk.StringVar()
            }
        refs_crud = campi_input_refs['combo_gestione_super']
        frame_input = ttk.Frame(frame_gestione)
        frame_input.grid(row=1, column=0, sticky='nw', pady=5)
        ttk.Label(frame_input, text="Nome Articolo:").grid(row=0, column=0, padx=5, pady=2, sticky='w')
        ttk.Entry(frame_input, textvariable=refs_crud['nome'], width=30).grid(row=0, column=1, padx=5, pady=2, sticky='w')
        ttk.Label(frame_input, text="Categoria:").grid(row=0, column=2, padx=5, pady=2, sticky='w')
        combo_categoria = ttk.Combobox(
            frame_input, 
            textvariable=refs_crud['categoria'],
            values=CATEGORIE_PREDEFINITE,
            state='readonly',
            style="Border.TCombobox",
            width=15
        )
        combo_categoria.grid(row=0, column=3, padx=5, pady=2, sticky='w') 
        if CATEGORIE_PREDEFINITE:
            combo_categoria.set(CATEGORIE_PREDEFINITE[0])
        ttk.Label(frame_input, text="Descrizione:").grid(row=1, column=0, padx=5, pady=2, sticky='w')
        ttk.Entry(frame_input, textvariable=refs_crud['descrizione'], width=30).grid(row=1, column=1, padx=5, pady=2, sticky='w')
        ttk.Label(frame_input, text="Quantit√† (es: 500g):").grid(row=1, column=2, padx=5, pady=2, sticky='w')
        ttk.Entry(frame_input, textvariable=refs_crud['quantita'], width=15).grid(row=1, column=3, padx=5, pady=2, sticky='w')
        ttk.Label(frame_input, text="Prezzo Normale (‚Ç¨):").grid(row=2, column=0, padx=5, pady=2, sticky='w')
        ttk.Entry(frame_input, textvariable=refs_crud['prezzo'], width=15).grid(row=2, column=1, padx=5, pady=2, sticky='w')
        ttk.Label(frame_input, text="Prezzo Promo (‚Ç¨):").grid(row=2, column=2, padx=5, pady=2, sticky='w')
        ttk.Entry(frame_input, textvariable=refs_crud['prezzo_promo'], width=15).grid(row=2, column=3, padx=5, pady=2, sticky='w')
        ttk.Checkbutton(frame_input, text="Articolo in Promozione", variable=refs_crud['promo_attiva']).grid(row=3, column=0, padx=5, pady=5, sticky='w')
        ttk.Label(frame_input, text="Data Inizio Promo:").grid(row=3, column=2, padx=5, pady=2, sticky='w')
        frame_data_inizio_promo = ttk.Frame(frame_input)
        frame_data_inizio_promo.grid(row=3, column=3, padx=5, pady=2, sticky='w')
        entry_data_inizio_promo = ttk.Entry(frame_data_inizio_promo, textvariable=refs_crud['data_inizio_promo'], width=15)
        entry_data_inizio_promo.grid(row=0, column=0, sticky='w')
        ttk.Button(
            frame_data_inizio_promo,
            text="üóìÔ∏è",
            style='Giallo.TButton',
            width=3,
            command=lambda e=entry_data_inizio_promo: self.mostra_calendario_popup_semplice(e, refs_crud['data_inizio_promo'])
        ).grid(row=0, column=1, sticky='w', padx=(5, 0))
        ttk.Label(frame_input, text="Data Inserimento Prezzo:").grid(row=4, column=0, padx=5, pady=2, sticky='w')
        frame_data_ins = ttk.Frame(frame_input)
        frame_data_ins.grid(row=4, column=1, padx=5, pady=2, sticky='w')
        entry_data_ins = ttk.Entry(frame_data_ins, textvariable=refs_crud['data_inserimento_prezzo'], width=15)
        entry_data_ins.grid(row=0, column=0, sticky='w')
        ttk.Button(
            frame_data_ins,
            text="üóìÔ∏è",
            style='Giallo.TButton',
            width=3,
            command=lambda e=entry_data_ins: self.mostra_calendario_popup_semplice(e, refs_crud['data_inserimento_prezzo'])
        ).grid(row=0, column=1, sticky='w', padx=(5, 0))
        ttk.Label(frame_input, text="Data Scadenza:").grid(row=4, column=2, padx=5, pady=2, sticky='w')
        frame_data_input = ttk.Frame(frame_input)
        frame_data_input.grid(row=4, column=3, padx=5, pady=2, sticky='w')
        entry_data_scadenza = ttk.Entry(frame_data_input, textvariable=refs_crud['data_scadenza'], width=15)
        entry_data_scadenza.grid(row=0, column=0, sticky='w')
        ttk.Button(
            frame_data_input, 
            text="üóìÔ∏è", 
            style='Giallo.TButton',
            width=3, 
            command=lambda e=entry_data_scadenza: self.mostra_calendario_popup_semplice(e, refs_crud['data_scadenza'])
        ).grid(row=0, column=1, sticky='w', padx=(5, 0))
        frame_ricerca_crud = ttk.Frame(frame_gestione)
        frame_ricerca_crud.grid(row=2, column=0, sticky='ew', pady=(0, 5))        
        frame_ricerca_crud = ttk.Frame(frame_gestione)
        frame_ricerca_crud.grid(row=2, column=0, sticky='ew', pady=(0, 5))
        ttk.Label(frame_ricerca_crud, text="Cerca Articolo (Testo):").pack(side='left', padx=5)
        ricerca_var_crud_attuale = tk.StringVar()
        entry_ricerca_crud = ttk.Entry(frame_ricerca_crud, textvariable=ricerca_var_crud_attuale, width=40)
        entry_ricerca_crud.pack(side='left', padx=5, fill='x', expand=True)
        def update_crud_search_var(e=None):
            current_superm = supermercato_selezionato_var.get()
            if current_superm != "Seleziona Supermercato":
                _cerca_articoli_crud(current_superm, tree_super_crud, ricerca_var_crud_attuale)
        def reset_ricerca_crud():
            ricerca_var_crud_attuale.set("") 
            update_crud_search_var()
        ttk.Button(frame_ricerca_crud, 
                   text="üîô",
                   style='Yellow.TButton', 
                   command=reset_ricerca_crud,
                   width=2
                  ).pack(side='left', padx=5)
        ttk.Button(frame_ricerca_crud, text="Cerca", style='Blu.TButton', command=update_crud_search_var).pack(side='left', padx=10)
        entry_ricerca_crud.bind('<KeyRelease>', update_crud_search_var)
        cols_super = ("Nome", "Descrizione", "Categoria", "Prezzo", "Data Ins.", "Promo", "P. Promo", "Quantit√†", "Inizio Promo", "Scadenza")
        frame_tv_crud = ttk.Frame(frame_gestione)
        frame_tv_crud.grid(row=3, column=0, sticky='nsew', pady=(5, 0))
        tree_super_crud = ttk.Treeview(frame_tv_crud, columns=cols_super, show='headings')
        tree_super_crud.tag_configure('promo_attiva', foreground='red')
        tree_super_crud.tag_configure('promo_in_arrivo', foreground='orange')
        vbar_tv = ttk.Scrollbar(frame_tv_crud, orient="vertical", command=tree_super_crud.yview, style="Vertical.TScrollbar")
        hbar_tv = ttk.Scrollbar(frame_tv_crud, orient="horizontal", command=tree_super_crud.xview, style="Horizontal.TScrollbar")
        tree_super_crud.configure(yscrollcommand=vbar_tv.set, xscrollcommand=hbar_tv.set)
        vbar_tv.pack(side="right", fill="y")
        hbar_tv.pack(side="bottom", fill="x")
        tree_super_crud.pack(side="left", fill='both', expand=True)
        for col in cols_super:
            text_to_show = col.replace("P. Promo", "Promo ‚Ç¨").replace("Data Ins.", "Data Inserita").replace("Inizio Promo", "Inizio Promo").replace("Scadenza", "Scadenza")
            tree_super_crud.heading(col, text=text_to_show, command=lambda _col=col, t=tree_super_crud: _sort_treeview(t, _col, False))
        tree_super_crud.column("Promo", width=50, anchor='center', stretch=False)
        tree_super_crud.column("P. Promo", width=70, anchor='e', stretch=False)
        tree_super_crud.column("Quantit√†", width=80, anchor='center', stretch=False)
        tree_super_crud.column("Prezzo", width=70, anchor='e', stretch=False)
        tree_super_crud.column("Inizio Promo", width=90, anchor='center', stretch=False)
        tree_super_crud.column("Scadenza", width=90, anchor='center', stretch=False)
        tree_super_crud.column("Nome", width=120, anchor='w')
        tree_super_crud.column("Descrizione", width=120, anchor='w')
        tree_super_crud.column("Categoria", width=90, anchor='w')
        tree_super_crud.column("Data Ins.", width=90, anchor='center', stretch=False)
        frame_pulsanti_crud = ttk.Frame(frame_gestione)
        frame_pulsanti_crud.grid(row=4, column=0, sticky='ew', pady=5)
        supermercato_destinazione_var = tk.StringVar() 
        ttk.Label(frame_pulsanti_crud, text="Sposta Articolo").pack(side='left', padx=(20, 5))
        combo_super_sposta = ttk.Combobox(
            frame_pulsanti_crud,
            textvariable=supermercato_destinazione_var,
            values=tuple(sorted(SUPERMERCATI)),
            style="Border.TCombobox",
            state='readonly',
            width=20
        )
        combo_super_sposta.pack(side='left', padx=5)
        ttk.Button(frame_pulsanti_crud, text="‚á® Sposta", style='Giallo.TButton',
                   command=lambda tv=tree_super_crud, combo=combo_super_sposta: _sposta_articolo_tra_super(tv, combo)).pack(side='left', padx=10)
        def _sposta_articolo_tra_super(treeview_crud, combo_superm_dest):
            selected_item_iid = treeview_crud.focus()
            if not selected_item_iid:
                self.show_custom_warning("Articolo Mancante", "Seleziona un articolo nella tabella da spostare.")
                return
            super_destinazione = combo_superm_dest.get()
            super_corrente = supermercato_selezionato_var.get()
            if not super_destinazione: 
                self.show_custom_warning("Destinazione Mancante", "Seleziona un supermercato di destinazione valido.")
                return
            if super_destinazione == super_corrente:
                self.show_custom_warning("Spostamento Inutile", "L'articolo √® gi√† nel supermercato selezionato come destinazione.")
                return
            if not dati_supermercati.get(super_corrente):
                self.show_custom_warning("Errore Dati", "Supermercato di origine non trovato.")
                return
            try:
                iid_parts = selected_item_iid.split('_')
                if len(iid_parts) == 3 and iid_parts[0] == 'item':
                    idx_da_rimuovere = int(iid_parts[2])
                else:
                    item_values = treeview_crud.item(selected_item_iid, 'values')
                    if not item_values:
                        self.show_custom_warning("Errore Dati", "Articolo non trovato nei dati del supermercato corrente.")
                        return
                    nome_articolo = item_values[0]
                    articoli_correnti = dati_supermercati[super_corrente]
                    idx_da_rimuovere = next(i for i, a in enumerate(articoli_correnti) if a.get('nome') == nome_articolo)
                articolo_spostato = dati_supermercati[super_corrente].pop(idx_da_rimuovere)
            except StopIteration:
                self.show_custom_warning("Errore Dati", "Articolo non trovato nei dati del supermercato corrente.")
                return
            except Exception as e:
                self.show_custom_warning("Errore Estrazione", f"Errore durante l'estrazione o rimozione dell'articolo: {e}")
                return
            if super_destinazione not in dati_supermercati:
                 dati_supermercati[super_destinazione] = []
            dati_supermercati[super_destinazione].append(articolo_spostato)
            supermercato_destinazione_var.set("")
            self.show_custom_warning("Spostamento Riuscito", f"L'articolo √® stato spostato con successo da '{super_corrente}' a '{super_destinazione}'.")
            ricerca_var_attuale = ricerca_vars_crud.get(super_corrente, tk.StringVar())
            _cerca_articoli_crud(super_corrente, treeview_crud, ricerca_var_attuale)
            if hasattr(self, 'risultati_tv_ref') and self.risultati_tv_ref:
                _aggiorna_lista_spesa_intelligente(self.risultati_tv_ref)
            _salva_dati_interno(dati_supermercati)
        def _genera_testo_esportazione_supermercato(supermercato):
            import datetime
            WIDTH_NOME = 29          
            WIDTH_DESC = 20          
            WIDTH_CAT = 20
            WIDTH_QTA = 10           
            WIDTH_PREZZO_N = 8
            WIDTH_PREZZO_P = 8
            WIDTH_PROMO = 5          
            WIDTH_INIZIO_PROMO = 10  
            WIDTH_SCAD = 10          
            WIDTH_DATA_INS = 10      
            EXTRA_SPACE = "  "
            data_esportazione = datetime.datetime.now().strftime("%d/%m/%Y %H:%M:%S")
            testo = f"=== CATALOGO SUPERMERCATO: {supermercato.upper()} ({data_esportazione}) ===\n"
            articoli = dati_supermercati.get(supermercato, [])
            if not articoli:
                testo += "\nNessun articolo registrato per questo supermercato."
                return testo
            articoli.sort(key=lambda x: x.get('nome', ''))
            intestazione = (
                f"{'Nome':<{WIDTH_NOME}} {'Descrizione':<{WIDTH_DESC}} {'Cat.':<{WIDTH_CAT}} " 
                f"{'Qt√†':<{WIDTH_QTA}} {'P.N.':>{WIDTH_PREZZO_N}} {'P.P.':>{WIDTH_PREZZO_P}} " 
                f"{'Pr.':<{WIDTH_PROMO}} "                               
                f"{'Iniz.Pr.':<{WIDTH_INIZIO_PROMO}}{EXTRA_SPACE}"  
                f"{'Scad.':<{WIDTH_SCAD}}{EXTRA_SPACE}"             
                f"{'Ins.':<{WIDTH_DATA_INS}}"                            
            )
            separatore = "-" * len(intestazione)
            testo += "\n" + separatore + "\n"
            testo += intestazione + "\n"
            testo += separatore + "\n"
            articoli_incompleti_count = 0
            articoli_esportati_count = 0
            for articolo in articoli:
                nome = articolo.get("nome", "")
                categoria = articolo.get("categoria", "")
                prezzo = str(articolo.get("prezzo", ""))
                mancanze = []
                if not nome: mancanze.append("Nome")
                if not categoria: mancanze.append("Cat")
                if not (prezzo and prezzo.replace('.', '', 1).isdigit()): mancanze.append("Prezzo")
                if mancanze:
                    articoli_incompleti_count += 1
                    continue 
                articoli_esportati_count += 1
                descrizione = articolo.get("descrizione", "")
                quantita = articolo.get("quantita", "")
                promo = "SI" if articolo.get("promo") else "NO"
                prezzo_promo = str(articolo.get("prezzo_promo", ""))
                data_scadenza = articolo.get("data_scadenza", "")
                data_inizio_promo = articolo.get("data_inizio_promo", "")
                data_inserimento = articolo.get("data_inserimento_prezzo", "") 
                prezzo_fmt = f"{float(prezzo):.2f}"
                promo_fmt = f"{float(prezzo_promo):.2f}" if prezzo_promo and prezzo_promo.replace('.', '', 1).isdigit() else ""
                linea = (
                    f"{nome[:WIDTH_NOME-1]:<{WIDTH_NOME}} "
                    f"{descrizione[:WIDTH_DESC-1]:<{WIDTH_DESC}} "
                    f"{categoria[:WIDTH_CAT-1]:<{WIDTH_CAT}} "
                    f"{quantita[:WIDTH_QTA-1]:<{WIDTH_QTA}} "
                    f"{prezzo_fmt:>{WIDTH_PREZZO_N}} " 
                    f"{promo_fmt:>{WIDTH_PREZZO_P}} " 
                    f"{promo:<{WIDTH_PROMO}} "                             
                    f"{data_inizio_promo:<{WIDTH_INIZIO_PROMO}}{EXTRA_SPACE}" 
                    f"{data_scadenza:<{WIDTH_SCAD}}{EXTRA_SPACE}"             
                    f"{data_inserimento:<{WIDTH_DATA_INS}}\n"              
                )
                testo += linea
            testo += separatore + "\n"
            total_articoli = len(articoli)
            testo += f"\n=== RIEPILOGO DATI ===\n"
            testo += f"Totale Articoli: {total_articoli}\n"
            testo += f"Articoli Esportati: {articoli_esportati_count}\n"
            testo += f"Articoli Ignorati: {articoli_incompleti_count}\n"
            testo += "=" * len(intestazione) + "\n"
            return testo
        def _mostra_anteprima_esportazione_supermercato(supermercato):
            if supermercato == "Seleziona Supermercato" or not supermercato:
                self.show_custom_warning("Selezione", "Seleziona un supermercato da esportare."); return
            anteprima_text = _genera_testo_esportazione_supermercato(supermercato)
            def _esporta_su_file_super(content_text, default_name, preview_popup):
                preview_popup.destroy()
                f = filedialog.asksaveasfilename(
                    defaultextension=".txt",
                    filetypes=[("File txt", "*.txt")],
                    title=f"Salva Catalogo {supermercato} su File",
                    initialdir=EXPORT_FILES,
                    confirmoverwrite=False,
                    initialfile=default_name,
                    parent=popup
                )
                if f:
                    try:
                        with open(f, 'w', encoding='utf-8') as file_handle: file_handle.write(content_text)
                        self.show_custom_warning("Successo", f"‚úì Catalogo salvato con successo in:\n{f}")
                    except Exception as e:
                        self.show_custom_warning("Errore", f"‚ùå Impossibile salvare il file:\n{e}")
            preview_popup = tk.Toplevel(popup, bg=self.COLOR_TOPLEVEL)
            preview_popup.title(f"Anteprima Esportazione Catalogo: {supermercato}")
            WIDTH = 1200
            HEIGHT = 600
            screen_width = preview_popup.winfo_screenwidth()
            screen_height = preview_popup.winfo_screenheight()
            x = (screen_width - WIDTH) // 2
            y = (screen_height - HEIGHT) // 2
            preview_popup.geometry(f"{WIDTH}x{HEIGHT}+{x}+{y}")
            preview_popup.after(10, lambda: preview_popup.focus_force())
            preview_popup.bind('<Escape>', lambda e: preview_popup.destroy())
            text_area = tk.Text(preview_popup, wrap='word', font=('Courier', 10), padx=10, pady=10)
            text_area.insert('1.0', anteprima_text)
            text_area.config(state='disabled')
            text_area.pack(fill='both', expand=True, padx=10, pady=10)
            frame_btn = tk.Frame(preview_popup, bg=self.COLOR_TOPLEVEL); frame_btn.pack(pady=(0, 10))
            ttk.Button(frame_btn, text="‚ùå Chiudi", command=preview_popup.destroy, style='Giallo.TButton').pack(side='right', padx=5)
            now = datetime.date.today()
            default_filename = f"Catalogo_{supermercato}_{now.day:02d}_{now.month:02d}_{now.year}.txt"
            ttk.Button(frame_btn, text="üì§ Esporta", style='Verde.TButton',
                         command=lambda: _esporta_su_file_super(anteprima_text, default_filename, preview_popup)
            ).pack(side='left', padx=5)
            ttk.Button(
                frame_btn, 
                text="üìÑ Stampa", 
                style='Blu.TButton',
                command=lambda: self._stampa_lista_diretta(
                anteprima_text, 
                self.show_custom_warning
                )
            ).pack(side='left', padx=5)
        def crud_wrapper(azione, tree, frame_input):
            superm = supermercato_selezionato_var.get()
            if superm == "Seleziona Supermercato":
                self.show_custom_warning("Selezione", "Seleziona un supermercato prima di eseguire l'azione."); return
            _funzione_crud(azione, superm, tree, frame_input)
        ttk.Button(frame_pulsanti_crud, text="‚ûï Inserisci", style='Blu.TButton',
                   command=lambda a='inserisci', t=tree_super_crud, f=frame_input: crud_wrapper(a, t, f)).pack(side='left', padx=5)
        ttk.Button(frame_pulsanti_crud, text="üßπ Modifica", style='Blu.TButton',
                   command=lambda a='modifica', t=tree_super_crud, f=frame_input: crud_wrapper(a, t, f)).pack(side='left', padx=5)
        ttk.Button(frame_pulsanti_crud, text="üíæ Salva Modifiche", style='Blu.TButton',
                   command=lambda a='salva', t=tree_super_crud, f=frame_input: crud_wrapper(a, t, f)).pack(side='left', padx=5)
        ttk.Button(frame_pulsanti_crud, text="‚ùå Cancella", style='Rosso.TButton',
                   command=lambda a='cancella', t=tree_super_crud, f=frame_input: crud_wrapper(a, t, f)).pack(side='left', padx=5)
        ttk.Button(frame_pulsanti_crud, text="üí£ AZZERA Dati", style='Rosso.TButton',
                   command=lambda s=supermercato_selezionato_var, t=tree_super_crud: _svuota_supermercato(s.get(), t)).pack(side='right', padx=15)
        ttk.Button(frame_pulsanti_crud, text="üìÑ Esporta Catalogo", style='Verde.TButton',
                   command=lambda s=supermercato_selezionato_var: _mostra_anteprima_esportazione_supermercato(s.get())).pack(side='right', padx=5)
        combo_supermercato.bind('<<ComboboxSelected>>', 
                                lambda e, c=combo_supermercato, t=tree_super_crud, f=frame_input, r=ricerca_var_crud_attuale: _on_supermercato_change(e, c, t, f, r))
        ttk.Button(frame_pulsanti_crud, text="üõí Importa Scontrini", 
                   command=self._avvia_editor_esterno, 
                   style='Blu.TButton').pack(side='left', padx=5)
        _cerca_articoli("", risultati_tv)
        _ricarica_lista_spesa(tv_lista_spesa)
        popup.wait_visibility()
    def mostra_help_supermercati(self):
        if not hasattr(self, '_popup_spesa_active') or not self._popup_spesa_active.winfo_exists():
            return 
        parent_window = self._popup_spesa_active
        help_text_lista = """
Obiettivo: Creare una lista spesa ottimizzata, trovando il prezzo migliore per ogni articolo tra tutti i cataloghi registrati.

# A. Sezione Confronto (Tabella Superiore)
1.  Filtro e Ricerca: Utilizza la casella di ricerca e il filtro supermercato per visualizzare solo gli articoli desiderati nel catalogo complessivo.
2.  La Colonna 'Confronto' (Il Cuore Smart):
    * Questa colonna esegue il confronto prezzi in tempo reale.
    * Se l'articolo costa meno altrove, la colonna ti mostra il costo minimo pi√π basso trovato e in quale supermercato, evidenziando l'opportunit√† di risparmio.
    * La tua scelta finale √® sempre basata sulla riga che selezioni.
    
3.  Aggiunta Articoli e Accumulo Quantit√† (Doppio Click):
    * Doppio click su una riga nella tabella superiore per aggiungere l'articolo alla lista spesa ottimizzata (tabella inferiore).
    * Cruciale: Se l'articolo √® gi√† presente nella lista inferiore, un ulteriore doppio click su di esso non aggiunge una nuova riga,\n      ma incrementa automaticamente la quantit√† da comprare di 1 unit√†.

# B. Sezione Lista Spesa Ottimizzata (Tabella Inferiore)
1.  Ottimizzazione Prezzo/Supermercato: La lista spesa finale suggerisce gli acquisti. La colonna 'Supermercato' indica dove\n
      √® consigliato comprare l'articolo per ottenere il prezzo finale pi√π basso.
2.  Modifica Quantit√†: Fai doppio click sulla cella della colonna 'Qt√† da Comprare' per modificare manualmente il numero esatto di unit√†.
3.  Gestione: Usa i pulsanti Rimuovi Selezionato, Svuota Lista e Esporta Lista per finalizzare e salvare la tua lista spesa ottimizzata.
"""
        help_text_gestione = """
Obiettivo: Mantenere aggiornati i cataloghi (prezzi, promozioni, descrizioni) di ciascun supermercato per garantire un confronto accurato.

# A. Operazioni Base (CRUD)
1.  Selezione Catalogo: Seleziona un supermercato dal ComboBox 'Seleziona Supermercato da Gestire'. La tabella sottostante si popoler√† con i suoi articoli.
2.  ‚ûï Inserisci: Compila tutti i campi di input (Nome Articolo, Categoria, Prezzo, ecc.) e aggiungi un nuovo articolo al catalogo selezionato.
3.   Modifica (Carica): Seleziona un articolo nella tabella e premi 'Modifica' per caricare i suoi dati nei campi di input per l'editing.
4.   Salva Modifiche (Aggiorna): Dopo aver modificato i dati negli input, premi 'Salva Modifiche' per aggiornare l'articolo precedentemente selezionato.
5.  ‚ùå Cancella: Seleziona un articolo e premi 'Cancella' per rimuoverlo dal catalogo.

# B. Funzionalit√† Aggiuntive
*  Sposta Articolo: Sposta l'articolo selezionato dal catalogo corrente a un altro supermercato, specificato nel ComboBox di destinazione.
*  Rinomina Selezionato: Permette di cambiare il nome del supermercato selezionato.
*  AZZERA Dati: Attenzione! Cancella TUTTI gli articoli del supermercato selezionato.
*  Esporta Catalogo: Salva l'intero catalogo del supermercato selezionato in un file di testo per backup o consultazione esterna.
*  Importa Scontrini: Strumento per l'importazione e modifica rapida di dati dagli scontrini per popolare il catalogo.

# C. Funzionalit√† Menu'
*  Importa Supermercati: Carica un archivio contenente l'intero database. ATTENZIONE: Sovrascrive TUTTI i dati esistenti.
*  Esporta Supermercati: Crea un archivio con l'intero database dei cataloghi per un backup completo .
"""
        testo_stampa_completo = (
            "========================================================\n"
            "         GUIDA COMPLETA: LISTA SPESA E CATALOGO\n"
            "========================================================\n\n"
            
            "--- SEZIONE 1: LISTA SPESA INTELLIGENTE ---\n"
            "Obiettivo: Creare una lista spesa ottimizzata, trovando il prezzo migliore per ogni articolo tra tutti i cataloghi registrati.\n\n"
            
            "A. Sezione Confronto (Tabella Superiore)\n"
            "1. Filtro e Ricerca: Utilizza la casella di ricerca e il filtro supermercato per visualizzare solo gli articoli desiderati.\n"
            "2. La Colonna 'Confronto' (Il Cuore Smart): Mostra il costo minimo pi√π basso trovato e il supermercato pi√π conveniente.\n"
            "3. Aggiunta Articoli e Accumulo Quantit√† (Doppio Click): Doppio click aggiunge l'articolo; se √® gi√† presente, incrementa la quantit√† di 1 unit√†.\n\n"
            
            "B. Sezione Lista Spesa Ottimizzata (Tabella Inferiore)\n"
            "1. Ottimizzazione Prezzo/Supermercato: La lista suggerisce dove comprare l'articolo per il prezzo pi√π basso.\n"
            "2. Modifica Quantit√†: Doppio click sulla cella 'Qt√† da Comprare' per modificare manualmente.\n"
            "3. Gestione: Usa i pulsanti Rimuovi Selezionato, Svuota Lista e Esporta Lista.\n\n"
            
            "--- SEZIONE 2: GESTIONE SUPERMERCATI ---\n"
            "Obiettivo: Mantenere aggiornati i cataloghi per garantire un confronto accurato.\n\n"
            
            "A. Operazioni Base (CRUD)\n"
            "1. Selezione Catalogo: Scegli il supermercato dal ComboBox per popolare la tabella.\n"
            "2. Inserisci: Compila i campi e aggiungi un nuovo articolo.\n"
            "3. Modifica (Carica): Seleziona un articolo e premi 'Modifica' per caricare i dati.\n"
            "4. Salva Modifiche (Aggiorna): Aggiorna l'articolo con i nuovi dati negli input.\n"
            "5. Cancella: Rimuove l'articolo dal catalogo.\n\n"
            
            "B. Funzionalit√† Aggiuntive\n"
            "* Sposta Articolo: Sposta l'articolo selezionato a un altro supermercato.\n"
            "* Rinomina Selezionato: Cambia il nome del supermercato.\n"
            "* AZZERA Dati: ATTENZIONE! Cancella TUTTI gli articoli del supermercato selezionato.\n"
            "* Esporta Catalogo: Salva l'intero catalogo in un file di testo.\n"
            "* Importa Scontrini: Strumento per l'importazione e modifica rapida di dati dagli scontrini.\n\n"
            
            "C. Funzionalit√† Menu\n"
            "* Importa Supermercati: Carica un archivio contenente l'intero database. ATTENZIONE: Sovrascrive TUTTI i dati esistenti.\n"
            "* Esporta Supermercati: Crea un archivio con l'intero database dei cataloghi per un backup completo."
        )
        def _crea_text_area(parent_frame, content):
            text_container = ttk.Frame(parent_frame)
            text_container.pack(fill='both', expand=True)
            text_area = tk.Text(text_container, wrap='word', font=('Arial', 10), 
                                padx=10, pady=10, background='#f0f0f0', borderwidth=0)
            text_area.insert('1.0', content)
            text_area.config(state='disabled') 
            scrollbar = ttk.Scrollbar(text_container, command=text_area.yview, style="Vertical.TScrollbar")
            text_area.config(yscrollcommand=scrollbar.set)
            scrollbar.pack(side='right', fill='y')
            text_area.pack(side='left', fill='both', expand=True)
        help_popup = tk.Toplevel(parent_window, bg=self.COLOR_TOPLEVEL) 
        help_popup.title("Guida Completa: Catalogo e Lista Spesa Intelligente")
        WIDTH = 1200
        HEIGHT = 630
        help_popup.resizable(False, False)
        screen_width = help_popup.winfo_screenwidth()
        screen_height = help_popup.winfo_screenheight()
        x = (screen_width - WIDTH) // 2
        y = (screen_height - HEIGHT) // 2
        help_popup.geometry(f"{WIDTH}x{HEIGHT}+{x}+{y}")
        help_popup.transient(parent_window)
        help_popup.bind("<Escape>", lambda e: help_popup.destroy())
        help_popup.grab_set()
        help_popup.protocol("WM_DELETE_WINDOW", help_popup.destroy)
        help_popup.after(10, lambda: help_popup.focus_force())
        main_frame = ttk.Frame(help_popup, padding="15")
        main_frame.pack(fill='both', expand=True)
        ttk.Label(main_frame, text="Guida all'Utilizzo delle Schede", 
                  font=('Arial', 14, 'bold')).pack(pady=(0, 15))
        notebook_help = ttk.Notebook(main_frame)
        notebook_help.pack(expand=True, fill='both')
        frame_help_lista = ttk.Frame(notebook_help, padding="10")
        notebook_help.add(frame_help_lista, text="Lista Spesa Intelligente")
        _crea_text_area(frame_help_lista, help_text_lista)
        frame_help_gestione = ttk.Frame(notebook_help, padding="10")
        notebook_help.add(frame_help_gestione, text="Gestione Supermercati (CRUD)")
        _crea_text_area(frame_help_gestione, help_text_gestione)
        btn_frame = ttk.Frame(help_popup, padding=(15, 0))
        btn_frame.pack(fill='x', padx=15, pady=(5, 15))
        ttk.Button(
            btn_frame, 
            text="üìÑ Stampa Guida", 
            command=lambda: self._stampa_lista_diretta(
                testo_stampa_completo, 
                self.show_custom_warning
            ), 
            style='Blu.TButton'
        ).pack(side=tk.LEFT, padx=10, pady=5)
        ttk.Button(
            btn_frame, 
            text="Ho Capito (OK)", 
            command=help_popup.destroy, 
            style='Giallo.TButton'
        ).pack(side=tk.RIGHT, padx=10, pady=5)
        help_popup.wait_window(help_popup)

    # Generatore QR Code / Link Promemoria Google Calendar
    def launch_qr_svg_generator(self, initial_category="", initial_amount="", initial_date="", initial_description="", initial_type=""):
        from datetime import datetime, timedelta
        from urllib.parse import quote
        import segno
        root_widget = self
        categories_list = getattr(self, 'categorie', [])
        CATEGORIES = [""] + categories_list
        TYPE_OPTIONS = ["Promemoria", "uscita", "entrata"]
        def create_google_calendar_url(category, description, amount, date_obj, transaction_type):
            description = description.strip()
            display_category = category if category else ""
            event_date = date_obj.date() if isinstance(date_obj, datetime) else date_obj
            start_date_fmt = event_date.strftime("%Y%m%d")
            end_date_fmt = (event_date + timedelta(days=1)).strftime("%Y%m%d")
            title = f"PROMEMORIA: {display_category}"
            details = (f"Descrizione: {description}\n"
                       f"Importo: {amount} ‚Ç¨\n"
                       f"Categoria: {display_category}\n"
                       f"Tipo: {transaction_type.upper()}")
            encoded_title = quote(title)
            encoded_details = quote(details)
            base_url = "https://www.google.com/calendar/event?action=TEMPLATE"
            dates_part = f"&dates={start_date_fmt}/{end_date_fmt}"
            title_part = f"&text={encoded_title}"
            details_part = f"&details={encoded_details}"
            return f"{base_url}{dates_part}{title_part}{details_part}"
        def show_unified_qr_generator(root_widget):
            qr_popup = tk.Toplevel(root_widget)
            qr_popup.title("Generatore Promemoria QRCODE Google Calendar")
            qr_popup.transient(root_widget)
            qr_popup.withdraw()
            W, H = 550, 500
            qr_popup.resizable(False, False)
            qr_popup.geometry(f'{W}x{H}')
            qr_popup.minsize(width=W, height=H)
            qr_popup.update_idletasks()
            screen_width = qr_popup.winfo_screenwidth()
            screen_height = qr_popup.winfo_screenheight()
            x = (screen_width // 2) - (W // 2)
            y = (screen_height // 2) - (H // 2)
            qr_popup.geometry(f'{W}x{H}+{x}+{y}')
            qr_popup.deiconify()
            save_path_tracker = None
            def close_and_cleanup():
                try:
                    self.popup_calendario.destroy() 
                except:
                    pass
                self.popup_calendario = None
                qr_popup.destroy()
                if save_path_tracker and os.path.exists(save_path_tracker):
                    os.remove(save_path_tracker)
            def open_agenda_url():
                webbrowser.open("https://calendar.google.com/calendar/u/0/r/agenda")
            qr_popup.protocol("WM_DELETE_WINDOW", close_and_cleanup)
            qr_popup.bind('<Escape>', lambda e: close_and_cleanup())
            main_frame = ttk.Frame(qr_popup, padding="15")
            main_frame.pack(fill="both", expand=True)
            qr_cat_var = tk.StringVar(qr_popup, value=initial_category or CATEGORIES[0]) 
            qr_type_var = tk.StringVar(qr_popup, value=initial_type if initial_type in TYPE_OPTIONS else TYPE_OPTIONS[0])
            qr_amount_var = tk.StringVar(qr_popup, value=initial_amount) 
            bg_box = self.COLOR_WIDGET_BG
            fg_text = self.TEXT_COLOR
            cursor_color = self.TEXT_COLOR 
            border_color = self.COLOR_HIGHLIGHT
            desc_text_widget = tk.Text(
                main_frame, 
                height=3, 
                width=30, 
                wrap="word",
                bg=bg_box,
                fg=fg_text,
                insertbackground=cursor_color,
                font=("Arial", 10),
                relief="flat",
                highlightthickness=1,
                highlightbackground=border_color
            )
            if initial_description:
                desc_text_widget.insert(tk.END, initial_description)
            date_to_use = initial_date
            if not date_to_use:
                date_to_use = datetime.now().strftime("%d-%m-%Y")
            qr_date_var = tk.StringVar(main_frame, value=date_to_use)
            date_entry_widget_frame = ttk.Frame(main_frame) 
            date_entry_input = ttk.Entry(
                date_entry_widget_frame,
                textvariable=qr_date_var,
                width=24
            )
            date_entry_input.pack(side=tk.LEFT, fill=tk.X, expand=True)
            calendar_button = ttk.Button(
                date_entry_widget_frame,
                text="üóìÔ∏è",
                width=3,
                style="Yellow.TButton",
                command=lambda: self.mostra_calendario_popup(date_entry_input, qr_date_var) 
            )
            calendar_button.pack(side=tk.RIGHT, padx=(2, 0))
            def validate_importo(P):
                if P == "":
                    return True
                try:
                    float(P)
                    if P.count('.') <= 1:
                        return True
                    else:
                        return False
                except ValueError:
                    return False
            vcmd = main_frame.register(validate_importo)
            qr_amount_entry = ttk.Entry(
                main_frame, 
                textvariable=qr_amount_var, 
                width=30,
                validate='key',
                validatecommand=(vcmd, '%P')
            )
            cat_combobox = ttk.Combobox(main_frame, textvariable=qr_cat_var, values=CATEGORIES, width=30, style='Border.TCombobox')
            def reset_fields():
                qr_cat_var.set(CATEGORIES[0])
                qr_type_var.set(TYPE_OPTIONS[0])
                qr_amount_var.set("")
                qr_date_var.set(datetime.now().strftime("%d-%m-%Y"))
                desc_text_widget.delete('1.0', tk.END)
                url_display_label.grid_remove()
                url_text.grid_remove()
                browser_button.grid_remove()
                link_button.grid_remove()
                browser_message.grid_remove()
                browser_message.config(text="")
                generate_button.config(text="Genera QR Code/Link")
            def generate_qr_and_show_result():
                nonlocal save_path_tracker
                browser_message.config(text="", foreground="blue")
                description = desc_text_widget.get("1.0", tk.END).strip()
                date_str = qr_date_var.get()
                try:
                    date_obj = datetime.strptime(date_str, "%d-%m-%Y") 
                except ValueError:
                    browser_message.config(text="Errore: Data non valida (formato gg-mm-aaaa).", foreground="red")
                    browser_message.grid()
                    return
                url = create_google_calendar_url(qr_cat_var.get(), description, qr_amount_var.get().replace(',', '.'), date_obj, qr_type_var.get())
                try:
                    if save_path_tracker and os.path.exists(save_path_tracker):
                        os.remove(save_path_tracker)
                    temp_file = tempfile.NamedTemporaryFile(suffix='.svg', delete=False)
                    temp_file.close()
                    save_path = temp_file.name
                    save_path_tracker = save_path
                except Exception as e:
                    browser_message.config(text=f"ERRORE TEMPFILE: {e}", foreground="red")
                    browser_message.grid()
                    return
                try:
                    qrcode = segno.make(url)
                    qrcode.save(save_path, scale=8, dark="#333", light="white")
                    browser_button.grid() 
                    
                except Exception as e:
                    error_msg = f"ERRORE: Generazione QR fallita. {e}"
                    browser_message.config(text=error_msg, foreground="red")
                    browser_message.grid()
                url_text.delete('1.0', tk.END)
                url_text.insert(tk.END, url)
                root_widget.clipboard_clear()
                root_widget.clipboard_append(url)
                browser_message.config(text="Link copiato negli appunti!", foreground="green")
                url_display_label.grid()
                url_text.grid()
                link_button.grid()
                browser_message.grid()
                def open_svg_in_browser():
                    try:
                        full_path = 'file://' + os.path.realpath(save_path_tracker)
                        webbrowser.open(full_path)
                        browser_message.config(text="QR Code temporaneo aperto nel browser!", foreground="dodgerblue")
                    except Exception:
                        browser_message.config(text="ERRORE: Impossibile aprire il browser.", foreground="red")
                def open_link_in_browser():
                    try:
                        webbrowser.open(url)
                        browser_message.config(text="Link promemoria aperto nel browser!", foreground="dodgerblue")
                    except Exception:
                        browser_message.config(text="ERRORE: Impossibile aprire il link.", foreground="red")
                browser_button.config(command=open_svg_in_browser)
                link_button.config(command=open_link_in_browser)
                generate_button.config(
                    text="Rigenera QR Code/Link",
                    command=generate_qr_and_show_result
                )
                def open_svg_in_browser():
                    if not segno: return
                    try:
                        full_path = 'file://' + os.path.realpath(save_path_tracker)
                        webbrowser.open(full_path)
                        browser_message.config(text="QR Code temporaneo aperto nel browser!", foreground="dodgerblue")
                    except Exception:
                        browser_message.config(text="ERRORE: Impossibile aprire il browser.", foreground="red")
                def open_link_in_browser():
                    try:
                        webbrowser.open(url)
                        browser_message.config(text="Link promemoria aperto nel browser!", foreground="dodgerblue")
                    except Exception:
                        browser_message.config(text="ERRORE: Impossibile aprire il link.", foreground="red")
                browser_button.config(command=open_svg_in_browser)
                link_button.config(command=open_link_in_browser)
                generate_button.config(
                    text="Rigenera QR Code/Link",
                    command=generate_qr_and_show_result
                )
            fields = [
                ("Categoria:", cat_combobox),
                ("Data:", date_entry_widget_frame),
                ("Descrizione (Note):", desc_text_widget),
                ("Tipo:", ttk.Combobox(main_frame, textvariable=qr_type_var, values=TYPE_OPTIONS, state="readonly", width=30, style='Border.TCombobox')),
                ("Importo:", qr_amount_entry) 
            ]
            current_row = 0
            for label_text, widget in fields:
                sticky_val = "nw" if isinstance(widget, tk.Text) else "w"
                ttk.Label(main_frame, text=label_text).grid(row=current_row, column=0, sticky=sticky_val, pady=5, padx=5)
                if isinstance(widget, tk.Text):
                    rowspan = 3 
                    widget.grid(row=current_row, column=1, sticky="ew", pady=5, padx=5, rowspan=rowspan)
                    current_row += rowspan 
                else:
                    widget.grid(row=current_row, column=1, sticky="ew", pady=5, padx=5)
                    current_row += 1 
            sep_row = current_row
            ttk.Separator(main_frame, orient='horizontal').grid(row=sep_row, columnspan=2, sticky="ew", pady=10)
            control_row_1 = sep_row + 1
            generate_button = ttk.Button(main_frame, text="Genera QR Code/Link", command=generate_qr_and_show_result, style="Blu.TButton")
            generate_button.grid(row=control_row_1, column=0, sticky="ew", pady=5, padx=(0, 5))
            close_button = ttk.Button(
                main_frame,
                text="‚ùå Chiudi",
                command=close_and_cleanup,
                style='Giallo.TButton'
            )
            close_button.grid(row=control_row_1, column=1, sticky="ew", pady=5, padx=(5, 0))
            control_row_2 = control_row_1 + 1 
            reset_button = ttk.Button(main_frame, text="üîÑ Reset Campi", command=reset_fields, style="Rosso.TButton")
            reset_button.grid(row=control_row_2, column=0, sticky="ew", pady=5, padx=(0, 5))
            agenda_button = ttk.Button(main_frame, text="üóìÔ∏è Vai ad Agenda Calendar", command=open_agenda_url, style="Blu.TButton")
            agenda_button.grid(row=control_row_2, column=1, sticky="ew", pady=5, padx=(5, 0))
            output_row_start = control_row_2 + 1 
            url_display_label = ttk.Label(main_frame, text="LINK GENERATO:", font=('Arial', 10, 'bold'))
            url_text = tk.Text(
                main_frame, 
                height=3, 
                width=50, 
                wrap="word", 
                bg=bg_box, 
                fg=fg_text,
                insertbackground=cursor_color,
                font=("Courier new", 9),
                relief="flat",
                highlightthickness=1,
                highlightbackground=border_color
            )
            browser_button = ttk.Button(main_frame, text="Mostra QR Code nel Browser", style="Blu.TButton")
            link_button = ttk.Button(main_frame, text="Apri Link Promemoria", style="Arancio.TButton")
            browser_message = ttk.Label(main_frame, text="", foreground="blue")
            url_display_label.grid(row=output_row_start, columnspan=2, sticky="w", pady=(10, 5))
            url_display_label.grid_remove()
            url_text.grid(row=output_row_start + 1, columnspan=2, sticky="ew")
            url_text.grid_remove()
            browser_button.grid(row=output_row_start + 2, column=0, sticky="ew", pady=10, padx=(0, 5))
            browser_button.grid_remove()
            link_button.grid(row=output_row_start + 2, column=1, sticky="ew", pady=10, padx=(5, 0))
            link_button.grid_remove()
            browser_message.grid(row=output_row_start + 3, columnspan=2, pady=5)
            browser_message.grid_remove()
            main_frame.grid_columnconfigure(0, weight=1)
            main_frame.grid_columnconfigure(1, weight=1)
        show_unified_qr_generator(root_widget)

    # Gestione Archivi PDF Documentali
    def gestisci_archivi_pdf(self, categoria_iniziale=None, data_iniziale=None, importo_iniziale=None, tipo_iniziale="Uscita", descrizione_iniziale=""):
        from datetime import datetime
        categorie_vuote = [] 
        if not hasattr(self, 'filtri_avanzati'):
             self.filtri_avanzati = {} 
        if categoria_iniziale and categoria_iniziale.strip() not in ("", "Generica", "‚Äî"):
             self.filtri_avanzati['categoria'] = categoria_iniziale
        elif 'categoria' in self.filtri_avanzati and not categoria_iniziale:
             del self.filtri_avanzati['categoria']
        if data_iniziale:
             self.filtri_avanzati['data_da'] = data_iniziale
             self.filtri_avanzati['data_a'] = data_iniziale
        else:
             self.filtri_avanzati.pop('data_da', None)
             self.filtri_avanzati.pop('data_a', None)
        # Rimuove i vincoli temporali: impostando le date a None, il database 
        # ignora il filtro del giorno e mostra lo storico completo dei documenti.
        #self.filtri_avanzati.update({'data_da': None, 'data_a': None})
        if not hasattr(self, '_ignore_trace'):
             self._ignore_trace = False
        def crea_directory_documenti():
             if not os.path.exists(DB_DIR): os.makedirs(DB_DIR)
             if not os.path.exists(DOC_DIR): os.makedirs(DOC_DIR)
        def load_document_registry():
             crea_directory_documenti()
             if os.path.exists(REGISTRY_FILE):
                 with open(REGISTRY_FILE, 'r', encoding='utf-8') as f:
                     try:
                         content = f.read()
                         if not content: return {}
                         f.seek(0)
                         return json.load(f)
                     except json.JSONDecodeError:
                         self.show_custom_warning("Attenzione", "Il file di registro √® corrotto. Creazione di un nuovo registro.")
                         return {}
             return {}
        def save_document_registry(registry):
             crea_directory_documenti()
             with open(REGISTRY_FILE, 'w', encoding='utf-8') as f:
                 json.dump(registry, f, indent=4, ensure_ascii=False)
             # DataBase Condiviso
             if DB_CONDIVISO:
                 self.notifica_modifica_web()
                 print("üì° Notifica di aggiornamento inviata .")
        def sanitizza_stringa(s, max_len=None):
             s_sanitizzata = s.strip().replace(' ', '_')
             s_sanitizzata = re.sub(r'[^\w\.-]', '', s_sanitizzata) 
             if max_len and len(s_sanitizzata) > max_len: return s_sanitizzata[:max_len]
             return s_sanitizzata.upper()
        def validate_importo(P):
             if P == "": return True
             if not re.match(r'^[\d,\.]*$', P): return False
             cifre = re.sub(r'[^\d]', '', P)
             if len(cifre) > 7: return False
             return True
        vcmd_importo = self.register(validate_importo) 

        def formatta_importo_pulito(importo_raw):
            try:
                importo_str = str(importo_raw).replace(',', '.').strip()
                if not importo_str or importo_str == "N/D":
                    return "0,00"
                valore_float = float(importo_str)
                if isinstance(importo_raw, str) and importo_raw.isdigit() and len(importo_raw) > 0:
                    padded_str = importo_raw.zfill(2)
                    interi = padded_str[:-2] if len(padded_str) > 2 else "0"
                    decimali = padded_str[-2:]
                else:
                    interi = str(int(valore_float))
                    decimali = f"{int(round((valore_float - int(valore_float)) * 100)):02d}"
                if not interi: interi = "0"
                interi_formattati = f"{int(interi):,}".replace(",", ".")
                return f"{interi_formattati},{decimali}"
            except Exception as e:
                print(f"Errore formattazione importo ({importo_raw}): {e}")
                return "0,00"
        def parse_importo_pulito(importo_str_visibile):
             if not importo_str_visibile: return None
             s = importo_str_visibile.replace(' ‚Ç¨', '').replace('.', '').replace(',', '.')
             try: return float(s.strip())
             except ValueError: return None
        def open_pdf(event, treeview):
             try:
                 selected_item = treeview.selection()[0]
                 values = treeview.item(selected_item, 'values')
                 file_name = values[5] 
                 if not file_name or file_name == "N/D":
                     self.show_custom_warning("Attenzione", "Il nome del file non √® disponibile per l'apertura.")
                     return
                 file_path = os.path.join(DOC_DIR, file_name)
                 if os.path.exists(file_path):
                     webbrowser.open(file_path)
                 else:
                     self.show_custom_warning("File Non Trovato", f"Il file:\n{file_name}\nnon esiste pi√π nel percorso:\n{DOC_DIR}")
                     if self.show_custom_askyesno("Registro Corrotto", "Vuoi rimuovere questa voce dal registro?"):
                         self.show_custom_info("Rimuovi Manualmente", "Rimuovi la voce con il tasto 'Cancella Documento' per pulire il registro.")
             except IndexError:
                 self.show_custom_warning("Selezione", "Seleziona un documento da aprire con doppio click.")
             except Exception as e:
                 self.show_custom_warning("Errore Apertura", f"Impossibile aprire il file: {e}")
        def get_document_components(filename, registry):
            DEFAULT_CATEGORY = "Generica"
            if filename in registry:
                doc_data = registry[filename]
                categoria = doc_data.get('categoria_esatta', DEFAULT_CATEGORY)
                descrizione = doc_data.get('descrizione_esatta', 'N/D')
                tipo = doc_data.get('tipo_esatto', 'N/D')
                data_ggmmaaaa = doc_data.get('data_raw', '00000000')
                try: 
                    data_formattata = datetime.strptime(data_ggmmaaaa, "%d%m%Y").strftime("%d-%m-%Y")
                except ValueError: 
                    data_formattata = "N/D"
                importo_raw = str(doc_data.get('importo_raw', 0))
                importo_formattato = formatta_importo_pulito(importo_raw)
                return (data_formattata, categoria, descrizione, importo_formattato, tipo, data_ggmmaaaa, importo_raw, True)
            return "N/D", "N/D", filename, "N/D", "N/D", "00000000", "0", False
        def treeview_sort_column(treeview, col, reverse):
             l = [(treeview.set(k, col), k) for k in treeview.get_children('')]
             if col == 'importo':
                 def sort_key_importo(item):
                     s = item[0].replace(' ‚Ç¨', '').replace('.', '').replace(',', '.')
                     try: return float(s.strip())
                     except ValueError: return -999999999
                 l.sort(key=sort_key_importo, reverse=reverse)
             elif col == 'data':
                 def sort_key_date(item):
                     date_str = item[0]
                     try: return datetime.strptime(date_str, "%d-%m-%Y")
                     except ValueError: return datetime.min
                 l.sort(key=sort_key_date, reverse=reverse)
             else:
                 l.sort(reverse=reverse)
             for index, (val, k) in enumerate(l):
                 treeview.move(k, '', index)
             treeview.heading(col, command=lambda c=col: treeview_sort_column(treeview, col, not reverse))
        def load_documents(treeview, filtri_attuali=None):
                self.funzione_carica_documenti = load_documents
                crea_directory_documenti()
                registry = load_document_registry()
                if not registry and os.path.exists(REGISTRY_FILE) and os.path.getsize(REGISTRY_FILE) > 2:
                        self.after(200, lambda: load_documents(treeview, filtri_attuali))
                        return
                for item in treeview.get_children(): treeview.delete(item)
                documenti_validi = [f for f in registry.keys() if f.endswith('.pdf')]
                items_caricati = []
                totale_filtrato = 0.0
                filtri_attuali = filtri_attuali or {}
                parola_chiave_lower = filtri_attuali.get('parola_chiave', '').lower().strip()
                data_da_obj = None; data_a_obj = None
                if filtri_attuali:
                        try: 
                                if filtri_attuali.get('data_da'): data_da_obj = datetime.strptime(filtri_attuali['data_da'], "%d-%m-%Y").date()
                                if filtri_attuali.get('data_a'): data_a_obj = datetime.strptime(filtri_attuali['data_a'], "%d-%m-%Y").date()
                        except ValueError: pass
                importo_da_float = parse_importo_pulito(filtri_attuali.get('importo_da', ''))
                importo_a_float = parse_importo_pulito(filtri_attuali.get('importo_a', ''))
                def sort_key(doc_file):
                        data_raw = registry.get(doc_file, {}).get('data_raw')
                        if data_raw and len(data_raw) == 8 and data_raw.isdigit():
                                giorno = data_raw[0:2]
                                mese = data_raw[2:4]
                                anno = data_raw[4:8]
                                return anno + mese + giorno
                        return '00000000'
                for doc_file in sorted(documenti_validi, key=sort_key, reverse=True):
                        data, categoria, descrizione, importo_formattato, tipo, data_raw, importo_raw, is_new_logic = get_document_components(doc_file, registry)
                        if not is_new_logic: continue
                        importo_visualizzato = f"{importo_formattato} ‚Ç¨" if importo_formattato != "N/D" else "N/D"
                        search_string = f"{data} {categoria} {descrizione} {tipo} {importo_formattato} {doc_file}".lower()
                        match = True
                        if parola_chiave_lower and parola_chiave_lower not in search_string: match = False
                        if filtri_attuali and match:
                                filtro_categoria_attuale = filtri_attuali.get("categoria")
                                if filtro_categoria_attuale and filtro_categoria_attuale != "‚Äî":
                                        if filtro_categoria_attuale != categoria: 
                                                match = False
                                if filtri_attuali.get("descrizione") and filtri_attuali["descrizione"].lower() not in descrizione.lower(): match = False
                                if filtri_attuali.get("tipo") and filtri_attuali["tipo"] != "‚Äî" and filtri_attuali["tipo"] != tipo: match = False
                                if data_raw != "00000000":
                                        try:
                                                doc_date_obj = datetime.strptime(data_raw, "%d%m%Y").date()
                                                if data_da_obj and doc_date_obj < data_da_obj: match = False
                                                if data_a_obj and doc_date_obj > data_a_obj: match = False
                                        except ValueError: pass 
                                if importo_raw.isdigit():
                                        doc_importo_float = float(importo_raw) / 100 
                                        if importo_da_float is not None and doc_importo_float < importo_da_float: match = False
                                        if importo_a_float is not None and doc_importo_float > importo_a_float: match = False
                        if match:
                                if tipo == "Uscita":
                                        tag_colore = 'uscita_tag'
                                elif tipo == "Entrata":
                                        tag_colore = 'entrata_tag'
                                else:
                                        tag_colore = ''
                                treeview.insert(
                                        "", 
                                        "end", 
                                        values=(data, categoria, descrizione, importo_visualizzato, tipo, doc_file),
                                        tags=(tag_colore,)
                                )
                                items_caricati.append(doc_file)
                                if importo_formattato != "N/D":
                                        importo_float_str = importo_formattato.replace('.', '').replace(',', '.')
                                        try: totale_filtrato += float(importo_float_str)
                                        except ValueError: pass
                num_risultati = len(items_caricati)
                lbl_conteggio_doc.config(text=f"Documenti visualizzati: {num_risultati}")
                if num_risultati > 0:
                        totale_in_centesimi = int(round(totale_filtrato * 100))
                        totale_formattato = formatta_importo_pulito(str(totale_in_centesimi))
                else:
                        totale_formattato = "0,00"
                lbl_totali.config(text=f"Totale Filtrato: {totale_formattato} ‚Ç¨", foreground="dodgerblue")                
                if num_risultati == 0: 
                        lbl_risultati.config(text="‚ùå Nessuna corrispondenza per i filtri attuali.", foreground="red")
                elif parola_chiave_lower or filtri_attuali: 
                        lbl_risultati.config(text=f"üîç Trovati {num_risultati} documenti filtrati.", foreground="dodgerblue")
                else: 
                        lbl_risultati.config(text=f"üìã Totale documenti archiviati: {num_risultati}.", foreground="gray")
                if num_risultati == 0: 
                        lbl_risultati.config(text="üìÇ L'archivio √® attualmente vuoto.", foreground="red")
                elif parola_chiave_lower or filtri_attuali: 
                        lbl_risultati.config(text=f"üîç Trovati {num_risultati} documenti.", foreground="dodgerblue")
                else: 
                        lbl_risultati.config(text=f"üìã Totale documenti archiviati: {num_risultati}.", foreground="gray")
                if num_risultati > 0:
                        totale_in_centesimi = int(round(totale_filtrato * 100))
                        totale_formattato = formatta_importo_pulito(str(totale_in_centesimi))
                else:
                        totale_formattato = "0,00"
                lbl_totali.config(text=f"Totale Filtrato: {totale_formattato} ‚Ç¨", foreground="dodgerblue")

        def inserisci_documento_e_copia():
            data_str = data_var.get()
            categoria_esatta = combo_categoria.get()
            descrizione_esatta = entry_descrizione.get().strip()
            tipo_esatto = combo_tipo.get()
            importo_vis = importo_var.get()
            try:
              data_obj = datetime.strptime(data_str, "%d-%m-%Y").date()
              data_ggmmaaaa = data_obj.strftime("%d%m%Y")
              imp_dec = Decimal(importo_vis.replace(",", "."))
              imp_float, imp_raw = float(imp_dec), str(int(imp_dec * 100))
            except Exception:
              return self.show_custom_warning("Errore", "Dati non validi.")
            desc_icona = f"üìé {descrizione_esatta}"
            f_name = f"{data_ggmmaaaa}_{sanitizza_stringa(descrizione_esatta, 30)}_{tipo_esatto}_{sanitizza_stringa(categoria_esatta, 20)}_{imp_raw}.pdf"
            path = filedialog.askopenfilename(parent=pdf_window, filetypes=[("PDF", "*.pdf")])
            if not path: return
            try:
              shutil.copy2(path, os.path.join(DOC_DIR, f_name))
              domanda_msg = "Ho trovato una spesa simile, vuoi aggiornarla con questo PDF?\n(Scegli 'No' per salvare solo il file)"
              aggiorna_spesa = self.show_custom_askyesno("Aggiorna Spese", domanda_msg)
              if aggiorna_spesa:
                if data_obj not in self.spese:
                  self.spese[data_obj] = [[categoria_esatta, desc_icona, imp_float, tipo_esatto]]
                else:
                  nuova_lista, trovato = [], False
                  for s in self.spese[data_obj]:
                    sp = list(s)
                    if abs(float(sp[2]) - imp_float) < 0.01 and sp[3] == tipo_esatto:
                        sp[0] = categoria_esatta 
                        sp[1] = desc_icona
                        trovato = True
                    nuova_lista.append(sp)
                  if not trovato: 
                      nuova_lista.append([categoria_esatta, desc_icona, imp_float, tipo_esatto])
                  self.spese[data_obj] = nuova_lista
                self.save_db()
              registry = load_document_registry()
              registry[f_name] = {
                "data_raw": data_ggmmaaaa, "categoria_esatta": categoria_esatta,
                "descrizione_esatta": desc_icona, "importo_raw": int(imp_raw),
                "tipo_esatto": tipo_esatto, "timestamp": datetime.now().isoformat()
              }
              save_document_registry(registry)
              self.refresh_gui() 
              if hasattr(self, 'filtri_avanzati'):
                  self.filtri_avanzati['categoria'] = categoria_esatta # Forza la categoria appena usata
              self.show_custom_info("Successo", "Documento salvato e spesa aggiornata.")
              filtra_documenti()
              self.show_custom_info("Successo", "Documento salvato correttamente.")
              pdf_window.after(100, filtra_documenti)
            except Exception as e:
              self.show_custom_warning("Errore", f"Errore: {e}")

        def cancella_documento():
            items = tree.selection()
            if not items: return self.show_custom_warning("Selezione", "Seleziona cosa cancellare.")
            try:
                reg, mod = load_document_registry(), False
                spese_trovate = False
                for item in items:
                    val = tree.item(item, 'values')
                    d_s, c_v, d_v, i_v, t_v, f_n = val
                    try:
                        d_o = datetime.strptime(d_s, "%d-%m-%Y").date()
                        i_f = float(i_v.replace("‚Ç¨","").replace(".","").replace(",",".").strip())
                        if d_o in self.spese:
                            for s in self.spese[d_o]:
                                desc_db = str(s[1]).replace("üìé ", "").strip()
                                desc_tabella = str(d_v).replace("üìé ", "").strip()
                                if (s[0] == c_v and s[3] == t_v and abs(float(s[2]) - i_f) < 0.01 and desc_db == desc_tabella):
                                    spese_trovate = True
                                    break
                    except: continue
                    if spese_trovate: break
                msg_doc = "Eliminare il documento selezionato?" if len(items) == 1 else f"Eliminare i {len(items)} documenti selezionati?"
                if not self.show_custom_askyesno("Conferma", msg_doc): return
                cancella_anche_spesa = False
                if spese_trovate:
                    cancella_anche_spesa = self.show_custom_askyesno("Database Spese", "Trovati Movimenti collegati. Vuoi rimuovere anche quelli?")
                for item in items:
                    val = tree.item(item, 'values')
                    d_s, c_v, d_v, i_v, t_v, f_n = val
                    p = os.path.join(DOC_DIR, f_n)
                    if os.path.exists(p): os.remove(p)
                    try:
                        d_o = datetime.strptime(d_s, "%d-%m-%Y").date()
                        i_f = float(i_v.replace("‚Ç¨","").replace(".","").replace(",",".").strip())
                        if d_o in self.spese:
                            nuova_lista = []
                            for s in self.spese[d_o]:
                                desc_db = str(s[1]).replace("üìé ", "").strip()
                                desc_tabella = str(d_v).replace("üìé ", "").strip()
                                if (s[0] == c_v and s[3] == t_v and abs(float(s[2]) - i_f) < 0.01 and desc_db == desc_tabella):
                                    mod = True
                                    if not cancella_anche_spesa:
                                        nuova_lista.append([s[0], desc_db, s[2], s[3]])
                                    else:
                                        continue 
                                else:
                                    nuova_lista.append(s)
                            self.spese[d_o] = nuova_lista
                    except: pass
                    if f_n in reg: del reg[f_n]
                    tree.delete(item)
                if mod: self.save_db(); self.refresh_gui()
                save_document_registry(reg); load_documents(tree, self.filtri_avanzati)
                self.show_custom_info("OK", "Operazione completata.")
            except Exception as e: self.show_custom_warning("Errore", f"Errore: {e}")
                
        def esporta_documenti_selezionati():
            selected_items = tree.selection()
            if not selected_items:
                self.show_custom_warning("Attenzione", "Seleziona almeno un documento da esportare.")
                return
            target_dir = filedialog.askdirectory(
                initialdir=EXPORT_FILES,
                title="Seleziona la cartella di destinazione per l'esportazione",
            )
            if not target_dir:
                return
            esportati_count = 0
            errori_count = 0
            for item_id in selected_items:
                try:
                    values = tree.item(item_id, 'values')
                    data = values[0]       
                    categoria = values[1]  
                    descrizione = values[2] 
                    original_file_name = values[5]
                    if not original_file_name or original_file_name == "N/D":
                        errori_count += 1
                        continue
                    original_path = os.path.join(DOC_DIR, original_file_name)
                    if not os.path.exists(original_path):
                        self.show_custom_warning("File Mancante", f"Il file sorgente '{original_file_name}' non √® stato trovato.")
                        errori_count += 1
                        continue
                    categoria_safe = categoria.replace(" ", "_").replace("/", "_")
                    descrizione_safe = descrizione.replace(" ", "_").replace("/", "_").replace(".", "")
                    data_safe = data.replace("-", "_")
                    if descrizione_safe and descrizione_safe != "N/D":
                         new_file_name = f"{categoria_safe}_{descrizione_safe}_{data_safe}.pdf"
                    else:
                         new_file_name = f"{categoria_safe}_{data_safe}.pdf"
                    target_path = os.path.join(target_dir, new_file_name)
                    shutil.copy2(original_path, target_path)
                    esportati_count += 1
                except Exception as e:
                    print(f"Errore durante l'esportazione del file '{item_id}': {e}") 
                    errori_count += 1
                    continue
            if esportati_count > 0:
                messaggio = f"Esportazione completata! Sono stati copiati {esportati_count} documenti nella cartella:\n{target_dir}"
                if errori_count > 0:
                    messaggio += f"\nAttenzione: {errori_count} documenti non sono stati esportati a causa di errori."
                self.show_custom_info("Esportazione Multipla Riuscita", messaggio)
                try:
                    os.startfile(target_dir)
                except Exception:
                    pass
            elif errori_count > 0:
                 self.show_custom_warning("Esportazione Fallita", f"Nessun documento √® stato esportato. {errori_count} errori riscontrati.")
        def apri_filtri_avanzati():
            root = pdf_window
            filtro_win = tk.Toplevel(root, bg=self.COLOR_TOPLEVEL)
            filtro_win.title("‚öôÔ∏è Filtri Avanzati")
            larghezza_finestra = 500
            altezza_finestra = 380
            x = root.winfo_rootx() + (root.winfo_width() // 2) - (larghezza_finestra // 2)
            y = root.winfo_rooty() + (root.winfo_height() // 2) - (altezza_finestra // 2)
            filtro_win.geometry(f"{larghezza_finestra}x{altezza_finestra}+{x}+{y}")
            filtro_win.protocol("WM_DELETE_WINDOW", lambda: (
                (self.popup_calendario.destroy(), setattr(self, 'popup_calendario', None)) 
                if hasattr(self, 'popup_calendario') and self.popup_calendario and self.popup_calendario.winfo_exists() 
                else None,
                filtro_win.destroy()
            ))
            filtro_win.bind("<Escape>", lambda e: filtro_win.destroy())
            filtro_win.transient(root)
            descrizione_initial = self.filtri_avanzati.get("descrizione", campo_input.get().strip() if 'campo_input' in locals() else '')
            descrizione_var = tk.StringVar(value=descrizione_initial)
            categoria_var = tk.StringVar(value=self.filtri_avanzati.get("categoria", "‚Äî"))
            tipo_var = tk.StringVar(value=self.filtri_avanzati.get("tipo", "‚Äî"))
            data_da_var = tk.StringVar(value=self.filtri_avanzati.get("data_da", ""))
            data_a_var = tk.StringVar(value=self.filtri_avanzati.get("data_a", ""))
            importo_da_var = tk.StringVar(value=self.filtri_avanzati.get("importo_da", ""))
            importo_a_var = tk.StringVar(value=self.filtri_avanzati.get("importo_a", ""))
            valori_categoria = ["‚Äî"] + (getattr(self, 'categorie', []))
            valori_tipo = ["‚Äî", "Entrata", "Uscita"]
            def applica_filtri():
                nuovi_filtri = {}; 
                if descrizione_var.get().strip():
                    nuovi_filtri["descrizione"] = descrizione_var.get().strip()
                    if 'campo_input' in locals(): campo_input.delete(0, tk.END) 
                if categoria_var.get() and categoria_var.get() != "‚Äî": nuovi_filtri["categoria"] = categoria_var.get()
                if tipo_var.get() and tipo_var.get() != "‚Äî": nuovi_filtri["tipo"] = tipo_var.get()
                try:
                    data_da_str = data_da_var.get().strip()
                    data_a_str = data_a_var.get().strip()
                    if data_da_str: 
                        datetime.strptime(data_da_str, "%d-%m-%Y")
                        nuovi_filtri["data_da"] = data_da_str
                    if data_a_str: 
                        datetime.strptime(data_a_str, "%d-%m-%Y")
                        nuovi_filtri["data_a"] = data_a_str
                except ValueError: 
                    self.show_custom_warning("Errore", "Formato Data non valido (DD-MM-YYYY).")
                    return 
                if parse_importo_pulito(importo_da_var.get()) is not None: nuovi_filtri["importo_da"] = importo_da_var.get()
                if parse_importo_pulito(importo_a_var.get()) is not None: nuovi_filtri["importo_a"] = importo_a_var.get()
                self.filtri_avanzati = nuovi_filtri
                filtro_win.destroy()
                load_documents(tree, self.filtri_avanzati) 
                self.show_custom_info("Filtri Applicati", "Filtri avanzati applicati con successo.")
            def chiudi_filtri(): filtro_win.destroy()
            frame_filtri = ttk.Frame(filtro_win, padding="10"); frame_filtri.pack(fill='both', expand=True)
            ttk.Label(frame_filtri, text="Descrizione (nel nome file):").grid(row=0, column=0, padx=5, pady=5, sticky="w")
            ttk.Entry(frame_filtri, textvariable=descrizione_var, width=30).grid(row=0, column=1, columnspan=2, padx=5, pady=5, sticky="ew")
            ttk.Label(frame_filtri, text="Categoria Esatta:").grid(row=1, column=0, padx=5, pady=5, sticky="w")
            combo_cat_filtro = ttk.Combobox(frame_filtri, textvariable=categoria_var, values=valori_categoria, style="Border.TCombobox", state='readonly', width=27)
            combo_cat_filtro.grid(row=1, column=1, columnspan=2, padx=5, pady=5, sticky="ew")
            ttk.Label(frame_filtri, text="Tipo (Entrata/Uscita):").grid(row=2, column=0, padx=5, pady=5, sticky="w")
            ttk.Combobox(frame_filtri, textvariable=tipo_var, values=valori_tipo, style="Border.TCombobox", state='readonly', width=27).grid(row=2, column=1, columnspan=2, padx=5, pady=5, sticky="ew")
            ttk.Separator(frame_filtri, orient='horizontal').grid(row=3, column=0, columnspan=3, sticky='ew', pady=10)
            ttk.Label(frame_filtri, text="Intervallo Data DA:").grid(row=4, column=0, padx=5, pady=5, sticky="w")
            entry_data_da = ttk.Entry(frame_filtri, textvariable=data_da_var, width=12)
            entry_data_da.grid(row=4, column=1, padx=(0, 2), pady=5, sticky="ew")
            ttk.Button(frame_filtri, text="üóìÔ∏è", style='Giallo.TButton', 
                       command=lambda: self.mostra_calendario_popup_semplice(entry_data_da, data_da_var), width=3).grid(row=4, column=2, padx=(0, 0), pady=5, sticky="w")
            ttk.Label(frame_filtri, text="Intervallo Data A:").grid(row=5, column=0, padx=5, pady=5, sticky="w")
            entry_data_a = ttk.Entry(frame_filtri, textvariable=data_a_var, width=12)
            entry_data_a.grid(row=5, column=1, padx=(0, 2), pady=5, sticky="ew")
            ttk.Button(frame_filtri, text="üóìÔ∏è", style='Giallo.TButton', 
                       command=lambda: self.mostra_calendario_popup_semplice(entry_data_a, data_a_var), width=3).grid(row=5, column=2, padx=(0, 0), pady=5, sticky="w")
            ttk.Label(frame_filtri, text="Importo DA (‚Ç¨):").grid(row=6, column=0, padx=5, pady=5, sticky="w")
            entry_importo_da = ttk.Entry(frame_filtri, textvariable=importo_da_var, width=15); entry_importo_da.grid(row=6, column=1, padx=5, pady=5, sticky="ew")
            ttk.Label(frame_filtri, text="Importo A (‚Ç¨):").grid(row=7, column=0, padx=5, pady=5, sticky="w")
            entry_importo_a = ttk.Entry(frame_filtri, textvariable=importo_a_var, width=15); entry_importo_a.grid(row=7, column=1, padx=5, pady=5, sticky="ew")
            frame_btns = tk.Frame(filtro_win, bg=self.COLOR_TOPLEVEL); frame_btns.pack(pady=10)
            ttk.Button(frame_btns, text="Applica Filtri", style='Blu.TButton', command=applica_filtri).pack(side='left', padx=10)
            ttk.Button(frame_btns, text="Annulla", style='Giallo.TButton', command=chiudi_filtri).pack(side='left', padx=10)
            filtro_win.wait_window()
        def stampa_documenti_selezionati():
            selected_items = tree.selection()
            if not selected_items:
                self.show_custom_warning("Attenzione", "Seleziona almeno un documento da stampare.")
                return
            stampati_count = 0
            errori_count = 0
            current_os = platform.system()
            for item_id in selected_items:
                try:
                    values = tree.item(item_id, 'values')
                    original_file_name = values[5] 
                    if not original_file_name or original_file_name == "N/D":
                        errori_count += 1
                        continue
                    original_path = os.path.join(DOC_DIR, original_file_name) 
                    if not os.path.exists(original_path):
                        self.show_custom_warning("File Mancante", f"Il file sorgente '{original_file_name}' non √® stato trovato.")
                        errori_count += 1
                        continue
                    if current_os == "Windows":
                        os.startfile(original_path, 'print')
                    elif current_os in ["Linux", "Darwin"]:
                        subprocess.Popen(['lp', original_path])
                    else:
                        self.show_custom_warning("OS Non Supportato", f"La stampa diretta di documenti non √® supportata su {current_os}.")
                        errori_count += 1
                        continue
                    stampati_count += 1
                except Exception as e:
                    print(f"Errore durante la preparazione alla stampa del file '{original_file_name}': {e}")
                    self.show_custom_warning("Errore Stampa", f"Impossibile avviare la stampa per '{original_file_name}'. Dettagli: {e}")
                    errori_count += 1
                    continue
            if stampati_count > 0:
                messaggio = f"Comando di stampa inviato per {stampati_count} documento/i."
                if errori_count > 0:
                    messaggio += f"\nAttenzione: {errori_count} documenti non sono stati elaborati per la stampa."
                self.show_custom_info("Stampa Avviata", messaggio)
            elif errori_count > 0:
                self.show_custom_warning("Stampa Fallita", f"Nessun documento √® stato stampato. {errori_count} errori riscontrati.")
        def chiudi_finestra():
             if hasattr(self, 'popup_calendario') and self.popup_calendario and self.popup_calendario.winfo_exists():
                 self.popup_calendario.destroy()
             threading.Thread(target=self.backup_documenti, daemon=False).start()   
             self.filtri_avanzati = {}
             self.pdf_window.destroy()
        def filtra_documenti(event=None):
             filtri = self.filtri_avanzati.copy(); filtri['parola_chiave'] = campo_input.get().strip()
             load_documents(tree, filtri)
        def resetta_campo():
             campo_input.delete(0, tk.END); self.filtri_avanzati = {}
             load_documents(tree, {})
        crea_directory_documenti()
        if hasattr(self, 'pdf_window') and self.pdf_window.winfo_exists(): self.pdf_window.lift(); return
        pdf_window = tk.Toplevel(self, bg=self.COLOR_TOPLEVEL)
        barra_menu_popup = tk.Menu(pdf_window, bg=self.MENU_BG_DARK, fg=self.MENU_FG_LIGHT, activebackground=self.MENU_ACT_BG_COLOR, activeforeground=self.MENU_ACT_FG_COLOR) 
        barra_menu_popup.config(bg=self.MENU_BG_DARK, fg=self.MENU_FG_LIGHT)
        pdf_window.config(menu=barra_menu_popup)
        menu_archivio = tk.Menu(barra_menu_popup, tearoff=0,bg=self.MENU_BG, fg=self.MENU_FG_LIGHT, activebackground=self.MENU_ACT_BG_COLOR, activeforeground=self.MENU_ACT_FG_COLOR)
        barra_menu_popup.add_cascade(label="üìÇ Archivio", menu=menu_archivio)
        menu_archivio.add_command(label="‚ùå Esporta documenti", command=self.esegui_export_documenti_pdf)
        menu_archivio.add_command(label="‚ùå Importa documenti", command=self.esegui_import_documenti_pdf)
        menu_archivio.add_separator()
        menu_archivio.add_command(label="‚ùå Chiudi (ESC)", command=chiudi_finestra)
        self.pdf_window = pdf_window
        pdf_window.title("üìÇ Archivio Documenti PDF")
        pdf_window.withdraw()
        larghezza_finestra = 1200
        altezza_finestra = 600
        larghezza_schermo = self.winfo_screenwidth()
        altezza_schermo = self.winfo_screenheight()
        x = (larghezza_schermo // 2) - (larghezza_finestra // 2)
        y = (altezza_schermo // 2) - (altezza_finestra // 2)
        pdf_window.geometry(f"{larghezza_finestra}x{altezza_finestra}+{x}+{y}")
        pdf_window.minsize(width=800, height=500)
        pdf_window.transient(self)
        pdf_window.deiconify()
        pdf_window.protocol("WM_DELETE_WINDOW", chiudi_finestra)
        pdf_window.bind('<Escape>', lambda e: chiudi_finestra())
        frame_input = ttk.Frame(pdf_window, padding="10") 
        frame_input.pack(fill='x', padx=10, pady=(10, 5))
        data_default = data_iniziale if data_iniziale else datetime.now().strftime("%d-%m-%Y")
        data_var = tk.StringVar(value=data_default)
        importo_var = tk.StringVar(value=importo_iniziale if importo_iniziale else "")
        desc_var = tk.StringVar(value=descrizione_iniziale if descrizione_iniziale else "")
        ttk.Label(frame_input, text="Data:").grid(row=0, column=0, padx=5, pady=5, sticky="w")
        sub_frame_data = ttk.Frame(frame_input)
        sub_frame_data.grid(row=0, column=1, padx=0, pady=5, sticky="w")
        entry_data = ttk.Entry(sub_frame_data, textvariable=data_var, width=12)
        entry_data.pack(side="left", padx=0)
        ttk.Label(frame_input, text="Data:").grid(row=0, column=0, padx=5, pady=5, sticky="w")
        sub_frame_data = ttk.Frame(frame_input)
        sub_frame_data.grid(row=0, column=1, padx=0, pady=5, sticky="w")
        entry_data = ttk.Entry(sub_frame_data, textvariable=data_var, width=12)
        entry_data.pack(side="left", padx=(0, 5))
        ttk.Button(sub_frame_data, text="üóìÔ∏è", style="Yellow.TButton", 
                   command=lambda: self.mostra_calendario_popup(entry_data, data_var), 
                   width=2).pack(side="left", padx=2)
        def imposta_data_oggi():
            oggi = datetime.now().strftime("%d-%m-%Y")
            data_var.set(oggi)
            tabella = getattr(self, 'tabella_documenti', None)
            funzione_load = getattr(self, 'funzione_carica_documenti', None)
            if tabella and funzione_load:
                funzione_load(tabella, {'data_da': oggi, 'data_a': oggi, 'categoria': combo_categoria.get()})
        ttk.Button(sub_frame_data, text="üîô", style="Yellow.TButton", 
                   command=imposta_data_oggi, width=2).pack(side="left", padx=2)
        def reset_data_totale():
            data_var.set("")
            tabella = getattr(self, 'tabella_documenti', None)
            funzione_load = getattr(self, 'funzione_carica_documenti', None)
            if tabella and funzione_load:
                funzione_load(tabella, {'categoria': combo_categoria.get(), 'data_da': None, 'data_a': None})
        ttk.Button(sub_frame_data, text="üîç", style="Yellow.TButton", 
                   command=reset_data_totale, width=2).pack(side="left", padx=2)
        ttk.Label(frame_input, text="Categoria:").grid(row=0, column=3, padx=5, pady=5, sticky="w")
        combo_categoria = ttk.Combobox(frame_input, values=(getattr(self, 'categorie', categorie_vuote)), width=35, style="Border.TCombobox", state='readonly') 
        combo_categoria.set(categoria_iniziale if categoria_iniziale and categoria_iniziale.strip() not in ("", "Generica", "‚Äî") else "Generica") 
        combo_categoria.grid(row=0, column=4, padx=5, pady=5, sticky="w")
        ttk.Label(frame_input, text="Descrizione:").grid(row=0, column=5, padx=5, pady=5, sticky="w")
        entry_descrizione = ttk.Entry(frame_input, width=35, textvariable=desc_var)
        entry_descrizione.grid(row=0, column=6, padx=5, pady=5, sticky="w")
        ttk.Label(frame_input, text="Importo:").grid(row=1, column=0, padx=5, pady=5, sticky="w")
        entry_importo = ttk.Entry(frame_input, width=15, textvariable=importo_var, validate='key', validatecommand=(vcmd_importo, '%P')) 
        entry_importo.grid(row=1, column=1, padx=5, pady=5, sticky="w")
        tipi_movimento = ["Entrata", "Uscita"] 
        ttk.Label(frame_input, text="Tipo:").grid(row=1, column=3, padx=5, pady=5, sticky="w")
        tipi_movimento = ["Entrata", "Uscita"] 
        ttk.Label(frame_input, text="Tipo:").grid(row=1, column=3, padx=5, pady=5, sticky="w")
        combo_tipo = ttk.Combobox(frame_input, values=tipi_movimento, width=15, style="Border.TCombobox", state='readonly')
        combo_tipo.set(tipo_iniziale if tipo_iniziale else "Uscita")  
        combo_tipo.grid(row=1, column=4, padx=5, pady=5, sticky="w")
        frame_ricerca = ttk.Frame(pdf_window, padding="10 0 10 5") 
        frame_ricerca.pack(fill='x', padx=10)
        lbl_cerca = ttk.Label(frame_ricerca, text="Ricerca Documenti:", font=('Arial', 10, 'bold'))
        lbl_cerca.pack(side="left", padx=(0, 5))
        campo_input = ttk.Entry(frame_ricerca, width=30)
        campo_input.pack(side="left", padx=(0, 5), fill='x', expand=True)
        campo_input.bind('<KeyRelease>', filtra_documenti)
        lbl_conteggio_doc = ttk.Label(frame_ricerca, text="Documenti visualizzati: 0", foreground="#0066cc", font=('Arial', 10, 'bold'))
        lbl_conteggio_doc.pack(side="left", padx=(10, 5))
        lbl_risultati = ttk.Label(frame_ricerca, text="", foreground="gray")
        lbl_risultati.pack(side="left")
        lbl_totali = ttk.Label(frame_ricerca, text="")
        lbl_totali.pack(side="left", padx=10)
        ttk.Button(frame_ricerca, text="?", command=lambda: self.mostra_help_pdf(), width=2, style="Yellow.TButton").pack(side="right", padx=(1, 5))
        ttk.Button(frame_ricerca, text="‚öôÔ∏è Filtri Avanzati", command=apri_filtri_avanzati, style="Blu.TButton").pack(side="right", padx=5)
        ttk.Button(frame_ricerca, text="üîô ", command=resetta_campo, style="Yellow.TButton").pack(side="right")
        frame_treeview_container = ttk.Frame(pdf_window)
        frame_treeview_container.pack(fill='both', expand=True, padx=10, pady=5)
        cols = ("data", "categoria", "descrizione", "importo", "tipo", "nome_completo")
        vsb = ttk.Scrollbar(frame_treeview_container, orient="vertical", style="Vertical.TScrollbar")
        tree = ttk.Treeview(frame_treeview_container, columns=cols, show='headings', selectmode='extended', yscrollcommand=vsb.set)
        self.tabella_documenti = tree
        vsb.config(command=tree.yview)
        vsb.pack(side='right', fill='y') 
        tree.pack(side='left', fill='both', expand=True) 
        col_widths = {'data': 100, 'categoria': 150, 'descrizione': 300, 'importo': 100, 'tipo': 70, 'nome_completo': 0}
        col_anchors = {'data': 'center', 'categoria': 'w', 'descrizione': 'w', 'importo': 'e', 'tipo': 'center', 'nome_completo': 'w'}
        for col in cols: 
            tree.heading(col, text=col.capitalize(), command=lambda c=col: treeview_sort_column(tree, c, False))
            tree.column(col, width=col_widths.get(col, 100), anchor=col_anchors.get(col, 'w'))
        tree.column("nome_completo", width=0, stretch=tk.NO) 
        tree.tag_configure('uscita_tag', foreground='red')
        tree.tag_configure('entrata_tag', foreground='green') 
        tree.bind('<Double-1>', lambda e: open_pdf(e, tree))
        tree.bind('<Delete>', lambda e: cancella_documento())
        tree.bind('<Button-3>', lambda event: esporta_documenti_selezionati())
        frame_bottom_buttons = ttk.Frame(pdf_window, padding="10") 
        frame_bottom_buttons.pack(fill='x', padx=10, pady=(5, 10))
        ttk.Button(frame_bottom_buttons, text="üì• Archivia PDF", style='Verde.TButton', command=inserisci_documento_e_copia).pack(side='left', padx=10)
        ttk.Button(frame_bottom_buttons, text="üìÑ Cancella Documenti", style='Rosso.TButton', command=cancella_documento).pack(side='left', padx=10)
        ttk.Button(frame_bottom_buttons, text="üìÑ Stampa Selezionati", style='Blu.TButton', command=stampa_documenti_selezionati).pack(side='left', padx=10)
        ttk.Button(frame_bottom_buttons, text="‚ùå Chiudi", command=chiudi_finestra, style='Giallo.TButton').pack(side='right', padx=10)
        filtra_documenti() 
        self.wait_window(pdf_window)
    def mostra_help_pdf(self):
        if hasattr(self, '_filter_help_popup') and self._filter_help_popup.winfo_exists():
            self._filter_help_popup.destroy()
        popup_aiuto = tk.Toplevel(self, bg=self.COLOR_TOPLEVEL)
        popup_aiuto.title("Guida: Archivio Documenti PDF")
        popup_width = 950
        popup_height = 500
        screen_width = self.winfo_screenwidth()
        screen_height = self.winfo_screenheight()
        center_x = int((screen_width / 2) - (popup_width / 2))
        center_y = int((screen_height / 2) - (popup_height / 2))
        popup_aiuto.geometry(f"{popup_width}x{popup_height}+{center_x}+{center_y}")
        popup_aiuto.resizable(False, False)
        popup_aiuto.transient(self)
        popup_aiuto.grab_set() 
        self._filter_help_popup = popup_aiuto
        main_frame = ttk.Frame(popup_aiuto, padding="15")
        main_frame.pack(fill="both", expand=True)
        content_frame = tk.Frame(main_frame)
        content_frame.pack(fill="both", expand=True)
        def ottieni_contenuto_testo():
            testo = ""

            testo += "=================================================\n"
            testo += "          HELP: ARCHIVIO DOCUMENTI PDF\n"
            testo += "=================================================\n"

            testo += "\nArchiviazione Nuovi Documenti:\n"
            testo += "---------------------------------------\n"
            testo += "‚Ä¢ Campi di Archiviazione: I campi nel pannello superiore sono obbligatori e vengono usati per creare il nome univoco del file e per registrare i metadati nel registro locale.\n\n"
            testo += "‚Ä¢ Archivia PDF (Bottone Verde): Apre il selettore file. Il PDF selezionato viene copiato nella directory locale (db/doc). Attenzione: se il nome file generato esiste gi√†, il file viene sovrascritto.\n"

            testo += "\nNavigazione e Interazione (Treeview Documenti):\n"
            testo += "---------------------------------------------------------\n"
            testo += "‚Ä¢ Apertura Documento (Doppio Clic): Doppio clic su una riga per aprire il file PDF associato.\n"
            testo += "‚Ä¢ Ordinamento: Clicca sull'intestazione di qualsiasi colonna (Data, Importo, Categoria, ecc.) per ordinare i dati.\n"
            testo += "‚Ä¢ Esportazione Selezionata (Tasto Destro): Seleziona righe, clicca Tasto Destro per esportare i file in una cartella esterna.\n"
            testo += "  > Utilizza CTRL + Click per selezionare righe sparse, o SHIFT + Click per selezionare un intervallo continuo.\n"
            testo += "‚Ä¢ Scroll e Navigazione: Utilizza la Rotella del Mouse per scorrere verticalmente in qualsiasi Treeview o area.\n"
            testo += "‚Ä¢ Cancellazione (Canc/Bottone): Seleziona una riga e premi CANC (o usa il bottone 'Cancella Documento') per eliminare file e registro.\n"

            testo += "\nRicerca e Filtraggio:\n"
            testo += "----------------------------\n"

            testo += "‚Ä¢ Ricerca Veloce: Digita una parola chiave; la ricerca √® effettuata su nome file, data, categoria, descrizione e tipo.\n"
            testo += "‚Ä¢ Filtri Avanzati (Bottone Filtro): Filtra documenti per Intervallo di Data, Intervallo di Importo, Categoria Esatta e Tipo (Entrata/Uscita).\n"
 
            testo += "\nOperazioni di Sistema (Menu Archivio):\n"
            testo += "--------------------------------------------------\n"

            testo += "‚Ä¢ Esporta documenti: Crea un archivio ZIP contenente tutti i PDF e il file di registro (.json) per il backup.\n"
            testo += "‚Ä¢ Importa documenti: Carica un archivio ZIP esportato. Attenzione: questa operazione √® distruttiva e sovrascrive tutti i documenti e il registro esistenti.\n"
            
            return testo.strip()
        tk.Label(
            content_frame, 
            text="Archiviazione Nuovi Documenti:", 
            font=("Arial", 11, "bold"), 
            anchor='w'
        ).pack(pady=(5, 5), fill='x')
        tk.Label(
            content_frame,
            text="‚Ä¢ Campi di Archiviazione: I campi nel pannello superiore sono obbligatori e vengono usati per creare il nome univoco del file\n¬† ¬† ¬† e per registrare i metadati nel registro locale.\n\n"
                 "‚Ä¢ Archivia PDF (Bottone Verde): Apre il selettore file. Il PDF selezionato viene copiato nella directory locale (`db/doc`).\n¬† ¬† ¬† Attenzione: se il nome file generato esiste gi√†, il file viene sovrascritto.",
            font=("Arial", 9),
            justify=tk.LEFT,
            anchor='w',
            wraplength=900 
        ).pack(fill='x', padx=5, pady=(0, 5))
        tk.Label(
            content_frame, 
            text="Navigazione e Interazione (Treeview Documenti):", 
            font=("Arial", 11, "bold"), 
            anchor='w'
        ).pack(pady=(10, 5), fill='x')
        tk.Label(
            content_frame,
            text="‚Ä¢ Apertura Documento (Doppio Clic): Doppio clic su una riga per aprire il file PDF associato.\n"
                 "‚Ä¢ Ordinamento: Clicca sull'intestazione di qualsiasi colonna (Data, Importo, Categoria, ecc.) per ordinare i dati.\n"
                 "‚Ä¢ Esportazione Selezionata (Tasto Destro): Seleziona righe, clicca Tasto Destro per esportare i file in una cartella esterna.\n"
                 "¬† > Utilizza CTRL + Click per selezionare righe sparse (selezione mista), o SHIFT + Click per selezionare un intervallo continuo di righe.\n" 
                 "‚Ä¢ Scroll e Navigazione: Utilizza la Rotella del Mouse per scorrere verticalmente in qualsiasi Treeview o area.\n"
                 "‚Ä¢ Cancellazione (Canc/Bottone): Seleziona una riga e premi CANC (o usa il bottone 'üìÑ Cancella Documento') per eliminare file e registro.",
            font=("Arial", 9),
            justify=tk.LEFT,
            anchor='w',
            wraplength=900
        ).pack(fill='x', padx=5, pady=(0, 5))
        tk.Label(
            content_frame, 
            text="Ricerca e Filtraggio:", 
            font=("Arial", 11, "bold"), 
            anchor='w'
        ).pack(pady=(10, 5), fill='x')
        tk.Label(
            content_frame,
            text="‚Ä¢ Ricerca Veloce: Digita una parola chiave; la ricerca √® effettuata su nome file, data, categoria, descrizione e tipo.\n"
                 "‚Ä¢ Filtri Avanzati (Bottone ‚öôÔ∏è): Filtra documenti per Intervallo di Data, Intervallo di Importo, Categoria Esatta e Tipo (Entrata/Uscita).",
            font=("Arial", 9),
            justify=tk.LEFT,
            anchor='w',
            wraplength=900
        ).pack(fill='x', padx=5, pady=(0, 5))
        tk.Label(
            content_frame, 
            text="Operazioni di Sistema (Menu üìÇ Archivio):", 
            font=("Arial", 11, "bold"), 
            anchor='w'
        ).pack(pady=(10, 5), fill='x')
        tk.Label(
            content_frame,
            text="‚Ä¢ Esporta documenti: Crea un archivio ZIP contenente tutti i PDF e il file di registro (`.json`) per il backup.\n"
                 "‚Ä¢ Importa documenti: Carica un archivio ZIP esportato. Attenzione: questa operazione √® distruttiva e sovrascrive tutti i documenti e il registro esistenti.",
            font=("Arial", 9),
            justify=tk.LEFT,
            anchor='w',
            wraplength=900
        ).pack(fill='x', padx=5, pady=(0, 5))
        bottom_frame = ttk.Frame(popup_aiuto)
        bottom_frame.pack(side=tk.BOTTOM, fill=tk.X, pady=(0, 10), padx=15)
        ttk.Button(
            bottom_frame,
            text="üìÑ Stampa Guida",
            command=lambda: self._stampa_lista_diretta(
                ottieni_contenuto_testo(),
                self.show_custom_warning
            ),
            style="Blu.TButton"
        ).pack(side=tk.LEFT, pady=5, padx=10)
        ttk.Button(
            bottom_frame, 
            text="Ho Capito (OK)", 
            command=popup_aiuto.destroy,
            style="Giallo.TButton" 
        ).pack(side=tk.RIGHT, pady=5, padx=10)
        popup_aiuto.bind("<Escape>", lambda e: popup_aiuto.destroy())
    def esegui_export_documenti_pdf(self):
        from datetime import datetime
        backup_formato = "zip"
        current_folder = os.path.basename(DOC_DIR)
        percorso_archivio = ""
        cartella_temp_path = None
        if not os.path.exists(DOC_DIR):
            self.show_custom_warning("Attenzione", f"La cartella sorgente '{DOC_DIR}' non esiste. Backup annullato.")
            return ""
        try:
            timestamp = datetime.now().strftime("%Y%m%d")
            default_name = f"Archivio_Doc-{timestamp}"
            percorso_completo_output = filedialog.asksaveasfilename(
                title="Path Archivio ZIP",
                initialdir=EXP_DB,
                initialfile=default_name,
                confirmoverwrite=False,
                defaultextension=f".{backup_formato}",
                filetypes=[(f"Archivi {backup_formato.upper()}", f"*.{backup_formato}"), ("Tutti i file", "*.*")]
            )
            if not percorso_completo_output:
                return ""
            self.update_idletasks()
            self.update() 
            percorso_output_senza_ext, _ = os.path.splitext(percorso_completo_output)
            cartella_temp_path = tempfile.mkdtemp()
            cartella_dati_nel_temp_path = os.path.join(cartella_temp_path, current_folder)
            shutil.copytree(
                DOC_DIR,
                cartella_dati_nel_temp_path,
                dirs_exist_ok=True
            )
            if os.path.exists(REGISTRY_FILE):
                destinazione_registro = os.path.join(cartella_temp_path, os.path.basename(REGISTRY_FILE))
                shutil.copy2(REGISTRY_FILE, destinazione_registro)
            percorso_archivio = shutil.make_archive(
                base_name=percorso_output_senza_ext,
                format=backup_formato,
                root_dir=cartella_temp_path,
                base_dir=''
            )
            self.show_custom_warning("Salvataggio", f"Estrazione Archivio PDF completato.\n\nFile salvato in: {percorso_archivio}")
        except Exception as e:
            self.show_custom_warning("Errore Backup", f"Errore durante la creazione del backup dei PDF: {e}")
        finally:
            if cartella_temp_path and os.path.exists(cartella_temp_path):
                shutil.rmtree(cartella_temp_path, ignore_errors=True)
        return percorso_archivio
    def esegui_import_documenti_pdf(self):
        current_folder_name = os.path.basename(DOC_DIR)
        registry_file_name = os.path.basename(REGISTRY_FILE)
        backup_file_path = filedialog.askopenfilename(
            title="Seleziona ZIP",
            defaultextension=".zip",
            initialdir=EXP_DB,
            filetypes=[("Archivi ZIP", "Archivio_Doc-*.zip"), ("Tutti i file", "*.*")]
        )
        if not backup_file_path:
            return
        cartella_temp_path = None
        try:
            cartella_temp_path = tempfile.mkdtemp()
            try:
                with zipfile.ZipFile(backup_file_path, 'r') as zip_ref:
                    zip_ref.extractall(cartella_temp_path)
            except zipfile.BadZipFile:
                self.show_custom_warning("Errore Importazione", "Il file selezionato non √® un archivio ZIP valido.")
                return
            temp_pdf_dir = os.path.join(cartella_temp_path, current_folder_name)
            temp_registry_file = os.path.join(cartella_temp_path, registry_file_name)
            if not os.path.isdir(temp_pdf_dir):
                 self.show_custom_warning("Errore Importazione", f"Archivio non valido. Manca la cartella '{current_folder_name}' al suo interno.")
                 return
            registry_present = os.path.exists(temp_registry_file)
            messaggio_conferma = (
                "ATTENZIONE: Stai per importare un backup.\n\n"
                "Sei sicuro di voler procedere con la\nSOVRASCRITTURA?"
            )
            response = self.show_custom_askyesno("Conferma Importazione e Sovrascrittura", messaggio_conferma)
            if not response:
                return   
            if os.path.exists(DOC_DIR):
                shutil.rmtree(DOC_DIR)
            shutil.copytree(temp_pdf_dir, DOC_DIR)
            if registry_present:
                if not os.path.exists(DB_DIR): os.makedirs(DB_DIR) 
                shutil.copy2(temp_registry_file, REGISTRY_FILE)
            if hasattr(self, 'pdf_window') and self.pdf_window.winfo_exists():
                self.filtri_avanzati = {}
                tabella = getattr(self, 'tabella_documenti', None)
                funzione_load = getattr(self, 'funzione_carica_documenti', None)
                if tabella and funzione_load:
                    for i in tabella.get_children():
                        tabella.delete(i)
                    funzione_load(tabella, {}) 
                    self.show_custom_info("Importazione Riuscita", "Lista aggiornata correttamente.")
                # DataBase Condiviso
                if DB_CONDIVISO:
                    self.notifica_modifica_web()
                    print("üì° Notifica di aggiornamento inviata .")    
        except Exception as e:
            self.show_custom_warning("Errore Importazione", f"Si √® verificato un errore critico durante l'importazione: {e}")
        finally:
            if cartella_temp_path and os.path.exists(cartella_temp_path):
                shutil.rmtree(cartella_temp_path, ignore_errors=True)
    def backup_documenti(self):
        from datetime import datetime
        backup_formato = "zip"
        current_folder = os.path.basename(DOC_DIR)
        cartella_temp_path = None
        if not os.path.exists(DOC_DIR):
            print(f"‚ö†Ô∏è Backup saltato: {DOC_DIR} non esiste.")
            return
        try:
            cartella_dest_backup = os.path.join(BASE_DIR, "backup")
            os.makedirs(cartella_dest_backup, exist_ok=True)
            timestamp = datetime.now().strftime("%d%m%Y_%H%M")
            nome_file_nuovo = f"Archivio_Doc-{timestamp}"
            percorso_output_senza_ext = os.path.join(cartella_dest_backup, nome_file_nuovo)
            cartella_temp_path = tempfile.mkdtemp()
            cartella_dati_nel_temp_path = os.path.join(cartella_temp_path, current_folder)
            shutil.copytree(DOC_DIR, cartella_dati_nel_temp_path, dirs_exist_ok=True)
            if os.path.exists(REGISTRY_FILE):
                shutil.copy2(REGISTRY_FILE, os.path.join(cartella_temp_path, os.path.basename(REGISTRY_FILE)))
            percorso_archivio = shutil.make_archive(
                base_name=percorso_output_senza_ext,
                format=backup_formato,
                root_dir=cartella_temp_path,
                base_dir=''
            )
            files = [os.path.join(cartella_dest_backup, f) for f in os.listdir(cartella_dest_backup) if f.startswith("Archivio_Doc-") and f.endswith(".zip")]
            files.sort(key=os.path.getmtime)
            while len(files) > 3:
                file_da_eliminare = files.pop(0)
                os.remove(file_da_eliminare)
            print(f"[{datetime.now().strftime('%H:%M:%S')}] ‚úì Backup Documenti (ZIP) completato con successo.")    
        except Exception as e:
            print(f"‚ùå Errore durante il backup con data: {e}")
        finally:
            if cartella_temp_path and os.path.exists(cartella_temp_path):
                shutil.rmtree(cartella_temp_path, ignore_errors=True)
                
    # Aggiornamenti Github Supermarket.pyw
    def check_supermarket_update(self):
        import datetime
        from datetime import timedelta
        nome_file_locale = NOME_EDITOR_LOCALE
        try:
            url_parts = GITHUB_SUPERMARKET.split('/')
            REPO_OWNER = url_parts[3] 
            REPO_NAME = url_parts[4]
            titolo_popup = "üîÑ Aggiornamento Disponibile"
        except IndexError:
            print("‚ö†Ô∏è Errore nel parsing dell'URL GITHUB_SUPERMARKET.")
            return
        except NameError:
            print("‚ö†Ô∏è Errore: Costanti GITHUB_SUPERMARKET o NOME_EDITOR_LOCALE non definite.")
            return
        try:
            api_url = f"https://api.github.com/repos/{REPO_OWNER}/{REPO_NAME}/commits"
            params = {"path": nome_file_locale, "per_page": 1} 
            response = requests.get(api_url, params=params, timeout=5)
            response.raise_for_status()
            commits = response.json()
            if not commits: return
            commit_date = commits[0]["commit"]["committer"]["date"]
            remote_time = datetime.datetime.strptime(commit_date, "%Y-%m-%dT%H:%M:%SZ").replace(microsecond=0)
            changelog_text = ""
            for commit in commits:
                date_str = commit["commit"]["committer"]["date"]
                commit_dt = datetime.datetime.strptime(date_str, "%Y-%m-%dT%H:%M:%SZ")
                message = commit["commit"]["message"].strip()
                message = message.replace('\r', '') 
                lines = message.split('\n')
                subject = lines[0] 
                body_lines = lines[1:] 
                start_index = 0
                while start_index < len(body_lines):
                    current_line = body_lines[start_index].strip()
                    if not current_line or current_line == subject.strip():
                        start_index += 1
                    else:
                        break
                body_lines = body_lines[start_index:]
                changelog_entry = f"üìù [{commit_dt.strftime('%d/%m/%y %H:%M')}] {subject}\n"
                if body_lines:
                    for line in body_lines:
                        if line.strip(): 
                            changelog_entry += f" ‚û°Ô∏è {line}\n"
                        else:
                             changelog_entry += "\n"
                changelog_entry += "\n" 
                changelog_text += changelog_entry
            if not os.path.exists(nome_file_locale):
                #self.show_custom_warning("File Editor Mancante", f"‚ö†Ô∏è L'editor locale ({nome_file_locale}) non esiste. Aggiornamento consigliato.")
                return
            import datetime
            from datetime import datetime, timezone
            local_time = datetime.fromtimestamp(os.path.getmtime(NOME_FILE), timezone.utc).replace(microsecond=0)
            if remote_time.date() > local_time.date():
                win = tk.Toplevel(self, bg=self.COLOR_UPDATE)
                win.title(titolo_popup)
                win.wm_attributes('-topmost', 1)
                label_timer = ttk.Label(win, text="‚è±Ô∏è Chiusura automatica tra 60 secondi", style="Timer.TLabel")
                label_timer.pack(pady=(10, 0))
                msg = (
                    "üÜï √à stato rilevato un possibile aggiornamento per l'Editor.\n\n"
                    f"üì° Ultima versione online: {remote_time.strftime('%d/%m/%Y %H:%M')}\n"
                    f"üñ•Ô∏è Versione attuale locale: {local_time.strftime('%d/%m/%Y %H:%M')}"
                )
                tk.Label(win, text=msg, bg=self.COLOR_UPDATE, wraplength=460, justify=tk.LEFT).pack(padx=20, pady=(10, 0))
                tk.Label(win, text="Storico Modifiche (Changelog):", bg=self.COLOR_UPDATE).pack(pady=(10, 0))
                frame_changelog = ttk.Frame(win)
                frame_changelog.pack(padx=20, pady=(5, 10), fill='both', expand=True)
                scrollbar = ttk.Scrollbar(frame_changelog, style="Vertical.TScrollbar")
                scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
                text_area = tk.Text(frame_changelog, wrap=tk.WORD, yscrollcommand=scrollbar.set, height=6, width=60, font=("Arial", 9))
                text_area.insert(tk.END, changelog_text.strip())
                text_area.config(state=tk.DISABLED, background="#ADD8E6") 
                text_area.pack(side=tk.LEFT, fill='both', expand=True)
                scrollbar.config(command=text_area.yview)
                tk.Label(win, text="üëâ Vuoi procedere con l'aggiornamento adesso?", bg=self.COLOR_UPDATE).pack(pady=(5, 10))
                frame_bottoni = tk.Frame(win, bg=self.COLOR_UPDATE)
                frame_bottoni.pack(pady=10)
                def aggiorna_timer(secondi_rimasti):
                    if secondi_rimasti > 0:
                        colore = "red" if secondi_rimasti <= 10 else "black"
                        label_timer.config(text=f"‚è±Ô∏è Chiusura automatica tra {secondi_rimasti} secondi")
                        win.after(1000, aggiorna_timer, secondi_rimasti - 1)
                    else:
                        label_timer.config(text="‚è±Ô∏è Chiusura automatica...")
                        win.destroy()
                timeout_id = win.after(60000, win.destroy)
                aggiorna_timer(60)
                def annulla_timeout():
                    win.after_cancel(timeout_id)
                def aggiorna():
                    annulla_timeout()
                    win.destroy()
                    if self.aggiorna(GITHUB_SUPERMARKET, nome_file_locale):
                        self.show_custom_info("Editor Aggiornato", f"L'editor {nome_file_locale} √® stato aggiornato!")
                def chiudi():
                    annulla_timeout()
                    win.destroy()
                ttk.Button(frame_bottoni, text="üîÑ AGGIORNA", command=aggiorna, style="Verde.TButton").pack(side="left", padx=5)
                ttk.Button(frame_bottoni, text="‚ùå CHIUDI", command=chiudi, style="Giallo.TButton").pack(side="left", padx=5)
                win.withdraw()
                win.update_idletasks()
                min_w, min_h = 660, 410
                w = max(win.winfo_width(), min_w)
                h = max(win.winfo_height(), min_h)
                x = self.winfo_rootx() + (self.winfo_width() // 2) - (w // 2)
                y = self.winfo_rooty() + (self.winfo_height() // 2) - (h // 2)
                win.geometry(f"{w}x{h}+{x}+{y}")
                win.deiconify()
                win.grab_set()
                win.transient(self.master)
                win.focus_set()
                win.bind('<Escape>', lambda e: chiudi())
        except requests.exceptions.ConnectionError:
            print(f"üåê Connessione assente o GitHub non raggiungibile per {nome_file_locale}.")
        except requests.exceptions.RequestException as e:
            print(f"‚ö†Ô∏è Errore HTTP o API per {nome_file_locale}: {e}")
        except Exception as e:
            print(f"‚ö†Ô∏è Errore generico durante il controllo aggiornamento per {nome_file_locale}: {e}")

    def check_supermarket_update_manuale(self):
        import datetime
        from datetime import timedelta
        nome_file_locale = NOME_EDITOR_LOCALE
        try:
            url_parts = GITHUB_SUPERMARKET.split('/')
            REPO_OWNER = url_parts[3]
            REPO_NAME = url_parts[4]
            titolo_popup = "üîÑ Aggiornamento Disponibile"
        except IndexError:
            print("‚ö†Ô∏è Errore nel parsing dell'URL GITHUB_SUPERMARKET.")
            return
        except NameError:
            print("‚ö†Ô∏è Errore: Costanti GITHUB_SUPERMARKET o NOME_EDITOR_LOCALE non definite.")
            return
        try:
            api_url = f"https://api.github.com/repos/{REPO_OWNER}/{REPO_NAME}/commits"
            params = {"path": nome_file_locale, "per_page": 1}
            response = requests.get(api_url, params=params, timeout=5)
            response.raise_for_status()
            commits = response.json()
            if not commits: return
            commit_date = commits[0]["commit"]["committer"]["date"]
            remote_time = datetime.datetime.strptime(commit_date, "%Y-%m-%dT%H:%M:%SZ").replace(microsecond=0)
            changelog_text = ""
            for commit in commits:
                date_str = commit["commit"]["committer"]["date"]
                commit_dt = datetime.datetime.strptime(date_str, "%Y-%m-%dT%H:%M:%SZ")
                message = commit["commit"]["message"].strip()
                message = message.replace('\r', '')
                lines = message.split('\n')
                subject = lines[0]
                body_lines = lines[1:]
                start_index = 0
                while start_index < len(body_lines):
                    current_line = body_lines[start_index].strip()
                    if not current_line or current_line == subject.strip():
                        start_index += 1
                    else:
                        break
                body_lines = body_lines[start_index:]
                changelog_entry = f"üìù [{commit_dt.strftime('%d/%m/%y %H:%M')}] {subject}\n"
                if body_lines:
                    for line in body_lines:
                        if line.strip():
                            changelog_entry += f" ‚û°Ô∏è {line}\n"
                        else:
                             changelog_entry += "\n"
                changelog_entry += "\n"
                changelog_text += changelog_entry
            if not os.path.exists(nome_file_locale):
                #self.show_custom_warning("File Editor Mancante", f"‚ö†Ô∏è L'editor locale ({nome_file_locale}) non esiste. Aggiornamento consigliato.")
                return
            import datetime
            from datetime import datetime, timezone
            local_time = datetime.fromtimestamp(os.path.getmtime(NOME_FILE), timezone.utc).replace(microsecond=0)
            if remote_time.date() > local_time.date():
                win = tk.Toplevel(self, bg=self.COLOR_UPDATE)
                win.title(titolo_popup)
                win.wm_attributes('-topmost', 1)
                label_timer = ttk.Label(win, text="‚è±Ô∏è Chiusura automatica tra 60 secondi", style="Timer.TLabel")
                label_timer.pack(pady=(10, 0))
                msg = (
                    "üÜï √à stato rilevato un possibile aggiornamento per l'Editor.\n\n"
                    f"üì° Ultima versione online: {remote_time.strftime('%d/%m/%Y %H:%M')}\n"
                    f"üñ•Ô∏è Versione attuale locale: {local_time.strftime('%d/%m/%Y %H:%M')}"
                )
                tk.Label(win, bg=self.COLOR_UPDATE, text=msg, wraplength=460, justify=tk.LEFT).pack(padx=20, pady=(10, 0))
                tk.Label(win, text="Storico Modifiche (Changelog):", bg=self.COLOR_UPDATE).pack(pady=(10, 0))
                frame_changelog = ttk.Frame(win)
                frame_changelog.pack(padx=20, pady=(5, 10), fill='both', expand=True)
                scrollbar = ttk.Scrollbar(frame_changelog, style="Vertical.TScrollbar")
                scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
                text_area = tk.Text(frame_changelog, wrap=tk.WORD, yscrollcommand=scrollbar.set, height=6, width=60, font=("Arial", 9))
                text_area.insert(tk.END, changelog_text.strip())
                text_area.config(state=tk.DISABLED, background="#ADD8E6")
                text_area.pack(side=tk.LEFT, fill='both', expand=True)
                scrollbar.config(command=text_area.yview)
                tk.Label(win, text="üëâ Vuoi procedere con l'aggiornamento adesso?", bg=self.COLOR_UPDATE).pack(pady=(5, 10))
                frame_bottoni = tk.Frame(win, bg=self.COLOR_UPDATE)
                frame_bottoni.pack(pady=10)
                def aggiorna_timer(secondi_rimasti):
                    if secondi_rimasti > 0:
                        colore = "red" if secondi_rimasti <= 10 else "black"
                        label_timer.config(text=f"‚è±Ô∏è Chiusura automatica tra {secondi_rimasti} secondi")
                        win.after(1000, aggiorna_timer, secondi_rimasti - 1)
                    else:
                        label_timer.config(text="‚è±Ô∏è Chiusura automatica...")
                        win.destroy()
                timeout_id = win.after(60000, win.destroy)
                aggiorna_timer(60)
                def annulla_timeout():
                    win.after_cancel(timeout_id)
                def aggiorna():
                    annulla_timeout()
                    win.destroy()
                    if self.aggiorna(GITHUB_SUPERMARKET, nome_file_locale):
                        self.show_custom_info("Editor Aggiornato", f"L'editor {nome_file_locale} √® stato aggiornato!")
                def chiudi():
                    annulla_timeout()
                    win.destroy()
                ttk.Button(frame_bottoni, text="üîÑ AGGIORNA", command=aggiorna, style="Verde.TButton").pack(side="left", padx=5)
                ttk.Button(frame_bottoni, text="‚ùå CHIUDI", command=chiudi, style="Giallo.TButton").pack(side="left", padx=5)
                win.withdraw()
                win.update_idletasks()
                min_w, min_h = 660, 410
                w = max(win.winfo_width(), min_w)
                h = max(win.winfo_height(), min_h)
                x = self.winfo_rootx() + (self.winfo_width() // 2) - (w // 2)
                y = self.winfo_rooty() + (self.winfo_height() // 2) - (h // 2)
                win.geometry(f"{w}x{h}+{x}+{y}")
                win.deiconify()
                win.grab_set()
                win.transient(self.master)
                win.focus_set()
                win.bind('<Escape>', lambda e: chiudi())
            else:
                self.show_custom_info(
                    "Aggiornamento Editor",
                    f"L'editor '{nome_file_locale}' √® gi√† aggiornato.\n"
                    f"Ultima versione locale: {local_time.strftime('%d/%m/%Y %H:%M')}"
                )
        except requests.exceptions.ConnectionError:
            self.show_custom_warning(
                 "Connessione Assente",
                 f"üåê Connessione assente o GitHub non raggiungibile per il controllo di {nome_file_locale}."
            )
        except requests.exceptions.RequestException as e:
            print(f"‚ö†Ô∏è Errore HTTP o API per {nome_file_locale}: {e}")
            self.show_custom_warning(
                 "Errore GitHub",
                 f"‚ö†Ô∏è Errore nel controllo della versione su GitHub per {nome_file_locale}."
            )
        except Exception as e:
            print(f"‚ö†Ô∏è Errore generico durante il controllo aggiornamento per {nome_file_locale}: {e}")

    def _rimuovi_editor_esterno(self):
        try:
            nome_file = NOME_EDITOR_LOCALE
            nome_backup = f"{nome_file}.bak"
            rimossi = []
            if os.path.exists(nome_file):
                try:
                    os.remove(nome_file)
                    rimossi.append(nome_file)
                except PermissionError:
                    self.show_custom_warning(
                        "Errore Permessi", 
                        f"‚ö†Ô∏è Impossibile rimuovere '{nome_file}'. Il file potrebbe essere in uso."
                    )
                    return
                except Exception as e:
                    self.show_custom_warning("Errore Rimozione", f"‚ùå Errore durante la rimozione di '{nome_file}': {e}")
                    return
            if os.path.exists(nome_backup):
                try:
                    os.remove(nome_backup)
                    rimossi.append(nome_backup)
                except Exception as e:
                    print(f"‚ö†Ô∏è Attenzione: Impossibile rimuovere il file di backup '{nome_backup}': {e}")
            if rimossi:
                messaggio_successo = "\n".join(f"‚úì Rimosso: {f}" for f in rimossi)
                self.show_custom_info(
                    "Rimozione Editor Completata", 
                    f"I seguenti file sono stati rimossi con successo:\n{messaggio_successo}"
                )
            elif not os.path.exists(nome_file) and not os.path.exists(nome_backup):
                self.show_custom_info(
                    "Rimozione Editor", 
                    "L'editor scontrini e il suo backup non erano presenti."
                )
        except NameError:
            self.show_custom_warning(
                "Errore Configurazione", 
                "‚ö†Ô∏è La costante NOME_EDITOR_LOCALE non √® definita. Impossibile procedere."
            )
        except Exception as e:
            self.show_custom_warning("Errore Sconosciuto", f"üõë Errore fatale: {e}")

    # Forza Installazione Editor Scontrini
    def _scarica_editor_esterno(self):
        url = GITHUB_SUPERMARKET
        filename = NOME_EDITOR_LOCALE
        try:
            response = requests.get(url, stream=True)
            response.raise_for_status()
            with open(filename, 'wb') as file:
                for chunk in response.iter_content(chunk_size=8192):
                    file.write(chunk)
            self.show_custom_info(
                "Download Editor", 
                f"‚úì Editor scaricato con successo come '{filename}'."
            )
        except requests.exceptions.RequestException as e:
            self.show_custom_warning(
                "Errore Download", 
                f"‚ùå Impossibile scaricare l'editor. Errore: {e}"
            )

    # Avvia Editor Scontrini
    def _avvia_editor_esterno(self):
        base_dir = os.path.dirname(os.path.abspath(sys.argv[0]))
        script_path = os.path.join(base_dir,"supermarket.pyw") 
        if not os.path.exists(script_path):
            self._scarica_editor_esterno()
            #self.show_custom_warning("Errore File", f"File non trovato. Assicurati che esista in: {script_path}")
            return
        try:
            if sys.platform.startswith('win'):
                comando = [sys.executable.replace('python.exe', 'pythonw.exe'), script_path]
            else:
                comando = ['python3', script_path]
            if hasattr(self, '_popup_spesa_active') and self._popup_spesa_active is not None and self._popup_spesa_active.winfo_exists():
                self._popup_spesa_active.destroy()
            subprocess.run(comando, close_fds=True)
            self.deiconify() 
            self.lift()
            self.focus_force()
        except OSError as e:
            self.show_custom_warning(
                "Errore Esecuzione", 
                f"Impossibile avviare il tool ({comando[0]}). Errore: {e}"
            )

    # Gestisci ripristino focus Blinker
    def _gestisci_ripristino_focus(self, event):
        if event.widget == self: 
            if hasattr(self, 'imp_entry'):
                self.after(0, self.imp_entry.focus_set)
            if ICO_SET_DATE:
                today_date = datetime.datetime.now().strftime("%d-%m-%Y") 
                self.data_spesa_var.set(today_date)
            if hasattr(self, 'ricorrenza_data_inizio'):
                self.ricorrenza_data_inizio.set(today_date)
            if hasattr(self, 'cal'):
                self.goto_today()
        self._reset_inattivita()
                     
    # Gestione Avanzata di Inattivit√† e Minimizzazione (Auto-Lock)                 
    def _attiva_timer_inattivita(self):
        if self._timer_inattivita:
            self.after_cancel(self._timer_inattivita)
        self._timer_inattivita = self.after(self._timeout_inattivita, self._iconizza_finestra)
    def _reset_inattivita(self, cancel_countdown=False): 
        if self._countdown_timer_id and cancel_countdown:
            self.after_cancel(self._countdown_timer_id)
            self._countdown_timer_id = None
            if self._countdown_splash:
                 self._countdown_splash.destroy()
                 self._countdown_splash = None
            self._attiva_timer_inattivita() 
            return 
        if self.state() == "iconic":
            self.deiconify()
            self.after(0, self.imp_entry.focus_set)
        self._attiva_timer_inattivita()
    def _iconizza_finestra(self):
        if self.state() == "iconic":
            self._attiva_timer_inattivita()
            return
        toplevel_active = False
        for widget in self.winfo_children():
            if isinstance(widget, tk.Toplevel) and widget.winfo_ismapped():
                toplevel_active = True
                break
        if toplevel_active:
            self._attiva_timer_inattivita() 
            return
        self._mostra_avviso_countdown()
    def mostra_avviso_iconizzata(self):
        splash = tk.Toplevel(self)
        splash.overrideredirect(True)
        splash.attributes("-topmost", True)
        width, height = 290, 100 
        screen_width = splash.winfo_screenwidth()
        screen_height = splash.winfo_screenheight()
        x = (screen_width // 2) - (width // 2)
        y = (screen_height // 2) - (height // 2)
        splash.geometry(f"{width}x{height}+{x}+{y}")
        bg_color = "#7fc2c7"
        splash.configure(bg=bg_color)
        label = tk.Label(
            splash,
            text = f"üí§ {NAME} Pro v.{VERSION}\n\nFinestra minimizzata per inattivit√†.",
            font=("Arial", 9, "bold"),
            bg=bg_color
        )
        label.pack(expand=True, pady=15)
        splash.update()
        splash.after(3000, splash.destroy)
    def _finalizza_iconizzazione(self):
        if self._countdown_splash:
            self._countdown_splash.destroy()
            self._countdown_splash = None
        self.iconify()
        self.mostra_avviso_iconizzata() 
        self._attiva_timer_inattivita()
    def _mostra_avviso_countdown(self):
        if self._timer_inattivita:
            self.after_cancel(self._timer_inattivita)
            self._timer_inattivita = None
        if self._countdown_splash:
            self._countdown_splash.destroy()
            self._countdown_splash = None
        if self._countdown_timer_id:
            self.after_cancel(self._countdown_timer_id)
            self._countdown_timer_id = None
        splash = tk.Toplevel(self)
        splash.overrideredirect(True)
        splash.attributes("-topmost", True)
        width, height = 290, 100
        screen_width = splash.winfo_screenwidth()
        screen_height = splash.winfo_screenheight()
        x = (screen_width // 2) - (width // 2)
        y = (screen_height // 2) - (height // 2)
        splash.geometry(f"{width}x{height}+{x}+{y}")
        bg_color = "#ffcccc"
        splash.configure(bg=bg_color)
        label = tk.Label(
            splash, 
            text="ATTENZIONE: Avviso di Inattivit√†", 
            font=("Arial", 9, "bold"), 
            bg=bg_color
        ) 
        label.pack(expand=True, pady=30, padx=10)
        splash.update()
        self._countdown_splash = splash
        self._countdown_label = label
        splash.bind("<Motion>", lambda e: self._reset_inattivita(cancel_countdown=True))
        label.bind("<Motion>", lambda e: self._reset_inattivita(cancel_countdown=True))
        self._aggiorna_countdown(self._countdown_delay)
    def _aggiorna_countdown(self, remaining_ms):
        if not self._countdown_splash:
            return
        if remaining_ms <= 0:
            self._finalizza_iconizzazione()
            return
        seconds = remaining_ms // 1000
        self._countdown_label.config(
            text=f"ATTENZIONE: Nessuna attivit√† rilevata.\n\nLa finestra si minimizzer√† tra {seconds} secondi."
        )
        self._countdown_timer_id = self.after(
            1000, 
            lambda: self._aggiorna_countdown(remaining_ms - 1000)
        )
    def _iconizza_finestra_startup(self):
        toplevel_active = False
        for widget in self.winfo_children():
            if isinstance(widget, tk.Toplevel) and widget.winfo_ismapped():
                toplevel_active = True
                break
        if toplevel_active:
            return 
        self.iconify()

    # Analisi e Promemoria Categorie di Spesa Ricorrenti Mancanti Manuale
    def controlla_ricorrenti_manual(self):
        from datetime import datetime
        oggi = datetime.today().date()
        def converti_data(d):
            if isinstance(d, str):
                try:
                    return datetime.strptime(d, "%d-%m-%Y").date()
                except:
                    return None
            elif isinstance(d, datetime):
                return d.date()
            return d
        categorie_base = {cat.title() for cat in self.categorie if cat}
        if not categorie_base:
            return
        categorie_mancanti_nel_mese = []
        presenti_questo_mese = set()
        conteggio_storico = {}
        MESI_INDIETRO = 12 
        for d, sp in self.spese.items():
            dd = converti_data(d)
            if not dd:
                continue
            diff_mesi = (oggi.year - dd.year) * 12 + (oggi.month - dd.month)
            if diff_mesi == 0:
                for voce in sp:
                    if len(voce) > 0 and voce[0].strip():
                        presenti_questo_mese.add(voce[0].strip().title())
            elif 1 <= diff_mesi <= MESI_INDIETRO:
                viste_in_data = set()
                for voce in sp:
                    if len(voce) > 0 and voce[0].strip():
                        cat = voce[0].strip().title()
                        if cat in categorie_base and cat not in viste_in_data:
                            conteggio_storico[cat] = conteggio_storico.get(cat, 0) + 1
                            viste_in_data.add(cat)
        for cat in categorie_base:
            presenze_passate = conteggio_storico.get(cat, 0)
            if presenze_passate >= 4 and cat not in presenti_questo_mese:
                categorie_mancanti_nel_mese.append(cat)
        if categorie_mancanti_nel_mese:
            elenco_mancanti = "\n".join(sorted(categorie_mancanti_nel_mese))
            messaggio = (
                f"‚ö†Ô∏è PROMEMORIA MOVIMENTI RICORRENTI!\n\n"
                f"Hai dimenticato qualcosa? Le seguenti categorie, registrate "
                f"abitualmente negli ultimi mesi, non risultano ancora presenti nel mese corrente:\n\n"
                f"{elenco_mancanti}\n\n"
                f"Premi S√¨ per aprire la verifica dettagliata, oppure No per chiudere."
            )
            risposta = self.show_custom_askyesno(
                "Promemoria Movimenti Ricorrenti", 
                messaggio
            )
            if risposta:
                self.calcola_mancanti()

    # Analisi e Promemoria Categorie di Spesa Ricorrenti Mancanti Automatico
    def controlla_ricorrenti_a_fine_mese(self):
        from datetime import datetime, timedelta
        if hasattr(self, 'changelog_window') and \
           self.changelog_window is not None and \
           self.changelog_window.winfo_exists():
            self.after(5000, self.controlla_ricorrenti_a_fine_mese) 
            return
        oggi = datetime.today().date()
        prossimo_mese = oggi.replace(day=28) + timedelta(days=4)
        ultimo_giorno_mese = prossimo_mese - timedelta(days=prossimo_mese.day)
        giorni_alla_fine = (ultimo_giorno_mese - oggi).days
        if giorni_alla_fine > SOGLIA_GIORNI_RICORRENTI or giorni_alla_fine < 0:
            return
        if self._last_dismiss_date and self._last_dismiss_date.year == oggi.year and self._last_dismiss_date.month == oggi.month:
            return
        def converti_data(d):
            if isinstance(d, str):
                try: return datetime.strptime(d, "%d-%m-%Y").date()
                except: return None
            elif isinstance(d, datetime): return d.date()
            return d
        categorie_base = {cat.title() for cat in self.categorie if cat}
        if not categorie_base:
            return
        categorie_mancanti_nel_mese = []
        presenti_questo_mese = set()
        conteggio_storico = {}
        MESI_INDIETRO = 12
        for d, sp in self.spese.items():
            dd = converti_data(d)
            if not dd: continue
            diff_mesi = (oggi.year - dd.year) * 12 + (oggi.month - dd.month)
            if diff_mesi == 0:
                for voce in sp:
                    if len(voce) > 0 and voce[0].strip():
                        presenti_questo_mese.add(voce[0].strip().title())            
            elif 1 <= diff_mesi <= MESI_INDIETRO:
                viste_oggi = set()
                for voce in sp:
                    if len(voce) > 0 and voce[0].strip():
                        cat = voce[0].strip().title()
                        if cat in categorie_base and cat not in viste_oggi:
                            conteggio_storico[cat] = conteggio_storico.get(cat, 0) + 1
                            viste_oggi.add(cat)
        for cat in categorie_base:
            presenze_passate = conteggio_storico.get(cat, 0)
            if presenze_passate >= 4 and cat not in presenti_questo_mese:
                categorie_mancanti_nel_mese.append(cat)
        if categorie_mancanti_nel_mese:
            if self.wm_state() == 'iconic':
                self.deiconify()
                self.lift()
            elenco_mancanti = "\n".join(sorted(categorie_mancanti_nel_mese))
            messaggio = (
                f"‚ö†Ô∏è PROMEMORIA MOVIMENTI RICORRENTI (Fine Mese)!\n\n"
                f"Hai dimenticato qualcosa? Le seguenti categorie, registrate "
                f"abitualmente nei mesi scorsi, non risultano ancora presenti:\n\n"
                f"{elenco_mancanti}\n\n"
                f"Premi S√¨ per aprire la verifica dettagliata, oppure No per nascondere l'avviso fino al mese prossimo."
            )
            risposta = self.show_custom_askyesno("Promemoria Movimenti Ricorrenti", messaggio)
            if risposta:
                self.calcola_mancanti()
            else:
                self._last_dismiss_date = oggi
                self._salva_dismiss_fm(oggi)

    # Persistenza e Gestione della Data di "Dismiss" Promemoria Ricorrenti
    def _carica_dismiss_fm(self):
        if not os.path.exists(CONTROLLO_F_M):
            return None
        try:
            with open(CONTROLLO_F_M, 'r') as f:
                data = json.load(f)
                data_str = data.get('last_recurring_dismiss')               
                if data_str:
                    return datetime.datetime.strptime(data_str, "%Y-%m-%d").date()
                return None
        except Exception as e:
            print(f"Errore nel caricamento del dismiss ricorrenti: {e}")
            return None
    def _salva_dismiss_fm(self, data_da_salvare):
        try:
            data_str = data_da_salvare.strftime("%Y-%m-%d")
            dati = {'last_recurring_dismiss': data_str}
            dir_path = os.path.dirname(CONTROLLO_F_M)
            if not os.path.exists(dir_path):
                os.makedirs(dir_path)
            with open(CONTROLLO_F_M, 'w') as f:
                json.dump(dati, f, indent=4)
            return True
        except Exception as e:
            errore_messaggio = (
                f"Errore critico durante il salvataggio della data di 'dismiss' "
                f"nel file di controllo ({os.path.basename(CONTROLLO_F_M)}).\n"
                f"L'avviso delle ricorrenti ricomparir√† al prossimo avvio.\n"
                f"Dettagli: {e}"
            )
            if hasattr(self, 'show_custom_error'):
                self.show_custom_warning("‚ö†Ô∏è Errore di Persistenza", errore_messaggio) 
            else:
                print(errore_messaggio)
            return False
            
    # Controllo Versione e Notifica Changelog Tramite GitHub API
    def verifica_e_mostra_changelog(self):
        from datetime import datetime
        import requests
        URL_API = f"https://api.github.com/repos/{REPO_OWNER}/{REPO_NAME}/commits"
        PARAMETRI = {"path": NOME_FILE, "per_page": 1}
        try:
            risposta = requests.get(URL_API, params=PARAMETRI, timeout=5)
            risposta.raise_for_status()
            commits = risposta.json()
            if not commits:
                return
            hash_commit_corrente = commits[0]["sha"]
            hash_visto_precedentemente = self._carica_changelog_hash()
            if hash_commit_corrente != hash_visto_precedentemente:
                self.new_release() 
                self._salva_changelog_hash(hash_commit_corrente)
        except requests.exceptions.RequestException as e:
            print(f"Impossibile controllare gli aggiornamenti su GitHub a causa di un errore di rete: {e}")
        except Exception as e:
            print(f"Errore generico nel controllo aggiornamenti changelog: {e}")
    
    # Recupero e Visualizzazione Dello Storico Modifiche (Changelog) da GitHub
    def new_release(self):
        if self.wm_state() == 'iconic':
            self.deiconify()
            self.lift()
        from datetime import datetime
        api_url = f"https://api.github.com/repos/{REPO_OWNER}/{REPO_NAME}/commits"
        params = {"path": NOME_FILE, "per_page": 1} 
        changelog_text = ""
        try:
            response = requests.get(api_url, params=params, timeout=10)
            response.raise_for_status()
            commits = response.json()
            if not commits:
                self.show_custom_info("Changelog Vuoto", "‚ö†Ô∏è Nessuno storico di commit trovato per questo file.")
                return
            for commit in commits:
                date_str = commit["commit"]["committer"]["date"]
                commit_dt = datetime.strptime(date_str, "%Y-%m-%dT%H:%M:%SZ")
                message = commit["commit"]["message"].strip()
                message = message.replace('\r', '')
                lines = message.split('\n')
                subject = lines[0]
                body_lines = lines[1:]
                start_index = 0
                while start_index < len(body_lines):
                    current_line = body_lines[start_index].strip()
                    if not current_line or current_line == subject.strip():
                        start_index += 1
                    else:
                        break
                body_lines = body_lines[start_index:]
                changelog_entry = f"üìù [{commit_dt.strftime('%d/%m/%y %H:%M')}] {subject}\n"
                if body_lines:
                    for line in body_lines:
                        if line.strip(): 
                            changelog_entry += f" ‚û°Ô∏è {line}\n"
                        else:
                            changelog_entry += "\n"
                changelog_entry += "\n"  
                changelog_text += changelog_entry
            win = tk.Toplevel(self)
            self.changelog_window = win
            win.title(f"üìÑ Storico Modifiche: {NOME_FILE}")
            win.bind('<Escape>', lambda e: win.destroy())
            ttk.Label(win, text=f"Note di Rilascio : v.{VERSION}", font=("Arial", 10, "bold")).pack(pady=(10, 0))
            frame_changelog = ttk.Frame(win)
            frame_changelog.pack(padx=20, pady=(5, 10), fill='both', expand=True)
            scrollbar = ttk.Scrollbar(frame_changelog, style="Vertical.TScrollbar")
            scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
            text_area = tk.Text(frame_changelog, wrap=tk.WORD, yscrollcommand=scrollbar.set, height=15, width=80, font=("Arial", 9))
            text_area.insert(tk.END, changelog_text.strip())
            text_area.config(state=tk.DISABLED, background="#FFFFE0") 
            text_area.pack(side=tk.LEFT, fill='both', expand=True)
            scrollbar.config(command=text_area.yview)
            ttk.Button(win, text="‚ùå Chiudi", command=win.destroy, style="Giallo.TButton").pack(pady=(0, 10))
            win.withdraw()
            win.update_idletasks()
            min_w, min_h = 660, 410
            w = max(win.winfo_width(), min_w)
            h = max(win.winfo_height(), min_h)
            x = self.winfo_rootx() + (self.winfo_width() // 2) - (w // 2)
            y = self.winfo_rooty() + (self.winfo_height() // 2) - (h // 2)
            win.geometry(f"{w}x{h}+{x}+{y}")
            win.deiconify()
            self.lift()
            win.attributes('-topmost', True)
            win.focus_set()
            win.grab_set()
            win.wait_window()
            self.changelog_window = None
        except requests.exceptions.RequestException as e:
            self.show_custom_warning("Errore Connessione", f"‚ö†Ô∏è Impossibile connettersi a GitHub:\n{e}")
        except Exception as e:
            self.show_custom_warning("Errore", f"‚ùå Errore generico durante la visualizzazione dello storico:\n{e}")
    def _carica_changelog_hash(self):
        if not os.path.exists(CONTROLLO_CHANGELOG):
            return ""
        try:
            with open(CONTROLLO_CHANGELOG, 'r') as f:
                data = json.load(f)
                return data.get('last_seen_hash', "")
        except Exception as e:
            print(f"Errore nel caricamento dell'hash del changelog: {e}")
            return ""
    def _salva_changelog_hash(self, commit_hash):
        try:
            dati = {'last_seen_hash': commit_hash}
            dir_path = os.path.dirname(CONTROLLO_CHANGELOG)
            if not os.path.exists(dir_path):
                os.makedirs(dir_path)
            with open(CONTROLLO_CHANGELOG, 'w') as f:
                json.dump(dati, f, indent=4)
            return True
        except Exception as e:
            print(f"Errore critico durante il salvataggio dell'hash del changelog: {e}")
            return False

    # Gestione Icona Applicazione con Fallback e Download Remoto
    def set_app_icon(window):
        ICON_PATH = os.path.join(DB_DIR, ICON_NAME)
        if os.path.exists(ICON_PATH):
            try:
                icon = tk.PhotoImage(file=ICON_PATH)
                window.iconphoto(True, icon) 
                window.icon_ref = icon
            except tk.TclError as e:
                print(f"Errore: Impossibile impostare l'icona dal file {ICON_PATH}.")
        else:
            print("Icona non trovata in locale. Tentativo di download...")
            try:
                response = requests.get(ICON_URL, timeout=10)
                response.raise_for_status()
                os.makedirs(DB_DIR, exist_ok=True)
                with open(ICON_PATH, 'wb') as f:
                    f.write(response.content)
                icon = tk.PhotoImage(file=ICON_PATH)
                window.iconphoto(True, icon)
                window.icon_ref = icon
                print("Icona scaricata e impostata con successo!")
            except requests.exceptions.RequestException as e:
                print(f"Errore durante il download dell'icona: {e}")
            except tk.TclError:
                print("Errore: L'immagine scaricata non √® un formato PhotoImage valido.")

    # Sistema Completo di Aggiornamento Software (Fetch, Notifica, Download, Riavvio)
    def check_aggiornamento_con_api(self):
        import subprocess, sys, os
        import time
        from datetime import datetime, timedelta
        try:
            if os.path.exists(RIMANDA_FILE):
                with open(RIMANDA_FILE, "r") as f:
                    data = json.load(f)
                    rimanda = datetime.strptime(data.get("rimanda_fino", ""), "%Y-%m-%d")
                    if datetime.today() < rimanda:
                        data_visiva = rimanda.strftime("%d-%m-%Y")
                        print(f"‚è≥ Aggiornamento Rimandato fino al {data_visiva}")
                        return
            api_url = f"https://api.github.com/repos/{REPO_OWNER}/{REPO_NAME}/commits"
            params = {"path": NOME_FILE, "per_page": 1}
            response = requests.get(api_url, params=params, timeout=5)
            response.raise_for_status()
            commits = response.json()
            if not commits:
                return 
            commit_date = commits[0]["commit"]["committer"]["date"]
            remote_time = datetime.strptime(commit_date, "%Y-%m-%dT%H:%M:%SZ").replace(microsecond=0)
            changelog_text = ""
            for commit in commits:
                date_str = commit["commit"]["committer"]["date"]
                commit_dt = datetime.strptime(date_str, "%Y-%m-%dT%H:%M:%SZ")
                message = commit["commit"]["message"].strip()
                message = message.replace('\r', '') 
                lines = message.split('\n')
                subject = lines[0] 
                body_lines = lines[1:] 
                start_index = 0
                while start_index < len(body_lines):
                    current_line = body_lines[start_index].strip()
                    if not current_line or current_line == subject.strip():
                        start_index += 1
                    else:
                        break
                body_lines = body_lines[start_index:]
                changelog_entry = f"üìù [{commit_dt.strftime('%d/%m/%y %H:%M')}] {subject}\n"
                if body_lines:
                    for line in body_lines:
                        if line.strip(): 
                            changelog_entry += f" ‚û°Ô∏è {line}\n"
                        else:
                             changelog_entry += "\n"
                changelog_entry += "\n" 
                changelog_text += changelog_entry
            if not os.path.exists(NOME_FILE):
                if self.state() == 'iconic':
                    self.deiconify()
                    self.lift()
                    self.focus_force()
                self.show_custom_warning(
                    "File mancante", 
                    f"‚ö†Ô∏è File '{NOME_FILE}' non trovato (rinominato o rimosso).\n\n"
                    "Vai in 'Opzioni' -> 'Forza Aggiornamento Software' per ripristinarlo."
                )
                return
            from datetime import timezone 
            local_time = datetime.fromtimestamp(os.path.getmtime(NOME_FILE), timezone.utc).replace(microsecond=0)
            if remote_time.date() > local_time.date():
                if self.state() == 'iconic':
                    self.deiconify()
                    self.lift()
                win = tk.Toplevel(self, bg=self.COLOR_UPDATE)
                win.title("üîÑ Aggiornamento disponibile")
                win.bind('<Escape>', lambda e: win.destroy())
                label_timer = ttk.Label(win, text="‚è±Ô∏è Chiusura automatica tra 60 secondi", style="Timer.TLabel")
                label_timer.pack(pady=(10, 0))
                msg = (
                    "üÜï √à stato rilevato un possibile aggiornamento.\n\n"
                    f"üì° Ultima versione online: {remote_time.strftime('%d/%m/%Y %H:%M')}\n"
                    f"üñ•Ô∏è Versione attuale locale: {local_time.strftime('%d/%m/%Y %H:%M')}"
                )
                tk.Label(win, text=msg, wraplength=460, justify=tk.LEFT, bg=self.COLOR_UPDATE).pack(padx=20, pady=(10, 0))
                tk.Label(win, text="Storico Modifiche (Changelog):", bg=self.COLOR_UPDATE).pack(pady=(10, 0))
                frame_changelog = ttk.Frame(win)
                frame_changelog.pack(padx=20, pady=(5, 10), fill='both', expand=True)
                scrollbar = ttk.Scrollbar(frame_changelog, style="Vertical.TScrollbar")
                scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
                text_area = tk.Text(frame_changelog, wrap=tk.WORD, yscrollcommand=scrollbar.set, height=6, width=60, font=("Arial", 9))
                text_area.insert(tk.END, changelog_text.strip())
                text_area.config(state=tk.DISABLED, background="#ADD8E6") 
                text_area.pack(side=tk.LEFT, fill='both', expand=True)
                scrollbar.config(command=text_area.yview)
                tk.Label(win, text="üëâ Vuoi procedere con l'aggiornamento adesso?", bg=self.COLOR_UPDATE).pack(pady=(5, 10))
                frame_bottoni = tk.Frame(win, bg=self.COLOR_UPDATE)
                frame_bottoni.pack(pady=10)
                def aggiorna_timer(secondi_rimasti):
                    if secondi_rimasti > 0:
                        colore = "red" if secondi_rimasti <= 10 else "black"
                        label_timer.config(text=f"‚è±Ô∏è Chiusura automatica tra {secondi_rimasti} secondi")
                        win.after(1000, aggiorna_timer, secondi_rimasti - 1)
                    else:
                        label_timer.config(text="‚è±Ô∏è Chiusura automatica...")
                        win.destroy()
                timeout_id = win.after(60000, win.destroy)
                aggiorna_timer(60)
                def annulla_timeout():
                    win.after_cancel(timeout_id)
                def aggiorna():
                    annulla_timeout()
                    url = f"https://raw.githubusercontent.com/{REPO_OWNER}/{REPO_NAME}/main/{NOME_FILE.replace(' ', '%20')}"
                    win.destroy()
                    try:
                        nome_backup = f"{NOME_FILE}.bak"
                        if os.path.exists(NOME_FILE):
                            shutil.copy2(NOME_FILE, nome_backup)
                        urllib.request.urlretrieve(url, NOME_FILE)
                        print(f"Download completato! {NOME_FILE} √® stato aggiornato.")
                        if os.path.exists(RIMANDA_FILE):
                            try:
                                os.remove(RIMANDA_FILE)
                                print("File rimando eliminato dopo aggiornamento.")
                            except Exception as err:
                                print(f"‚ö†Ô∏è Errore durante l'eliminazione del file rimando: {err}")
                        messaggio = "üîÑ Riavvio in corso. File aggiornato! ATTENDERE..."
                        duration_s = 2 
                        width = 350
                        height = 80
                        popup_win = tk.Toplevel(self)
                        popup_win.overrideredirect(True) 
                        popup_win.resizable(False, False)
                        w_root, h_root = self.winfo_width(), self.winfo_height()
                        x_root, y_root = self.winfo_rootx(), self.winfo_rooty()
                        x_pos = (w_root // 2) - (width // 2)
                        y_pos = (h_root // 2) - (height // 2)
                        popup_win.geometry(f"{width}x{height}+{x_root + x_pos}+{y_root + y_pos}")
                        popup_frame = tk.Frame(popup_win, bg="orange", bd=3, relief="raised")
                        popup_frame.pack(expand=True, fill='both')
                        tk.Label(popup_frame, text=messaggio, font=("Arial", 10, "bold"), 
                                 justify="center", padx=10, pady=10, bg="orange", fg="black").pack(expand=True, fill='both')
                        popup_win.lift() 
                        try:
                            popup_win.attributes('-topmost', True) 
                        except:
                            pass
                        self.update() 
                        time.sleep(duration_s)
                        script_path = os.path.abspath(sys.argv[0])
                        args = [sys.executable, script_path] + sys.argv[1:]
                        if os.name == 'nt':
                            subprocess.Popen(args, creationflags=0x00000008, shell=False, close_fds=True)
                        else:
                            subprocess.Popen(args, start_new_session=True, close_fds=True)
                        os._exit(0)
                    except Exception as e:
                        if 'shutil' in sys.modules and os.path.exists(nome_backup):
                            shutil.copy2(nome_backup, NOME_FILE)
                            os.remove(nome_backup)
                        self.show_custom_warning("Attenzione", f"‚ùå Aggiornamento fallito durante il download/riavvio:\n{e}")
                        return
                def chiudi():
                    annulla_timeout()
                    win.destroy()
                def rimanda():
                    annulla_timeout()
                    win.destroy()
                    nuova_data = datetime.today() + timedelta(days=15)
                    with open(RIMANDA_FILE, "w") as f:
                        json.dump({"rimanda_fino": nuova_data.strftime("%Y-%m-%d")}, f)
                    print(f"‚è≥ Aggiornamento Rimandato fino al {nuova_data.date()}")
                    data_formattata = nuova_data.date().strftime("%d/%m/%Y")
                    self.show_custom_warning("Aggiornamento Rimandato", f"‚è≥ Aggiornamento Rimandato fino al {data_formattata}")
                ttk.Button(frame_bottoni, text="üîÑ AGGIORNA", command=aggiorna, style="Verde.TButton").pack(side="left", padx=5)
                ttk.Button(frame_bottoni, text="‚ùå CHIUDI", command=chiudi, style="Giallo.TButton").pack(side="left", padx=5)
                ttk.Button(frame_bottoni, text="‚è≥ RIMANDA", command=rimanda, style="Arancio.TButton").pack(side="left", padx=5)
                win.withdraw()
                win.update_idletasks()
                min_w, min_h = 660, 410
                w = max(win.winfo_width(), min_w)
                h = max(win.winfo_height(), min_h)
                x = self.winfo_rootx() + (self.winfo_width() // 2) - (w // 2)
                y = self.winfo_rooty() + (self.winfo_height() // 2) - (h // 2)
                win.geometry(f"{w}x{h}+{x}+{y}")
                win.deiconify()
                win.grab_set()
                win.transient(self)
                win.focus_set()
                win.wait_window()
            else:
                self.verifica_e_mostra_changelog()
        except ConnectionError:
            print("üåê Connessione assente o GitHub non raggiungibile.")
        except RequestException as e:
            print(f"‚ö†Ô∏è Errore HTTP o API: {e}")
        except Exception as e:
            print(f"‚ö†Ô∏è Errore generico durante il controllo aggiornamento: {e}")
            
    # Controllo Manuale Forzato degli Aggiornamenti Software
    def forza_check_aggiornamento_con_api(self):
        import time
        from datetime import datetime, timedelta
        import subprocess, sys, os
        if os.path.exists(RIMANDA_FILE):
            try:
                os.remove(RIMANDA_FILE)
                print("File rimando cancellato per la verifica manuale forzata.")
            except Exception as e:
                print(f"‚ö†Ô∏è Errore durante la cancellazione del file rimando: {e}")
        try:
            api_url = f"https://api.github.com/repos/{REPO_OWNER}/{REPO_NAME}/commits"
            params = {"path": NOME_FILE, "per_page": 1}
            response = requests.get(api_url, params=params, timeout=5)
            response.raise_for_status()
            commits = response.json()
            if not commits:
                self.show_custom_warning("Controllo Aggiornamento", "‚ö†Ô∏è Nessun commit trovato. Impossibile verificare lo stato.")
                return 
            commit_date = commits[0]["commit"]["committer"]["date"]
            remote_time = datetime.strptime(commit_date, "%Y-%m-%dT%H:%M:%SZ").replace(microsecond=0)
            changelog_text = ""
            for commit in commits:
                date_str = commit["commit"]["committer"]["date"]
                commit_dt = datetime.strptime(date_str, "%Y-%m-%dT%H:%M:%SZ")
                message = commit["commit"]["message"].strip()
                message = message.replace('\r', '') 
                lines = message.split('\n')
                subject = lines[0] 
                body_lines = lines[1:] 
                start_index = 0
                while start_index < len(body_lines):
                    current_line = body_lines[start_index].strip()
                    if not current_line or current_line == subject.strip():
                        start_index += 1
                    else:
                        break
                body_lines = body_lines[start_index:]
                changelog_entry = f"üìù [{commit_dt.strftime('%d/%m/%y %H:%M')}] {subject}\n"
                if body_lines:
                    for line in body_lines:
                        if line.strip(): 
                            changelog_entry += f" ‚û°Ô∏è {line}\n"
                        else:
                             changelog_entry += "\n"
                changelog_entry += "\n" 
                changelog_text += changelog_entry
            if not os.path.exists(NOME_FILE):
                if self.state() == 'iconic':
                    self.deiconify()
                    self.lift()
                    self.focus_force()
                self.show_custom_warning(
                    "File mancante", 
                    f"‚ö†Ô∏è File '{NOME_FILE}' non trovato (rinominato o rimosso).\n\n"
                    "Vai in 'Opzioni' -> 'Forza Aggiornamento Software' per ripristinarlo."
                )
                return
            from datetime import datetime, timezone
            local_time = datetime.fromtimestamp(os.path.getmtime(NOME_FILE), timezone.utc).replace(microsecond=0)
            if remote_time.date() > local_time.date():
                win = tk.Toplevel(self, bg=self.COLOR_UPDATE)
                win.title("üîÑ Aggiornamento disponibile")
                win.bind('<Escape>', lambda e: win.destroy())
                frame_timer = tk.Frame(win, bg=self.COLOR_UPDATE)
                frame_timer.pack(fill="x", pady=(10, 0))
                label_timer = ttk.Label(frame_timer, text="‚è±Ô∏è Chiusura automatica tra 60 secondi", style="Timer.TLabel")
                label_timer.pack(pady=(10, 0))
                msg = (
                    "üÜï √à stato rilevato un possibile aggiornamento.\n\n"
                    f"üì° Ultima versione online: {remote_time.strftime('%d/%m/%Y %H:%M')}\n"
                    f"üñ•Ô∏è Versione attuale locale: {local_time.strftime('%d/%m/%Y %H:%M')}"
                )
                tk.Label(win, bg=self.COLOR_UPDATE, text=msg, wraplength=460, justify=tk.LEFT).pack(padx=20, pady=(10, 0))
                tk.Label(win, text="Storico Modifiche (Changelog):", bg=self.COLOR_UPDATE).pack(pady=(10, 0))
                frame_changelog = ttk.Frame(win)
                frame_changelog.pack(padx=20, pady=(5, 10), fill='both', expand=True)
                scrollbar = ttk.Scrollbar(frame_changelog, style="Vertical.TScrollbar")
                scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
                text_area = tk.Text(frame_changelog, wrap=tk.WORD, yscrollcommand=scrollbar.set, height=6, width=60, font=("Arial", 9))
                text_area.insert(tk.END, changelog_text.strip())
                text_area.config(state=tk.DISABLED, background="#ADD8E6") 
                text_area.pack(side=tk.LEFT, fill='both', expand=True)
                scrollbar.config(command=text_area.yview)
                tk.Label(win, text="üëâ Vuoi procedere con l'aggiornamento adesso?", bg=self.COLOR_UPDATE).pack(pady=(5, 10))
                frame_bottoni = tk.Frame(win, bg=self.COLOR_UPDATE)
                frame_bottoni.pack(pady=10)
                def aggiorna_timer(secondi_rimasti):
                    if secondi_rimasti > 0:
                        colore = "red" if secondi_rimasti <= 10 else "black"
                        label_timer.config(text=f"‚è±Ô∏è Chiusura automatica tra {secondi_rimasti} secondi")
                        win.after(1000, aggiorna_timer, secondi_rimasti - 1)
                    else:
                        label_timer.config(text="‚è±Ô∏è Chiusura automatica...")
                        win.destroy()
                timeout_id = win.after(60000, win.destroy)
                aggiorna_timer(60)
                def annulla_timeout():
                    win.after_cancel(timeout_id)
                def aggiorna():
                    annulla_timeout()
                    url = f"https://raw.githubusercontent.com/{REPO_OWNER}/{REPO_NAME}/main/{NOME_FILE.replace(' ', '%20')}"
                    win.destroy()
                    try:
                        nome_backup = f"{NOME_FILE}.bak"
                        if os.path.exists(NOME_FILE):
                            shutil.copy2(NOME_FILE, nome_backup)
                        urllib.request.urlretrieve(url, NOME_FILE)
                        print(f"Download completato! {NOME_FILE} √® stato aggiornato.")
                        if os.path.exists(RIMANDA_FILE):
                            try:
                                os.remove(RIMANDA_FILE)
                                print("File rimando eliminato dopo aggiornamento.")
                            except Exception as err:
                                print(f"‚ö†Ô∏è Errore durante l'eliminazione del file rimando: {err}")
                        messaggio = "üîÑ Riavvio in corso. File aggiornato! ATTENDERE..."
                        duration_s = 2 
                        width = 350
                        height = 80
                        popup_win = tk.Toplevel(self)
                        popup_win.overrideredirect(True) 
                        popup_win.resizable(False, False)
                        w_root, h_root = self.winfo_width(), self.winfo_height()
                        x_root, y_root = self.winfo_rootx(), self.winfo_rooty()
                        x_pos = (w_root // 2) - (width // 2)
                        y_pos = (h_root // 2) - (height // 2)
                        popup_win.geometry(f"{width}x{height}+{x_root + x_pos}+{y_root + y_pos}")
                        popup_frame = tk.Frame(popup_win, bg="orange", bd=3, relief="raised")
                        popup_frame.pack(expand=True, fill='both')
                        tk.Label(popup_frame, text=messaggio, font=("Arial", 10, "bold"), 
                                 justify="center", padx=10, pady=10, bg="orange", fg="black").pack(expand=True, fill='both')
                        popup_win.lift() 
                        try:
                            popup_win.attributes('-topmost', True) 
                        except:
                            pass
                        self.update() 
                        time.sleep(duration_s)
                        script_path = os.path.abspath(sys.argv[0])
                        args = [sys.executable, script_path] + sys.argv[1:]
                        if os.name == 'nt':
                            subprocess.Popen(args, creationflags=0x00000008, shell=False, close_fds=True)
                        else:
                            subprocess.Popen(args, start_new_session=True, close_fds=True)
                        os._exit(0)
                    except Exception as e:
                        if 'shutil' in sys.modules and os.path.exists(nome_backup):
                            shutil.copy2(nome_backup, NOME_FILE)
                            os.remove(nome_backup)
                        self.show_custom_warning("Attenzione", f"‚ùå Aggiornamento fallito durante il download/riavvio:\n{e}")
                        return
                def chiudi():
                    annulla_timeout()
                    win.destroy()
                def rimanda():
                    annulla_timeout()
                    win.destroy()
                    nuova_data = datetime.today() + timedelta(days=15)
                    with open(RIMANDA_FILE, "w") as f:
                        json.dump({"rimanda_fino": nuova_data.strftime("%Y-%m-%d")}, f)
                    print(f"‚è≥ Aggiornamento Rimandato fino al {nuova_data.date()}")
                    data_formattata = nuova_data.date().strftime("%d/%m/%Y")
                    self.show_custom_warning("Aggiornamento Rimandato", f"‚è≥ Aggiornamento Rimandato fino al {data_formattata}")
                ttk.Button(frame_bottoni, text="üîÑ AGGIORNA", command=aggiorna, style="Verde.TButton").pack(side="left", padx=5)
                ttk.Button(frame_bottoni, text="‚ùå CHIUDI", command=chiudi, style="Giallo.TButton").pack(side="left", padx=5)
                ttk.Button(frame_bottoni, text="‚è≥ RIMANDA", command=rimanda, style="Arancio.TButton").pack(side="left", padx=5)
                win.withdraw()
                win.update_idletasks()
                min_w, min_h = 660, 410
                w = max(win.winfo_width(), min_w)
                h = max(win.winfo_height(), min_h)
                x = self.winfo_rootx() + (self.winfo_width() // 2) - (w // 2)
                y = self.winfo_rooty() + (self.winfo_height() // 2) - (h // 2)
                win.geometry(f"{w}x{h}+{x}+{y}")
                win.deiconify()
                win.grab_set()
                win.transient(self)
                win.focus_set()
                win.wait_window()
            else:
                self.show_custom_warning("Controllo Manuale", "‚úì Nessun nuovo aggiornamento software disponibile. Sei gi√† all'ultima versione.")
                return
        except ConnectionError:
            print("üåê Connessione assente o GitHub non raggiungibile.")
        except RequestException as e:
            print(f"‚ö†Ô∏è Errore HTTP o API: {e}")
        except Exception as e:
            print(f"‚ö†Ô∏è Errore generico durante il controllo aggiornamento: {e}")
    
    # Funzione di Ripristino del Software da Backup Locale con Riavvio
    def ripristina_da_backup(self):
        import time
        import subprocess, sys, os
        nome_backup = f"{NOME_FILE}.bak"
        p_locale = os.path.dirname(os.path.abspath(__file__))
        file_config = os.path.join(p_locale, "db", "config.json")
        if not os.path.exists(nome_backup):
            self.show_custom_info("Non Riuscito", 
                                  f"‚ùå File di backup ({nome_backup}) non trovato. Impossibile procedere al ripristino.")
            return
        conferma = self.show_custom_askyesno(
            title="Ripristino",
            message=f"Sei sicuro di voler ripristinare il file '{NOME_FILE}' dalla copia di backup?\n\n"
                    f"Questo annuller√† l'ultima modifica/aggiornamento e riavvier√† l'applicazione."
        )
        if not conferma:
            self.show_custom_warning("Annullato", "Ripristino annullato dall'utente.")
            return
        try:
            shutil.copy2(nome_backup, NOME_FILE)
            if os.path.exists(file_config):
                try:
                    os.remove(file_config)
                except Exception as e:
                    print(f"Errore rimozione config: {e}")
            if os.path.exists(nome_backup):        
                os.remove(nome_backup)
            self.save_db()
            self._on_close_lock() 
            messaggio = "Riavvio in corso. File aggiornato! ATTENDERE..."
            duration_s = 2
            width = 350
            height = 80
            parent = self
            parent.update_idletasks()
            parent_width = parent.winfo_width()
            parent_height = parent.winfo_height()
            x_pos = (parent_width // 2) - (width // 2)
            y_pos = (parent_height // 2) - (height // 2)
            popup_frame = tk.Frame(parent, bg="orange", bd=3, relief="raised")
            popup_frame.place(x=x_pos, y=y_pos, width=width, height=height)
            popup_frame.lift()
            label = tk.Label(popup_frame, text=messaggio, font=("Arial", 10, "bold"), 
                              justify="center", padx=10, pady=10, bg="orange", fg="black")
            label.pack(expand=True, fill='both')
            parent.update() 
            time.sleep(duration_s)
            script_path = os.path.abspath(sys.argv[0])
            args = [sys.executable, script_path] + sys.argv[1:]
            if os.name == 'nt':
                subprocess.Popen(args, creationflags=0x00000008, shell=False, close_fds=True)
            else:
                subprocess.Popen(args, start_new_session=True, close_fds=True)
            os._exit(0)
        except Exception as e:
            self.show_custom_warning("Errore Grave", 
                                     f"üõë Errore critico durante il ripristino del file:\n{e}")

    # Visualizzazione Dettagliata dello Storico Modifiche (Changelog Manuale)
    def visualizza_changelog(self):
        from datetime import datetime
        api_url = f"https://api.github.com/repos/{REPO_OWNER}/{REPO_NAME}/commits"
        params = {"path": NOME_FILE, "per_page": 20} 
        changelog_text = ""
        try:
            response = requests.get(api_url, params=params, timeout=10)
            response.raise_for_status()
            commits = response.json()
            if not commits:
                self.show_custom_info("Changelog Vuoto", "‚ö†Ô∏è Nessuno storico di commit trovato per questo file.")
                return
            for commit in commits:
                date_str = commit["commit"]["committer"]["date"]
                commit_dt = datetime.strptime(date_str, "%Y-%m-%dT%H:%M:%SZ")
                message = commit["commit"]["message"].strip()
                message = message.replace('\r', '')
                lines = message.split('\n')
                subject = lines[0]
                body_lines = lines[1:]
                start_index = 0
                while start_index < len(body_lines):
                    current_line = body_lines[start_index].strip()
                    if not current_line or current_line == subject.strip():
                        start_index += 1
                    else:
                        break
                body_lines = body_lines[start_index:]
                changelog_entry = f"üìù [{commit_dt.strftime('%d/%m/%y %H:%M')}] {subject}\n"
                if body_lines:
                    for line in body_lines:
                        if line.strip(): 
                            changelog_entry += f" ‚û°Ô∏è {line}\n"
                        else:
                            changelog_entry += "\n"
                changelog_entry += "\n"  
                changelog_text += changelog_entry
            win = tk.Toplevel(self, bg=self.COLOR_UPDATE)
            win.title(f"üìÑ Storico Modifiche: {NOME_FILE}")
            win.bind('<Escape>', lambda e: win.destroy())
            tk.Label(win, text="Storico degli ultimi commit da GitHub:", bg=self.COLOR_UPDATE, font=("Arial", 10, "bold")).pack(pady=(10, 0))
            frame_changelog = ttk.Frame(win)
            frame_changelog.pack(padx=20, pady=(5, 10), fill='both', expand=True)
            scrollbar = ttk.Scrollbar(frame_changelog, style="Vertical.TScrollbar")
            scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
            text_area = tk.Text(frame_changelog, wrap=tk.WORD, yscrollcommand=scrollbar.set, height=15, width=80, font=("Arial", 9))
            text_area.insert(tk.END, changelog_text.strip())
            text_area.config(state=tk.DISABLED, background="#ADD8E6") 
            text_area.pack(side=tk.LEFT, fill='both', expand=True)
            scrollbar.config(command=text_area.yview)
            ttk.Button(win, text="‚ùå Chiudi", command=win.destroy, style="Giallo.TButton").pack(pady=(0, 10))
            win.withdraw()
            win.update_idletasks()
            min_w, min_h = 660, 410
            w = max(win.winfo_width(), min_w)
            h = max(win.winfo_height(), min_h)
            x = self.winfo_rootx() + (self.winfo_width() // 2) - (w // 2)
            y = self.winfo_rooty() + (self.winfo_height() // 2) - (h // 2)
            win.geometry(f"{w}x{h}+{x}+{y}")
            win.deiconify()
            win.transient(self)
            win.focus_set()
            win.wait_window()
        except requests.exceptions.RequestException as e:
            self.show_custom_warning("Errore Connessione", f"‚ö†Ô∏è Impossibile connettersi a GitHub:\n{e}")
        except Exception as e:
            self.show_custom_warning("Errore", f"‚ùå Errore generico durante la visualizzazione dello storico:\n{e}")
                  
    # Creazione e Archiviazione (ZIP/Formato Specifico) Completa             
    def esegui_backup_zip(self):
        from datetime import datetime
        percorso_archivio = ""
        cartella_temp_path = None
        print(f"‚úì Tentativo di backup di '{self.current_folder}'...")
        try:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            default_name = f"{self.current_folder}_backup_{timestamp}"
            percorso_completo_output = filedialog.asksaveasfilename(
                title="Scegli dove salvare il file di backup",
                initialdir=os.path.expanduser('~'),
                initialfile=default_name,
                confirmoverwrite=False,
                defaultextension=f".{self.backup_formato}",
                filetypes=[(f"Archivi {self.backup_formato.upper()}", f"*.{self.backup_formato}")]
            )
            if not percorso_completo_output:
                print("‚ùå Backup annullato dall'utente.")
                return ""
            popup = Toplevel(self)
            popup.overrideredirect(True)
            bg_color = self.COLOR_WIDGET_BG
            text_color = self.COLOR_HEADER
            accent_color = self.COLOR_HIGHLIGHT
            popup.configure(bg=bg_color, highlightbackground=accent_color, highlightthickness=2)
            w, h = 380, 120
            x = self.winfo_x() + (self.winfo_width() // 2) - (w // 2)
            y = self.winfo_y() + (self.winfo_height() // 2) - (h // 2)
            popup.geometry(f"{w}x{h}+{x}+{y}")
            popup.grab_set()
            lbl_status = Label(
                popup, 
                text="Inizializzazione backup...", 
                font=("Arial", 10, "bold"),
                bg=bg_color,
                fg=text_color
            )
            lbl_status.pack(pady=(25, 5))
            progress = ttk.Progressbar(
                popup, 
                orient="horizontal", 
                length=320, 
                mode="determinate",
                style="Backup.Horizontal.TProgressbar"
            )
            progress.pack(pady=10)
            def aggiorna_UI(valore, testo):
                progress['value'] = valore
                lbl_status.config(text=testo)
                popup.update()
            aggiorna_UI(15, "Preparazione file temporanei...")
            percorso_output_senza_ext, _ = os.path.splitext(percorso_completo_output)
            cartella_destinazione = os.path.dirname(percorso_output_senza_ext)
            root_dir_compress = os.path.dirname(os.getcwd())
            cartella_sorgente = os.path.join(root_dir_compress, self.current_folder)
            cartella_temp_path = tempfile.mkdtemp()
            cartella_dati_nel_temp_nome = self.current_folder
            cartella_dati_nel_temp_path = os.path.join(cartella_temp_path, cartella_dati_nel_temp_nome)
            aggiorna_UI(40, f"Copia dati: {self.current_folder}...")
            PATTERNS_DA_IGNORARE = ('*.lock', '*-journal', '*.db-wal', '*.tmp')
            shutil.copytree(
                cartella_sorgente,
                cartella_dati_nel_temp_path,
                ignore=shutil.ignore_patterns(*PATTERNS_DA_IGNORARE)
            )
            aggiorna_UI(75, "Compressione archivio finale...")
            os.makedirs(cartella_destinazione, exist_ok=True)
            percorso_archivio = shutil.make_archive(
                base_name=percorso_output_senza_ext,
                format=self.backup_formato,
                root_dir=cartella_temp_path,
                base_dir=cartella_dati_nel_temp_nome
            )
            aggiorna_UI(100, "Operazione completata!")
            popup.after(400, popup.destroy)
            self.show_custom_warning("Backup", f"Salvataggio di '{self.current_folder}' eseguito con successo!")
        except Exception as e:
            if 'popup' in locals():
                popup.destroy()
            print(f"‚ùå ERRORE: {e}")
            self.show_custom_warning("Errore", f"Errore durante il backup:\n{e}")
        finally:
            if cartella_temp_path and os.path.exists(cartella_temp_path):
                shutil.rmtree(cartella_temp_path, ignore_errors=True)
                print("‚úì Pulizia file temporanei eseguita.")
        
    # Finestra di Configurazione Avanzata e Gestione delle Preferenze Utente 
    def gestisci_configurazione(self):
        if hasattr(self, 'ferma_scorrimento_automatico'):
            try: self.ferma_scorrimento_automatico()
            except: pass
        if hasattr(self, 'btn_ciclico_carosello'):
            self.btn_ciclico_carosello.configure(variable="") 
            self.btn_ciclico_carosello.state(['!active', '!selected', '!alternate'])
            self.btn_ciclico_carosello.update_idletasks()
        if not self.winfo_exists():
            return
        try:
            with open(CONFIG_FILE, 'r', encoding='utf-8') as f:
                config = json.load(f)
        except (FileNotFoundError, json.JSONDecodeError):
            config = DEFAULT_CONFIG.copy()
        use_wait_window_iniziale = config.get("use_wait_window", DEFAULT_CONFIG.get("use_wait_window", False))
        warn_timeout_ms_iniziale = config.get("warn_timeout_ms", DEFAULT_CONFIG.get("warn_timeout_ms", 20000))
        timeout_sec_iniziale = round(warn_timeout_ms_iniziale / 1000)
        timeout_sec_iniziale = max(5, min(60, timeout_sec_iniziale))
        ico_set_date_iniziale = config.get("ico_set_date", DEFAULT_CONFIG["ico_set_date"])
        recurring_reminder_iniziale = config.get("enable_recurring_reminder", DEFAULT_CONFIG["enable_recurring_reminder"])
        max_backup_iniziale = config.get("max_backup", DEFAULT_CONFIG.get("max_backup", 5))
        max_backup_iniziale = max(1, min(10, max_backup_iniziale))
        soglia_giorni_ricorrenti_iniziale = config.get("soglia_giorni_ricorrenti", DEFAULT_CONFIG.get("soglia_giorni_ricorrenti", 5))
        soglia_giorni_ricorrenti_iniziale = max(1, min(10, soglia_giorni_ricorrenti_iniziale))
        timeout_ms_iniziale = config.get("inactivity_timeout_ms", DEFAULT_CONFIG["inactivity_timeout_ms"])
        timeout_minuti_iniziale = round(timeout_ms_iniziale / 60000)
        timeout_minuti_iniziale = max(5, min(60, timeout_minuti_iniziale))
        anni_da_mantenere_iniziale = config.get("anni_da_mantenere", DEFAULT_CONFIG["anni_da_mantenere"])
        anni_da_mantenere_iniziale = max(2, min(10, anni_da_mantenere_iniziale))
        iconizza_inattivita_iniziale = config.get("iconizza_inattivita", DEFAULT_CONFIG["iconizza_inattivita"])
        smartcat_enabled_iniziale = config.get("smartcat_enabled", DEFAULT_CONFIG.get("smartcat_enabled", True))
        bank_link_iniziale = config.get("bank_link", DEFAULT_CONFIG.get("bank_link", ""))
        thema_iniziale = config.get("thema", DEFAULT_CONFIG.get("thema", "MATERIAL"))
        carosello_enabled_iniziale = config.get("carosello_enabled", DEFAULT_CONFIG.get("carosello_enabled", True))
        carosello_intervallo_iniziale = config.get("carosello_intervallo", DEFAULT_CONFIG.get("carosello_intervallo", 10000))
        carosello_intervallo_sec_iniziale = round(carosello_intervallo_iniziale / 1000)
        carosello_intervallo_sec_iniziale = max(5, min(30, carosello_intervallo_sec_iniziale))
        udp_port_1_iniziale = config.get("udp_port_1", 5555)
        udp_port_2_iniziale = config.get("udp_port_2", 5556)
        target_mese_iniziale = config.get("target_mese", 0)
        target_anno_iniziale = config.get("target_anno", 0)
        sync_enabled_iniziale = config.get("sync_dati_enabled", DEFAULT_CONFIG.get("sync_dati_enabled", False))
        email_user_iniziale = config.get("email_user", DEFAULT_CONFIG.get("email_user", ""))
        app_password_iniziale = config.get("app_password", DEFAULT_CONFIG.get("app_password", ""))
        gemini_api_key_iniziale = config.get("gemini_api_key", DEFAULT_CONFIG.get("gemini_api_key", ""))
        pk_raw = config.get("parole_chiave", DEFAULT_CONFIG.get("parole_chiave", "no-reply-ML@aceaenergia.it, no-reply.acque@acque.net, contotelefonico@fatturazione.windtre.it"))
        if isinstance(pk_raw, list):
            parole_chiave_iniziale = ", ".join(pk_raw)
        else:
            parole_chiave_iniziale = pk_raw
            
        sync_intervallo_iniziale = config.get("sync_intervallo_min", DEFAULT_CONFIG.get("sync_intervallo_min", 720))
        
        config_window = Toplevel(self)
        config_window.title("‚öôÔ∏è Configurazione Applicazione")
        config_window.bind('<Escape>', lambda e: config_window.destroy())
        config_window.resizable(False, False)
        self.var_use_wait_window = tk.BooleanVar(value=use_wait_window_iniziale)
        self.var_warn_timeout_sec = tk.DoubleVar(value=timeout_sec_iniziale)
        self.var_ico_set_date = tk.BooleanVar(value=ico_set_date_iniziale)
        self.var_recurring_reminder = tk.BooleanVar(value=recurring_reminder_iniziale)
        self.var_max_backup = tk.IntVar(value=max_backup_iniziale)
        self.var_soglia_ricorrenti = tk.IntVar(value=soglia_giorni_ricorrenti_iniziale)
        self.var_smartcat_enabled = tk.BooleanVar(value=smartcat_enabled_iniziale)
        self.var_auto_login = tk.BooleanVar(value=config.get("enable_auto_login_flow", DEFAULT_CONFIG["enable_auto_login_flow"]))
        self.var_webserver_enabled = tk.BooleanVar(value=config.get("webserver_enabled", DEFAULT_CONFIG["webserver_enabled"]))
        self.var_timeout_minuti = tk.DoubleVar(value=timeout_minuti_iniziale)
        self.var_port = tk.IntVar(value=config.get("webserver_port", DEFAULT_CONFIG["webserver_port"]))
        self.var_bank_link = tk.StringVar(value=bank_link_iniziale)
        self.var_load_geometry = tk.BooleanVar(value=config.get("load_saved_geometry", DEFAULT_CONFIG["load_saved_geometry"]))
        self.var_anni_da_mantenere = tk.IntVar(value=anni_da_mantenere_iniziale)
        self.var_iconizza_inattivita = tk.BooleanVar(value=iconizza_inattivita_iniziale)
        self.var_thema = tk.StringVar(value=thema_iniziale.capitalize())
        self.var_carosello_enabled = tk.BooleanVar(value=carosello_enabled_iniziale)
        self.var_carosello_intervallo_sec = tk.DoubleVar(value=carosello_intervallo_sec_iniziale)
        self.var_cal_tooltips = tk.BooleanVar(value=config.get("cal_tooltips_enabled", False))
        self.var_shared_db = tk.BooleanVar(value=config.get("shared_db", DEFAULT_CONFIG.get("shared_db", False)))
        self.var_shared_db_path = tk.StringVar(value=config.get("shared_db_path", DEFAULT_CONFIG.get("shared_db_path", "")))
        self.var_udp_port_1 = tk.IntVar(value=udp_port_1_iniziale)
        self.var_udp_port_2 = tk.IntVar(value=udp_port_2_iniziale)
        self.var_target_mese = tk.DoubleVar(value=target_mese_iniziale)
        self.var_target_anno = tk.DoubleVar(value=target_anno_iniziale)
 
        self.var_sync_enabled = tk.BooleanVar(value=sync_enabled_iniziale)
        self.var_email_user = tk.StringVar(value=email_user_iniziale)
        self.var_app_password = tk.StringVar(value=app_password_iniziale)
        self.var_gemini_api_key = tk.StringVar(value=gemini_api_key_iniziale)
        self.var_parole_chiave = tk.StringVar(value=parole_chiave_iniziale)
        self.var_sync_intervallo = tk.IntVar(value=sync_intervallo_iniziale)
        
        main_frame = ttk.Frame(config_window, padding="10 10 10 5")
        main_frame.pack(fill="both", expand=True)
        main_frame.columnconfigure(0, weight=1)
        main_frame.columnconfigure(1, weight=1)
        main_frame.columnconfigure(2, weight=0)
        warn_timeout_label = ttk.Label(main_frame, text="")
        timeout_label = ttk.Label(main_frame, text="")
        anni_label = ttk.Label(main_frame, text="")
        max_backup_label = ttk.Label(main_frame, text="")
        soglia_ricorrenti_label = ttk.Label(main_frame, text="")
        carosello_intervallo_label = ttk.Label(main_frame, text="")
        target_mese_label = ttk.Label(main_frame, text="")
        target_anno_label = ttk.Label(main_frame, text="")

        def update_warn_timeout_label(value):
            current_sec = int(round(self.var_warn_timeout_sec.get()))
            warn_timeout_label.config(text=f"{current_sec} Sec.")
        def update_timeout_label(value):
            current_minuti = int(round(self.var_timeout_minuti.get()))
            timeout_label.config(text=f"{current_minuti} Min.")
        def update_anni_label(value):
            current_anni = int(round(self.var_anni_da_mantenere.get()))
            anni_label.config(text=f"{current_anni} Anni")
        def update_max_backup_label(value):
            current_val = int(round(self.var_max_backup.get()))
            max_backup_label.config(text=f"{current_val} Copie")
        def update_soglia_ricorrenti_label(value):
            current_val = int(round(self.var_soglia_ricorrenti.get()))
            soglia_ricorrenti_label.config(text=f"{current_val} Giorni")
        def update_carosello_intervallo_label(value):
            current_sec = int(round(self.var_carosello_intervallo_sec.get()))
            carosello_intervallo_label.config(text=f"{current_sec} Sec.")      
        def update_target_mese_label(*args):
            val = self.var_target_mese.get()
            target_mese_label.config(text=f"{val:,.2f} ‚Ç¨")
        def update_target_anno_label(*args):
            val = self.var_target_anno.get()
            target_anno_label.config(text=f"{val:,.2f} ‚Ç¨")
        
        def reset_defaults():
            self.var_auto_login.set(DEFAULT_CONFIG["enable_auto_login_flow"])
            self.var_webserver_enabled.set(DEFAULT_CONFIG["webserver_enabled"])
            self.var_port.set(DEFAULT_CONFIG["webserver_port"])
            self.var_bank_link.set(DEFAULT_CONFIG.get("bank_link", ""))
            self.var_load_geometry.set(DEFAULT_CONFIG["load_saved_geometry"])
            self.var_use_wait_window.set(DEFAULT_CONFIG.get("use_wait_window", False))
            default_timeout_min = round(DEFAULT_CONFIG["inactivity_timeout_ms"] / 60000)
            self.var_timeout_minuti.set(max(5, default_timeout_min))
            update_timeout_label(self.var_timeout_minuti.get())
            self.var_anni_da_mantenere.set(DEFAULT_CONFIG["anni_da_mantenere"])
            update_anni_label(self.var_anni_da_mantenere.get())
            self.var_iconizza_inattivita.set(DEFAULT_CONFIG["iconizza_inattivita"])
            self.var_ico_set_date.set(DEFAULT_CONFIG["ico_set_date"])
            self.var_recurring_reminder.set(DEFAULT_CONFIG.get("enable_recurring_reminder", False))
            self.var_max_backup.set(max(1, min(10, DEFAULT_CONFIG.get("max_backup", 5))))
            update_max_backup_label(self.var_max_backup.get())
            self.var_soglia_ricorrenti.set(max(1, min(10, DEFAULT_CONFIG.get("soglia_giorni_ricorrenti", 5))))
            update_soglia_ricorrenti_label(self.var_soglia_ricorrenti.get())
            self.var_smartcat_enabled.set(DEFAULT_CONFIG.get("smartcat_enabled", True))
            self.var_thema.set(DEFAULT_CONFIG.get("thema", "OBSIDIAN").capitalize())
            self.var_carosello_enabled.set(DEFAULT_CONFIG.get("carosello_enabled", True))
            default_carosello_sec = round(DEFAULT_CONFIG.get("carosello_intervallo", 10000) / 1000)
            self.var_carosello_intervallo_sec.set(max(5, min(30, default_carosello_sec)))
            update_carosello_intervallo_label(self.var_carosello_intervallo_sec.get())
            self.var_cal_tooltips.set(False)
            self.var_shared_db.set(DEFAULT_CONFIG.get("shared_db", False))
            self.var_shared_db_path.set(DEFAULT_CONFIG.get("shared_db_path", PATH_LOCALE))
            self.var_udp_port_1.set(DEFAULT_CONFIG.get("udp_port_1", 5555))
            self.var_udp_port_2.set(DEFAULT_CONFIG.get("udp_port_2", 5556))
            self.var_target_mese.set(DEFAULT_CONFIG.get("target_mese", 0))
            self.var_target_anno.set(DEFAULT_CONFIG.get("target_anno", 0))
            self.var_sync_enabled.set(DEFAULT_CONFIG.get("sync_dati_enabled", False))
            self.var_email_user.set(DEFAULT_CONFIG.get("email_user", "@gmail.com"))
            self.var_app_password.set(DEFAULT_CONFIG.get("app_password", ""))
            self.var_gemini_api_key.set(DEFAULT_CONFIG.get("gemini_api_key", ""))
            self.var_parole_chiave.set(", ".join(DEFAULT_CONFIG.get("parole_chiave", ["no-reply-ML@aceaenergia.it, no-reply.acque@acque.net, contotelefonico@fatturazione.windtre.it"])))
            self.show_custom_info("Reset", "Impostazioni ripristinate ai valori predefinite. Clicca su Salva per applicare.")
            self.var_sync_intervallo.set(DEFAULT_CONFIG.get("sync_intervallo_min", 720))
            
        def chiudi_config():
            config_window.destroy()
            
        def salva_e_chiudi():
            try:
                anni = self.var_anni_da_mantenere.get()
                if anni < 2 or anni > 10:
                    raise ValueError("Anni da mantenere deve essere tra 2 e 10.")
                max_backup = self.var_max_backup.get()
                if max_backup < 1 or max_backup > 10:
                    raise ValueError("Il numero massimo di backup deve essere tra 1 e 10.")
                soglia_giorni = self.var_soglia_ricorrenti.get()
                if soglia_giorni < 1 or soglia_giorni > 10:
                    raise ValueError("La soglia giorni ricorrenti deve essere tra 1 e 10.")
                timeout_minuti = round(self.var_timeout_minuti.get())
                if timeout_minuti < 5 or timeout_minuti > 60:
                    raise ValueError("Timeout Inattivit√† deve essere tra 5 e 60 minuti.")
                timeout_ms = int(timeout_minuti * 60000)
                warn_timeout_sec = round(self.var_warn_timeout_sec.get())
                if warn_timeout_sec < 5 or warn_timeout_sec > 60:
                    raise ValueError("Timeout Avviso Popup deve essere tra 5 e 60 secondi.")
                warn_timeout_ms = int(warn_timeout_sec * 1000)
                webserver_port = self.var_port.get()
                if webserver_port < 1024 or webserver_port > 65535:
                    raise ValueError("La porta Webserver non √® valida (range 1024-65535).")
                udp_1 = self.var_udp_port_1.get()
                udp_2 = self.var_udp_port_2.get()
                if udp_1 < 1024 or udp_1 > 65535 or udp_2 < 1024 or udp_2 > 65535:
                    raise ValueError("Le porte UDP devono essere comprese tra 1024 e 65535.")
                carosello_intervallo_sec = round(self.var_carosello_intervallo_sec.get())
                if carosello_intervallo_sec < 5 or carosello_intervallo_sec > 30:
                    raise ValueError("L'intervallo Carosello deve essere tra 5 e 30 secondi.")
                carosello_intervallo_ms = int(carosello_intervallo_sec * 1000)
                target_mese = self.var_target_mese.get()
                target_anno = self.var_target_anno.get()
                if target_mese < 0 or target_anno < 0:
                    raise ValueError("I Target di spesa non possono essere negativi.")
                sync_enabled = self.var_sync_enabled.get()
                email_user = self.var_email_user.get().strip()
                app_password = self.var_app_password.get().strip()
                parole_chiave_raw = self.var_parole_chiave.get()
                if sync_enabled:
                    if not email_user or "@gmail.com" not in email_user.lower():
                        raise ValueError("Inserire un indirizzo Gmail valido per la sincronizzazione.")
                    if not app_password:
                        raise ValueError("L'App Password di Google √® obbligatoria per il sync.")
                    if len(app_password.replace(" ", "")) != 16:
                        raise ValueError("La Password Google deve essere di 16 caratteri.")
                    if not parole_chiave_raw:
                        raise ValueError("Inserire almeno una parola chiave (es: Amazon, Enel) per il sync.")
                    if not gemini_api_key:
                        raise ValueError("La API Key di Gemini √® necessaria per il parsing intelligente.")
                lista_chiavi = [k.strip() for k in parole_chiave_raw.split(",") if k.strip()]
                parole_chiave_pulite = ", ".join(lista_chiavi)   
                                 
                nuova_config = {
                    "enable_auto_login_flow": self.var_auto_login.get(),
                    "webserver_enabled": self.var_webserver_enabled.get(),
                    "inactivity_timeout_ms": timeout_ms,
                    "webserver_port": webserver_port,
                    "bank_link": self.var_bank_link.get(),
                    "load_saved_geometry": self.var_load_geometry.get(),
                    "anni_da_mantenere": anni,
                    "iconizza_inattivita": self.var_iconizza_inattivita.get(),
                    "ico_set_date": self.var_ico_set_date.get(),
                    "enable_recurring_reminder": self.var_recurring_reminder.get(),
                    "max_backup": max_backup,
                    "soglia_giorni_ricorrenti": soglia_giorni,
                    "smartcat_enabled": self.var_smartcat_enabled.get(),
                    "use_wait_window": self.var_use_wait_window.get(),
                    "warn_timeout_ms": warn_timeout_ms,
                    "thema": self.var_thema.get().upper(),
                    "carosello_enabled": self.var_carosello_enabled.get(),
                    "carosello_intervallo": carosello_intervallo_ms,
                    "cal_tooltips_enabled": self.var_cal_tooltips.get(),
                    "shared_db": self.var_shared_db.get(),
                    "shared_db_path": self.var_shared_db_path.get(),
                    "udp_port_1": self.var_udp_port_1.get(),
                    "udp_port_2": self.var_udp_port_2.get(),
                    "target_mese": self.var_target_mese.get(),
                    "target_anno": self.var_target_anno.get(),
                    "sync_dati_enabled": self.var_sync_enabled.get(),
                    "email_user": self.var_email_user.get().strip(),
                    "app_password": self.var_app_password.get().strip(),
                    "gemini_api_key": self.var_gemini_api_key.get().strip(),
                    "parole_chiave": ", ".join([k.strip() for k in self.var_parole_chiave.get().split(",") if k.strip()]),
                    "sync_intervallo_min": int(self.var_sync_intervallo.get() or 720),
                }
                if not os.path.exists(DB_DIR):
                    os.makedirs(DB_DIR)
                with open(CONFIG_FILE, 'w', encoding='utf-8') as f:
                    json.dump(nuova_config, f, indent=4)
                try:
                    global ANNI_DA_MANTENERE
                    ANNI_DA_MANTENERE = int(nuova_config.get("anni_da_mantenere", 10))
                    self.save_db()
                    self.load_db()
                    self.refresh_gui()
                    if DB_CONDIVISO:
                        self.notifica_modifica_web()
                        print("üì° Notifica di aggiornamento inviata .")    
                except Exception as e:
                    print(f"‚ö†Ô∏è Errore durante la pulizia database pre-riavvio: {e}")    
                self.suggerimenti_attivi = self.var_smartcat_enabled.get()
                if config_window.winfo_exists():
                    config_window.destroy()
                riavvia_subito = self.show_custom_askyesno(
                    title="Riavvio Necessario",
                    message="Per applicare completamente alcune modifiche\n(es. porta WebServer, timeout, pulizia database, tema)\n√® necessario riavviare l'applicazione.\n\nRiavviare ora?"
                )
                if riavvia_subito:
                    riavvia_app_definitivo()
                else:
                    self.show_custom_warning("Riavvio in Sospeso", "‚ö†Ô∏è Riavvio posticipato. Le modifiche saranno applicate al prossimo avvio manuale.")
            except ValueError as e:
                self.show_custom_info("Errore di Validazione", str(e))
            except Exception as e:
                self.show_custom_info("Errore di Salvataggio", f"Impossibile salvare la configurazione: {e}")                
        def riavvia_app_definitivo():
            import subprocess, sys, os
            if self.winfo_exists():
                self.destroy()
            script_path = os.path.abspath(sys.argv[0])
            args = [sys.executable, script_path] + sys.argv[1:]
            if os.name == 'nt':
                subprocess.Popen(args, creationflags=0x00000008, shell=False, close_fds=True)
            else:
                subprocess.Popen(args, start_new_session=True, close_fds=True)
            os._exit(0)
            
        def mostra_help_configurazione():
            fixed_width = 1000
            fixed_height = 600
            help_window = Toplevel(config_window)
            help_window.title("‚ùì Aiuto Dettagliato Configurazione")
            help_window.resizable(False, False)
            help_window.configure(bg=self.COLOR_TOPLEVEL)
            help_window.transient(config_window)
            help_window.grab_set()
            help_window.focus_set()
            help_window.bind('<Escape>', lambda e: help_window.destroy())
            help_window.withdraw()
            main_container = ttk.Frame(help_window, padding="10")
            main_container.pack(fill="both", expand=True)
            ttk.Label(main_container, text="Manuale d'uso - Opzioni di Configurazione", 
                      font=("Arial", 12, "bold"), foreground="#00529B").pack(pady=(0, 10))
            notebook = ttk.Notebook(main_container)
            notebook.pack(fill="both", expand=True, pady=(0, 10))
            def crea_tab_bianco(titolo, contenuto_testo):
                frame_tab = ttk.Frame(notebook)
                notebook.add(frame_tab, text=titolo)
                container = tk.Frame(frame_tab, bg=self.COLOR_WHITE, 
                                     highlightbackground=self.COLOR_TOPLEVEL, 
                                     highlightthickness=4, bd=0)
                container.pack(fill="both", expand=True, padx=15, pady=15)
                lbl = tk.Label(container, text=contenuto_testo, 
                               font=("Arial", 10), 
                               bg=self.COLOR_WHITE, 
                               fg=self.COLOR_BLACK, 
                               justify=tk.LEFT, 
                               anchor='nw', 
                               wraplength=900)
                lbl.pack(fill='both', expand=True, padx=15, pady=15)
                return frame_tab
            testo_tab1 = (
                "‚Ä¢ FLUSSO LOGIN/ICONIZZA: Se attivo, l'applicazione si riduce automaticamente a icona nella tray bar dopo l'accesso.\n\n"
                "‚Ä¢ ATTIVA SMARTCAT: Sistema di intelligenza artificiale che suggerisce la categoria pi√π probabile in base alle tue abitudini di movimenti.\n\n"
                "‚Ä¢ WEB SERVER: Abilita il portale per consultare i dati da remoto (es. smartphone). TUNNEL VPN CONSIGLIATO. Richiede riavvio.\n\n"
                "‚Ä¢ PORTA WEB SERVER: Specifica la porta di ascolto (default 8080). Assicurati che non sia usata da altri programmi.\n\n"
                "‚Ä¢ LINK BANCA: Inserisci l'URL diretto della tua home banking per aprirlo rapidamente con l'icona dedicata nella schermata principale."
            )
            testo_tab2 = (
                "‚Ä¢ CARICA POSIZIONE: All'avvio, l'app si riposiziona esattamente dove l'avevi chiusa l'ultima volta.\n\n"
                "‚Ä¢ ABILITA SMART INFO-POINT: Passando il mouse sopra i giorni del calendario, apparir√† un popup con il riepilogo istantaneo dei movimenti.\n\n"
                "‚Ä¢ AGGIORNA DATA AL RIPRISTINO: Se l'app rimane aperta per molto tempo, al ripristino dalla tray bar imposta il calendario sulla data odierna.\n\n"
                "‚Ä¢ AVVISI BLOCCANTI: Se attivo, i messaggi di conferma (es. 'Salvataggio completato') rimarranno a schermo finch√© non clicchi OK.\n\n"
                "‚Ä¢ TIMER AUTO-CHIUSURA: Durata in secondi dei messaggi informativi prima che scompaiano automaticamente.\n\n"
                "‚Ä¢ ICONIZZA PER INATTIVIT√Ä: Riduce l'app a icona dopo un periodo di inutilizzo impostabile per proteggere la tua privacy.\n\n"
                "‚Ä¢ TEMA UI: Passa dalla modalit√† Chiara classica a quella Material Design (colori pi√π moderni)."
            )
            testo_tab3 = (
                "‚Ä¢ ABILITA CAROSELLO: Mostra a rotazione i grafici delle spese mensili e dei saldi quando non stai usando l'applicazione.\n\n"
                "‚Ä¢ INTERVALLO CAROSELLO: Tempo di permanenza (5-30 secondi) di ogni schermata statistica prima di passare alla successiva.\n\n"
                "‚Ä¢ PROMEMORIA MENSILE: Ti avvisa se ci sono categorie di movimenti ricorrenti che non hai ancora registrato nel mese corrente.\n\n"
                "‚Ä¢ SOGLIA ANTICIPO: Specifica quanti giorni prima della fine del mese deve iniziare a mostrarti l'avviso dei promemoria."
                "‚Ä¢ TARGET (MESE/ANNO): Imposta i margini in uscita. Se > 0, attiva il calcolo del margine residuo attuale nei riepiloghi."
            )
            testo_tab4 = (
                "‚Ä¢ DATABASE CONDIVISO: Permette di spostare il database su una cartella di rete (NAS o Cloud locale) per condividere i dati tra pi√π PC.\n\n"
                "‚Ä¢ PATH DATABASE: Il percorso completo (es. Z:\\Dati\\mio_db.db) dove risiede la cartella condivisa.\n\n"
                "‚Ä¢ PORTE UDP (1 & 2): Porte utilizzate per la sincronizzazione istantanea dei dati tra pi√π postazioni nella stessa rete locale.\n\n"
                "‚Ä¢ ANNI STORICO: Determina quanti anni di dati mantenere nel database prima della pulizia automatica (Range: 2-10 anni).\n\n"
                "‚Ä¢ MAX COPIE BACKUP: Numero di file di sicurezza salvati nella cartella backup. Raggiunto il limite, il pi√π vecchio viene eliminato.\n\n"
                "‚Ä¢ SYNC EMAIL: Attiva la lettura automatica della posta per scaricare i movimenti ricevuti via Gmail.\n\n"
                "‚Ä¢ APP PASSWORD: Non √® la password della mail, ma il codice a 16 cifre generato nelle impostazioni di sicurezza Google.\n\n"
                "  üåê Generala qui: https://myaccount.google.com/apppasswords\n\n"
                "‚Ä¢ PAROLE CHIAVE: Filtri (separati da virgola) usati per identificare le Email pertinenti (Es. contotelefonico@fatturazione.windtre.it).\n\n"
                "‚Ä¢ API KEY GEMINI: Inserisci la tua chiave personale di Google AI per abilitare l'analisi automatica dei documenti \n\n"
                "‚Ä¢ FREQUENZA SYNC: Imposta ogni quanti minuti il programma deve controllare la posta.\n "
                "----------------------------------------------------------------------\n\n"
                "** ESEMPIO EMAIL RICONOSCIUTA **\n"
                "Da: Mario Rossi <m.rossi@gmail.com>\n"
                "Data: mar 3 feb, 08:12\n"
                "Testo: Avviso di accredito: √® stato ricevuto un bonifico a vostro favore "
                "di 1200,00 ‚Ç¨ disposto da AZIENDA ROSSI SPA. I fondi sono disponibili."
            )
            crea_tab_bianco("ü§ñ Automatismo & Web", testo_tab1)
            crea_tab_bianco("üñ•Ô∏è Interfaccia & Window", testo_tab2)
            crea_tab_bianco("üìä Carosello & Alert", testo_tab3)
            crea_tab_bianco("üíæ Database & Backup", testo_tab4)
            footer_frame = ttk.Frame(main_container)
            footer_frame.pack(fill="x", side="bottom")
            ttk.Separator(footer_frame, orient='horizontal').pack(fill="x", pady=5)            
            ttk.Label(footer_frame, text="Tasto Rapido: Premi [ESC] per chiudere.", 
                      font=("Arial", 9, "italic"), foreground="#D35400").pack(side="left")            
            ttk.Button(footer_frame, text="‚ùå Chiudi", command=help_window.destroy, 
                       style="Giallo.TButton").pack(side="right")
            help_window.update_idletasks()
            c_x = config_window.winfo_rootx() + (config_window.winfo_width() // 2) - (fixed_width // 2)
            c_y = config_window.winfo_rooty() + (config_window.winfo_height() // 2) - (fixed_height // 2)
            help_window.geometry(f"{fixed_width}x{fixed_height}+{c_x}+{c_y}")
            help_window.deiconify()
        row_counter = 0
        
        def create_checkbutton(container, text, variable, row, column=0):
            cb = ttk.Checkbutton(container, text=text, variable=variable)
            cb.grid(row=row, column=column, sticky="w", padx=10, pady=2)
            return cb
            
        def create_combobox(container, text, variable, values, row, column=0):
            f = ttk.Frame(container)
            f.grid(row=row, column=column, sticky="w", padx=10, pady=2)
            ttk.Label(f, text=text).pack(side="left")
            cb = ttk.Combobox(
                f, 
                textvariable=variable, 
                values=values, 
                state="readonly", 
                width=15,
                style="Border.TCombobox"
            )
            cb.pack(side="left", padx=5)
            return cb
            
        def create_entry(parent, label_text, variable, row, column=0, width=30):
            f = ttk.Frame(parent)
            f.grid(row=row, column=column, sticky="we", pady=1, padx=(10, 10))
            lbl = ttk.Label(f, text=label_text, width=25, anchor="w")
            lbl.pack(side="left")
            ent = ttk.Entry(f, textvariable=variable, width=width)
            ent.pack(side="left", fill="x", expand=True, padx=5)
            return f
            
        def create_slider_row(container, text, min_val, max_val, variable, update_func, label_obj, row, column=0, colspan=1):
            f = ttk.Frame(container)
            f.grid(row=row, column=column, columnspan=colspan, sticky="we", padx=10, pady=2)
            lbl = ttk.Label(f, text=text)
            lbl.grid(row=0, column=0, sticky="w")
            slider = ttk.Scale(
                f, from_=min_val, to=max_val, 
                variable=variable, 
                command=update_func, 
                orient='horizontal'
            )
            slider.grid(row=0, column=1, sticky="ew", padx=10)
            f.columnconfigure(1, weight=1)
            label_obj.lift() 
            label_obj.grid(in_=f, row=0, column=2, sticky="e", padx=5)
            update_func(variable.get())
            return slider
 
        create_combobox(main_frame, "Tema UI:", self.var_thema, ["Chiaro", "Material", "Blu", "Obsidian"], row_counter, column=0)
        row_counter += 1
        ttk.Separator(main_frame, orient='horizontal', style="Rosso.TSeparator").grid(row=row_counter, column=0, columnspan=2, sticky="ew", pady=5)
        row_counter += 1
        create_checkbutton(main_frame, "Abilita Flusso Login/Iconizza Automatica", self.var_auto_login, row_counter, column=0)
        create_checkbutton(main_frame, "Attiva SmartCat (Suggerimento Categorie)", self.var_smartcat_enabled, row_counter, column=1)
        row_counter += 1
        create_checkbutton(main_frame, "Data Odierna alla Riapertura", self.var_ico_set_date, row_counter, column=0)
        create_checkbutton(main_frame, "Carica Posizione Finestra Salvata", self.var_load_geometry, row_counter, column=1)
        row_counter += 1
        create_checkbutton(main_frame, "Abilita Smart Info-Point su Calendario", self.var_cal_tooltips, row_counter, column=0)
        f_bank = ttk.Frame(main_frame)
        f_bank.grid(row=row_counter, column=1, sticky="we", padx=10, pady=2)
        ttk.Label(f_bank, text="Link Banca:").pack(side="left")
        ent_bank = ttk.Entry(f_bank, textvariable=self.var_bank_link, width=45)
        ent_bank.pack(side="left", fill="x", expand=True, padx=5)
        row_counter += 1
        ttk.Separator(main_frame, orient='horizontal', style="Rosso.TSeparator").grid(row=row_counter, column=0, columnspan=2, sticky="ew", pady=5)
        row_counter += 1
        create_checkbutton(main_frame, "Abilita Web Server all'avvio", self.var_webserver_enabled, row_counter, column=0)
        create_entry(main_frame, "Porta Web Server (8080 default)", self.var_port, row_counter, column=1)
        row_counter += 1
        ttk.Separator(main_frame, orient='horizontal', style="Rosso.TSeparator").grid(row=row_counter, column=0, columnspan=2, sticky="ew", pady=5)
        row_counter += 1
        create_checkbutton(main_frame, "Abilita Database Condiviso (Rete)", self.var_shared_db, row_counter, column=0)
        f_path = ttk.Frame(main_frame)
        f_path.grid(row=row_counter, column=1, sticky="we", padx=10, pady=2)
        ttk.Label(f_path, text="Path Database Condiviso (UNC o Unit√†)").pack(side="left")
        ttk.Entry(f_path, textvariable=self.var_shared_db_path, width=40).pack(side="left", fill="x", expand=True, padx=5)
        row_counter += 1
        create_entry(main_frame, "Porta UDP 1", self.var_udp_port_1, row_counter, column=0)
        create_entry(main_frame, "Porta UDP 2", self.var_udp_port_2, row_counter, column=1)
        row_counter += 1
        ttk.Separator(main_frame, orient='horizontal', style="Rosso.TSeparator").grid(row=row_counter, column=0, columnspan=2, sticky="ew", pady=5)
        row_counter += 1
        create_checkbutton(main_frame, "Avvisi Bloccanti (Richiedono Interazione)", self.var_use_wait_window, row_counter, column=0)
        create_slider_row(main_frame, "Timer  Auto-Chiusura Avvisi (5-60 secondi)", 5, 60, self.var_warn_timeout_sec, update_warn_timeout_label, warn_timeout_label, row_counter, column=1)
        row_counter += 1
        create_checkbutton(main_frame, "Iconizza App in caso di Inattivit√†", self.var_iconizza_inattivita, row_counter, column=0)
        create_slider_row(main_frame, "Timeout Inattivit√† (5-60 minuti)", 5, 60, self.var_timeout_minuti, update_timeout_label, timeout_label, row_counter, column=1)
        row_counter += 1
        create_checkbutton(main_frame, "Attiva Promemoria Mensile Categorie Mancanti", self.var_recurring_reminder, row_counter, column=0)
        create_slider_row(main_frame, "Soglia Giorni Anticipo Promemoria (1-10 giorni)", 1, 10, self.var_soglia_ricorrenti, update_soglia_ricorrenti_label, soglia_ricorrenti_label, row_counter, column=1)
        row_counter += 1

        create_checkbutton(main_frame, "Abilita Carosello Statistiche", self.var_carosello_enabled, row_counter, column=0)
        create_slider_row(main_frame, "Intervallo Carosello (5-30 secondi)", 5, 30, self.var_carosello_intervallo_sec, update_carosello_intervallo_label, carosello_intervallo_label, row_counter, column=1)
        row_counter += 1
        ttk.Separator(main_frame, orient='horizontal', style="Rosso.TSeparator").grid(row=row_counter, column=0, columnspan=2, sticky="ew", pady=5)
        row_counter += 1
        create_slider_row(main_frame, "Anni di Storico Dati (periodo di conservazione - 2-10 anni)", 2, 10, self.var_anni_da_mantenere, update_anni_label, anni_label, row_counter, column=0)
        main_frame.grid_slaves(row=row_counter, column=0)[0].grid(columnspan=2, sticky="we")
        row_counter += 1
        create_slider_row(main_frame, "Max. Copie Backup da Mantenere (1-10)", 1, 10, self.var_max_backup, update_max_backup_label, max_backup_label, row_counter, column=0)
        main_frame.grid_slaves(row=row_counter, column=0)[0].grid(columnspan=2, sticky="we")
        row_counter += 1
        ttk.Separator(main_frame, orient='horizontal', style="Rosso.TSeparator").grid(row=row_counter, column=0, columnspan=2, sticky="ew", pady=5)
        row_counter += 1
        create_checkbutton(main_frame, "Abilita Lettura Automatica Movimenti (Solo Gmail):", self.var_sync_enabled, row_counter)
        row_counter += 1
        create_entry(main_frame, "Indirizzo Gmail:", self.var_email_user, row_counter, column=0, width=50)
        main_frame.grid_slaves(row=row_counter, column=0)[0].grid(columnspan=2, sticky="we")
        row_counter += 1
        f_pass = ttk.Frame(main_frame)
        f_pass.grid(row=row_counter, column=0, columnspan=2, sticky="we", padx=10, pady=2)
        ttk.Label(f_pass, text="App Password (16 cifre):", width=25, anchor="w").pack(side="left")
        ent_pass = ttk.Entry(f_pass, textvariable=self.var_app_password, width=35)
        ent_pass.pack(side="left", padx=5, fill="x", expand=True)
        import webbrowser
        btn_google = ttk.Button(f_pass, text="üåê Genera", width=10, style="Verde.TButton",
                                command=lambda: webbrowser.open("https://myaccount.google.com/apppasswords"))
        btn_google.pack(side="left", padx=(0, 5))
        row_counter += 1
        f_keys = ttk.Frame(main_frame)
        f_keys.grid(row=row_counter, column=0, columnspan=2, sticky="we", padx=10, pady=2)
        ttk.Label(f_keys, text="Filtri Email (Enel, Wind)").pack(side="left")
        ttk.Entry(f_keys, textvariable=self.var_parole_chiave).pack(side="left", fill="x", expand=True, padx=5)
        row_counter += 1
        f_api = ttk.Frame(main_frame)
        f_api.grid(row=row_counter, column=0, columnspan=2, sticky="we", padx=10, pady=2)
        ttk.Label(f_api, text="Gemini API Key:", width=25, anchor="w").pack(side="left")
        ent_api = ttk.Entry(f_api, textvariable=self.var_gemini_api_key, width=35, show="*")
        ent_api.pack(side="left", padx=5, fill="x", expand=True)
        btn_api = ttk.Button(f_api, text="üîë Ottieni", width=10, style="Verde.TButton",
                             command=lambda: webbrowser.open("https://aistudio.google.com/app/apikey"))
        btn_api.pack(side="left", padx=(0, 5))
        row_counter += 1
        def aggiorna_label_sync(*args):
            minuti = int(self.var_sync_intervallo.get())
            ore = minuti // 60
            min_residui = minuti % 60
            if min_residui == 0:
                testo = f"Sincronizza ogni: {ore} ore"
            else:
                testo = f"Sincronizza ogni: {ore} ore e {min_residui} min"
            sync_intervallo_label.config(text=testo)
        sync_intervallo_label = ttk.Label(main_frame, text="")
        sync_intervallo_label.grid(row=row_counter, column=0, sticky="w", padx=10)
        scale_sync = ttk.Scale(
            main_frame, 
            from_=720,
            to=1440,
            variable=self.var_sync_intervallo, 
            orient="horizontal", 
            command=aggiorna_label_sync
        )
        scale_sync.grid(row=row_counter, column=1, sticky="we", padx=10, pady=5)
        aggiorna_label_sync()
        row_counter += 1
        ttk.Separator(main_frame, orient='horizontal', style="Rosso.TSeparator").grid(row=row_counter, column=0, columnspan=2, sticky="ew", pady=5)
        row_counter += 1
        button_frame = ttk.Frame(main_frame)
        button_frame.grid(row=row_counter, column=0, columnspan=3, pady=15, sticky="n")
        save_button = ttk.Button(button_frame, text="üíæ Salva", command=salva_e_chiudi, style="Verde.TButton")
        save_button.grid(row=0, column=0, padx=5)
        defaults_button = ttk.Button(button_frame, text="‚≠ê Defaults", command=reset_defaults, style="Rosso.TButton")
        defaults_button.grid(row=0, column=1, padx=5)
        close_button = ttk.Button(button_frame, text="‚ùå Chiudi", command=chiudi_config, style="Giallo.TButton")
        close_button.grid(row=0, column=2, padx=5)
        help_button = ttk.Button(button_frame, text="‚ùì", command=mostra_help_configurazione, style="Giallo.TButton", width=3)
        help_button.grid(row=0, column=3, padx=5)
        config_window.protocol("WM_DELETE_WINDOW", chiudi_config)
        config_window.bind_all("<Escape>", chiudi_config)
        row_counter += 1
        config_window.withdraw()
        config_window.minsize(1000, 650) 
        config_window.update_idletasks()
        width = config_window.winfo_width()
        height = config_window.winfo_height()
        if width < 1000: width = 1000
        if height < 650: height = 650
        screen_w = self.winfo_screenwidth()
        screen_h = self.winfo_screenheight()
        center_x = (screen_w // 2) - (width // 2)
        center_y = (screen_h // 2) - (height // 2)
        config_window.geometry(f"{width}x{height}+{center_x}+{center_y}")
        config_window.deiconify()
        config_window.lift()
        self.wait_window(config_window)

    # Implementazione di Effetti di Lampeggio Ricorsivo per Widget Tkinter
    def start_blinking(self, label):
        if hasattr(label, "_blinking_timer_id"):
            self.after_cancel(label._blinking_timer_id)
        label._is_blinking_on = True 
        label.state(['!disabled']) 
        self._blink_recursive(label)
    def _blink_recursive(self, label):
        try:
            label.winfo_exists()
        except:
            return
        if not hasattr(label, "_is_blinking_on"):
             label._is_blinking_on = True 
        label._is_blinking_on = not label._is_blinking_on
        if label._is_blinking_on:
            label.state(['!disabled'])
        else:
            label.state(['disabled'])
        try:
            interval = self.blinking_interval
            timer_id = self.after(interval, lambda: self._blink_recursive(label))
            label._blinking_timer_id = timer_id
        except Exception:
            print("Errore nel scheduling del timer. Controllare self.blinking_interval.")
            pass
    def stop_blinking(self, label):
        if hasattr(label, "_blinking_timer_id"):
            try:
                self.after_cancel(label._blinking_timer_id)
            except ValueError:
                pass 
            del label._blinking_timer_id
        try:
            label.state(['disabled'])
        except Exception:
            pass
        if hasattr(label, "_is_blinking_on"):
            del label._is_blinking_on
    def toggle_blinking(self, label):
        if hasattr(label, "_blinking_timer_id"):
            self.stop_blinking(label)
        else:
            self.start_blinking(label) 
                 
    # Implementazione di Effetti di Lampeggio Ricorsivo per Widget Totalizzatore mese/anno        
    def _global_blink_loop(self):
        if not hasattr(self, "blinking_widgets") or not self.blinking_widgets:
            self._blink_loop_active = False
            return
        self._blink_loop_active = True
        if not hasattr(self, "_blink_phase"):
            self._blink_phase = True
        self._blink_phase = not self._blink_phase
        color = "red" if self._blink_phase else "dodgerblue"
        for label in list(self.blinking_widgets):
            try:
                if label.winfo_exists():
                    label.config(foreground=color)
                else:
                    self.blinking_widgets.discard(label)
            except Exception:
                self.blinking_widgets.discard(label)
        interval = getattr(self, "blinking_interval", 500)
        self.after(interval, self._global_blink_loop)
    def start_blinking_colors(self, label):
        if not hasattr(self, "blinking_widgets"):
            self.blinking_widgets = set()
        self.blinking_widgets.add(label)
        if not getattr(self, "_blink_loop_active", False):
            self._global_blink_loop()
    def stop_blinking_colors(self, label):
        if hasattr(self, "blinking_widgets"):
            self.blinking_widgets.discard(label)
        try:
            if label.winfo_exists():
                label.config(foreground="dodgerblue")
        except Exception:
            pass
            
    # Genera QRCode Gateway Locale/Remoto
    def genera_qr_web(self):
        try:
            ip_locale = self.get_ip_locale_reale() 
            try:
                risposta = requests.get('https://api.myip.com', timeout=3).json()
                ip_remoto = risposta.get('ip')
            except:
                ip_remoto = "Non Raggiungibile"
            url_locale = f"http://{ip_locale}:{PORTA}"
            url_remoto = f"http://{ip_remoto}:{PORTA}"
            qr_loc_tmp = tempfile.NamedTemporaryFile(suffix=".png", delete=False)
            qr_rem_tmp = tempfile.NamedTemporaryFile(suffix=".png", delete=False)
            segno.make(url_locale, error='L').save(qr_loc_tmp.name, scale=8)
            segno.make(url_remoto, error='L').save(qr_rem_tmp.name, scale=8)
            html_template = """
            <html>
            <body style="font-family: sans-serif; display: flex; flex-direction: column; justify-content: center; align-items: center; min-height: 100vh; margin: 0; background-color: #f4f4f4;">
            <div style="text-align: center; margin-bottom: 30px; max-width: 800px;">
                <h1 style="color: #333; margin-bottom: 10px;">Gestione Accessi Remoti</h1>
                <p style="color: #666; font-size: 1.1em;">Inquadra il QR Code con un altro smartphone o tablet per connetterti al sistema.</p>
            </div>
            <div style="display: flex; gap: 50px; background: white; padding: 40px; border-radius: 20px; box-shadow: 0 10px 30px rgba(0,0,0,0.1);">
                <div style="text-align: center;">
                    <h2 style="margin-bottom: 5px;">Connessione Locale</h2>
                    <p style="color: #888; font-size: 0.8em; margin-bottom: 15px;">(Stesso Wi-Fi / LAN)</p>
                    <img src="file://%s" style="border: 1px solid #ddd; padding: 10px; border-radius: 10px; width: 250px;">
                    <p style="margin-top: 15px; font-weight: bold; color: #444;">%s</p>
                </div>
                <div style="width: 2px; background: #eee; align-self: stretch;"></div>
                <div style="text-align: center;">
                    <h2 style="color: #007bff; margin-bottom: 5px;">Connessione Web</h2>
                    <p style="color: #888; font-size: 0.8em; margin-bottom: 15px;">(Accesso Remoto)</p>
                    <img src="file://%s" style="border: 1px solid #cfe2ff; padding: 10px; border-radius: 10px; width: 250px;">
                    <p style="margin-top: 15px; font-weight: bold; color: #007bff;">%s</p>
                </div>
            </div>
            <div style="text-align: center; margin-top: 20px; max-width: 800px; color: #666; font-size: 0.9em; line-height: 1.5;">
                <p>‚ÑπÔ∏è La connessione locale opera su protocollo HTTP non cifrato all'interno della LAN.<br>
                <strong>Nota di sicurezza:</strong> Per l'accesso da rete esterna (WAN), si raccomanda l'uso di una <strong>VPN</strong> per stabilire un tunnel cifrato end-to-end, garantendo l'integrit√† dei dati e l'offuscamento dell'endpoint rispetto a connessioni dirette non protette.</p>
            </div>
            </body>
            </html>
            """ % (os.path.abspath(qr_loc_tmp.name), url_locale, os.path.abspath(qr_rem_tmp.name), url_remoto)
            with tempfile.NamedTemporaryFile(suffix=".html", delete=False, mode='w', encoding='utf-8') as tmp_html:
                tmp_html.write(html_template)
                path_html = tmp_html.name
            webbrowser.open("file://" + os.path.realpath(path_html))
        except Exception as e:
            print(f"‚ùå Errore: {e}")
       
    # INFO IP: Recupera l'indirizzo IP privato (192.168.x.x)        
    def get_ip_locale_reale(self):
        try:
            indirizzi = socket.getaddrinfo(socket.gethostname(), None)
            ips = [addr[4][0] for addr in indirizzi if ":" not in addr[4][0]]
            for ip in ips:
                if ip.startswith("192.168."):
                    return ip
            for ip in ips:
                if ip.startswith("172."):
                    return ip
            return self.get_ip_locale() 
        except:
            return "127.0.0.1"

    # Genera la pagina Cruscotto HTML riassuntiva con tabelle e grafici
    def genera_report_html(self):
        import webbrowser, os, tempfile, datetime, json
        from collections import defaultdict
        oggi = datetime.date.today()
        anno_curr = oggi.year
        mesi_nomi = ["", "Gennaio", "Febbraio", "Marzo", "Aprile", "Maggio", "Giugno", "Luglio", "Agosto", "Settembre", "Ottobre", "Novembre", "Dicembre"]
        data_punti, movimenti_per_id = defaultdict(float), defaultdict(list)
        tot_anno, tot_st = {"in": 0.0, "out": 0.0}, {"in": 0.0, "out": 0.0}
        cat_anno_val, cat_anno_count = defaultdict(float), defaultdict(int)
        cat_st_val, cat_st_count = defaultdict(float), defaultdict(int)
        giorni_ordinati = sorted(self.spese.keys(), reverse=True)
        for giorno in giorni_ordinati:
            entries = self.spese[giorno]
            anno, mese = giorno.year, giorno.month
            for entry in entries:
                cat, desc, imp, tipo = (entry.get("categoria", "Varie"), entry.get("descrizione", ""), entry.get("importo", 0), entry.get("tipo", "Uscita")) if isinstance(entry, dict) else (entry[0], entry[1], entry[2], entry[3])
                try: val = float(str(imp).replace(",", ".").replace("‚Ç¨", "").strip())
                except: val = 0
                t_tipo = str(tipo).lower()
                suffix = "in" if t_tipo == "entrata" else "out"
                data_str = giorno.strftime('%d/%m/%Y')
                riga_html = f"<div style='margin-bottom:10px;border-bottom:1px solid #444;padding-bottom:5px;'><div style='display:flex;justify-content:space-between;align-items:flex-start;'><span style='font-weight:bold;'>{data_str} {cat}</span><span style='color:#2ecc71;font-weight:bold;white-space:nowrap;margin-left:10px;'>‚Ç¨ {val:,.2f}</span></div><div style='font-size:0.75rem;color:#bdc3c7;margin-top:3px;line-height:1.2;word-break:break-word;'>{desc}</div></div>"
                tot_st[suffix] += val
                data_punti[f"st_a_{anno}_{suffix}"] += val
                if t_tipo == "uscita":
                    cat_st_val[cat] += val
                    cat_st_count[cat] += 1
                    movimenti_per_id[f"st_cat_{cat}"].append(riga_html)
                movimenti_per_id[f"st_a_{anno}_{suffix}"].append(riga_html)
                if anno == anno_curr:
                    tot_anno[suffix] += val
                    data_punti[f"curr_m_{mese}_{suffix}"] += val
                    if t_tipo == "uscita":
                        cat_anno_val[cat] += val
                        cat_anno_count[cat] += 1
                        movimenti_per_id[f"curr_cat_{cat}"].append(riga_html)
                    movimenti_per_id[f"curr_m_{mese}_{suffix}"].append(riga_html)
        anni_lista = sorted(list(set(int(k.split('_')[2]) for k in data_punti.keys() if k.startswith('st_a_'))))
        range_anni = f"{anni_lista[0]}-{anni_lista[-1]}" if anni_lista else str(anno_curr)
        mesi_attivi = sorted([m for m in range(1, 13) if data_punti[f"curr_m_{m}_in"] > 0 or data_punti[f"curr_m_{m}_out"] > 0])
        labels_mesi = [f"{mesi_nomi[m]} ({'+' if (data_punti[f'curr_m_{m}_in']-data_punti[f'curr_m_{m}_out'])>=0 else ''}‚Ç¨ {data_punti[f'curr_m_{m}_in']-data_punti[f'curr_m_{m}_out']:,.0f})" for m in mesi_attivi]
        labels_anni = [f"Anno {a} ({'+' if (data_punti[f'st_a_{a}_in']-data_punti[f'st_a_{a}_out'])>=0 else ''}‚Ç¨ {data_punti[f'st_a_{a}_in']-data_punti[f'st_a_{a}_out']:,.0f})" for a in anni_lista]
        cat_a_sorted = sorted(cat_anno_val.keys(), key=lambda x: cat_anno_val[x], reverse=True)
        cat_s_sorted = sorted(cat_st_val.keys(), key=lambda x: cat_st_val[x], reverse=True)
        cls_s_a = "positivo" if (tot_anno['in']-tot_anno['out'])>=0 else "negativo"
        cls_s_s = "positivo" if (tot_st['in']-tot_st['out'])>=0 else "negativo"
        html = f"""<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2"></script>
    <style>
        body {{ font-family:'Segoe UI',Arial;margin:0;padding:0;background:#f4f7f6;display:flex;flex-direction:column;height:100vh;overflow:hidden; }}
        .top-bar {{ background:#2c3e50;color:white;display:flex;align-items:center;padding:0 20px;height:50px;flex-shrink:0;z-index:2000;box-shadow:0 2px 5px rgba(0,0,0,0.2); }}
        .top-bar h1 {{ font-size:1rem;margin:0;flex-grow:1; }}
        .main-content {{ display:flex;flex:1;overflow:hidden; }}
        .container {{ flex:1;padding:20px;overflow-y:auto;background:#f4f7f6; }}
        .card {{ background:white;padding:15px;border-radius:8px;margin-bottom:20px;box-shadow:0 2px 5px rgba(0,0,0,0.05);page-break-inside:avoid; }}
        h2 {{ font-size:0.9rem;margin:0 0 10px 0;color:#2c3e50;border-left:4px solid #3498db;padding-left:10px; }}
        #sidebar {{ width:350px;background:#2c3e50;color:white;display:flex;flex-direction:column;flex-shrink:0; }}
        .sidebar-inner {{ padding:15px;overflow-y:auto;flex:1;font-size:0.8rem; }}
        .sidebar-header {{ padding:15px;background:#1a252f;border-bottom:1px solid #444; }}
        .totali-grid {{ display:flex;gap:5px;margin-bottom:10px; }}
        .tot-box {{ flex:1;background:#f8f9fa;padding:5px;border-radius:4px;text-align:center;border:1px solid #eee;font-size:0.7rem;color:#333; }}
        .positivo {{ color:#27ae60!important;font-weight:bold; }}
        .negativo {{ color:#e74c3c!important;font-weight:bold; }}
        .btn-print {{ padding:6px 12px;background:#3498db;color:white;border:none;border-radius:4px;cursor:pointer;font-weight:bold;font-size:0.75rem; }}
        .sort-btn {{ cursor:pointer;background:#444;border:none;color:white;padding:3px 7px;border-radius:3px;font-size:0.7rem; }}
        @media print {{ .top-bar,#sidebar {{ display:none!important; }} body,.main-content,.container {{ overflow:visible!important;display:block!important;height:auto!important; }} .card {{ box-shadow:none;border:1px solid #eee; }} }}
    </style>
</head>
<body>
    <div class="top-bar">
        <h1>üìä Report Casa Facile Pro</h1>
        <button class="btn-print" onclick="window.print()">üìÑ STAMPA PDF</button>
    </div>
    <div class="main-content">
        <div class="container">
            <div class="card">
                <h2>üìÖ Riepilogo Anno {anno_curr}</h2>
                <div class="totali-grid">
                    <div class="tot-box">ENTRATE: <span class="positivo">‚Ç¨{tot_anno['in']:,.2f}</span></div>
                    <div class="tot-box">USCITE: <span class="negativo">‚Ç¨{tot_anno['out']:,.2f}</span></div>
                    <div class="tot-box">SALDO: <span class="{cls_s_a}">‚Ç¨{tot_anno['in']-tot_anno['out']:,.2f}</span></div>
                </div>
                <div style="height:{len(mesi_attivi)*45+50}px;"><canvas id="chart_mesi"></canvas></div>
            </div>
            <div class="card">
                <h2>üìÇ Categorie Anno {anno_curr}</h2>
                <div style="height:{len(cat_a_sorted)*25+50}px;"><canvas id="chart_cat_anno"></canvas></div>
            </div>
            <div class="card">
                <h2>üèõÔ∏è Bilancio Storico ({range_anni})</h2>
                <div class="totali-grid">
                    <div class="tot-box">TOT. ENTRATE: <span class="positivo">‚Ç¨{tot_st['in']:,.2f}</span></div>
                    <div class="tot-box">TOT. USCITE: <span class="negativo">‚Ç¨{tot_st['out']:,.2f}</span></div>
                    <div class="tot-box">SALDO TOT: <span class="{cls_s_s}">‚Ç¨{tot_st['in']-tot_st['out']:,.2f}</span></div>
                </div>
                <div style="height:{len(anni_lista)*55+50}px;"><canvas id="chart_anni"></canvas></div>
            </div>
            <div class="card">
                <h2>üåç Categorie Storiche</h2>
                <div style="height:{len(cat_s_sorted)*25+50}px;"><canvas id="chart_st_full"></canvas></div>
            </div>
        </div>
        <div id="sidebar">
            <div class="sidebar-header">
                <div style="display:flex;justify-content:space-between;align-items:center;">
                    <span style="font-weight:bold;font-size:0.9rem;">Dettaglio Movimenti</span>
                    <div>
                        <button class="sort-btn" onclick="sortMov(true)">üîΩ</button>
                        <button class="sort-btn" onclick="sortMov(false)">üîº</button>
                    </div>
                </div>
                <div id="side-title" style="font-size:0.75rem;margin-top:8px;font-weight:bold;"></div>
            </div>
            <div class="sidebar-inner" id="side-info">Clicca su una barra del grafico per vedere le voci.</div>
        </div>
    </div>
    <script>
        Chart.register(ChartDataLabels);
        const db={json.dumps(movimenti_per_id)};
        let currentId=null;
        function sortMov(reverse){{
            if(!currentId)return;
            let list=[...db[currentId]];
            if(!reverse)list.reverse();
            renderList(list);
        }}
        function renderList(list){{
            document.getElementById('side-info').innerHTML=list.join("");
        }}
        function makeChart(ctxId,labels,datasets,showLegend=false){{
            new Chart(document.getElementById(ctxId),{{
                type:'bar',
                data:{{labels,datasets}},
                options:{{
                    indexAxis:'y',
                    responsive:true,
                    maintainAspectRatio:false,
                    clip:false,
                    layout:{{padding:{{right:80}}}},
                    onClick:(e,el)=>{{
                        if(el.length){{
                            const idx=el[0].index;
                            const ds=datasets[el[0].datasetIndex];
                            currentId=ds.ids[idx];
                            let t=labels[idx].split(' (')[0];
                            if(ctxId==='chart_mesi')t+=" {anno_curr}";
                            const sT=document.getElementById('side-title');
                            sT.innerText=t;
                            sT.style.color=labels[idx].includes('(-')?'#e74c3c':'#3498db';
                            renderList(db[currentId]||[]);
                        }}
                    }},
                    plugins:{{
                        legend:{{display:showLegend,labels:{{color:'#333',font:{{size:10}}}}}},
                        datalabels:{{
                            anchor:'end',align:'right',offset:5,
                            color:(ctx)=>{{
                                const l=ctx.dataset.label;
                                return l==='Entrate'?'#27ae60':(l==='Uscite'?'#e74c3c':'#333');
                            }},
                            formatter:v=>v>0?'‚Ç¨'+v.toLocaleString('it-IT',{{minimumFractionDigits:2}}):'',
                            font:{{weight:'bold',size:10}}
                        }}
                    }},
                    scales:{{
                        x:{{display:false,grace:'10%'}},
                        y:{{ticks:{{color:'#333',font:{{weight:'bold'}}}}}}
                    }}
                }}
            }});
        }}
        makeChart('chart_mesi',{json.dumps(labels_mesi)},[
            {{label:'Entrate',data:{[data_punti[f"curr_m_{m}_in"] for m in mesi_attivi]},backgroundColor:'#2ecc71',ids:{json.dumps([f"curr_m_{m}_in" for m in mesi_attivi])}}},
            {{label:'Uscite',data:{[data_punti[f"curr_m_{m}_out"] for m in mesi_attivi]},backgroundColor:'#e74c3c',ids:{json.dumps([f"curr_m_{m}_out" for m in mesi_attivi])}}}
        ],true);
        makeChart('chart_cat_anno',{json.dumps([f"{c} ({cat_anno_count[c]})" for c in cat_a_sorted])},[
            {{data:{json.dumps([cat_anno_val[c] for c in cat_a_sorted])},backgroundColor:'#f39c12',ids:{json.dumps(["curr_cat_"+c for c in cat_a_sorted])}}}
        ]);
        makeChart('chart_anni',{json.dumps(labels_anni)},[
            {{label:'Entrate',data:{[data_punti[f"st_a_{a}_in"] for a in anni_lista]},backgroundColor:'#2ecc71',ids:{json.dumps([f"st_a_{a}_in" for a in anni_lista])}}},
            {{label:'Uscite',data:{[data_punti[f"st_a_{a}_out"] for a in anni_lista]},backgroundColor:'#e74c3c',ids:{json.dumps([f"st_a_{a}_out" for a in anni_lista])}}}
        ],true);
        makeChart('chart_st_full',{json.dumps([f"{c} ({cat_st_count[c]})" for c in cat_s_sorted])},[
            {{data:{json.dumps([cat_st_val[c] for c in cat_s_sorted])},backgroundColor:'#c0392b',ids:{json.dumps(["st_cat_"+c for c in cat_s_sorted])}}}
        ]);
    </script>
</body>
</html>"""
        with tempfile.NamedTemporaryFile('w',delete=False,suffix='.html',encoding='utf-8') as tf:
            tf.write(html)
            t_path=tf.name
        webbrowser.open('file://'+os.path.realpath(t_path))

    # Gestione Budget Calcolo Mese/Anno
    def aggiorna_monitoraggio_budget(self):
        import datetime
        oggi = datetime.date.today()
        anno_curr = oggi.year
        mese_curr = oggi.month
        budget_m = getattr(self, 'budget_mensile', 0.0)
        budget_a = getattr(self, 'budget_annuale', 0.0)
        uscite_mese = 0.0
        uscite_anno = 0.0
        if self.budget_mensile > 0:
                self.lbl_titolo_target_m.grid()
                self.lbl_budget_mese.grid()
        else:
                self.lbl_titolo_target_m.grid_remove()
                self.lbl_budget_mese.grid_remove()
        if self.budget_annuale > 0:
                self.lbl_titolo_target_a.grid()
                self.lbl_budget_anno.grid()
        else:
                self.lbl_titolo_target_a.grid_remove()
                self.lbl_budget_anno.grid_remove()     
        for giorno, entries in self.spese.items():
            if giorno.year == anno_curr:
                for entry in entries:
                    try:
                        tipo = str(entry[3]).lower()
                        importo = float(entry[2])
                    except (IndexError, ValueError):
                        continue
                    if tipo == "uscita":
                        uscite_anno += importo
                        if giorno.month == mese_curr:
                            uscite_mese += importo
        rimanente_m = budget_m - uscite_mese
        rimanente_a = budget_a - uscite_anno
        self.lbl_budget_mese.config(
                text=f"{rimanente_m:,.2f} ‚Ç¨",
                foreground=self.COLOR_GREEN if rimanente_m >= 0 else self.COLOR_RED
        )
        self.lbl_budget_anno.config(
                text=f"{rimanente_a:,.2f} ‚Ç¨",
                foreground=self.COLOR_GREEN if rimanente_a >= 0 else self.COLOR_RED
        )

    # Visualizzazione e Gestione del Registro Errori di Sistema
    def mostra_registro_errori(self, event=None):
        log_path = os.path.join(DB_DIR, "error_log.txt")
        if not os.path.exists(log_path) or os.path.getsize(log_path) == 0:
            self.show_custom_warning("Registro Vuoto", "Non ci sono errori registrati nel log.")
            return
        with open(log_path, "r", encoding="utf-8") as f:
            contenuto = f.read()
        anteprima = tk.Toplevel(bg=self.COLOR_TOPLEVEL)
        anteprima.withdraw()
        anteprima.title("üìú Registro Anomalie di Sistema (Log)")
        anteprima.resizable(False, False)  
        larghezza_finestra = 1000
        altezza_finestra = 600
        def centra_finestra():
            larghezza_schermo = anteprima.winfo_screenwidth()
            altezza_schermo = anteprima.winfo_screenheight()
            x = (larghezza_schermo // 2) - (larghezza_finestra // 2)
            y = (altezza_schermo // 2) - (altezza_finestra // 2)
            anteprima.geometry(f"{larghezza_finestra}x{altezza_finestra}+{x}+{y}")
            anteprima.deiconify()
            anteprima.lift()
            anteprima.focus_force()
        anteprima.after(0, centra_finestra)
        anteprima.bind("<Escape>", lambda e: anteprima.destroy())
        frame_testo = tk.Frame(anteprima, bg=self.COLOR_BACKGROUND)
        frame_testo.pack(padx=10, pady=10, fill="both", expand=True)
        txt = tk.Text(frame_testo, wrap="word", font=("Courier New", 10), 
                      bg=self.COLOR_WIDGET_BG, fg=self.TEXT_COLOR, insertbackground="white")
        scrollbar = ttk.Scrollbar(frame_testo, orient="vertical", command=txt.yview)
        txt.configure(yscrollcommand=scrollbar.set)
        txt.insert("1.0", contenuto)
        txt.config(state="disabled")
        scrollbar.pack(side="right", fill="y")
        txt.pack(side="left", fill="both", expand=True)
        def esporta_log():
            import datetime
            now = datetime.date.today()
            nome_file_default = f"Registro_Anomalie_{now:%d-%m-%Y}.txt"
            file_dest = filedialog.asksaveasfilename(
                defaultextension=".txt",
                filetypes=[("File di testo", "*.txt")],
                initialfile=nome_file_default,
                initialdir=EXPORT_FILES,
                title="Esporta Registro Errori",
                confirmoverwrite=False,
                parent=anteprima
            )
            if file_dest:
                if os.path.exists(file_dest):
                    conferma = self.show_custom_askyesno(
                        "Sovrascrivere file?",
                        f"Il file '{os.path.basename(file_dest)}' \nesiste gi√†. Vuoi sovrascriverlo?"
                    )
                    if not conferma:
                        return
                try:
                    with open(file_dest, "w", encoding="utf-8") as f:
                        f.write(contenuto)
                    self.show_custom_warning("Esportazione completata", f"File salvato:\n{file_dest}")
                except Exception as e:
                    self.show_custom_warning("Errore", f"Impossibile esportare il file: {e}")
        def cancella_log():
            if self.show_custom_askyesno("Conferma", "Vuoi svuotare definitivamente il registro anomalie ?"):
                with open(log_path, "w", encoding="utf-8") as f:
                    f.write("")
                txt.config(state="normal")
                txt.delete("1.0", "end")
                txt.config(state="disabled")
                self.show_custom_warning("Pulizia", "Registro svuotato.")
        def stampa_log():
            self._stampa_lista_diretta(contenuto, self.show_custom_warning)
        frame_bottoni = tk.Frame(anteprima, bg=self.COLOR_TOPLEVEL)
        frame_bottoni.pack(pady=10, fill="x")
        ttk.Button(frame_bottoni, text="üíæ Esporta", style="Blu.TButton", command=esporta_log).pack(side="left", padx=10)
        ttk.Button(frame_bottoni, text="üìÑ Stampa", style="Blu.TButton", command=stampa_log).pack(side="left", padx=10)
        ttk.Button(frame_bottoni, text="üìÑ Cancella Registro", style="Giallo.TButton", command=cancella_log).pack(side="left", padx=10)
        ttk.Button(frame_bottoni, text="‚ùå Chiudi", style="Giallo.TButton", command=anteprima.destroy).pack(side="right", padx=10)

    # Avvia Sincronizzazione web
    def avvia_sincronizzazione(self, manuale=False):
        if manuale:
            if not EMAIL_USER or "@gmail.com" not in EMAIL_USER.lower():
                self.show_custom_warning("Dati Mancanti", "Gmail non valida o mancante!")
                return
            if not APP_PASSWORD or len(APP_PASSWORD.replace(" ", "")) != 16:
                self.show_custom_warning("Dati Mancanti", "Password App Google deve essere di 16 cifre!")
                return
            if not API_KEY:
                self.show_custom_warning("Dati Mancanti", "Chiave API Gemini mancante!")
                return
            if not PAROLE_CHIAVE:
                self.show_custom_warning("Dati Mancanti", "Inserire almeno una Email!")
                return
        kw_data = app_config_globale.get("parole_chiave", [])
        if isinstance(kw_data, str):
            parole_chiave = [k.strip().lower() for k in kw_data.replace(",", " ").split() if k.strip()]
        else:
            parole_chiave = [str(k).strip().lower() for k in kw_data if str(k).strip()]
        if not EMAIL_USER or not APP_PASSWORD or not API_KEY:
            if manuale: self.show_custom_warning("Errore", "Credenziali mancanti!")
            return
        CATEGORIA_TEMPORANEA = "Zona @Web/Bank"
        if CATEGORIA_TEMPORANEA not in self.categorie:
            self.categorie.append(CATEGORIA_TEMPORANEA)
            self.categorie_tipi[CATEGORIA_TEMPORANEA] = "Uscita"
            self.aggiorna_combobox_categorie()
        import time, json, re, imaplib, email
        from google.genai import types
        cartella_pdf = os.path.join(os.getcwd(), "Fatture_GMail")
        if not os.path.exists(cartella_pdf):
            os.makedirs(cartella_pdf)
        try:
            is_iconified = self.wm_state() == 'iconic'
            popup = None
            if not is_iconified:
                popup = Toplevel(self)
                popup.overrideredirect(True)
                popup.attributes("-topmost", True)
                popup.configure(bg=self.COLOR_WIDGET_BG, highlightbackground=self.COLOR_HIGHLIGHT, highlightthickness=2)
                w, h = 400, 130
                sw, sh = popup.winfo_screenwidth(), popup.winfo_screenheight()
                popup.geometry(f"{w}x{h}+{(sw//2)-(w//2)}+{(sh//2)-(h//2)}")
                lbl_status = Label(popup, text="Ricerca mail in corso...", bg=self.COLOR_WIDGET_BG, fg=self.COLOR_HEADER, font=("Arial", 10, "bold"))
                lbl_status.pack(pady=10)
                progress = ttk.Progressbar(popup, orient="horizontal", length=300, mode="determinate")
                progress.pack(pady=5)
                lbl_cont = Label(popup, text="In attesa...", bg=self.COLOR_WIDGET_BG, fg=self.COLOR_TEXT)
                lbl_cont.pack()
            def aggiorna_UI(testo, val=None, nuovi=None, dettaglio=None):
                if is_iconified: return
                if popup and popup.winfo_exists():
                    lbl_status.config(text=testo)
                    if val is not None: progress['value'] = val
                    if dettaglio is not None:
                        testo_pulito = str(dettaglio).strip()
                        if len(testo_pulito) > 50:
                            testo_pulito = testo_pulito[:47] + "..."
                        lbl_cont.config(text=testo_pulito)
                    elif nuovi is not None:
                        lbl_cont.config(text=f"‚úì Acquisite: {nuovi}")
                    popup.update()
            mail = imaplib.IMAP4_SSL("imap.gmail.com")
            mail.login(EMAIL_USER, APP_PASSWORD.replace(" ", ""))
            from datetime import datetime, timedelta
            data_limite = (datetime.now() - timedelta(days=30)).strftime("%d-%b-%Y")
            data_it = (datetime.now() - timedelta(days=30)).strftime("%d/%m/%Y")
            status, cartelle = mail.list()
            lista_nomi = str(cartelle)
            nome_cartella = '"[Gmail]/Tutti i messaggi"'
            if "All Mail" in lista_nomi: nome_cartella = '"[Gmail]/All Mail"'
            mail.select(nome_cartella)
            tutti_ids = []
            self.operazioni_scaricate_sessione = 0
            for i, kw in enumerate(parole_chiave):
                kw = kw.strip().lower()
                if not kw: continue
                perc_ricerca = int(((i + 1) / len(parole_chiave)) * 100)
                aggiorna_UI(f"üîç Ricerca in corso dal {data_it}...", perc_ricerca, dettaglio=kw)
                time.sleep(0.5)
                status, messages = mail.search(None, f'(UNSEEN SINCE "{data_limite}" TEXT "{kw}")')
                if status == 'OK':
                    ids_trovati = messages[0].split()
                    for m_id in ids_trovati:
                        if m_id not in tutti_ids: 
                            tutti_ids.append(m_id)
            if not tutti_ids:
                if popup: popup.destroy()
                mail.logout()
                return
            client = genai_client.Client(api_key=API_KEY)
            for i, m_id in enumerate(tutti_ids):
                percentuale = int(((i + 1) / len(tutti_ids)) * 100)
                res, data = mail.fetch(m_id, "(BODY[HEADER.FIELDS (SUBJECT)])")
                msg_temp = email.message_from_bytes(data[0][1])
                oggetto = str(msg_temp.get("Subject", "Nessun Oggetto"))
                aggiorna_UI(f"üì© Analisi {i+1}/{len(tutti_ids)}", percentuale, dettaglio=oggetto)
                data_oggi = datetime.now().date()
                res, msg_data = mail.fetch(m_id, "(BODY.PEEK[])")
                for response_part in msg_data:
                    if isinstance(response_part, tuple):
                        msg = email.message_from_bytes(response_part[1])
                        oggetto = str(msg.get("Subject", ""))
                        data_dt = email.utils.parsedate_to_datetime(msg.get("Date")).date()
                        corpo = ""
                        pdf_data = None
                        for part in msg.walk():
                            if part.get_content_type() in ["text/plain", "text/html"]:
                                try:
                                    raw = part.get_payload(decode=True).decode(errors='ignore')
                                    corpo += re.sub(r'<[^<]+?>', ' ', raw)
                                except: pass
                            elif "pdf" in part.get_content_type():
                                pdf_data = part.get_payload(decode=True)
                        try:
                            prompt = f"""Analizza questa mail/bolletta. 
                            Le parole chiave di riferimento sono: {', '.join(parole_chiave)}.
                            Estrai in JSON:
                            {{"importo": float, "azienda": "nome", "fattura": "numero", "direzione": "Entrata/Uscita"}}
                            REGOLE: 
                            1. Se non trovi l'importo, scrivi 0.01. 
                            2. Determina Entrata/Uscita. 
                            3. Il campo "azienda" deve contenere SOLO il nome, senza icone, emoji o prefissi tipo 'ü§ñ'."""
                            response = client.models.generate_content(
                                model="gemini-2.5-flash",
                                contents=[prompt, f"Oggetto: {oggetto}\nCorpo: {corpo}"] + 
                                         ([types.Part.from_bytes(data=pdf_data, mime_type="application/pdf")] if pdf_data else [])
                            )
                            res_text = response.text.strip().replace("```json", "").replace("```", "")
                            dati = json.loads(res_text)
                            importo = float(dati.get("importo") or 0.01)
                            azienda = dati.get("azienda") or "Fattura"
                            direzione = dati.get("direzione", "Uscita")
                            desc = f"{azienda}"
                            if dati.get("fattura"): desc += f" {dati['fattura']}"
                            esiste = False
                            for d_chiave in self.spese:
                                for s in self.spese[d_chiave]:
                                    if s[1] == desc and abs(s[2] - importo) < 0.01:
                                        esiste = True
                                        break
                                if esiste: break
                            if not esiste:
                                self.spese.setdefault(data_oggi, []).append((CATEGORIA_TEMPORANEA, desc, importo, direzione))
                                self.operazioni_scaricate_sessione += 1
                                if pdf_data:
                                    nome_pulito = re.sub(r'[\\/*?:"<>|]', "", azienda)
                                    numero_fatt = dati.get('fattura', 'NA')
                                    nome_file = f"{data_oggi.strftime('%d-%m-%Y')}_{nome_pulito}_fatt_{dati.get('fattura') or 'mancante'}.pdf"
                                    percorso_completo = os.path.join(cartella_pdf, nome_file)
                                    with open(percorso_completo, "wb") as f:
                                        f.write(pdf_data)
                                    print(f"File salvato: {nome_file}")
                                if hasattr(self, 'lbl_sync_count_widget'):
                                    self.lbl_sync_count_widget.config(text=f"üì° Sync {self.operazioni_scaricate_sessione}")
                            mail.store(m_id, '+FLAGS', '\\Seen')
                            aggiorna_UI(f"OK: {azienda}", percentuale, self.operazioni_scaricate_sessione)
                            time.sleep(5) 
                        except Exception as e_ai:
                            err_msg = str(e_ai)
                            if "429" in err_msg or "RESOURCE_EXHAUSTED" in err_msg:
                                msg_stop = "Limite Giornaliero AI raggiunto."
                                print(msg_stop)
                                aggiorna_UI(msg_stop)
                                self.save_db()
                                if 'mail' in locals(): 
                                    try: mail.logout()
                                    except: pass
                                time.sleep(2)
                                if popup: popup.destroy()
                                return 
                            print(f"Errore minore (salto mail): {err_msg}")
                            continue
            mail.logout()
            self.save_db()
            self.refresh_gui()
            if popup: popup.destroy()
        except Exception as e:
            print(f"Errore Generale: {e}")
            if 'popup' in locals() and popup: popup.destroy()

    def ricalcola_operazioni_web(self):
        contatore = 0
        categoria_target = "Zona @Web/Bank" 
        for entries in self.spese.values():
            for e in entries:
                if e[0] == categoria_target:
                    contatore += 1
        self.operazioni_scaricate_sessione = contatore
        contatore_pdf = 0
        path_pdf = os.path.join(os.getcwd(), "Fatture_GMail")
        if os.path.exists(path_pdf):
            contatore_pdf = len([f for f in os.listdir(path_pdf) if f.lower().endswith('.pdf')])
        def applica_stato_visivo():
            if hasattr(self, 'lbl_sync_count_widget') and self.lbl_sync_count_widget.winfo_exists():
                try:
                    self.lbl_sync_count_widget.config(text=f"üì° Sync: {self.operazioni_scaricate_sessione}")
                    if self.operazioni_scaricate_sessione > 0 or contatore_pdf > 0:
                        colore_stato = self.COLOR_RED
                    else:
                        colore_stato = self.COLOR_GREEN
                    if hasattr(self, 'btn_open_pdf_folder'):
                        self.btn_open_pdf_folder.config(foreground=colore_stato)
                    self.lbl_sync_count_widget.config(foreground=colore_stato)
                except:
                    pass
        if hasattr(self, 'lbl_sync_count_widget') and self.lbl_sync_count_widget.winfo_exists():
            applica_stato_visivo()
        else:
            self.after(200, applica_stato_visivo)
                
    # Mostra i Tooltip Movimenti in TkCalendar 
    def mostra_tooltip(self, event):
        if self.tooltip_timer:
            self.after_cancel(self.tooltip_timer)
            self.tooltip_timer = None
        if event.type == '11':
            self.tooltip_win.withdraw()
            return
        x_abs, y_abs = self.winfo_pointerxy()
        try:
            widget = self.winfo_containing(x_abs, y_abs)
            if not widget or "!menu" in str(widget):
                self.tooltip_win.withdraw()
                return
            if "label" in str(widget) and widget.cget("text").isdigit():
                g = int(widget.cget("text"))
                m, a = self.cal.get_displayed_month()
                data = datetime.date(a, m, g)
                evs = self.cal.get_calevents(data)
                spese = "".join([self.cal.calevent_cget(i, "text") + "\n" for i in evs if self.cal.calevent_cget(i, "text") != "Oggi"]).strip()
                if spese:
                    testo = spese
                elif data == datetime.date.today():
                    testo = "Oggi"
                else:
                    testo = ""
                if testo:
                    self.tooltip_timer = self.after(1000, lambda: self.esegui_disegno(testo, x_abs, y_abs))
                    return
        except (KeyError, Exception):
            pass
            
        self.tooltip_win.withdraw()
    def esegui_disegno(self, testo, x, y):
        self.tooltip_win.withdraw()
        for c in self.tooltip_win.winfo_children(): 
            c.destroy()
        main_frame = tk.Frame(self.tooltip_win, bg=self.COLOR_TOOLTIP, 
                              relief="solid", borderwidth=1)
        main_frame.pack(fill="both", expand=True)
        righe = testo.split('\n')
        for riga in righe:
            if not riga.strip(): continue
            colore_testo = self.COLOR_TEXT_TOOLTIP
            if "-" in riga:
                colore_testo = self.COLOR_RED_SMOOTH
            elif "+" in riga:
                colore_testo = self.COLOR_GREEN_SMOOTH
            if riga.strip() == "Oggi":
                colore_testo = self.COLOR_TEXT_TOOLTIP
                fnt = ("Courier New", 9, "bold")
            else:
                fnt = ("Courier New", 9, "bold")
            tk.Label(
                main_frame, 
                text=riga, 
                fg=colore_testo, 
                bg=self.COLOR_TOOLTIP,
                font=fnt, 
                justify="left",
                padx=10, 
                pady=2
            ).pack(anchor="w")
        self.tooltip_win.geometry(f"+{x+15}+{y+10}")
        self.tooltip_win.update_idletasks()
        self.tooltip_win.deiconify()
        self.tooltip_win.attributes("-topmost", True)
    def applica_ricorsivo_tooltip(self, widget):
        widget.bind("<Motion>", self.mostra_tooltip)
        widget.bind("<Leave>", self.mostra_tooltip)
        for child in widget.winfo_children():
            self.applica_ricorsivo_tooltip(child)
            
    # DataBase Condiviso
    def notifica_modifica_web(self):
        import socket
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
            messaggio = f"REFRESH_NOW|{self.SESSION_ID}".encode('utf-8')
            for porta in [UDP_PORT_1, UDP_PORT_2]:
                sock.sendto(messaggio, ('255.255.255.255', porta))
            sock.close()
        except Exception as e:
            print(f"‚ö†Ô∏è Errore invio: {e}")
            
    # Refresh Remoto per Sincronizzazione Condivisa        
    def refresh_remote(self):
        try:
            print("üîî Segnale ricevuto: avvio ricaricamento dati...")
            self.load_db()
            self.mostra_treeview_statistiche()
            if hasattr(self, 'update_stats'):
                self.update_stats()
            self.update_totalizzatore_anno_corrente()
            self.update_totalizzatore_mese_corrente()
            self.update_spese_mese_corrente()
            self.colora_giorni_spese()
            self.aggiorna_monitoraggio_budget()
            if hasattr(self, 'pdf_window') and self.pdf_window.winfo_exists():
                tabella = getattr(self, 'tabella_documenti', None)
                funzione_load = getattr(self, 'funzione_carica_documenti', None)
                if tabella and funzione_load:
                    self.filtri_avanzati = {}
                    print("üìÇ Ricaricamento PDF tra 800ms...")
                    self.after(800, lambda: funzione_load(tabella, {}))
            self.update_idletasks()
            print("‚úì Refresh completato con successo!")
        except Exception as e:
            print(f"‚ùå Errore durante il refresh: {e}")
            
    # Sync dati esterni
    def pianifica_sincro_web(self):
        from datetime import datetime
        try:
            print(f"[{datetime.now().strftime('%H:%M:%S')}] Avvio sincronizzazione web automatica...")
            threading.Thread(target=self._esegui_sincro_thread, daemon=True).start()
        except Exception as e:
            print(f"‚ùå Errore durante il trigger della sincronizzazione: {e}")
        SYNC_INTERVALLO_MS = SYNC_INT_MIN * 60 * 1000
        self.after(SYNC_INTERVALLO_MS, self.pianifica_sincro_web)
    def _esegui_sincro_thread(self):
        from datetime import datetime
        try:
            self.avvia_sincronizzazione()
            print(f"[{datetime.now().strftime('%H:%M:%S')}] ‚úì Sincronizzazione completata con successo.")
        except Exception as e:
            print(f"[{datetime.now().strftime('%H:%M:%S')}] ‚ö†Ô∏è Sincro fallita: {e}")
                    
    # Timing Backup Incrementale threading
    def pianifica_backup_orario(self):
        from datetime import datetime
        try:
            print(f"[{datetime.now().strftime('%H:%M:%S')}] Avvio backup automatico...")
            threading.Thread(target=self._esegui_backup_json).start()
            threading.Thread(target=self.backup_documenti).start()
        except Exception as e:
            print(f"‚ùå Errore durante il trigger del backup: {e}")
        # Backup Ogni 12 ore
        self.after(43200000, self.pianifica_backup_orario)
               
    # Backup Incrementale threading
    def _esegui_backup_json(self):
        from datetime import datetime
        lista_file = [
            DB_FILE, SALDO_FILE, DATI_FILE, UTENZE_DB, REGISTRY_FILE,
            PW_FILE, MEM_CAT, CONFIG_FILE, RIMANDA_FILE, 
            PROMEMORIA_FILE, SUPERMERCATI_DB, DEFAULT_API, CONTROLLO_F_M
        ]
        file_copiati = 0
        for f in lista_file:
            try:
                if os.path.exists(f):
                    backup_incrementale(f)
                    file_copiati += 1
            except Exception as e:
                print(f"Errore backup nel thread per {f}: {e}")
        print(f"[{datetime.now().strftime('%H:%M:%S')}] ‚úì Backup Database terminato ({file_copiati} file salvati).")

# Backup Incrementale
def backup_incrementale(file_path, cartella_backup="backup", max_backup=MAX_BACKUP):
    if not os.path.exists(file_path):
        return
    os.makedirs(cartella_backup, exist_ok=True)
    nome_completo = os.path.basename(file_path)
    data = datetime.datetime.today().strftime("%d-%m-%Y") 
    backup_file_name = f"{data}-{nome_completo}"
    backup_file_path = os.path.join(cartella_backup, backup_file_name)
    shutil.copy2(file_path, backup_file_path)
    stringa_filtro = f"-{nome_completo}"
    files_to_check = [f for f in os.listdir(cartella_backup) if f.endswith(stringa_filtro)]
    if not files_to_check:
        return
    def get_sort_key(filename):
        date_str = filename[:10] 
        return datetime.datetime.strptime(date_str, "%d-%m-%Y")
    files_ordinati = sorted(
        files_to_check,
        key=get_sort_key,
        reverse=True 
    )
    files_da_cancellare = files_ordinati[max_backup:]
    if files_da_cancellare:
        for f in files_da_cancellare:
            os.remove(os.path.join(cartella_backup, f))

# Installazione Automatica e Gestione Condizionale delle Dipendenze Python
def install_tkcalendar():
    package_name = "tkcalendar"
    try:
        from tkcalendar import Calendar, DateEntry
    except ImportError:
        print(f"{package_name} non √® installato. Installazione in corso...")
        subprocess.run([sys.executable, "-m", "pip", "install", package_name], check=True)
        print(f"{package_name} installato con successo!")
        from tkcalendar import Calendar, DateEntry
    return Calendar, DateEntry

def install_genai():
    try:
        from google import genai
        return genai
    except ImportError:
        print("Il modulo 'google-genai' non √® stato trovato. Installazione in corso...")
        try:
            subprocess.run([sys.executable, "-m", "pip", "install", "google-genai"], check=True)
            print("'google-genai' installato con successo.")
            from google import genai
            return genai
        except subprocess.CalledProcessError as e:
            print(f"ERRORE: Installazione di 'google-genai' fallita. Dettagli: {e}")
            sys.exit(1)
        except ImportError:
            print("ERRORE: Impossibile importare 'google-genai' anche dopo l'installazione.")
            sys.exit(1)
genai_client = install_genai()
from google.genai.errors import APIError

def install_requests():
    try:
        import requests
    except ImportError:
        print("requests non trovato. Installazione in corso...")
        subprocess.run([sys.executable, "-m", "pip", "install", "requests"], check=True)
        import requests
    return requests
requests = install_requests()
from requests.exceptions import ConnectionError, RequestException

def install_segno():
    try:
        import segno
    except ImportError:
        print("segno non trovato. Installazione in corso...")
        subprocess.run([sys.executable, "-m", "pip", "install", "segno"], check=True)
        import segno
    return segno
segno = install_segno()

def install_win32_libraries():
    if platform.system() != "Windows":
        print("Sistema operativo non Windows: installazione non necessaria.")
        return None, None, None
    try:
        import win32print # type: ignore
        import win32api   # type: ignore
        import win32con   # type: ignore
    except ImportError:
        print("Moduli win32 non trovati. Installazione di pywin32 in corso...")
        subprocess.run([sys.executable, "-m", "pip", "install", "pywin32"], check=True)
        print("pywin32 installato con successo.")

# Controllo dell'Istanza Unica (Single Instance Check) Tramite Mutex o File Lock
def check_single_instance():
    global _lock_file_handle
    global _mutex_handle
    _lock_file_handle = None 
    _mutex_handle = None
    if sys.platform.startswith("win"):
        import ctypes
        LAST_ERROR_ALREADY_EXISTS = 183
        mutex_name = "Global\\CasaFacileWeb_Mutex_34A5B6C7"
        mutex = ctypes.windll.kernel32.CreateMutexW(None, True, mutex_name)
        if ctypes.windll.kernel32.GetLastError() == LAST_ERROR_ALREADY_EXISTS:
            print("Un'altra istanza √® gi√† in esecuzione! (Windows)")
            show_warning_popup()
            sys.exit(1)
        _mutex_handle = mutex
        print("Avvio riuscito. Acquisito il Mutex (Windows).")
        return
    else:
        import fcntl
        lock_dir = os.path.dirname(os.path.abspath(sys.argv[0]))
        lock_file_path = os.path.join(lock_dir, 'casa_facile.lock')
        try:
            lock_file = open(lock_file_path, 'a')
            fcntl.lockf(lock_file.fileno(), fcntl.LOCK_EX | fcntl.LOCK_NB)
            _lock_file_handle = lock_file
            lock_file.write(f"{os.getpid()}\n") 
            lock_file.flush()
            print("Avvio riuscito. Acquisito il lock (Linux/Unix).")
            return
        except BlockingIOError:
            print("Un'altra istanza √® gi√† in esecuzione! (Linux/Unix)")
            show_warning_popup()
            sys.exit(1)
        except Exception as e:
            print(f"Errore critico durante la creazione del lock: {e}")
            sys.exit(1)

# Visualizzazione Popup di Avviso Istanza Duplicata (Splash Screen Temporaneo)
def show_warning_popup():
    splash = tk.Tk()
    splash.overrideredirect(True)
    width, height = 380, 120
    x = (splash.winfo_screenwidth() // 2) - (width // 2)
    y = (splash.winfo_screenheight() // 2) - (height // 2)
    splash.geometry(f"{width}x{height}+{x}+{y}")
    splash.configure(bg="#000000", highlightthickness=2, highlightbackground="#61AFEF")
    label = tk.Label(
        splash,
        text=f"‚ö†Ô∏è {NAME} Pro\nL'applicazione √® gi√† in esecuzione",
        font=("Arial", 12, "bold"),
        fg="#61AFEF",
        bg="#000000",
        justify="center",
        padx=10,
        pady=10
    )
    label.pack(expand=True, fill="both")
    splash.after(4000, splash.destroy)
    splash.attributes("-topmost", True)
    splash.mainloop()

def leggi_configurazione_globale():
    final_config = DEFAULT_CONFIG.copy()
    if not os.path.exists(CONFIG_FILE):
        try:
            with open(CONFIG_FILE, 'w', encoding='utf-8') as f:
                json.dump(final_config, f, indent=4)
            return final_config
        except Exception:
            return final_config
    try:
        with open(CONFIG_FILE, 'r', encoding='utf-8') as f:
            config_data = json.load(f)
            for key, value in config_data.items():
                final_config[key] = value
    except Exception as e:
        print(f"‚ö†Ô∏è Errore lettura config.json: {e}")
    return final_config
    
# DataBase Condiviso
def ascolta_aggiornamenti_rete(app_istanza):
    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    port = UDP_PORT_1
    try:
        sock.bind(('', port))
    except Exception:
        port = UDP_PORT_2
        try:
            sock.bind(('', port))
        except Exception:
            print(f"‚ùå ERRORE: Entrambe le porte ({UDP_PORT_1}, {UDP_PORT_2}) sono occupate!")
            return
    print(f"üëÇ Ricevitore attivo sulla porta: {port}")
    while True:
        try:
            data, addr = sock.recvfrom(1024)
            messaggio = data.decode('utf-8')
            if "REFRESH_NOW" in messaggio:
                parti = messaggio.split("|")
                mittente_id = parti[1] if len(parti) > 1 else ""
                if mittente_id == str(app_istanza.SESSION_ID):
                    print(f"‚ôªÔ∏è Rimbalzo locale ignorato (ID: {mittente_id})")
                    continue
                print(f"üîî Segnale da ALTRO PC ({addr}): avvio ricaricamento...")
                app_istanza.after(100, app_istanza.refresh_remote)
        except Exception as e:
            print(f"‚ùå Errore ricezione: {e}")
            
if __name__ == "__main__":
    import traceback

    # CrashLog
    log_file = os.path.join(DB_DIR, "error_log.txt")

    # Manuale degli Argomenti da Riga di Comando (CLI)
    print(f"""
    üìò {NAME} Pro ‚Äî Guida agli argomenti da riga di comando
    
    ‚ñ∂ auto        Avvio automatico con impostazione password:

      ‚Ä¢ auto <password>   ‚Üí usa la password specificata
      ‚Ä¢ auto ""            ‚Üí imposta una password vuota
      ‚Ä¢ auto               ‚Üí usa la password predefinita (es. "return")

    ‚ñ∂ noweb       Avvia senza interfaccia web (disabilita server locale)

    Esempi:
    {NAME}.pyw auto 1234     # imposta password ‚Äú1234‚Äù
    {NAME}.pyw auto ""       # password vuota
    {NAME}.pyw auto          # password automatica (definita da utente)
    {NAME}.pyw noweb         # GUI senza web server
    {NAME}.pyw auto "" noweb # password vuota + niente web

    """)

    try:
        # Sequenza di Inizializzazione e Controllo di Avvio
        Calendar, DateEntry = install_tkcalendar()
        install_segno()
        install_genai()
        install_requests()
        install_win32_libraries()
        check_single_instance()
        
        # Inizializzazione Struttura delle Directory e dei File di Sistema
        if not os.path.exists(EXPORT_FILES):
            os.makedirs(EXPORT_FILES)
        if not os.path.exists(DB_DIR):
            os.makedirs(DB_DIR)
        if not os.path.exists(EXP_DB):
            os.makedirs(EXP_DB)
        if not os.path.exists(UTENZE_DB):
            with open(UTENZE_DB, "w") as file:
                file.write("")  
        
        # Caricamento Finale dei Parametri di Configurazione Globali
        app_config_globale = leggi_configurazione_globale()
        AUTO_ICONIZE_STARTUP = app_config_globale.get("enable_auto_login_flow", False)
        ICONIZZA_INATTIVITA = app_config_globale.get("iconizza_inattivita", True)
        TIMEOUT_INATTIVITA_MS = app_config_globale.get("inactivity_timeout_ms", 1200000)
        SALVA_GEOMETRIA_INIZIALE = app_config_globale.get("load_saved_geometry", False)
        ABILITA_WEBSERVER = app_config_globale.get("webserver_enabled", True)
        PORTA = app_config_globale.get("webserver_port", 8080)
        ANNI_DA_MANTENERE = app_config_globale.get("anni_da_mantenere", 10)
        ICO_SET_DATE = app_config_globale.get("ico_set_date", True)
        CHECK_MESE = app_config_globale.get("enable_recurring_reminder", True)
        SOGLIA_GIORNI_RICORRENTI = app_config_globale.get("soglia_giorni_ricorrenti", 5)
        MAX_BACKUP = app_config_globale.get("max_backup", 5)
        SMARTCAT = app_config_globale.get("smartcat_enabled", True)
        USE_WAIT_WINDOW = app_config_globale.get("use_wait_window", False)
        WARN_TIMEOUT = app_config_globale.get("warn_timeout_ms", 20000)
        LINK_BANCA = app_config_globale.get("bank_link", "")
        THEMA = app_config_globale.get("thema", "OBSIDIAN")
        CAROSELLO = app_config_globale.get("carosello_enabled", True)
        CAROSELLO_INTERVALLO = app_config_globale.get("carosello_intervallo", 10000)
        CAL_TOOLTIPS = app_config_globale.get("cal_tooltips_enabled", False)
        DB_CONDIVISO = app_config_globale.get("shared_db", False)
        PATH_RETE = app_config_globale.get("shared_db_path", PATH_LOCALE)
        UDP_PORT_1 = app_config_globale.get("udp_port_1", 5555)
        UDP_PORT_2 = app_config_globale.get("udp_port_2", 5556)
        TARGET_MESE = app_config_globale.get("target_mese", 0)
        TARGET_ANNO = app_config_globale.get("target_anno", 0)         
        SYNC_DATI = app_config_globale.get("sync_dati_enabled", False)
        SYNC_INT_MIN = app_config_globale.get("sync_intervallo_min", 720)
        EMAIL_USER = app_config_globale.get("email_user", "")
        APP_PASSWORD = app_config_globale.get("app_password", "")
        API_KEY = app_config_globale.get("gemini_api_key", "")
        kw_raw = app_config_globale.get("parole_chiave", "")
        if isinstance(kw_raw, list):
            PAROLE_CHIAVE = kw_raw
        else:
            PAROLE_CHIAVE = [k.strip() for k in str(kw_raw).split(",") if k.strip()]
                     
        print(f"‚úì Modalit√†: {'RETE' if DB_CONDIVISO else 'LOCALE'}")
        
        # Lancio dell'Applicazione Principale e Ciclo di Eventi (Main Loop)
        app = GestioneSpese()
        
        # DataBase Condiviso
        if DB_CONDIVISO:
            t = threading.Thread(target=ascolta_aggiornamenti_rete, args=(app,), daemon=True)
            t.start()
            print("üì° Modalit√† Rete Attiva")
            
        app.mainloop()

    except Exception as e:
        error_info = traceback.format_exc()
        print(f"\nERRORE CRITICO (v{VERSION})\n{error_info}")
        try:
            if os.path.exists(log_file) and os.path.getsize(log_file) > 50 * 1024:
                open(log_file, "w").close()
            with open(log_file, "a", encoding="utf-8") as f:
                timestamp = datetime.datetime.now().strftime("%d-%m-%Y %H:%M:%S")
                f.write(f"CRASH RILEVATO IL: {timestamp}\n")
                f.write(f"VERSIONE APP: {VERSION}\n")
                f.write(f"CONFIGURAZIONE ATTIVA:\n")
                if 'app_config_globale' in locals():
                    for chiave, valore in app_config_globale.items():
                        f.write(f"{chiave}: {valore}\n")
                else:
                    f.write("Configurazione non ancora caricata al momento del crash.\n")
                f.write(f"TRACEBACK:\n{error_info}\n\n")
        except Exception as log_err:
            print(f"Impossibile scrivere il log: {log_err}")
        sys.exit(1)
        

