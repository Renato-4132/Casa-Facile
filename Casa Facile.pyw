#!/usr/bin/env python3

import os
import re
import sys
import csv
import json
import html
import math
import uuid
import base64
import random
import socket
import ctypes
import shutil
import hashlib
import zipfile
import platform
import calendar
import datetime
import tempfile
import threading
import subprocess
import webbrowser
import importlib.util

import urllib.parse
import urllib.request
from urllib.parse import urlparse, parse_qs
from decimal import Decimal, InvalidOperation
from http.server import BaseHTTPRequestHandler, HTTPServer
from collections import defaultdict
import tkinter as tk
from tkinter import ttk, messagebox, filedialog, Toplevel, Label, Button, TclError
import html as html_escape

URL_PDF = "https://raw.githubusercontent.com/Renato-4132/Casa-Facile/refs/heads/main/Casa%20Facile.pdf"
URL_PDF_CONSUMI = "https://raw.githubusercontent.com/Renato-4132/Casa-Facile/main/Tabella%20Contatori.pdf"
GITHUB_FILE_URL = "https://raw.githubusercontent.com/Renato-4132/Casa-Facile/refs/heads/main/Casa%20Facile.pyw"
GITHUB_SUPERMARKET = "https://raw.githubusercontent.com/Renato-4132/Casa-Facile/main/supermarket.pyw"
NOME_EDITOR_LOCALE = "supermarket.pyw"
ICON_URL = "https://github.com/Renato-4132/Casa-Facile/blob/main/casa-facile.png?raw=true"
NOME_FILE = "Casa Facile.pyw" 
REPO_OWNER = "Renato-4132"
REPO_NAME = "Casa-Facile"
NAME = "Casa-Facile"
EXPORTDB_DIR = "export"
DB_DIR = "db"
DB_FILE = os.path.join(DB_DIR, "spese_db.json")
DATI_FILE = os.path.join(DB_DIR,"rubrica.json")
UTENZE_DB = os.path.join(DB_DIR, "utenze_db.json")
DOC_DIR = os.path.join(DB_DIR, "documenti")
REGISTRY_FILE = os.path.join(DB_DIR, "documenti_archiviati.json")
SALDO_FILE = os.path.join(DB_DIR, "saldo_db.json")
SUPERMERCATI_DB = os.path.join(DB_DIR, "supermercati.json")
EXPORT_FILES = "export"
EXP_DB = os.path.join(DB_DIR, EXPORTDB_DIR)
PW_FILE = os.path.join(DB_DIR, "password.json")
MEM_CAT = os.path.join(DB_DIR, "memoria_categorie.json")
CONFIG_FILE = os.path.join(DB_DIR, "config.json")
RIMANDA_FILE = os.path.join(DB_DIR, "update.json")
PROMEMORIA_FILE = os.path.join(DB_DIR, "promemoria.json")
ICON_NAME = "casa-facile.png"
DEFAULT_API = os.path.join(DB_DIR, "api.json")
CONTROLLO_F_M = os.path.join(DB_DIR, "controllo_fm.json")
APRI_BROWSER = False
URL_QST = "https://forms.gle/VidTCh7ySkWHCAE6A"
CONTROLLO_CHANGELOG = os.path.join(DB_DIR, "changelog_hash.json")
LINK_BANCA = ""

# Imposta timeout Messaggi Popup (millisecondi)
WARN_TIMEOUT = 20000

# Imposta a True se vuoi chiusura con conferma self.show_custom_warning
# Imposta a False per forzare timeout chiusura  self.show_custom_warning
USE_WAIT_WINDOW = False

# Imposta working directory (Dove risiede lo script)
os.chdir(os.path.dirname(os.path.abspath(sys.argv[0])))

# Nome della cartella corrente in cui si trova lo script in esecuzione
current_folder = os.path.basename(os.getcwd())

#Tolleranza Movimenti simili (SmartCat)
toll = 30 #Euro

#Versione
VERSION = "9.3.5"

# Attiva/disattiva Timer Minimizza
ICONIZZA_INATTIVITA = True

# 20 minuti in millisecondi Timer Minimizza
TIMEOUT_INATTIVITA_MS = 1200000

# Numero di anni che l'applicazione conserver√† nel db
ANNI_DA_MANTENERE = 10

# Salva la posizione della gui
SALVA_GEOMETRIA_INIZIALE = False

# Set data quando iconizza o deiconizza
ICO_SET_DATE = True

#Riconoscimento automatico categorie
SMARTCAT = True

# Set check categorie mancanti a termine mese
CHECK_MESE = True
#Avviso gg prima del termine mese
SOGLIA_GIORNI_RICORRENTI = 5

# Copie backup da conservare
MAX_BACKUP=10

# Rotazione automatica e ciclica dei contenuti visuali (come i grafici)
CAROSELLO = True

# Abilita Tooltips su Calendario (Sperimentale - non sempre stabile)
CAL_TOOLTIPS = False

BACKGROUND_DARK = "black"  # Sfondo Barra menu superiore
FOREGROUND_LIGHT = "white" # Colore di primo piano chiaro (bianco)
MENU_BG = "#424242"        # Sfondo dei sottomenu
ACCENT_COLOR = "#00BCD4"   # Colore di evidenziazione (ciano)

# Default thema avvio
THEMA = "MATERIAL"

DEFAULT_CONFIG = {
    "enable_auto_login_flow": False,
    "webserver_enabled": True,
    "iconizza_inattivita": True,
    "inactivity_timeout_ms": 1200000,
    "webserver_port": 8080,
    "load_saved_geometry": False,
    "anni_da_mantenere": 10,
    "ico_set_date": True,
    "enable_recurring_reminder": True,
    "recurring_days_threshold": 5,
    "max_backup": 10,
    "smartcat_enabled": True,
    "use_wait_window": False,
    "warn_timeout_ms": 20000,
    "link_bank": "",
    "thema": "MATERIAL",
    "carosello_enabled": True,
    "carosello_intervallo": 10000,
    "cal_tooltips_enabled": False,
}

CATEGORIE_PREDEFINITE = [
    "Affettati",
    "Acqua",
    "Animali Domestici",
    "Articoli Bimbi",
    "Assorbenza",
    "Auto e Elettronica",
    "Birre",
    "Biscotti",
    "Bucato",
    "Caff√® e Bevande",
    "Cancelleria/Party",
    "Carne",
    "Carta Casa/Igiene",
    "Carta e Alluminio",
    "Casalinghi/Tessile",
    "Cereali Colazione",
    "Cibi Etnici",
    "Cioccolato",
    "Conserve Pesce",
    "Cosmetici",
    "Cura dei Capelli",
    "Cura del Corpo",
    "Dolciumi e Caramelle",
    "Farine e Lieviti",
    "Formaggi Freschi",
    "Formaggi Stagionati",
    "Frutta Fresca",
    "Gastronomia",
    "Gelati",
    "Giardino e Fai da",
    "Igiene Persona",
    "Insalate Pronte",
    "Integratori/Sanitari",
    "Latte e Burro",
    "Latticini e Yogurt",
    "Legumi Secchi/Scatole",
    "Liquori e Distillati",
    "Marmellate/Creme",
    "Merende e Snack",
    "Molluschi/Crostacei",
    "Olio",
    "Ortaggi e Tuberi",
    "Pane e Panini",
    "Pasta Fresca",
    "Pasta Secca",
    "Pesce",
    "Piatti Pronti",
    "Pizze Surgelate",
    "Pollame",
    "Prodotti Bio",
    "Prodotti Dietetici",
    "Prodotti Veg/Vegan",
    "Pulizia Casa",
    "Riso",
    "Salumi",
    "Salse e Condimenti",
    "Snack Panetteria",
    "Snack Salati",
    "Sottoli/Sottaceti",
    "Spugne e Guanti",
    "Succhi/Bibite",
    "Surgelati Pesce",
    "Surgelati Vari",
    "Surgelati Verdura",
    "Sushi e Tartare",
    "Uova",
    "Varie",
    "Verdura Fresca",
    "Vini e Spumanti",
]


class CasaFacileWebHandler(BaseHTTPRequestHandler):

    def do_GET(self):
        path = urlparse(self.path).path
        cookie = self.headers.get("Cookie", "")
        is_logged_in = "logged_in=true" in cookie
        if path == "/login":
            html = self.server.app.html_login(self.path)
            self.send_response(200)
            self.send_header("Content-type", "text/html; charset=utf-8")
            self.end_headers()
            self.wfile.write(html.encode("utf-8"))
            return
        elif path == "/logoff":
            self.send_response(303)
            self.send_header("Set-Cookie", "logged_in=false; Path=/")
            self.send_header("Location", "/login")
            self.end_headers()
            return
        if not is_logged_in:
            self.send_response(303)
            self.send_header("Location", "/login")
            self.end_headers()
            return
        if path == "/":
            html = self.server.app.html_form()
        elif path == "/gestione_categorie":
            html = self.server.app.html_gestione_categorie() 
        elif path.startswith("/stats"):
            html = self.server.app.stats_mensili_html()
        elif path.startswith("/lista"):
            html = self.server.app.html_lista_spese_mensili()
        elif path.startswith("/menu_esplora"):
            html = self.server.app.pagina_menu_esplora()
        elif path.startswith("/cerca_avanzata"):
            params = parse_qs(urlparse(self.path).query)
            html = self.server.app.pagina_risultati_avanzati(params)
        elif path.startswith("/modifica"):
            params = parse_qs(urlparse(self.path).query)
            html = self.server.app.modifica_voce_form(params)
        elif path.startswith("/report_annuo"):
            params = parse_qs(urlparse(self.path).query)
            html = self.server.app.pagina_statistiche_annuali_web()
        elif path.startswith("/utenze"):
            params = parse_qs(urlparse(self.path).query)
            anno = params.get("anno", [str(datetime.datetime.now().year)])[0]
            html = self.server.app.genera_html_utenze(UTENZE_DB, anno)
            self.send_response(200)
            self.send_header("Content-type", "text/html; charset=utf-8")
            self.end_headers()
            self.wfile.write(html.encode("utf-8"))
            return
        elif path.startswith("/consultazione_supermercati"):
            html = self.server.app.genera_html_consultazione() 
            self.send_response(200)
            self.send_header("Content-type", "text/html; charset=utf-8")
            self.end_headers()
            self.wfile.write(html.encode("utf-8"))
            return
        elif path.startswith("/documenti_pdf_web"):
            html = self.server.app.documenti_pdf_web()
            self.send_response(200)
            self.send_header("Content-type", "text/html; charset=utf-8")
            self.end_headers()
            self.wfile.write(html.encode("utf-8"))
            return
        else:
            self.send_error(404, "Pagina non trovata")
            return
        self.send_response(200)
        self.send_header("Content-type", "text/html; charset=utf-8")
        self.end_headers()
        self.wfile.write(html.encode("utf-8"))

    def do_POST(self):
        path = self.path
        cookie = self.headers.get("Cookie", "")
        is_logged_in = "logged_in=true" in cookie
        if path.startswith("/check_login"):
            content_len = int(self.headers.get("Content-Length", 0))
            body = self.rfile.read(content_len).decode()
            params = parse_qs(body)
            password = params.get("password", [""])[0].strip()
            if not self.server.app.leggi_hash():
                self.server.app.salva_hash(password)
                success = True
            else:
                success = self.server.app.verifica_password(password)
            if success:
                self.send_response(303)
                self.send_header("Set-Cookie", "logged_in=true; Path=/")
                self.send_header("Location", "/")
            else:
                self.send_response(303)
                self.send_header("Location", "/login?error=1")
            self.end_headers()
            return
        if not is_logged_in:
            self.send_response(303)
            self.send_header("Location", "/login")
            self.end_headers()
            return
        if path == "/":
            content_len = int(self.headers.get("Content-Length", 0))
            body = self.rfile.read(content_len).decode()
            params = parse_qs(body)
            voce = {
                "date": params.get("data", ["01-01-2024"])[0],
                "categoria": params.get("categoria", ["Generica"])[0],
                "descrizione": params.get("descrizione", [""])[0],
                "importo": float(params.get("importo", ["0"])[0]),
                "tipo": params.get("tipo", ["Uscita"])[0]
            }
            self.server.app.aggiungi_voce_web(voce)
            self.server.app.carica_db_web()
            self.server.app.refresh_gui()
            self.send_response(303)
            self.send_header("Location", "/")
            self.end_headers()
            return
        if path == "/salva_categoria":
            content_len = int(self.headers.get("Content-Length", 0))
            body = self.rfile.read(content_len).decode()
            params = parse_qs(body)
            operazione = params.get("operazione", [""])[0]
            if operazione == "aggiungi":
                self.server.app.add_categoria_web(params)
            elif operazione == "modifica":
                self.server.app.modifica_categoria_web(params)
            self.server.app.carica_db_web()
            self.server.app.refresh_gui()
            self.send_response(303)
            self.send_header("Location", "/gestione_categorie?status=success")
            self.end_headers()
            return
        if path == "/cancella_categoria":
            content_len = int(self.headers.get("Content-Length", 0))
            body = self.rfile.read(content_len).decode()
            params = parse_qs(body)
            self.server.app.cancella_categoria_web(params)
            self.server.app.carica_db_web()
            self.server.app.refresh_gui()
            self.send_response(303)
            self.send_header("Location", "/gestione_categorie?status=deleted")
            self.end_headers()
            return
        if path == "/salva_modifica":
            content_len = int(self.headers.get("Content-Length", 0))
            body = self.rfile.read(content_len).decode()
            params = parse_qs(body)
            self.server.app.salva_modifica_voce(params)
            self.server.app.refresh_gui()
            self.send_response(303)
            self.send_header("Location", "/")
            self.end_headers()
            return
        if path == "/cancella":
            content_len = int(self.headers.get("Content-Length", 0))
            body = self.rfile.read(content_len).decode()
            params = parse_qs(body)
            giorno = params.get("data", [""])[0]
            idx = int(params.get("idx", ["-1"])[0])
            self.server.app.cancella_voce_web(giorno, idx)
            self.server.app.refresh_gui()
            self.send_response(303)
            self.send_header("Location", "/")
            self.end_headers()
            return
        if path == "/":
             content_len = int(self.headers.get("Content-Length", 0))
             body = self.rfile.read(content_len).decode()

        self.send_error(404, "Pagina POST non gestita")


class GestioneSpese(tk.Tk):

    CATEGORIA_RIMOSSA = "Categoria Rimossa"
    
    def __init__(self):
        super().__init__()

        self.salva_geometria = SALVA_GEOMETRIA_INIZIALE
        self.withdraw()
        self.update_idletasks()
        
        initial_width = 1270
        initial_height = 620
        screen_width = self.winfo_screenwidth()
        screen_height = self.winfo_screenheight()

        self._window_geometry = None
        self.load_window_geometry()

        if self._window_geometry:
            self.geometry(self._window_geometry)
        else:
            x = (screen_width // 2) - (initial_width // 2)
            y = (screen_height // 2) - (initial_height // 2)
            self.geometry(f"{initial_width}x{initial_height}+{x}+{y}")
        
        if not self.gestione_login():
            sys.exit()
            return

        self.resizable(True, True)
        self.minsize(1270, 620)
        self.lift()
        self.focus_force()
        self.after(250, self.deiconify)
        
        # Carica Icona
        self.set_app_icon()
        
        # Variabili Backup Completo
        self.current_folder = current_folder
        self.backup_formato = 'zip'

        # Variabile Tabella Iniziale
        self.stats_view_mode = tk.StringVar(value="tabella")
        
        # Timer Carosello
        self.chiamato_da_carosello = True
        self.intervallo_scorrimento = 10000  # 10 secondi 
        self.id_scorrimento_automatico = None
        self.intervallo_scorrimento = CAROSELLO_INTERVALLO
        
        # Timer Countdown Minimizza
        self._countdown_delay = 5000 
        self._countdown_splash = None
        self._countdown_timer_id = None

        # Intervallo Lampeggio Cursore
        self.blinking_interval = 500

        # Menu Principale
        barra_menu = tk.Menu(self, background=BACKGROUND_DARK, foreground=FOREGROUND_LIGHT, activebackground=ACCENT_COLOR, activeforeground='black')
        self.config(menu=barra_menu)
        menu_gestione = tk.Menu(barra_menu, tearoff=0, bg=MENU_BG, fg=FOREGROUND_LIGHT, activebackground=ACCENT_COLOR, activeforeground='black')
        barra_menu.add_cascade(label="üóÇÔ∏è Gestione", menu=menu_gestione)
        menu_gestione.add_command(label="üìã Gestione SuperMarket", command=self.spesa_supermercato)
        menu_gestione.add_command(label="üì§ Gestione Documenti", command=self.gestisci_archivi_pdf)
        menu_gestione.add_command(label="üë• Gestione Utenze", accelerator="Ctrl+U", command=self.utenze)
        menu_gestione.add_command(label="üìÖ Rubrica", accelerator="Ctrl+R", command=self.rubrica_app)
        menu_gestione.add_command(label="üìã Promemoria", accelerator="Ctrl+Y", command=self.gestisci_promemoria)
        menu_gestione.add_command(label="üìò GCalendar", command=self.launch_qr_svg_generator)
        menu_ricorrenze = tk.Menu(menu_gestione, tearoff=0, bg=MENU_BG, fg=FOREGROUND_LIGHT, activebackground=ACCENT_COLOR, activeforeground='black')
        menu_gestione.add_cascade(label="‚ôªÔ∏è Ricorrenze", menu=menu_ricorrenze)
        menu_ricorrenze.add_command(label="üìã Gestione Ricorrenze", accelerator="Ctrl+T", command=self.mostra_ricorrenza_popup)
        menu_ricorrenze.add_command(label="üìã Lista Ricorrenze", accelerator="Ctrl+L", command=self.mostra_lista_ricorrenze)
        menu_ricorrenze.add_command(label="üìã Scadenze Mese", accelerator="Ctrl+J", command=self.scadenze_mese)
        menu_gestione.add_separator()
        menu_gestione.add_command(label="üìÖ Stampa", accelerator="Ctrl+P", command=self.anteprima_e_stampa_txt)
        menu_gestione.add_command(label="üí∞ Saldo Conto", accelerator="Ctrl+S", command=self.open_saldo_conto)
        menu_gestione.add_command(label="üìã Pannello Controllo", accelerator="Ctrl+Z", command=self.calcola_mancanti)
        menu_gestione.add_command(label="üìã Calcolatrice", accelerator="Ctrl+E", command=self.apri_calcolatrice)
        menu_gestione.add_command(label="üìã Cancella Voci Bulk", command=self.apri_cancella_spese_treeview_unica)
        menu_gestione.add_separator()
        menu_gestione.add_command(label="‚úñÔ∏è Salva e chiudi", accelerator="Ctrl+Q", command=self._on_close)
        menu_gestione.add_command(label="‚úñÔ∏è Riduci a icona", accelerator="Ctrl+X", command=self.iconify)
        menu_analisi = tk.Menu(barra_menu, tearoff=0, bg=MENU_BG, fg=FOREGROUND_LIGHT, activebackground=ACCENT_COLOR, activeforeground='black')
        barra_menu.add_cascade(label="üìä Analisi", menu=menu_analisi)
        
        menu_analisi.add_command(label="üîç Ricerca Globale", accelerator="Ctrl+F", command=self.cerca_operazioni)
        menu_analisi.add_command(label="üìä Confronta Periodi", accelerator="Ctrl+C", command=self.open_compare_window)
        menu_analisi.add_command(label="üìä Time Machine", accelerator="Ctrl+W", command=self.time_machine)
        menu_analisi.add_command(label="üìÇ Aggrega Categorie", accelerator="Ctrl+G", command=self.gruppo_categorie)
        menu_analisi.add_command(label="üìã Bilancio Annuo", accelerator="Ctrl+A", command=self.calcola_statistiche_annuali)
        menu_analisi.add_command(label="üìã Grafici Interattivi", accelerator="Alt+H", command=self.mostra_analisi_grafici)
        menu_finanze = tk.Menu(barra_menu, tearoff=0, bg=MENU_BG, fg=FOREGROUND_LIGHT, activebackground=ACCENT_COLOR, activeforeground='black')
        barra_menu.add_cascade(label="üí∏ Finanze", menu=menu_finanze)
        menu_finanze.add_command(label="üìä Finanziamenti", accelerator="Ctrl+O", command=self.calcolo_mutuo_prestito)
        menu_estrazioni = tk.Menu(menu_finanze, tearoff=0, bg=MENU_BG, fg=FOREGROUND_LIGHT, activebackground=ACCENT_COLOR, activeforeground='black')
        menu_finanze.add_cascade(label="üóÉÔ∏è Estrazioni", menu=menu_estrazioni)
        menu_estrazioni.add_command(label="üìÖ Report Giorno", accelerator="Alt+J", command=self.export_giorno_forzato)
        menu_estrazioni.add_command(label="üìÖ Report Mese", accelerator="Alt+K", command=self.export_month_detail)
        menu_estrazioni.add_command(label="üìä Report Anno", accelerator="Alt+L", command=self.export_anno_dettagliato)
        menu_categorie = tk.Menu(barra_menu, tearoff=0, bg=MENU_BG, fg=FOREGROUND_LIGHT, activebackground=ACCENT_COLOR, activeforeground='black')
        barra_menu.add_cascade(label="üìÜ Categorie", menu=menu_categorie)
        menu_categorie.add_command(label="‚è∞ Analisi Categorie", accelerator="Ctrl+K", command=self.open_analisi_categoria)
        menu_categorie.add_command(label="‚è∞ Suggerisci Categorie", accelerator="Ctrl+Shift+K", command=self.apri_categorie_suggerite)
        menu_categorie.add_command(label="‚è∞ Gestione Categorie", accelerator="Ctrl+Shift+T", command=self.mostra_categorie_popup)
        menu_categorie.add_command(label="‚è∞ Gestione Categorie Bulk", accelerator="Ctrl+Shift+S", command=self.apri_cancella_multiplo)
        menu_opzioni = tk.Menu(barra_menu, tearoff=0, bg=MENU_BG, fg=FOREGROUND_LIGHT, activebackground=ACCENT_COLOR, activeforeground='black')
        barra_menu.add_cascade(label="‚öôÔ∏è Opzioni", menu=menu_opzioni)
        menu_opzioni.add_command(label="‚öôÔ∏è Impostazioni App", command=self.gestisci_configurazione)
        menu_db = tk.Menu(menu_opzioni, tearoff=0, bg=MENU_BG, fg=FOREGROUND_LIGHT, activebackground=ACCENT_COLOR, activeforeground='black')
        menu_opzioni.add_cascade(label="üíæ Database", menu=menu_db)
        menu_db.add_command(label="üì§ Esporta DB Transazioni", command=self.export_db)
        menu_db.add_command(label="üì§ Importa DB Transazioni", command=self.import_db)
        menu_db.add_command(label="üì§ Reset DB", command=self.show_reset_dialog)
        menu_db.add_command(label="üì§ Esegui Backup Completo Zip", command=self.esegui_backup_zip)
        menu_opzioni.add_separator()
        menu_opzioni.add_command(label="üîÑ Controlla Aggiornamento Software", command=self.forza_check_aggiornamento_con_api)
        menu_opzioni.add_command(label="üîÑ Forza Aggiornamento Software", command=self.forza_aggiorna)
        menu_opzioni.add_command(label="‚Ü©Ô∏è Annulla Ultimo Aggiornamento", command=self.ripristina_da_backup)
        menu_opzioni.add_command(label="üìÑ Visualizza Storico Aggiornamenti", command=self.visualizza_changelog)
        menu_opzioni.add_separator()
        menu_opzioni.add_command(label="üñ•Ô∏è Visualizza Interfaccia Web", command=self.apri_webserver)
        menu_info = tk.Menu(barra_menu, tearoff=0, bg=MENU_BG, fg=FOREGROUND_LIGHT, activebackground=ACCENT_COLOR, activeforeground='black')
        barra_menu.add_cascade(label="üõà Info", menu=menu_info)
        menu_info.add_command(label="üõà Info App", command=self.show_info_app, accelerator="Ctrl+I")
        menu_info.add_command(label="üìò Apri Manuale", command=self.scarica_manuale, accelerator="Ctrl+M")

        self.bind_all("<Control-u>", lambda e: self.utenze())
        self.bind_all("<Control-r>", lambda e: self.rubrica_app())
        self.bind_all("<Control-y>", lambda e: self.gestisci_promemoria())
        self.bind_all("<Control-p>", lambda e: self.anteprima_e_stampa_txt())
        self.bind_all("<Control-s>", lambda e: self.open_saldo_conto())
        self.bind_all("<Control-z>", lambda e: self.calcola_mancanti())
        self.bind_all("<Control-e>", lambda e: self.apri_calcolatrice())
        self.bind_all("<Control-q>", lambda e: self._on_close())
        self.bind_all("<Control-x>", lambda e: self.iconify())
        self.bind_all("<Control-t>", lambda e: self.mostra_ricorrenza_popup())
        self.bind_all("<Control-l>", lambda e: self.mostra_lista_ricorrenze())
        self.bind_all("<Control-j>", lambda e: self.scadenze_mese())
        self.bind_all("<Control-f>", lambda e: self.cerca_operazioni())
        self.bind_all("<Control-c>", lambda e: self.open_compare_window())
        self.bind_all("<Control-w>", lambda e: self.time_machine())
        self.bind_all("<Control-g>", lambda e: self.gruppo_categorie())
        self.bind_all("<Control-a>", lambda e: self.calcola_statistiche_annuali())
        self.bind_all("<Alt-h>", lambda e: self.mostra_analisi_grafici())
        self.bind_all("<Control-o>", lambda e: self.calcolo_mutuo_prestito())
        self.bind_all("<Alt-j>", lambda e: self.export_giorno_forzato())
        self.bind_all("<Alt-k>", lambda e: self.export_month_detail())
        self.bind_all("<Alt-l>", lambda e: self.export_anno_dettagliato())
        self.bind_all("<Control-k>", lambda e: self.open_analisi_categoria())
        self.bind_all("<Control-Shift-K>", lambda e: self.apri_categorie_suggerite())
        self.bind_all("<Control-Shift-T>", lambda e: self.mostra_categorie_popup())
        self.bind_all("<Control-Shift-S>", lambda e: self.apri_cancella_multiplo())
        self.bind_all("<Control-i>", lambda e: self.show_info_app())
        self.bind_all("<Control-m>", lambda e: self.scarica_manuale())
        
        if not os.path.exists(DB_DIR):
            os.makedirs(DB_DIR)
        if not os.path.exists(EXP_DB):
            os.makedirs(EXP_DB)
            
        backup_incrementale(DB_FILE)
        backup_incrementale(SALDO_FILE)
        backup_incrementale(DATI_FILE)
        backup_incrementale(UTENZE_DB)
        backup_incrementale(REGISTRY_FILE)
        
        backup_incrementale(PW_FILE)
        backup_incrementale(MEM_CAT)
        backup_incrementale(CONFIG_FILE)
        
        backup_incrementale(RIMANDA_FILE)
        backup_incrementale(PROMEMORIA_FILE)
        backup_incrementale(SUPERMERCATI_DB)
        backup_incrementale(DEFAULT_API)

        self.aggiorna_titolo_finestra()
        
        self.categoria_bloccata = False
        
        # Suggerimento categorie
        self.suggerimenti_attivi = SMARTCAT

        # Timeout Iconizza
        if ICONIZZA_INATTIVITA:
            self._timeout_inattivita = TIMEOUT_INATTIVITA_MS
            self._timer_inattivita = None
            self._attiva_timer_inattivita()
        
        # Check Movimenti mancanti fine mese    
        if CHECK_MESE:
            self._last_dismiss_date = self._carica_dismiss_fm()
            self.after(8000, self.controlla_ricorrenti_a_fine_mese)  
        
        self.categorie = ["Generica", self.CATEGORIA_RIMOSSA]
        self.categorie_tipi = {"Generica": "Uscita", self.CATEGORIA_RIMOSSA: "Uscita"}
        self.spese = {}
        self.ricorrenze = {}  
        self.modifica_idx = None
        self.stats_refdate = datetime.date.today()
        self.load_db()
        self.carica_memoria_descrizioni()

        # Themi
        if THEMA == "CHIARO":
            style = ttk.Style()
            style.theme_use('default')
 
            COLOR_BACKGROUND = "#FFFFFF"        # Sfondo principale (Bianco Puro)
            COLOR_WIDGET_BG = "#F0F0F0"         # Sfondo widget leggero (Grigio chiaro)
            TEXT_COLOR = "black"                # Testo nero
            COLOR_HIGHLIGHT = "#007ACC"         # Blu Windows/VSCode per la selezione
            COLOR_TEXT = "#333333"              # Testo scuro/nero
            COLOR_HEADER = "black"              # Testo scuro per le intestazioni
            COLOR_RED_SMOOTH = "red"            # Rosso standard
            COLOR_GREEN_SMOOTH = "green"        # Verde standard
            COLOR_HEADER_BG = "#AAAAAA"         # Grigio medio per sfondo header Treeview
            COLOR_BUTTON_BG = "#DDDDDD"         # Grigio chiaro per bottoni standard
            COLOR_BLINK_OFF = "#333333"         # Il colore "spento" √® Bianco
            COLOR_UPDATE = "#FFFFAA"            # Giallo acceso per l'avviso (come richiesto in precedenza)
            COLOR_BLACK = "black"               # Nero 
            COLOR_YELLOW = "yellow"             # Giallo 
            COLOR_WHITE = "white"               # Bianco 
            COLOR_LIGHTGREEN = "lightgreen"     # LightGreen
            COLOR_LIGHTCORAL = "lightcoral"     # LightCoral
            COLOR_KHAKI = "khaki"               # Khaki
            COLOR_TOOLTIP = "#F9F9F9"
            
            self.COLOR_TOPLEVEL = COLOR_WIDGET_BG
            self.TEXT_COLOR = TEXT_COLOR
            self.COLOR_BACKGROUND = COLOR_BACKGROUND
            self.COLOR_WIDGET_BG = COLOR_WIDGET_BG
            self.COLOR_HIGHLIGHT = COLOR_HIGHLIGHT
            self.COLOR_TEXT = COLOR_TEXT
            self.COLOR_HEADER = COLOR_HEADER
            self.COLOR_RED_SMOOTH = COLOR_RED_SMOOTH
            self.COLOR_GREEN_SMOOTH = COLOR_GREEN_SMOOTH
            self.COLOR_HEADER_BG = COLOR_HEADER_BG
            self.COLOR_BUTTON_BG = COLOR_BUTTON_BG
            self.COLOR_BLINK_OFF = COLOR_BLINK_OFF
            self.COLOR_UPDATE = COLOR_UPDATE
            self.COLOR_BLACK = COLOR_BLACK
            self.COLOR_YELLOW = COLOR_YELLOW
            self.COLOR_WHITE = COLOR_WHITE     
            self.COLOR_LIGHTGREEN = COLOR_LIGHTGREEN
            self.COLOR_LIGHTCORAL = COLOR_LIGHTCORAL
            self.COLOR_KHAKI = COLOR_KHAKI
            self.COLOR_TOOLTIP = COLOR_TOOLTIP
            
            try:
                self.option_add('*selectBackground', COLOR_HIGHLIGHT)
                self.option_add('*selectForeground', COLOR_WHITE)
                self.option_add('*Focus.background', COLOR_WIDGET_BG)
                self.option_add('*Focus.relief', 'solid')
                self.option_add('*Focus.borderwidth', 1)
            except Exception:
                pass
                
            self.configure(bg=COLOR_BACKGROUND)                  

            style.configure("TFrame", background=COLOR_WIDGET_BG)
            style.configure("BlackFrame.TFrame", background=COLOR_WIDGET_BG)
            style.configure("TLabelframe", background=COLOR_WIDGET_BG) 
            style.configure("TLabelframe.Label", background=COLOR_WIDGET_BG, foreground=COLOR_HEADER)
            style.configure("RedBold.TLabelframe.Label", foreground=COLOR_RED_SMOOTH, background=COLOR_WIDGET_BG, font=("Arial", 10, "bold"))
            
            style.configure("Treeview", 
                            background=COLOR_WHITE, 
                            foreground=COLOR_TEXT, 
                            rowheight=25,
                            fieldbackground=COLOR_WHITE, 
                            font=("Arial", 10),
                            borderwidth=0)
            style.configure("Treeview.Heading", 
                            background="#F2F2F2",
                            foreground=COLOR_HEADER, 
                            font=('Arial', 10, 'bold'), 
                            relief="flat",
                            borderwidth=1) 
            style.map('Treeview', 
                      foreground=[('selected', COLOR_WHITE)], 
                      background=[('selected', COLOR_HIGHLIGHT)],
                      fieldbackground=[('!disabled', COLOR_WIDGET_BG)]
            )
            style.map('Treeview.Heading', 
                foreground=[('active', COLOR_HIGHLIGHT), ('pressed', COLOR_HIGHLIGHT)], 
                background=[('active', "#EAEAEA"), ('pressed', "#DDDDDD")] 
            )
            style.configure("TNotebook", background=COLOR_WIDGET_BG, borderwidth=0)

            style.configure("TNotebook.Tab", 
                            background=COLOR_BACKGROUND,
                            foreground=COLOR_TEXT,
                            font=('Arial', 10, 'normal'),
                            padding=[10, 5])
            
            style.map("TNotebook.Tab",
                      background=[('selected', COLOR_HIGHLIGHT)], 
                      foreground=[('selected', COLOR_WHITE)],
                      expand=[('active', [1, 1, 1, 0])])

            style.configure("Custom.TRadiobutton", background=COLOR_WIDGET_BG, foreground=TEXT_COLOR, font=('Arial', 10))

            style.configure('Highlight.TCombobox', 
                fieldbackground=COLOR_WIDGET_BG,
                background=COLOR_BUTTON_BG, 
                foreground=COLOR_RED_SMOOTH,
                relief='solid', 
                arrowsize=8, 
                borderwidth=1)

            style.map('Highlight.TCombobox', 
                arrowcolor=[('!disabled', COLOR_RED_SMOOTH)],
                fieldbackground=[
                    ('readonly', COLOR_WIDGET_BG), 
                    ('focus', COLOR_WIDGET_BG), 
                    ('active', COLOR_WIDGET_BG),
                    ('!disabled', COLOR_WIDGET_BG)
                ],
                foreground=[
                    ('readonly', COLOR_RED_SMOOTH), 
                    ('focus', COLOR_RED_SMOOTH), 
                    ('active', COLOR_RED_SMOOTH),
                    ('!disabled', COLOR_RED_SMOOTH)
                ])
            
            style.configure('Border.TCombobox', 
                fieldbackground=COLOR_WHITE, 
                background=COLOR_YELLOW, 
                foreground=COLOR_BLACK, 
                relief='flat',
                arrowsize=8,
                borderwidth=1)
            style.map('Border.TCombobox', 
                arrowcolor=[('!disabled', COLOR_HIGHLIGHT)],
                fieldbackground=[('readonly', COLOR_WHITE), ('!focus', COLOR_WHITE), ('!disabled', COLOR_WHITE)])
                
            style.configure("TLabel", background=COLOR_WIDGET_BG, foreground=COLOR_TEXT) 
            style.configure("Timer.TLabel", foreground=COLOR_TEXT, background=COLOR_UPDATE, font=("Helvetica", 10, "bold"))
            style.configure("Legend.TLabel", background=COLOR_WIDGET_BG, foreground=COLOR_TEXT, font=("Arial", 10), anchor="w")
            style.configure("White.TLabel", foreground=COLOR_TEXT, background=COLOR_WIDGET_BG, font=("Arial", 11))
            style.configure("WhiteSmall.TLabel", foreground=COLOR_TEXT, background=COLOR_WIDGET_BG, font=("Arial", 10))
            style.configure("Verde.TLabel", foreground=COLOR_GREEN_SMOOTH, background=COLOR_WIDGET_BG, font=("Arial", 10, "bold"), padding=5)

            style.configure("Saldo.TLabel", foreground=COLOR_GREEN_SMOOTH, background=COLOR_WIDGET_BG, font=("Arial", 14, "bold"))
            style.map("Saldo.TLabel", background=[('active', COLOR_WIDGET_BG)], foreground=[('active', COLOR_GREEN_SMOOTH)], relief=[('active', 'flat')])
            style.configure("Doc.TLabel", foreground=COLOR_GREEN_SMOOTH, background=COLOR_WIDGET_BG, font=("Arial", 14, "bold"))
            style.map("Doc.TLabel", background=[('active', COLOR_WIDGET_BG)], foreground=[('active', COLOR_GREEN_SMOOTH)], relief=[('active', 'flat')])
            
            style.configure("GSaldo.TLabel", font=("Arial", 10, "bold"), background=COLOR_WIDGET_BG) 
            style.map("GSaldoPositivo.TLabel", foreground=[('active', COLOR_GREEN_SMOOTH), ('!disabled', COLOR_GREEN_SMOOTH)], parent="GSaldo.TLabel")
            style.map("GSaldoNegativo.TLabel", foreground=[('active', COLOR_RED_SMOOTH), ('!disabled', COLOR_RED_SMOOTH)], parent="GSaldo.TLabel")

            style.configure("BlinkAllarme.TLabel", foreground=COLOR_BLINK_OFF, background=COLOR_WIDGET_BG, font=("Arial", 10, "bold"))
            style.map("BlinkAllarme.TLabel", foreground=[('!disabled', COLOR_RED_SMOOTH)], background=[('!disabled', COLOR_WIDGET_BG), ('disabled', COLOR_WIDGET_BG)])

            SPESSORE_SCROLL = 7
            style.configure("Vertical.TScrollbar", 
                background=COLOR_BUTTON_BG, 
                troughcolor=COLOR_BACKGROUND, 
                arrowcolor=COLOR_HEADER, 
                relief="flat", 
                borderwidth=0,
                arrowsize=SPESSORE_SCROLL,
                width=SPESSORE_SCROLL)
            style.configure("Horizontal.TScrollbar", 
                background=COLOR_BUTTON_BG, 
                troughcolor=COLOR_BACKGROUND, 
                arrowcolor=COLOR_HEADER, 
                relief="flat", 
                borderwidth=0,
                arrowsize=SPESSORE_SCROLL,
                width=SPESSORE_SCROLL)
            style.map("Vertical.TScrollbar", background=[('active', '#BBBBBB')])
            style.map("Horizontal.TScrollbar", background=[('active', '#BBBBBB')])

            style.configure("TScale", 
                background=COLOR_WIDGET_BG, 
                foreground=COLOR_HIGHLIGHT,
                troughcolor="#E0E0E0",
                sliderthickness=10,
                troughthickness=2,
                sliderlength=15,
                relief='flat')

            style.map("TScale", 
                background=[('active', COLOR_HIGHLIGHT)],
               troughcolor=[('disabled', COLOR_WIDGET_BG)])

            style.configure("TCheckbutton", background=COLOR_WIDGET_BG, foreground=COLOR_HEADER, font=("Arial", 10))
            style.map("TCheckbutton", background=[('active', COLOR_WIDGET_BG)], foreground=[('active', COLOR_HEADER),('selected', COLOR_HEADER)])

            style.configure("Tooltip.TLabel", background=COLOR_TOOLTIP, foreground=COLOR_BLACK, font=("Arial", 9), borderwidth=1, relief="solid", anchor='w', padding=2)
            
            style.configure("TButton", relief='flat', borderwidth=0, font=("Arial", 9, "bold"), padding=5, background=COLOR_BUTTON_BG, foreground=COLOR_TEXT) 
            style.map("TButton", background=[("active", "#CCCCCC")])

            style.configure("Yellow.TButton", background=COLOR_YELLOW, foreground=COLOR_BLACK, font=("Arial", 8, "bold"), width=2)
            style.map("Yellow.TButton", background=[("active", "#FFE680")])
            style.configure("Giallo.TButton", background=COLOR_YELLOW, foreground=COLOR_BLACK, font=("Arial", 8, "bold"))
            style.map("Giallo.TButton", background=[("active", "#FFE680")])

            style.configure("Verde.TButton", background=COLOR_GREEN_SMOOTH, foreground=COLOR_BLACK, font=("Arial", 8, "bold"))
            style.map("Verde.TButton", background=[('active', '#8AAB6F')], foreground=[('disabled', COLOR_YELLOW)])
            style.configure("Rosso.TButton", background=COLOR_RED_SMOOTH, foreground=COLOR_BLACK, font=("Arial", 8, "bold"))
            style.map("Rosso.TButton", background=[('active', '#C8606B')], foreground=[('disabled', COLOR_YELLOW)])
            style.configure("Arancio.TButton", background="#FFA500", foreground=COLOR_BLACK, font=("Arial", 8, "bold"))
            style.map("Arancio.TButton", background=[("active", "#FFC766")])
            style.configure("Blu.TButton", background=COLOR_HIGHLIGHT, foreground=COLOR_WHITE, font=("Arial", 8, "bold"))
            style.map("Blu.TButton", background=[("active", "#00AADD")])

            style.configure("Low.Blu.TButton", background=COLOR_HIGHLIGHT, foreground=COLOR_WHITE, font=("Arial", 6, "bold"), padding=(4, 1))
            style.map("Low.Blu.TButton", background=[("active", "#00AADD")])

            style.configure("Num.TButton", foreground=COLOR_TEXT, background=COLOR_WIDGET_BG, borderwidth=1, relief="raised", font=("Arial", 8, "bold"), padding=6) 
            style.map("Num.TButton", background=[("active", COLOR_HEADER_BG)]) 
            
            style.configure("GreenOutline.TButton", foreground=COLOR_GREEN_SMOOTH, background=COLOR_WIDGET_BG, borderwidth=1, relief="solid", padding=(5, 1), font=("Arial", 10, "bold")) 
            style.map("GreenOutline.TButton", 
                      background=[("active", "#E6FFE6"), ("pressed", "#CCFFCC")],
                      bordercolor=[("!disabled", COLOR_GREEN_SMOOTH)], 
                      foreground=[("!disabled", COLOR_GREEN_SMOOTH)])

            style.configure("RedOutline.TButton", foreground=COLOR_RED_SMOOTH, background=COLOR_WIDGET_BG, borderwidth=1, relief="solid", padding=(5, 1), font=("Arial", 10, "bold")) 
            style.map("RedOutline.TButton", 
                      background=[("active", "#FFEEEE"), ("pressed", "#FFCCCC")],
                      bordercolor=[("!disabled", COLOR_RED_SMOOTH)], 
                      foreground=[("!disabled", COLOR_RED_SMOOTH)])

            style.configure(
                "Backup.Horizontal.TProgressbar",
                troughcolor=self.COLOR_WIDGET_BG,
                background=self.COLOR_HIGHLIGHT,
                thickness=10
            )
                       
            stili_tabella = [
            ("mensile", "#E6FFE6", "#004C00"),
            ("regolare", "#F0FFF0", "#333333"),
            ("bimestrale", "#FFFFE0", "#CC9900"),
            ("trimestrale", "#FFF0E0", "#FF6600"),
            ("irregolare", "#FFEEEE", "#CC0000"),
            ]
        
            for alias, bg, fg in stili_tabella:
                style.configure(
                    f"Legenda.{alias}.TLabel", 
                    background=bg, 
                    foreground=fg, 
                    font=("Arial", 8, "bold"),
                    padding=3
                )
                
            self.cal_bg = COLOR_WIDGET_BG
            self.cal_fg = COLOR_TEXT
            self.cal_weekend_bg = COLOR_WIDGET_BG  
            self.cal_weekend_fg = COLOR_HIGHLIGHT
            self.cal_weekday_bg = COLOR_WIDGET_BG  
            self.cal_weekday_fg = COLOR_HEADER
            self.cal_select_bg = COLOR_HIGHLIGHT 
            self.cal_select_fg = COLOR_BLACK     
            self.cal_header_bg = COLOR_WIDGET_BG   
            self.cal_header_fg = COLOR_HEADER

        if THEMA == "MATERIAL":
            style = ttk.Style()
            style.theme_use('default')
            
            COLOR_BACKGROUND = "#20232A"           # Grigio Ardesia Scuro / Quasi Nero (Sfondo Principale)
            COLOR_WIDGET_BG = "#2A273F"            # Blu Violaceo Scuro (Sfondo per Widget/Frame)
            TEXT_COLOR = "white"                   # Bianco Puro (Testo Primario)
            COLOR_HIGHLIGHT = "#61AFEF"            # Azzurro Ciano Brillante (Colore di Enfasi/Selezione Attiva)
            COLOR_TEXT = "#ABB2BF"                 # Grigio Chiaro Freddo (Testo Secondario)
            COLOR_HEADER = "#E0E0E0"               # Grigio Molto Chiaro (Titoli/Intestazioni)
            COLOR_RED_SMOOTH = "#E06C75"           # Rosso Salmone Tenue (Avvisi, Negativo/Uscite)
            COLOR_GREEN_SMOOTH = "#98C379"         # Verde Oliva/Salvia (Successo, Positivo/Entrate)
            COLOR_HEADER_BG = "#39355C"            # Viola Scuro Melanzana (Sfondo Intestazioni/Barre Titolo)
            COLOR_BUTTON_BG = "#4B4673"            # Viola Scuro/Indaco (Sfondo Pulsanti)
            COLOR_BLINK_OFF = COLOR_TEXT           # # Grigio Chiaro Freddo (Stato di Non Lampeggio)
            COLOR_UPDATE = "#FFFFAA"               # Giallo Molto Chiaro/Crema (Notifiche di Aggiornamento/Blink)
            COLOR_BLACK = "black"                  # Nero (Interni Combobox)
            COLOR_YELLOW = "yellow"                # Giallo (Pulsante combobox)
            COLOR_WHITE = "white"                  # Bianco (Sfondo combobox)
            COLOR_LIGHTGREEN = "lightgreen"        # LightGreen
            COLOR_LIGHTCORAL = "lightcoral"        # LightCoral
            COLOR_KHAKI = "khaki"                  # Khaki
            COLOR_TOOLTIP = "#4B4673" 
            
            self.COLOR_TOPLEVEL = COLOR_WIDGET_BG
            self.TEXT_COLOR = TEXT_COLOR
            self.COLOR_BACKGROUND = COLOR_BACKGROUND
            self.COLOR_WIDGET_BG = COLOR_WIDGET_BG
            self.COLOR_HIGHLIGHT = COLOR_HIGHLIGHT
            self.COLOR_TEXT = COLOR_TEXT
            self.COLOR_HEADER = COLOR_HEADER
            self.COLOR_RED_SMOOTH = COLOR_RED_SMOOTH
            self.COLOR_GREEN_SMOOTH = COLOR_GREEN_SMOOTH
            self.COLOR_HEADER_BG = COLOR_HEADER_BG
            self.COLOR_BUTTON_BG = COLOR_BUTTON_BG
            self.COLOR_BLINK_OFF = COLOR_BLINK_OFF
            self.COLOR_UPDATE = COLOR_UPDATE
            self.COLOR_BLACK = COLOR_BLACK
            self.COLOR_YELLOW = COLOR_YELLOW
            self.COLOR_WHITE = COLOR_WHITE
            self.COLOR_LIGHTGREEN = COLOR_LIGHTGREEN
            self.COLOR_LIGHTCORAL = COLOR_LIGHTCORAL
            self.COLOR_KHAKI = COLOR_KHAKI
            self.COLOR_TOOLTIP = COLOR_TOOLTIP
            
            try:
                self.option_add('*selectBackground', COLOR_HIGHLIGHT)
                self.option_add('*selectForeground', COLOR_WHITE)
                self.option_add('*Focus.background', COLOR_WIDGET_BG)
                self.option_add('*Focus.relief', 'solid')
                self.option_add('*Focus.borderwidth', 1)
                self.option_add('*TCombobox*Listbox.background', COLOR_WIDGET_BG)
                self.option_add('*TCombobox*Listbox.foreground', COLOR_WHITE)
                self.option_add('*TCombobox*Listbox.selectBackground', COLOR_HIGHLIGHT)
                self.option_add('*TCombobox*Listbox.selectForeground', COLOR_BLACK)
                self.option_add('*TCombobox*Listbox.font', ("Arial", 10))
                self.option_add('*TCombobox*Listbox.borderWidth', 0)  
            except Exception:
                pass
                
            self.configure(bg=COLOR_BACKGROUND)
            
            style.configure("TFrame", background=COLOR_WIDGET_BG)
            style.configure("BlackFrame.TFrame", background=COLOR_WIDGET_BG)
            style.configure("TLabelframe", background=COLOR_WIDGET_BG) 
            style.configure("TLabelframe.Label", background=COLOR_WIDGET_BG, foreground=COLOR_HEADER)
            style.configure("RedBold.TLabelframe.Label", foreground=COLOR_RED_SMOOTH, background=COLOR_WIDGET_BG, font=("Arial", 10, "bold"))

            style.configure("Treeview", 
                background=COLOR_WIDGET_BG, 
                foreground=COLOR_TEXT, 
                rowheight=25,
                fieldbackground=COLOR_WIDGET_BG, 
                font=("Arial", 10),
                )
            style.configure("Treeview.Heading", 
                background=COLOR_HEADER_BG, 
                foreground=COLOR_HEADER, 
                font=('Arial', 10, 'bold'), 
                relief="flat")
            style.map('Treeview', 
                background=[('selected', COLOR_HIGHLIGHT)], 
                foreground=[('selected', COLOR_WHITE)],
                fieldbackground=[('!disabled', COLOR_WIDGET_BG)]
            )
            style.map('Treeview.Heading', 
                 background=[('active', COLOR_HIGHLIGHT), ('pressed', COLOR_HIGHLIGHT)],
                 foreground=[('active', COLOR_BLACK), ('pressed', COLOR_BLACK)])
        
            style.configure("TNotebook", background=COLOR_WIDGET_BG, borderwidth=0)

            style.configure("TNotebook.Tab", 
                            background=COLOR_BUTTON_BG,
                            foreground=COLOR_TEXT,
                            font=('Arial', 10, 'normal'),
                            padding=[10, 5])
            
            style.map("TNotebook.Tab",
                      background=[('selected', COLOR_HIGHLIGHT)], 
                      foreground=[('selected', COLOR_WHITE)],
                      expand=[('active', [1, 1, 1, 0])])

            style.configure("Custom.TRadiobutton", background=COLOR_WIDGET_BG, foreground=TEXT_COLOR, font=('Arial', 10))
            
            style.configure('Highlight.TCombobox', 
                fieldbackground=COLOR_WIDGET_BG,
                background=COLOR_BUTTON_BG,
                foreground=COLOR_RED_SMOOTH,
                relief='solid',
                arrowsize=8,
                borderwidth=1)

            style.map('Highlight.TCombobox', 
                arrowcolor=[('!disabled', COLOR_RED_SMOOTH)],
                fieldbackground=[
                    ('readonly', COLOR_WIDGET_BG), 
                    ('focus', COLOR_WIDGET_BG), 
                    ('active', COLOR_WIDGET_BG),
                    ('!disabled', COLOR_WIDGET_BG)
                ],
                foreground=[
                    ('readonly', COLOR_RED_SMOOTH), 
                    ('focus', COLOR_RED_SMOOTH), 
                    ('active', COLOR_RED_SMOOTH),
                    ('!disabled', COLOR_RED_SMOOTH)
                ])
          
            style.configure('Border.TCombobox', 
                fieldbackground=COLOR_WIDGET_BG,
                background=COLOR_BUTTON_BG,
                foreground=COLOR_WHITE,
                relief='flat',
                arrowsize=8,
                borderwidth=1)

            style.map('Border.TCombobox', 
                arrowcolor=[('!disabled', COLOR_HIGHLIGHT)],
                fieldbackground=[
                    ('readonly', COLOR_WIDGET_BG), 
                    ('focus', COLOR_WIDGET_BG), 
                    ('active', COLOR_WIDGET_BG),
                    ('!disabled', COLOR_WIDGET_BG)
                ],
                foreground=[
                    ('readonly', COLOR_WHITE), 
                    ('focus', COLOR_WHITE), 
                    ('!disabled', COLOR_WHITE)
                ])

            style.configure("TEntry", 
                            fieldbackground=COLOR_WIDGET_BG, 
                            foreground=COLOR_WHITE, 
                            insertcolor=COLOR_WHITE,
                            borderwidth=1, 
                            relief="flat")
            
            style.map("TEntry", 
                      fieldbackground=[('focus', COLOR_WIDGET_BG), ('readonly', COLOR_WIDGET_BG)],
                      foreground=[('disabled', COLOR_TEXT)])
            
            style.configure("TLabel", background=COLOR_WIDGET_BG, foreground=COLOR_TEXT) 
        
            style.configure("Timer.TLabel", foreground=COLOR_TEXT, background=self.COLOR_UPDATE, font=("Helvetica", 10, "bold"))
            style.configure("Legend.TLabel", background=COLOR_WIDGET_BG, foreground=COLOR_TEXT, font=("Arial", 10), anchor="w")
            style.configure("White.TLabel", foreground=COLOR_HEADER, background=COLOR_WIDGET_BG, font=("Arial", 11))
            style.configure("WhiteSmall.TLabel", foreground=COLOR_HEADER, background=COLOR_WIDGET_BG, font=("Arial", 10))
            style.configure("Verde.TLabel", foreground=COLOR_GREEN_SMOOTH, background=COLOR_WIDGET_BG, font=("Arial", 10, "bold"), padding=5)

            style.configure("Saldo.TLabel", foreground=COLOR_GREEN_SMOOTH, background=COLOR_WIDGET_BG, font=("Arial", 14, "bold"))
            style.map("Saldo.TLabel", background=[('active', COLOR_WIDGET_BG)], foreground=[('active', COLOR_GREEN_SMOOTH)], relief=[('active', 'flat')])
            style.configure("Doc.TLabel", foreground=COLOR_GREEN_SMOOTH, background=COLOR_WIDGET_BG, font=("Arial", 14, "bold"))
            style.map("Doc.TLabel", background=[('active', COLOR_WIDGET_BG)], foreground=[('active', COLOR_GREEN_SMOOTH)], relief=[('active', 'flat')])
        
            style.configure("GSaldo.TLabel", font=("Arial", 10, "bold"), background=COLOR_WIDGET_BG) 
            style.map("GSaldoPositivo.TLabel", foreground=[('active', COLOR_GREEN_SMOOTH), ('!disabled', COLOR_GREEN_SMOOTH)], parent="GSaldo.TLabel")
            style.map("GSaldoNegativo.TLabel", foreground=[('active', COLOR_RED_SMOOTH), ('!disabled', COLOR_RED_SMOOTH)], parent="GSaldo.TLabel")

            style.configure("BlinkAllarme.TLabel", foreground=COLOR_BLINK_OFF, background=COLOR_WIDGET_BG, font=("Arial", 10, "bold"))
            style.map("BlinkAllarme.TLabel", foreground=[('!disabled', COLOR_RED_SMOOTH)], background=[('!disabled', COLOR_WIDGET_BG), ('disabled', COLOR_WIDGET_BG)])
            
            SPESSORE_SCROLL = 7
            style.configure("Vertical.TScrollbar", 
                background=COLOR_BUTTON_BG, 
                troughcolor=COLOR_BACKGROUND, 
                arrowcolor=COLOR_HEADER, 
                relief="flat", 
                borderwidth=0,
                arrowsize=SPESSORE_SCROLL,
                width=SPESSORE_SCROLL)
            style.configure("Horizontal.TScrollbar", 
                background=COLOR_BUTTON_BG, 
                troughcolor=COLOR_BACKGROUND, 
                arrowcolor=COLOR_HEADER, 
                relief="flat", 
                borderwidth=0,
                arrowsize=SPESSORE_SCROLL,
                width=SPESSORE_SCROLL)
            style.map("Vertical.TScrollbar", background=[('active', COLOR_HIGHLIGHT)])
            style.map("Horizontal.TScrollbar", background=[('active', COLOR_HIGHLIGHT)])
            
            style.configure("TScale", 
                background=COLOR_WIDGET_BG, 
                foreground=COLOR_HIGHLIGHT,
                troughcolor="#E0E0E0",
                sliderthickness=10,
                troughthickness=2,
                sliderlength=15,
                relief='flat')

            style.map("TScale", 
                background=[('active', COLOR_HIGHLIGHT)],
               troughcolor=[('disabled', COLOR_WIDGET_BG)])
            
            style.configure("TCheckbutton", background=COLOR_WIDGET_BG, foreground=COLOR_HEADER, font=("Arial", 10))
            style.map("TCheckbutton", background=[('active', COLOR_WIDGET_BG)], foreground=[('active', COLOR_HEADER),('selected', COLOR_HEADER)])
            
            style.configure("Tooltip.TLabel", background=COLOR_TOOLTIP, foreground="#FFFFFF", font=("Arial", 9), borderwidth=1, relief="solid", anchor='w', padding=2)
            
            style.configure("TButton", relief='flat', borderwidth=0, font=("Arial", 9, "bold"), padding=5, background=COLOR_BUTTON_BG, foreground=COLOR_HEADER) 
            style.map("TButton", background=[("active", "#5E598F")]) 
            
            style.configure("Yellow.TButton", background="#E5C07B", foreground=COLOR_BLACK, font=("Arial", 8, "bold"), width=2)
            style.map("Yellow.TButton", background=[("active", "#CFB076")])
            style.configure("Giallo.TButton", background="#E5C07B", foreground=COLOR_BLACK, font=("Arial", 8, "bold"))
            style.map("Giallo.TButton", background=[("active", "#CFB076")])
            style.configure("Verde.TButton", background=COLOR_GREEN_SMOOTH, foreground=COLOR_BLACK, font=("Arial", 8, "bold"))
            style.map("Verde.TButton", background=[('active', '#8AAB6F')], foreground=[('disabled', COLOR_YELLOW)])
            style.configure("Rosso.TButton", background=COLOR_RED_SMOOTH, foreground=COLOR_BLACK, font=("Arial", 8, "bold"))
            style.map("Rosso.TButton", background=[('active', '#C8606B')], foreground=[('disabled', COLOR_YELLOW)])
            style.configure("Arancio.TButton", background="#D19A66", foreground=COLOR_BLACK, font=("Arial", 8, "bold"))
            style.map("Arancio.TButton", background=[("active", "#C18B5C")])
            style.configure("Blu.TButton", background=COLOR_HIGHLIGHT, foreground=COLOR_BLACK, font=("Arial", 8, "bold"))
            style.map("Blu.TButton", background=[("active", "#509FE2")])
            style.configure("Num.TButton", foreground=COLOR_HEADER, background=COLOR_WIDGET_BG, borderwidth=1, relief="raised", font=("Arial", 8, "bold"), padding=6) 
            style.map("Num.TButton", background=[("active", COLOR_HEADER_BG)]) 
            
            style.configure("Low.Blu.TButton", background=COLOR_HIGHLIGHT, foreground=COLOR_BLACK, font=("Arial", 8, "bold"), padding=(5, 2))
            style.map("Low.Blu.TButton", background=[("active", "#509FE2")])
            
            style.configure("GreenOutline.TButton", 
                            foreground=COLOR_GREEN_SMOOTH, 
                            background=COLOR_WIDGET_BG, 
                            borderwidth=1, 
                            relief="solid", 
                            padding=(5, 1), 
                            font=("Arial", 10, "bold")) 
            style.map("GreenOutline.TButton", 
                      background=[("active", "#1B3D1B"), ("pressed", "#142E14")], 
                      bordercolor=[("!disabled", COLOR_GREEN_SMOOTH)], 
                      foreground=[("!disabled", COLOR_GREEN_SMOOTH)])

            style.configure("RedOutline.TButton", 
                            foreground=COLOR_RED_SMOOTH, 
                            background=COLOR_WIDGET_BG, 
                            borderwidth=1, 
                            relief="solid", 
                            padding=(5, 1), 
                            font=("Arial", 10, "bold")) 
            style.map("RedOutline.TButton", 
                      background=[("active", "#3D1B1B"), ("pressed", "#2E1414")], 
                      bordercolor=[("!disabled", COLOR_RED_SMOOTH)], 
                      foreground=[("!disabled", COLOR_RED_SMOOTH)])
                      
            style.configure(
                "Backup.Horizontal.TProgressbar",
                troughcolor=self.COLOR_WIDGET_BG,
                background=self.COLOR_HIGHLIGHT,
                thickness=10
            )

            stili_tabella = [
            ("mensile", "#E6FFE6", "#004C00"),
            ("regolare", "#F0FFF0", "#333333"),
            ("bimestrale", "#FFFFE0", "#CC9900"),
            ("trimestrale", "#FFF0E0", "#FF6600"),
            ("irregolare", "#FFEEEE", "#CC0000"),
            ]
        
            for alias, bg, fg in stili_tabella:
                style.configure(
                    f"Legenda.{alias}.TLabel", 
                    background=bg, 
                    foreground=fg, 
                    font=("Arial", 8, "bold"),
                    padding=3
                )
 
            self.cal_bg = COLOR_WIDGET_BG
            self.cal_fg = COLOR_TEXT
            self.cal_weekend_bg = COLOR_WIDGET_BG  
            self.cal_weekend_fg = COLOR_HIGHLIGHT
            self.cal_weekday_bg = COLOR_WIDGET_BG  
            self.cal_weekday_fg = COLOR_HEADER
            self.cal_select_bg = COLOR_HIGHLIGHT 
            self.cal_select_fg = COLOR_BLACK     
            self.cal_header_bg = COLOR_WIDGET_BG   
            self.cal_header_fg = COLOR_HEADER
            
        main_frame = ttk.Frame(self, style="BlackFrame.TFrame")
        main_frame.pack(fill=tk.BOTH, expand=True, padx=8, pady=4)
        
        cal_frame = ttk.Frame(main_frame, style="BlackFrame.TFrame")
        cal_frame.pack(side=tk.LEFT, fill=tk.Y, padx=(0, 15))
        today = datetime.date.today()
        
        self.cal = Calendar(
            cal_frame,
            selectmode="day",
            year=today.year,
            month=today.month,
            day=today.day,
            locale="it_IT",
            date_pattern="dd-mm-yyyy",
            font=("Arial", 10),
            cursor="hand2",
            background=self.cal_header_bg,
            foreground=self.cal_header_fg,
            headersbackground=self.cal_header_bg,
            headersforeground=self.cal_header_fg,
            normalbackground=self.cal_bg,
            normalforeground=self.cal_fg,
            weekendbackground=self.cal_weekend_bg,
            weekendforeground=self.cal_weekend_fg,
            selectbackground=self.cal_select_bg,
            selectforeground=self.cal_select_fg,
            bordercolor=self.cal_bg,            
            tooltipdelay=1500,
            tooltipbackground=COLOR_TOOLTIP, 
            tooltipforeground=self.TEXT_COLOR,
            tooltipalpha=1.0,
            showothermonthdays=False
        )
        self.cal.pack(fill="both", expand=True)
        self.cal.configure(borderwidth=0)

        # Abilita Tooltips su Calendario (Sperimentale)
        if CAL_TOOLTIPS:
            try:
                self.cal.tooltip_wrapper.configure(
                    background=self.COLOR_TOOLTIP,
                    borderwidth=1,
                    font=("Courier new", 9),
                    relief="solid"
                )
            except Exception as e:
                print(f"Tooltip non disponibile: {e}")
        else:
            self.cal.configure(tooltipdelay=999999)
        
        legenda = ttk.Frame(cal_frame, style="BlackFrame.TFrame")
        legenda.pack(pady=(4, 0))
        btn_oggi = ttk.Button(legenda, text="‚Ü∫ Oggi", command=self.goto_today, width=8, style="Giallo.TButton")
        btn_oggi.pack(side="left", padx=3)

        ttk.Label(legenda, text="Entrata", background="lightgreen", foreground="black", width=8, anchor="center", font=("Arial", 10)).pack(side="left", padx=3)
        ttk.Label(legenda, text="Uscita", background="lightcoral", foreground="black", width=8, anchor="center", font=("Arial", 10)).pack(side="left", padx=3)
        ttk.Label(legenda, text="Entrata+Uscita", background="khaki", foreground="black", width=14, anchor="center", font=("Arial", 10)).pack(side="left", padx=3)
        ttk.Label(legenda, text="Weekend", background=self.cal_weekend_bg, foreground=self.cal_weekend_fg, font=("Arial", 10), width=10, anchor="center").pack(side="left", padx=3)
        ttk.Label(legenda, text="Sel.", background="dodgerblue", foreground="white", font=("Arial", 10), width=6, anchor="center").pack(side="left", padx=3)

        oggi = datetime.date.today()
        self.cal.calevent_create(oggi, "Oggi", "today")
        self.cal.tag_config("today", background="gold", foreground="black")

        try:
           self.cal._header_month.config(font=("Arial", 14, "bold"))
           self.cal._header_year.config(font=("Arial", 14, "bold"))
        except:
           pass
      
        self.cal.pack(fill="x", expand=True, padx=10, pady=5)
        self.cal.tag_config("verde", background=self.COLOR_LIGHTGREEN, foreground=self.COLOR_BLACK)
        self.cal.tag_config("rosso", background=self.COLOR_LIGHTCORAL, foreground=self.COLOR_BLACK)
        self.cal.tag_config("misto", background=self.COLOR_KHAKI, foreground=self.COLOR_BLACK)
        self.cal.tag_config("today", background=self.COLOR_YELLOW, foreground=self.COLOR_BLACK)

        self.cal.bind("<<CalendarSelected>>", self.on_calendar_change)
        self.cal.bind("<<CalendarMonthChanged>>", self.on_month_changed)
        self.colora_giorni_spese()
         
        self.estratto_month_var = tk.StringVar(value=f"{today.month:02d}")
        self.estratto_year_var = tk.StringVar(value=str(today.year))

        current_year = today.year
        self.years = [str(y) for y in range(current_year - 15, current_year + 11)]
        self.months = [
            "01 - Gennaio", "02 - Febbraio", "03 - Marzo", "04 - Aprile", "05 - Maggio", "06 - Giugno",
            "07 - Luglio", "08 - Agosto", "09 - Settembre", "10 - Ottobre", "11 - Novembre", "12 - Dicembre"
        ]

        riepilogo_frame = ttk.Frame(cal_frame)
        riepilogo_frame.pack(fill=tk.X, padx=2, pady=(8, 8))

        self.totalizzatore_mese_frame = ttk.LabelFrame(riepilogo_frame, text="‚öôÔ∏è Riepilogo Mese Attuale", style="RedBold.TLabelframe")
        self.totalizzatore_mese_frame.pack(side="left", fill="both", expand=True, padx=(0, 4))
        self.totalizzatore_mese_frame.grid_columnconfigure(1, weight=1)

        ttk.Label(self.totalizzatore_mese_frame, text="Totale Entrate mese:", foreground="green", font=("Arial", 10, "bold")).grid(row=0, column=0, sticky="w", padx=(6,0), pady=(2, 0))
        self.totalizzatore_mese_entrate_label = ttk.Label(self.totalizzatore_mese_frame, text="0.00 ‚Ç¨", foreground="green", font=("Arial", 10, "bold"))
        self.totalizzatore_mese_entrate_label.grid(row=0, column=1, sticky="e", padx=(0,6), pady=(2, 0))
        
        ttk.Label(self.totalizzatore_mese_frame, text="Totale Uscite mese:", foreground="red", font=("Arial", 10, "bold")).grid(row=1, column=0, sticky="w", padx=(6,0), pady=(2, 0))
        self.totalizzatore_mese_uscite_label = ttk.Label(self.totalizzatore_mese_frame, text="0.00 ‚Ç¨", foreground="red", font=("Arial", 10, "bold"))
        self.totalizzatore_mese_uscite_label.grid(row=1, column=1, sticky="e", padx=(0,6), pady=(2, 0))

        ttk.Label(self.totalizzatore_mese_frame, text="Differenza mese:", foreground="dodgerblue", font=("Arial", 10, "bold")).grid(row=2, column=0, sticky="w", padx=(6,0), pady=(2, 4))
        self.totalizzatore_mese_diff_label = ttk.Label(self.totalizzatore_mese_frame, text="0.00 ‚Ç¨", foreground="dodgerblue", font=("Arial", 10, "bold"))
        self.totalizzatore_mese_diff_label.grid(row=2, column=1, sticky="e", padx=(0,6), pady=(2, 4))

        self.totalizzatore_frame = ttk.LabelFrame(riepilogo_frame, text="‚öôÔ∏è Riepilogo Anno Attuale", style="RedBold.TLabelframe")
        self.totalizzatore_frame.pack(side="left", fill="both", expand=True, padx=(4, 0))
        self.totalizzatore_frame.grid_columnconfigure(1, weight=1)

        ttk.Label(self.totalizzatore_frame, text="Totale Entrate:", foreground="green", font=("Arial", 10, "bold")).grid(row=0, column=0, sticky="w", padx=(6,0), pady=(2, 0))
        self.totalizzatore_entrate_label = ttk.Label(self.totalizzatore_frame, text="0.00 ‚Ç¨", foreground="green", font=("Arial", 10, "bold"))
        self.totalizzatore_entrate_label.grid(row=0, column=1, sticky="e", padx=(0,6), pady=(2, 0))

        ttk.Label(self.totalizzatore_frame, text="Totale Uscite:", foreground="red", font=("Arial", 10, "bold")).grid(row=1, column=0, sticky="w", padx=(6,0), pady=(2, 0))
        self.totalizzatore_uscite_label = ttk.Label(self.totalizzatore_frame, text="0.00 ‚Ç¨", foreground="red", font=("Arial", 10, "bold"))
        self.totalizzatore_uscite_label.grid(row=1, column=1, sticky="e", padx=(0,6), pady=(2, 0))
        
        ttk.Label(self.totalizzatore_frame, text="Differenza:", foreground="dodgerblue", font=("Arial", 10, "bold")).grid(row=2, column=0, sticky="w", padx=(6,0), pady=(2, 4))
        self.totalizzatore_diff_label = ttk.Label(self.totalizzatore_frame, text="0.00 ‚Ç¨", foreground="dodgerblue", font=("Arial", 10, "bold"))
        self.totalizzatore_diff_label.grid(row=2, column=1, sticky="e", padx=(0,6), pady=(2, 4))

        self.spese_mese_frame = ttk.LabelFrame(cal_frame, text="Analisi Mese Attuale", style="RedBold.TLabelframe")
        self.spese_mese_frame.pack(fill=tk.BOTH, expand=True, padx=2, pady=(2,4))

        treeview_container = ttk.Frame(self.spese_mese_frame)
        treeview_container.pack(fill=tk.BOTH, expand=True, padx=2, pady=2)
        
        vsb = ttk.Scrollbar(treeview_container, orient="vertical")
        
        self.spese_mese_tree = ttk.Treeview(
            treeview_container, 
            columns=("Data", "Categoria", "Descrizione", "Importo", "Tipo"),
            show="headings",
            height=30,
            yscrollcommand=vsb.set 
        )
        
        vsb.config(command=self.spese_mese_tree.yview)

        vsb.pack(side="right", fill="y")
        self.spese_mese_tree.pack(side="left", fill=tk.BOTH, expand=True) 
        
        self.spese_mese_tree.bind("<Double-1>", self.on_spese_mese_tree_double_click) 
        
        self.spese_mese_tree.heading("Data", text="Data")
        self.spese_mese_tree.heading("Categoria", text="Categoria")
        self.spese_mese_tree.heading("Descrizione", text="Descrizione")
        self.spese_mese_tree.heading("Importo", text="Importo (‚Ç¨)")
        self.spese_mese_tree.heading("Tipo", text="Tipo")
        
        self.spese_mese_tree.column("Data", width=80, anchor="center")
        self.spese_mese_tree.column("Categoria", width=120, anchor="center")
        self.spese_mese_tree.column("Descrizione", width=100, anchor="center")
        self.spese_mese_tree.column("Importo", width=82, anchor="e")
        self.spese_mese_tree.column("Tipo", width=50, anchor="center")
        
        self.spese_mese_tree.tag_configure('entrata', foreground='green')
        self.spese_mese_tree.tag_configure('uscita', foreground='red')
        
        for col in self.spese_mese_tree["columns"]:
            self.spese_mese_tree.heading(col, command=lambda _col=col: self.treeview_sort_column(self.spese_mese_tree, _col, False))
            
        right_frame = ttk.Frame(main_frame)
        right_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        stat_frame = ttk.LabelFrame(right_frame, text="‚öôÔ∏è Riepilogo Avanzato", style="RedBold.TLabelframe")
        stat_frame.pack(fill=tk.BOTH, expand=True, padx=2, pady=(8, 8))
        stat_frame.rowconfigure(3, weight=1) 
        stat_frame.columnconfigure(0, weight=1)
        self.stats_frame_ref = stat_frame 
        self.bind("<Escape>", lambda e: self.mostra_treeview_statistiche() if self.stats_view_mode.get() != "tabella" else None)
        self.stats_mode = tk.StringVar(value="giorno")
        
        mode_frame = ttk.Frame(stat_frame)
        mode_frame.grid(row=0, column=0, sticky="ew", padx=6, pady=(4, 0))
        
        self.stats_mode = tk.StringVar(value="giorno")
        self.STATO_CORRENTE = 0
        self.STATI_VISTA = ["tabella", "grafico", "grafico_mensile", "grafico_saldo"]
        self.LABEL_PROSSIMO_STATO = [
            "üìä",
            "üìà",
            "‚öñÔ∏è",
            "üìã"
        ]
        label_iniziale = self.LABEL_PROSSIMO_STATO[ (self.STATO_CORRENTE + 1) % len(self.STATI_VISTA) ]
        
        self.btn_ciclico = ttk.Button(mode_frame, text=label_iniziale, command=self.cicla_visualizzazione_statistiche, width=2, style="Blu.TButton")
        self.btn_ciclico.pack(side=tk.LEFT, padx=(5, 2)) 
        self.bind("<Right>", lambda e: self.cicla_visualizzazione_statistiche())
        self.bind("<Left>", lambda e: self.cicla_indietro())
        
        self.btn_analisi = ttk.Button(mode_frame, text="üîç", command=lambda: self.mostra_analisi_grafici(), width=2, style="Blu.TButton")
        self.btn_analisi.pack(side=tk.LEFT, padx=1) 
        ttk.Button(mode_frame, text="?", command=lambda: self.mostra_help(), width=2, style="Yellow.TButton").pack(side=tk.LEFT, padx=(1, 5))
        
        self.btn_giorno = ttk.Button(mode_frame, text="üìÖ Giorno", command=lambda: self.set_stats_mode("giorno"), width=9, style="Blu.TButton")
        self.btn_giorno.pack(side=tk.LEFT, padx=1)
        self.btn_mese = ttk.Button(mode_frame, text="üìÖ Mese", command=lambda: self.set_stats_mode("mese"), width=9, style="Blu.TButton")
        self.btn_mese.pack(side=tk.LEFT, padx=1)
        self.btn_anno = ttk.Button(mode_frame, text="üìÖ Anno", command=lambda: self.set_stats_mode("anno"), width=9, style="Blu.TButton")
        self.btn_anno.pack(side=tk.LEFT, padx=1)
        self.btn_totali = ttk.Button(mode_frame, text="üìÖ Totali", command=lambda: self.set_stats_mode("totali"), width=9, style="Blu.TButton")
        self.btn_totali.pack(side=tk.LEFT, padx=1)
        
        btn_iconizza = ttk.Label(
            mode_frame,
            text="‚ûñ",
            cursor="hand2",
            style="Saldo.TLabel"
        )
        btn_iconizza.bind('<Button-1>', lambda e: self.iconify())        
        btn_iconizza.pack(side="right", anchor="e", padx=(0, 5))
        
        lbl_saldo_tot = ttk.Label(mode_frame, text="üí∞", style="Saldo.TLabel")
        lbl_saldo_tot.pack(side="right", anchor="e", padx=5)
        lbl_saldo_tot.bind("<Button-1>", lambda e: self.open_saldo_conto())
        lbl_saldo_tot.bind("<Enter>", lambda e: self.show_tooltip_saldo(e))
        lbl_saldo_tot.bind("<Leave>", self.hide_tooltip_saldo)
        
        self.btn_banca_icon = ttk.Button(
            mode_frame, 
            text="üè¶", 
            command=lambda: self.chiama_banca(), 
            cursor="hand2",
            style="Doc.TLabel"
        )
        self.btn_banca_icon.pack(side="right", anchor="e", padx=(0, 5)) 
        
        btn_spesa_super_icon = ttk.Label(
            mode_frame,
            text="üõí",
            cursor="hand2",
            style="Saldo.TLabel"
        )
        btn_spesa_super_icon.bind('<Button-1>', lambda e: self.spesa_supermercato())
        btn_spesa_super_icon.pack(side="right", anchor="e", padx=(0, 5))
        
        self.btn_documenti_icona = ttk.Button(
            mode_frame, 
            text="üìÅ", 
            command=lambda: self.gestisci_archivi_pdf(), 
            cursor="hand2",
            style="Doc.TLabel"
        )
        self.btn_documenti_icona.pack(side="right", anchor="e", padx=(0, 5)) 
        
        self.btn_controlla_ricorrenze = ttk.Button(
            mode_frame, 
            text="üîç", 
            command=lambda: self.controlla_ricorrenti_manual(), 
            cursor="hand2",
            style="Doc.TLabel"
        )
        self.btn_controlla_ricorrenze.pack(side="right", anchor="e", padx=(0, 5)) 
        
        self.btn_qr_generator = ttk.Button(
            mode_frame, 
            text="‚è∞", 
            command=lambda: self.launch_qr_svg_generator(), 
            cursor="hand2",
            style="Doc.TLabel"
        )
        self.btn_qr_generator.pack(side="right", anchor="e", padx=(0, 5))
        
        self.btn_promemoria = ttk.Button(
            mode_frame, 
            text="üìå", 
            command=lambda: self.gestisci_promemoria(), 
            cursor="hand2",
            style="Doc.TLabel"
        )
        self.btn_promemoria.pack(side="right", anchor="e", padx=(0, 5))
        
        self.stats_label = ttk.Label(stat_frame, text="")
        self.stats_label.grid(row=1, column=0, sticky="w", padx=6, pady=(2, 0))
        
        totali_row = ttk.Frame(stat_frame)
        totali_row.grid(row=2, column=0, sticky="ew", padx=6, pady=(2, 0))
        self.totali_label = ttk.Label(totali_row, text="", font=("Arial", 11))
        
        self.totali_label.pack(side=tk.LEFT)
        self.considera_ricorrenze_var = tk.BooleanVar(value=True)
        
        chk_container_frame = ttk.Frame(totali_row)
        chk_container_frame.pack(side=tk.RIGHT, padx=12)
        
        # Pulsante Carosello
        if CAROSELLO:
            self.var_carosello_enabled = tk.BooleanVar(self, value=True)
            self.btn_ciclico_carosello = ttk.Checkbutton(
                chk_container_frame,
                text="üîÑ",
                variable=self.var_carosello_enabled,
                command=self.toggle_carosello
            )
            self.btn_ciclico_carosello.pack(side=tk.LEFT, padx=0) 
        
        self.chk_ricorrenze = ttk.Checkbutton(
            chk_container_frame,
            text="Includi movimenti futuri nei totali",
            variable=self.considera_ricorrenze_var,
            command=self.refresh_gui
        )
        self.chk_ricorrenze.pack(side=tk.LEFT, padx=0) 
        self.filtri_temporali = [self.btn_giorno, self.btn_mese, self.btn_anno, self.btn_totali, self.chk_ricorrenze]
        
        table_container = ttk.Frame(stat_frame)
        table_container.grid(row=3, column=0, sticky="nsew", padx=4, pady=4)
        self.vsb_stats = ttk.Scrollbar(table_container, orient="vertical", style="Vertical.TScrollbar")
        self.vsb_stats.pack(side=tk.RIGHT, fill=tk.Y)
        
        self.stats_table = ttk.Treeview(
            table_container, 
            columns=("A", "B", "C", "D", "E", "F"), 
            show="headings",
            yscrollcommand=self.vsb_stats.set
        )
        self.stats_table.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        self.vsb_stats.config(command=self.stats_table.yview)
        self.stats_text_area = tk.Text(stat_frame, wrap=tk.WORD, state=tk.DISABLED, bg="#F0F0F0")
        
        headers = {
            "A": "Data",
            "B": "Categoria",
            "C": "Descrizione",
            "D": "Importo (‚Ç¨)",
            "E": "Tipo",
            "F": "Modifica"
        }
        for col in ("A", "B", "C", "D", "E", "F"):
            self.stats_table.heading(col, text=headers[col], command=lambda _col=col: self.treeview_sort_column(self.stats_table, _col, False))
            
        self.stats_table.column("A", width=100, anchor="center")
        self.stats_table.column("B", width=150, anchor="center")
        self.stats_table.column("C", width=250, anchor="w")
        self.stats_table.column("D", width=100, anchor="e")
        self.stats_table.column("E", width=80, anchor="center")
        self.stats_table.column("F", width=60, anchor="center")
        
        self.set_stats_mode("giorno")
        self.stats_table.tag_configure("uscita", foreground="red")
        self.stats_table.tag_configure("entrata", foreground="green")
        
        self.stats_table.bind("<Double-1>", self.on_stats_table_double_click)
        self.stats_table.bind("<ButtonRelease-1>", self.on_table_click)
        self.stats_table.bind("<Button-3>", self.on_stats_table_right_click)

        form_frame = ttk.LabelFrame(right_frame, text="‚öôÔ∏è Registra o Modifica Movimento", style="RedBold.TLabelframe")
        form_frame.pack(fill=tk.X, padx=2, pady=(8, 8))
        form_frame.grid_columnconfigure(1, weight=1)

        row = 0
        
        self.label_data_spesa = ttk.Label(
            form_frame, 
            text="üìÖ Data Movimento:", 
            font=("Arial", 10, "bold"),
            style="BlinkAllarme.TLabel" 
        )
        self.label_data_spesa.grid(row=row, column=0, sticky="e", padx=5, pady=5)

        self.data_spesa_var = tk.StringVar(value=today.strftime("%d-%m-%Y"))
        
        data_frame = ttk.Frame(form_frame)
        data_frame.grid(row=row, column=1, columnspan=2, sticky="w")
        
        self.data_spesa_entry = ttk.Entry(
            data_frame,
            width=15,
            font=("Arial", 10, "bold"),
            textvariable=self.data_spesa_var
        )
        self.data_spesa_entry.pack(side="left")

        self.btn_cal_data_spesa = ttk.Button(
            data_frame,
            text="üìÖ",
            width=2,
            command=lambda: self.mostra_calendario_popup(self.data_spesa_entry, self.data_spesa_var),
            style="Yellow.TButton"
        )
             
        self.btn_cal_data_spesa.pack(side="left", padx=4)

        self.btn_reset_data_spesa = ttk.Button(
            data_frame,
            text="‚Ü∫",
            command=self.reset_data_spesa,
            style="Yellow.TButton"
        )
        self.btn_reset_data_spesa.pack(side="left", padx=4)

        self.blocca_data_var = tk.BooleanVar(value=False)
        self.checkbox_blocca_data = ttk.Checkbutton(
            data_frame,
            text="Blocca data",
            variable=self.blocca_data_var,
            command=self.on_blocca_data_changed
        )
        self.checkbox_blocca_data.pack(side="left", padx=4)
        btn_importa_popup = ttk.Button(data_frame, text="üì• Importa", command=self.apri_finestra_importa, style="Blu.TButton")
        btn_importa_popup.pack(side="left", padx=6)
        row += 1
        
        ttk.Label(form_frame, text="üîç Seleziona categoria:").grid(row=row, column=0, sticky="e")
        combo_frame = ttk.Frame(form_frame)
        combo_frame.grid(row=row, column=1, sticky="w", columnspan=2, pady=(4, 4))

        self.cat_sel = tk.StringVar(value=self.categorie[0])
        
        self.cat_menu = ttk.Combobox(combo_frame, textvariable=self.cat_sel, values=sorted(self.categorie), state="readonly", width=25, style="Border.TCombobox",font=("Arial", 10, "bold"))
        self.cat_menu.pack(side="left")
        
        self.label_smartcat = ttk.Label(combo_frame, text="üí° SmartCat attiva", foreground="red", font=("Arial", 9, "bold"))
        self.label_smartcat.pack(side="left", padx=(6, 0))
        self.btn_spese_simili = ttk.Button(combo_frame, text=f"üîç Voci simili ¬± {toll}", style="Low.Blu.TButton", command=self.mostra_spese_simili)
        self.btn_spese_simili.pack(side="left", padx=(6, 0))
        self.btn_spese_simili.pack_forget()

        if not self.suggerimenti_attivi:
            self.label_smartcat.config(text="üõ†Ô∏è SmartCat disattiva", foreground="green")
            self.aggiorna_bottone_spese_simili(visibile=False)
        else:
             self.label_smartcat.config(text="üí° SmartCat attiva", foreground="red")
             
        self.cat_menu.bind("<<ComboboxSelected>>", self.on_categoria_changed)
        row += 1
        
        ttk.Label(form_frame, text="‚ÑπÔ∏è Descrizione:").grid(row=row, column=0, sticky="e", pady=(4, 8))
        def convalida_descrizione(nuovo_valore_1):
         return len(nuovo_valore_1) <= 30

        vdesc = form_frame.register(convalida_descrizione)
        self.desc_entry = ttk.Entry(form_frame, width=30, validate="key", validatecommand=(vdesc, "%P"))
        self.desc_entry.grid(row=row, column=1, sticky="w")
        row += 1
        
        ttk.Label(form_frame, text="üí∞ Importo (‚Ç¨):‚èé").grid(row=row, column=0, sticky="e")
        importo_frame = ttk.Frame(form_frame)

        def convalida_input(nuovo_valore_2):
         if nuovo_valore_2 == "":
              return True  
         import re
         # Imposta massimo
         return len(nuovo_valore_2) <= 8 and re.match(r"^\d*[.,]?\d{0,2}$", nuovo_valore_2) is not None

        vcmd = form_frame.register(convalida_input)       
        self.imp_entry = ttk.Entry(importo_frame, width=12, validate="key", validatecommand=(vcmd, "%P"))  
        self.imp_entry.pack(side=tk.LEFT)      
        self.imp_entry.bind("<KeyRelease>", self.aggiorna_categoria_automatica)
        self.imp_entry.bind("<Return>", lambda event: self.add_spesa()) 
        self.imp_entry.bind("<KP_Enter>", lambda event: self.add_spesa()) 
        
        def start_blinking_callback(event):
            self.start_blinking(self.label_data_spesa)
            if self.STATO_CORRENTE != 0:
                self.mostra_treeview_statistiche()           
        def stop_blinking_callback(event):
            self.stop_blinking(self.label_data_spesa)
        
        self.imp_entry.bind('<FocusIn>', start_blinking_callback)
        self.imp_entry.bind('<FocusOut>', stop_blinking_callback)
        
        self.bind("<Map>", self._gestisci_ripristino_focus)
        
        importo_frame.grid(row=row, column=1, sticky="w")
        if hasattr(self, 'imp_entry'):
            self.after(0, self.imp_entry.focus_set)
        row += 1

        pannello_bottoni = ttk.Frame(form_frame)
        pannello_bottoni.grid(row=row, column=1, columnspan=8, sticky="w", pady=4)
        self.btn_aggiungi = ttk.Button(pannello_bottoni, text="üí∏ Aggiungi Movimento", command=self.add_spesa, style="Verde.TButton")
        self.btn_aggiungi.pack(side="left", padx=4)
        self.calc_button = ttk.Button(pannello_bottoni, text="üî¢", style="Yellow.TButton", command=self.apri_calcolatrice)
        self.calc_button.pack(side="left")
        self.btn_reset_form = ttk.Button(pannello_bottoni,text="‚Ü∫",width=2,command=self.reset_form, style="Giallo.TButton")
        self.btn_reset_form.pack(side="left", padx=(4, 0))
        self.btn_modifica = ttk.Button(pannello_bottoni, text="üíæ Salva Modifica", command=self.salva_modifica, state=tk.DISABLED, style="Verde.TButton")
        self.btn_modifica.pack(side="left", padx=4)
        self.btn_cancella = ttk.Button(pannello_bottoni, text="‚ùå Cancella", command=self.cancella_voce, state=tk.DISABLED, style="Rosso.TButton")
        self.btn_cancella.pack(side="left", padx=4)
        btn_ricorrenze = ttk.Button(pannello_bottoni, text="‚ôªÔ∏è Ricorrenze", command=lambda: self.mostra_ricorrenza_popup(), style="Blu.TButton")
        btn_ricorrenze.pack(side="left", padx=4)
        self.btn_gestisci_categorie = ttk.Button(pannello_bottoni, text="‚úÖ Categorie", command=lambda: self.mostra_categorie_popup(), style="Blu.TButton")
        self.btn_gestisci_categorie.pack(side="left", padx=4)
        btn_scadenze_mese = ttk.Button(pannello_bottoni, text="‚úÖ", command=lambda: self.scadenze_mese(), style="Blu.TButton", width=3)
        btn_scadenze_mese.pack(side="left", padx=4)

        row += 1

        cat_default_type = self.categorie_tipi.get(self.cat_sel.get(), "Uscita")
        self.tipo_spesa_var = tk.StringVar(value=cat_default_type)
        btn_style = 'GreenOutline.TButton' if self.tipo_spesa_var.get() == "Entrata" else 'RedOutline.TButton'
        self.btn_tipo_spesa = ttk.Button(
            importo_frame,
            text=self.tipo_spesa_var.get(),
            width=10,
            command=self.toggle_tipo_spesa,
            style=btn_style,
            takefocus=0
        )
        self.btn_tipo_spesa.pack(side=tk.LEFT, padx=8)
        self.metodo_pagamento_var = tk.StringVar(value="") 
        metodi = ["", "üí∞ Contanti", "üîÑ RID/SDD", "üè¶ Bonifico", "üíé C.Credito", "üí≥ C.Debito", ]
        self.metodo_pagamento_combobox = ttk.Combobox(
            importo_frame, 
            textvariable=self.metodo_pagamento_var, 
            values=metodi,
            state="readonly",
            style="Border.TCombobox",
            width=10
        )
        self.metodo_pagamento_combobox.pack(side=tk.LEFT, padx=4) 
        self.metodo_pagamento_combobox.bind("<<ComboboxSelected>>", self.aggiorna_descrizione_con_simbolo)
        row += 1
        self.lbl_tipo_percentuale = ttk.Label(importo_frame, text="", font=("Arial", 9, "bold"))
        self.lbl_tipo_percentuale.pack(side=tk.LEFT, padx=4)
        self.on_categoria_changed(manuale=False)
        self.refresh_gui()
        self.after(1000, self.check_aggiornamento_con_api)
        self.protocol("WM_DELETE_WINDOW", self._on_close)
      
        # Start Carosello
        if CAROSELLO:
            self.after(100, self.riavvia_scorrimento_automatico)
           
    def aggiorna_descrizione_con_simbolo(self, event=None):
        simboli_metodo = {
            "üí∞ Contanti": "üí∞",
            "üîÑ RID/SDD": "üîÑ",
            "üíé C.Credito": "üíé",
            "üí≥ C.Debito": "üí≥",
            "üè¶ Bonifico": "üè¶"
        }
        desc_attuale = self.desc_entry.get().strip()
        metodo_selezionato = self.metodo_pagamento_var.get()
        desc_pulita = desc_attuale
        simboli_possibili = list(simboli_metodo.values()) 
        simbolo_trovato = None
        for simbolo in simboli_possibili:
            if desc_pulita.startswith(simbolo):
                simbolo_trovato = simbolo
                desc_pulita = desc_pulita[len(simbolo_trovato):].lstrip() 
                break 
        nuovo_simbolo = simboli_metodo.get(metodo_selezionato, '')
        
        if not desc_pulita and metodo_selezionato:
            testo_base_da_inserire = metodo_selezionato
        else:
            testo_base_da_inserire = desc_pulita
            
        self.desc_entry.delete(0, tk.END)
        if nuovo_simbolo:
            nuova_desc = f"{nuovo_simbolo} {desc_pulita}".strip()
            self.desc_entry.insert(0, nuova_desc)
        else:
            self.desc_entry.insert(0, desc_pulita)
        self.desc_entry.icursor(tk.END)

    # Cicla
    def mostra_treeview_statistiche(self):
        self.STATO_CORRENTE = 0
        self.toggle_stats_view("tabella")
        self.btn_ciclico.config(text=self.LABEL_PROSSIMO_STATO[1])
    def cicla_visualizzazione_statistiche(self):
        NUOVO_STATO = (self.STATO_CORRENTE + 1) % len(self.STATI_VISTA)
        tipo_vista = self.STATI_VISTA[NUOVO_STATO]
        self.toggle_stats_view(tipo_vista)
        nuova_label = self.LABEL_PROSSIMO_STATO[NUOVO_STATO]
        self.btn_ciclico.config(text=nuova_label)
        self.STATO_CORRENTE = NUOVO_STATO
    def cicla_indietro(self, event=None):
        NUOVO_STATO = (self.STATO_CORRENTE - 1) % len(self.STATI_VISTA)
        tipo_vista = self.STATI_VISTA[NUOVO_STATO]
        self.toggle_stats_view(tipo_vista)
        nuova_label = self.LABEL_PROSSIMO_STATO[(NUOVO_STATO + 1) % len(self.STATI_VISTA)]
        self.btn_ciclico.config(text=nuova_label)
        self.STATO_CORRENTE = NUOVO_STATO
    
    # Start Carosello
    def attiva_binding_stop(self):
        root = self.winfo_toplevel()
        handler = self.handle_stop_carosello
        root.bind('<Motion>', handler)
        root.bind('<Any-KeyPress>', handler)
        root.bind('<Button-1>', handler)
    def disattiva_binding_stop(self):
        root = self.winfo_toplevel()
        try: root.unbind('<Motion>') 
        except: pass
        try: root.unbind('<Any-KeyPress>') 
        except: pass
        try: root.unbind('<Button-1>')
        except: pass
    def esegui_scorrimento_e_riprogramma(self):
        self.chiamato_da_carosello=True
        if not hasattr(self, 'STATI_VISTA'): return
        NUOVO_STATO = (self.STATO_CORRENTE + 1) % len(self.STATI_VISTA)
        tipo_vista = self.STATI_VISTA[NUOVO_STATO]
        self.toggle_stats_view(tipo_vista)   
        nuova_label = self.LABEL_PROSSIMO_STATO[NUOVO_STATO]
        if hasattr(self, 'btn_ciclico_carosello'):
            self.btn_ciclico_carosello.config(text=f"üîÑ{nuova_label}")
        self.STATO_CORRENTE = NUOVO_STATO
        self.id_scorrimento_automatico = self.after(
            self.intervallo_scorrimento, 
            self.esegui_scorrimento_e_riprogramma
        )
    def handle_stop_carosello(self, event=None):
        try:
            self.ferma_scorrimento_automatico()
        except Exception as e:
            pass
    def ferma_scorrimento_automatico(self):
        self.chiamato_da_carosello=False
        self.btn_ciclico_carosello.config(text="üîÑ")
        if hasattr(self, 'id_scorrimento_automatico') and self.id_scorrimento_automatico is not None:
            try:
                self.after_cancel(self.id_scorrimento_automatico) 
            except Exception:
                pass
            self.id_scorrimento_automatico = None
            self.STATO_CORRENTE = 0
            if hasattr(self, 'mostra_treeview_statistiche'):
                try:
                    self.mostra_treeview_statistiche()
                except Exception:
                    pass
            if hasattr(self, 'var_carosello_enabled'):
                self.var_carosello_enabled.set(False)
        self.disattiva_binding_stop()
    def riavvia_scorrimento_automatico(self):
        self.ferma_scorrimento_automatico() 
        self.id_scorrimento_automatico = self.after(
            self.intervallo_scorrimento, 
            self.esegui_scorrimento_e_riprogramma
        )
        self.attiva_binding_stop()
    def riavvia_scorrimento_manuale(self):
        self.ferma_scorrimento_automatico() 
        self.id_scorrimento_automatico = self.after(
            self.intervallo_scorrimento, 
            self.esegui_scorrimento_e_riprogramma
        )
    def toggle_carosello(self):
        if self.var_carosello_enabled.get():
            self.chiamato_da_carosello=True
            self.STATO_CORRENTE = -1 
            self.riavvia_scorrimento_manuale()
        else:
            self.chiamato_da_carosello=False
            self.ferma_scorrimento_automatico()
            if hasattr(self, 'btn_ciclico_carosello'):
                self.btn_ciclico_carosello.config(text="üîÑ")
                
    # Grafici Interni    
    def toggle_stats_view(self, tipo="grafico"):
        parent_frame = None
        if hasattr(self, 'stats_table') and self.stats_table and self.stats_table.winfo_exists():
            parent_frame = self.stats_table.master
            self.stats_table.destroy()
        if hasattr(self, 'stats_canvas') and self.stats_canvas and self.stats_canvas.winfo_exists():
            if parent_frame is None:
                parent_frame = self.stats_canvas.master
            self.stats_canvas.destroy()
        if parent_frame is None and hasattr(self, 'stats_container_frame'):
            parent_frame = self.stats_frame_ref
        for btn in self.filtri_temporali:
            btn.pack_forget()
        if hasattr(self, 'stats_label'):
            self.stats_label.grid_remove()
        if hasattr(self, 'totali_label'):
            self.totali_label.pack_forget()
        if tipo in ("grafico", "grafico_mensile", "grafico_saldo"):
            self.stats_canvas = tk.Canvas(parent_frame, bg="white")
            self.stats_canvas.pack(fill=tk.BOTH, expand=True)
            nomi_mesi_italiano = [
                "", "Gen", "Feb", "Mar", "Apr", "Mag", "Giu", 
                "Lug", "Ago", "Set", "Ott", "Nov", "Dic"
            ]
            oggi = datetime.date.today()
            anno_corrente = oggi.year
            if tipo == "grafico":
                self.stats_view_mode.set("grafico")
                category_totals = defaultdict(float)
                for giorno, entries in self.spese.items():
                    if giorno.year != anno_corrente: 
                        continue
                    for entry in entries:
                        if isinstance(entry, dict):
                            categoria = entry.get("categoria", "Altro")
                            importo = entry.get("importo", 0)
                            tipo_voce = entry.get("tipo", "")
                        elif isinstance(entry, tuple) and len(entry) >= 4:
                            categoria = entry[0]
                            importo = entry[2]
                            tipo_voce = entry[3]
                        else:
                            continue
                        if tipo_voce == "Uscita" and importo > 0:
                            category_totals[categoria] += importo
                self.data_for_chart = [{'label': cat, 'value': val} for cat, val in category_totals.items()]
                self.data_for_chart.sort(key=lambda x: x['value'], reverse=True)
                self.total_value = sum(item['value'] for item in self.data_for_chart)
                if not self.data_for_chart:
                    self.stats_canvas.after(50, lambda: self.stats_canvas.create_text(
                        self.stats_canvas.winfo_width() // 2, self.stats_canvas.winfo_height() // 2,
                        text="Nessuna spesa da visualizzare", font=("Helvetica", 16), fill="gray"
                    ))
                    return
                self.stats_canvas.bind("<Configure>", self.draw_bar_chart)
                self.stats_canvas.after(100, self.draw_bar_chart) 
            elif tipo == "grafico_mensile":
                self.visualizza_tutti_gli_anni = False
                self.stats_view_mode.set("grafico_mensile")
                mensili = defaultdict(lambda: {"Entrata": 0.0, "Uscita": 0.0})
                for giorno, entries in self.spese.items():
                    if giorno.year != anno_corrente: continue
                    for entry in entries:
                        if isinstance(entry, dict):
                            imp = entry.get("importo", 0)
                            tipo_voce = entry.get("tipo", "")
                        elif isinstance(entry, tuple) and len(entry) >= 4:
                            imp = entry[2]
                            tipo_voce = entry[3]
                        else: continue
                        mese = giorno.month
                        if tipo_voce in ("Entrata", "Uscita"):
                            mensili[mese][tipo_voce] += imp
                self.data_for_chart = []
                for mese in range(1, 13):
                    self.data_for_chart.append({
                        "label": nomi_mesi_italiano[mese],
                        "entrata": mensili[mese]["Entrata"],
                        "uscita": mensili[mese]["Uscita"]
                    })
                self.stats_canvas.bind("<Configure>", self.draw_mensile_chart)
                self.stats_canvas.after(100, self.draw_mensile_chart) 
            elif tipo == "grafico_saldo":
                self.visualizza_tutti_gli_anni = False
                self.stats_view_mode.set("grafico_saldo")
                mensili = defaultdict(lambda: {"Entrata": 0.0, "Uscita": 0.0})
                for giorno, entries in self.spese.items():
                    if giorno.year != anno_corrente: continue
                    for entry in entries:
                        if isinstance(entry, dict):
                            imp = entry.get("importo", 0)
                            tipo_voce = entry.get("tipo", "")
                        elif isinstance(entry, tuple) and len(entry) >= 4:
                            imp = entry[2]
                            tipo_voce = entry[3]
                        else: continue
                        mese = giorno.month
                        if tipo_voce == "Entrata":
                            mensili[mese]["Entrata"] += imp
                        elif tipo_voce == "Uscita":
                            mensili[mese]["Uscita"] += imp
                self.data_for_chart = []
                max_abs_val = 0
                for mese in range(1, 13):
                    saldo = mensili[mese]["Entrata"] - mensili[mese]["Uscita"]
                    self.data_for_chart.append({
                        "label": nomi_mesi_italiano[mese],
                        "saldo": saldo
                    })
                    if abs(saldo) > max_abs_val:
                        max_abs_val = abs(saldo)
                if max_abs_val == 0:
                    self.stats_canvas.after(50, lambda: self.stats_canvas.create_text(
                        self.stats_canvas.winfo_width() // 2, self.stats_canvas.winfo_height() // 2,
                        text="Nessun saldo disponibile (tutti i saldi sono zero).",
                        font=("Helvetica", 12), fill="gray"
                    ))
                    return
                self.stats_canvas.bind("<Configure>", self.draw_saldo_chart)
                self.stats_canvas.after(100, self.draw_saldo_chart) 
        else:
            self.stats_table = ttk.Treeview(parent_frame, columns=("A", "B", "C", "D", "E", "F"), show="headings")
            headers = {
                "A": "Data", "B": "Categoria", "C": "Descrizione",
                "D": "Importo (‚Ç¨)", "E": "Tipo", "F": "Modifica"
            }
            for col in headers:
                self.stats_table.heading(col, text=headers[col], command=lambda _col=col: self.treeview_sort_column(self.stats_table, _col, False))
            self.stats_table.column("A", width=100, anchor="center")
            self.stats_table.column("B", width=150, anchor="center")
            self.stats_table.column("C", width=250, anchor="w")
            self.stats_table.column("D", width=100, anchor="e")
            self.stats_table.column("E", width=80, anchor="center")
            self.stats_table.column("F", width=60, anchor="center")
            
            # Cambia stato in mese se il Carosello e' attivo
            if self.chiamato_da_carosello:
                self.set_stats_mode("mese")
            else:
                self.set_stats_mode("giorno")
            #self.set_stats_mode("giorno")
            
            self.stats_table.tag_configure("uscita", foreground="red")
            self.stats_table.tag_configure("entrata", foreground="green")
            self.stats_table.bind("<Double-1>", self.on_stats_table_double_click)
            self.stats_table.bind("<ButtonRelease-1>", self.on_table_click)
            self.stats_table.bind("<Button-3>", self.on_stats_table_right_click)
            self.stats_table.pack(fill=tk.BOTH, expand=True) 
            if hasattr(self, 'stats_label'):
                self.stats_label.grid()
            if hasattr(self, 'totali_label'):
                self.totali_label.pack(side=tk.LEFT)
            self.stats_view_mode.set("tabella")
            for btn in self.filtri_temporali:
                btn.pack(side=tk.LEFT, padx=1)
                
    def draw_bar_chart(self, event=None):
        if self.stats_view_mode.get() != "grafico":
            return
        canvas = self.stats_canvas
        canvas.delete("all")
        if not hasattr(self, 'visualizza_tutti_gli_anni'):
            self.visualizza_tutti_gli_anni = False
        def toggle_anni():
            self.visualizza_tutti_gli_anni = not self.visualizza_tutti_gli_anni
            self.draw_bar_chart()
        canvas.update_idletasks()
        btn_text = "üóì Tutti gli anni" if not self.visualizza_tutti_gli_anni else "üìÖ Solo anno corrente"
        btn_toggle = ttk.Button(canvas, text=btn_text, command=toggle_anni, style="Blu.TButton")
        canvas.create_window(canvas.winfo_width() - 10, 2, window=btn_toggle, anchor="ne")
        category_totals = defaultdict(float)
        oggi = datetime.date.today()
        anno_corrente = oggi.year
        for giorno, entries in self.spese.items():
            if hasattr(giorno, "year") and (self.visualizza_tutti_gli_anni or giorno.year == anno_corrente):
                for entry in entries:
                    if isinstance(entry, dict):
                        categoria = entry.get("categoria", "Altro")
                        importo = entry.get("importo", 0)
                        tipo = entry.get("tipo", "")
                    elif isinstance(entry, tuple) and len(entry) >= 4:
                        categoria = entry[0]
                        importo = entry[2]
                        tipo = entry[3]
                    else:
                        continue
                    try:
                        importo = float(str(importo).replace(",", ".").replace("‚Ç¨", "").strip())
                    except Exception:
                        importo = 0
                    if tipo.lower() == "uscita" and importo > 0:
                        category_totals[categoria] += importo
        self.data_for_chart = [
            {'label': cat, 'value': val}
            for cat, val in category_totals.items()
            if val > 0
        ]
        self.data_for_chart.sort(key=lambda x: x['value'], reverse=True)
        self.data_for_chart = self.data_for_chart[:40]
        self.total_value = sum(item['value'] for item in self.data_for_chart)
        if not self.data_for_chart or self.total_value == 0:
            canvas.create_text(canvas.winfo_width() // 2, canvas.winfo_height() // 2,
                               text="Nessuna spesa da visualizzare", font=("Arial", 12))
            return
        COLORS = ["#36A2EB", "#FF6384", "#FFCE56", "#4BC0C0", "#9966FF", "#FF9F40", "#A3A3A3", "#5AD45A"]
        canvas_width = canvas.winfo_width()
        canvas_height = canvas.winfo_height()
        CHART_LEFT = 50
        CHART_RIGHT = canvas_width - 20
        CHART_TOP = 50
        CHART_BOTTOM = canvas_height - 130
        CHART_AREA_WIDTH = CHART_RIGHT - CHART_LEFT
        CHART_HEIGHT = CHART_BOTTOM - CHART_TOP
        if CHART_AREA_WIDTH < 100 or CHART_HEIGHT < 50:
            canvas.create_text(canvas_width // 2, canvas_height // 3,
                               text="Area di disegno insufficiente.", font=("Arial", 12))
            return
        oggi = datetime.date.today()
        anno_corrente = oggi.year
        if self.visualizza_tutti_gli_anni:
            anni_presenti = [giorno.year for giorno in self.spese.keys() if hasattr(giorno, 'year')]
            min_anno = min(anni_presenti) if anni_presenti else anno_corrente
            periodo = f"({min_anno} - {anno_corrente})"
            titolo = f"üìä Uscite per Categoria (Tutto lo Storico) {periodo}"
        else:
            periodo = f"({anno_corrente})"
            titolo = f"üìä Uscite per Categoria - Anno Corrente {periodo}"
        canvas.create_text(canvas_width // 2, CHART_TOP / 3, 
                           text=titolo, 
                           font=("Arial", 8, "bold"), fill="black")
        self.total_annuale = 0
        for giorno, entries in self.spese.items():
            if hasattr(giorno, "year") and (self.visualizza_tutti_gli_anni or giorno.year == anno_corrente):
                for entry in entries:
                    if isinstance(entry, dict):
                        tipo = entry.get("tipo", "").strip().lower()
                        importo = entry.get("importo", 0)
                    elif isinstance(entry, tuple) and len(entry) >= 4:
                        tipo = str(entry[3]).strip().lower()
                        try:
                            importo = float(entry[2])
                        except Exception:
                            importo = 0
                    else:
                        continue
                    if tipo == "uscita" and importo > 0:
                        self.total_annuale += importo
        canvas.create_line(CHART_LEFT, CHART_BOTTOM, CHART_LEFT, CHART_TOP, fill="black", width=2)
        canvas.create_line(CHART_LEFT, CHART_BOTTOM, CHART_RIGHT, CHART_BOTTOM, fill="black", width=2)
        max_value = max(item['value'] for item in self.data_for_chart)
        num_bars = len(self.data_for_chart)
        bar_space_total = CHART_AREA_WIDTH / num_bars
        bar_width = bar_space_total * 0.7
        for i, item in enumerate(self.data_for_chart):
            bar_height = (item['value'] / max_value) * CHART_HEIGHT
            x_center = CHART_LEFT + (i + 0.5) * bar_space_total
            x1 = x_center - bar_width / 2
            x2 = x_center + bar_width / 2
            y1 = CHART_BOTTOM - bar_height
            y2 = CHART_BOTTOM
            color = COLORS[i % len(COLORS)]
            tag = f"barra_{i}"
            canvas.create_rectangle(x1, y1, x2, y2, fill=color, outline="black", tags=tag)
            canvas.create_text(x_center, CHART_BOTTOM + 60, text=item['label'], anchor="n", angle=45,
                               font=("Arial", 7, "bold"), fill=color)
            canvas.create_text(x_center, y1 - 5, text=f"{item['value']:.0f}", anchor="s",
                               font=("Arial", 7, "bold"), fill=color)
            tooltip_text = f"{item['label']}: ‚Ç¨{item['value']:.2f}"
            canvas.tag_bind(tag, "<Enter>", lambda e, t=tooltip_text: self.show_tooltip(e, t))
            canvas.tag_bind(tag, "<Leave>", self.hide_tooltip)
            data_filter = {
                "anno": None if self.visualizza_tutti_gli_anni else str(anno_corrente),
                "mese": None,
                "categoria": item["label"],
                "tipo": "Uscita"
            }
            popup_title = f"Uscita per Categoria '{item['label']}' {periodo}"
            canvas.tag_bind(tag, "<Double-1>", lambda e, f=data_filter, t=popup_title:
                                self.mostra_transazioni_popup(f, t)) 
        canvas.create_text(CHART_LEFT - 5, CHART_TOP, text=f"{max_value:.0f}", anchor="e",
                           font=("Arial", 7), fill="black")
        canvas.create_text(CHART_LEFT - 5, CHART_BOTTOM, text="0", anchor="e",
                           font=("Arial", 7), fill="black")
        mostrate = len(self.data_for_chart)
        totali_disponibili = len([val for val in category_totals.values() if val > 0])
        messaggio_riepilogo = (
            f"Totale Visualizzato: {self.total_value:,.2f} ‚Ç¨ | "
            f"Totale Anno: {self.total_annuale:,.2f} ‚Ç¨ | "
            f"Categorie mostrate: {mostrate} su {totali_disponibili}"
        )
        canvas.create_text(
            canvas.winfo_width() // 2,
            canvas.winfo_height() - 10,
            text=messaggio_riepilogo,
            anchor="center", 
            font=("Arial", 8, "bold"), 
            fill="#4B0082"
        )
                    
    def draw_mensile_chart(self, event=None):
        if self.stats_view_mode.get() != "grafico_mensile":
            return
        canvas = self.stats_canvas
        canvas.delete("all")
        mesi_completi = ["Gennaio", "Febbraio", "Marzo", "Aprile", "Maggio", "Giugno",
                         "Luglio", "Agosto", "Settembre", "Ottobre", "Novembre", "Dicembre"]
        if not hasattr(self, 'visualizza_tutti_gli_anni_mensile'):
            self.visualizza_tutti_gli_anni_mensile = False
        def toggle_anni():
            self.visualizza_tutti_gli_anni_mensile = not self.visualizza_tutti_gli_anni_mensile
            self.draw_mensile_chart()
        canvas.update_idletasks()
        btn_text = "üóì Tutti gli anni" if not self.visualizza_tutti_gli_anni_mensile else "üìÖ Solo anno corrente"
        btn_toggle = ttk.Button(canvas, text=btn_text, command=toggle_anni, style="Blu.TButton")
        canvas.create_window(canvas.winfo_width() - 10, 2, window=btn_toggle, anchor="ne")
        oggi = datetime.date.today()
        anno_corrente = oggi.year
        if self.visualizza_tutti_gli_anni_mensile:
            aggregati = {}
            for giorno, entries in self.spese.items():
                if hasattr(giorno, "year"):
                    anno = giorno.year
                    if anno not in aggregati:
                        aggregati[anno] = {"label": str(anno), "entrata": 0.0, "uscita": 0.0}
                    for entry in entries:
                        tipo = entry[3] if isinstance(entry, tuple) else entry.get("tipo", "")
                        importo = float(entry[2]) if isinstance(entry, tuple) and len(entry) >= 4 else float(entry.get("importo", 0))
                        if tipo == "Entrata":
                            aggregati[anno]["entrata"] += importo
                        elif tipo == "Uscita":
                            aggregati[anno]["uscita"] += importo
            self.data_for_chart = [aggregati[anno] for anno in sorted(aggregati)]
        else:
            mesi = ["Gen", "Feb", "Mar", "Apr", "Mag", "Giu", "Lug", "Ago", "Set", "Ott", "Nov", "Dic"]
            mensili = [{"label": m, "entrata": 0.0, "uscita": 0.0} for m in mesi]
            for giorno, entries in self.spese.items():
                if hasattr(giorno, "year") and giorno.year == anno_corrente:
                    mese_index = giorno.month - 1
                    for entry in entries:
                        tipo = entry[3] if isinstance(entry, tuple) else entry.get("tipo", "")
                        importo = float(entry[2]) if isinstance(entry, tuple) and len(entry) >= 4 else float(entry.get("importo", 0))
                        
                        if tipo == "Entrata":
                            mensili[mese_index]["entrata"] += importo
                        elif tipo == "Uscita":
                            mensili[mese_index]["uscita"] += importo
            self.data_for_chart = mensili
        canvas_width = canvas.winfo_width()
        canvas_height = canvas.winfo_height()
        CHART_LEFT = 60
        CHART_RIGHT = canvas_width - 20
        CHART_TOP = 50
        CHART_BOTTOM = canvas_height - 80
        CHART_AREA_WIDTH = CHART_RIGHT - CHART_LEFT
        CHART_HEIGHT = CHART_BOTTOM - CHART_TOP
        if canvas_width < 100 or canvas_height < 50 or not self.data_for_chart:
            canvas.create_text(canvas_width // 2, canvas_height // 2,
                               text="Nessun dato disponibile.",
                               font=("Arial", 12), fill="gray")
            return
        max_value = max(max(item["entrata"], item["uscita"]) for item in self.data_for_chart)
        num_bars = len(self.data_for_chart)
        bar_space_total = CHART_AREA_WIDTH / num_bars
        bar_width = bar_space_total * 0.47
        canvas.create_line(CHART_LEFT, CHART_BOTTOM, CHART_LEFT, CHART_TOP, fill="black", width=2)
        canvas.create_line(CHART_LEFT, CHART_BOTTOM, CHART_RIGHT, CHART_BOTTOM, fill="black", width=2)
        for i, item in enumerate(self.data_for_chart):
            x_center = CHART_LEFT + (i + 0.5) * bar_space_total
            x_entrata_start = x_center - bar_width
            x_entrata_end = x_center
            x_uscita_start = x_center
            x_uscita_end = x_center + bar_width
            h_entrata = (item["entrata"] / max_value) * CHART_HEIGHT if max_value > 0 else 0
            h_uscita = (item["uscita"] / max_value) * CHART_HEIGHT if max_value > 0 else 0
            y_bottom = CHART_BOTTOM
            y_entrata_top = CHART_BOTTOM - h_entrata
            y_uscita_top = CHART_BOTTOM - h_uscita
            tag_entrata = f"entrata_{i}"
            tag_uscita = f"uscita_{i}"
            canvas.create_rectangle(x_entrata_start, y_entrata_top, x_entrata_end, y_bottom, fill="green", outline="black", tags=tag_entrata)
            canvas.create_rectangle(x_uscita_start, y_uscita_top, x_uscita_end, y_bottom, fill="red", outline="black", tags=tag_uscita)
            canvas.create_text(x_center, CHART_BOTTOM + 30, text=item["label"], anchor="n", angle=45, font=("Arial", 8))
            if item['entrata'] > 0:
                canvas.create_text(x_entrata_start + bar_width / 2, y_entrata_top - 5, text=f"{item['entrata']:.0f}", anchor="s", font=("Arial", 7), fill="green")
            if item['uscita'] > 0:
                canvas.create_text(x_uscita_start + bar_width / 2, y_uscita_top - 5, text=f"{item['uscita']:.0f}", anchor="s", font=("Arial", 7), fill="red")
            tooltip_entrata = f"{item['label']} - Entrata: ‚Ç¨{item['entrata']:.2f}"
            tooltip_uscita = f"{item['label']} - Uscita: ‚Ç¨{item['uscita']:.2f}"
            canvas.tag_bind(tag_entrata, "<Enter>", lambda e, t=tooltip_entrata: self.show_tooltip(e, t))
            canvas.tag_bind(tag_entrata, "<Leave>", self.hide_tooltip)
            canvas.tag_bind(tag_uscita, "<Enter>", lambda e, t=tooltip_uscita: self.show_tooltip(e, t))
            canvas.tag_bind(tag_uscita, "<Leave>", self.hide_tooltip)
            data_filter_e = {
                "anno": item["label"] if self.visualizza_tutti_gli_anni_mensile else str(anno_corrente),
                "mese": None if self.visualizza_tutti_gli_anni_mensile else i + 1,
                "categoria": None,
                "tipo": "Entrata"
            }
            data_filter_u = {
                "anno": item["label"] if self.visualizza_tutti_gli_anni_mensile else str(anno_corrente),
                "mese": None if self.visualizza_tutti_gli_anni_mensile else i + 1,
                "categoria": None,
                "tipo": "Uscita"
            }
            if not self.visualizza_tutti_gli_anni_mensile:
                mese_nome = mesi_completi[i]
                popup_title_e = f"Transazioni Entrata per {mese_nome} {anno_corrente}"
                canvas.tag_bind(tag_entrata, "<Double-1>", 
                    lambda e, f=data_filter_e, t=popup_title_e: 
                        self.mostra_transazioni_popup(f, t))
                popup_title_u = f"Transazioni Uscita per {mese_nome} {anno_corrente}"
                canvas.tag_bind(tag_uscita, "<Double-1>", 
                    lambda e, f=data_filter_u, t=popup_title_u: 
                        self.mostra_transazioni_popup(f, t))
            else:
                anno = item['label']
                popup_title_e = f"Transazioni Entrata per l'Anno {anno}"
                canvas.tag_bind(tag_entrata, "<Double-1>", 
                    lambda e, f=data_filter_e, t=popup_title_e: 
                        self.mostra_transazioni_popup(f, t))
                popup_title_u = f"Transazioni Uscita per l'Anno {anno}"
                canvas.tag_bind(tag_uscita, "<Double-1>", 
                    lambda e, f=data_filter_u, t=popup_title_u: 
                        self.mostra_transazioni_popup(f, t))
        if self.visualizza_tutti_gli_anni_mensile:
            anni_presenti = [item["label"] for item in self.data_for_chart]
            label_periodo = f"({anni_presenti[0]} - {anni_presenti[-1]})" if anni_presenti else "(N.D.)"
            titolo_grafico = f"Entrate/Uscite Aggregate per Anno {label_periodo}"
        else:
            label_periodo = f"({anno_corrente})"
            titolo_grafico = f"Entrate/Uscite per Mese {label_periodo}"
        canvas.create_text(canvas_width // 2, CHART_TOP / 3, 
                           text=titolo_grafico, 
                           font=("Arial", 8, "bold"), fill="black")
        canvas.create_text(CHART_LEFT - 5, CHART_TOP, text=f"{max_value:,.0f}", anchor="e", font=("Arial", 8), fill="black")
        canvas.create_text(CHART_LEFT - 5, CHART_BOTTOM, text="0", anchor="e", font=("Arial", 8), fill="black")
        total_entrata = sum(item["entrata"] for item in self.data_for_chart)
        total_uscita = sum(item["uscita"] for item in self.data_for_chart)
        total_saldo = total_entrata - total_uscita
        saldo_color = "green" if total_saldo >= 0 else "red"
        text_y_pos = canvas_height - 15
        x_pos_1 = CHART_LEFT + CHART_AREA_WIDTH * 0.15
        x_pos_2 = CHART_LEFT + CHART_AREA_WIDTH * 0.5
        x_pos_3 = CHART_LEFT + CHART_AREA_WIDTH * 0.85
        font_style = ("Arial", 10, "bold")
        canvas.create_text(x_pos_1, text_y_pos, 
                           text=f"Totale Entrate: ‚Ç¨{total_entrata:,.2f}", 
                           anchor="center", font=font_style, fill="green")
        canvas.create_text(x_pos_2, text_y_pos, 
                           text=f"Totale Uscite: ‚Ç¨{total_uscita:,.2f}", 
                           anchor="center", font=font_style, fill="red")
        canvas.create_text(x_pos_3, text_y_pos, 
                           text=f"Saldo Complessivo: ‚Ç¨{total_saldo:,.2f}", 
                           anchor="center", font=font_style, fill=saldo_color)
                      
    def show_tooltip(self, event, text):
        self.hide_tooltip()
        x = self.stats_canvas.winfo_rootx() + event.x + 10
        y = self.stats_canvas.winfo_rooty() + event.y + 10
        self.tooltip_window = tk.Toplevel(self.stats_canvas)
        self.tooltip_window.wm_overrideredirect(True)
        self.tooltip_window.wm_geometry(f"+{x}+{y}")
        label = ttk.Label(self.tooltip_window, text=text, style="Tooltip.TLabel")
        label.pack()

    def hide_tooltip(self, event=None):
        if hasattr(self, 'tooltip_window') and self.tooltip_window:
            self.tooltip_window.destroy()
            self.tooltip_window = None
                           
    def draw_saldo_chart(self, event=None):
        oggi = datetime.date.today()
        anno_corrente = oggi.year
        canvas = self.stats_canvas
        canvas.delete("all")
        canvas.update_idletasks()
        canvas_width = canvas.winfo_width()
        canvas_height = canvas.winfo_height()
        CHART_LEFT = 80
        CHART_RIGHT = canvas_width - 20
        CHART_TOP = 50
        NUOVO_SPAZIO_LEGENDA = 80  
        CHART_BOTTOM = canvas_height - NUOVO_SPAZIO_LEGENDA
        CHART_AREA_WIDTH = CHART_RIGHT - CHART_LEFT
        CHART_HEIGHT = CHART_BOTTOM - CHART_TOP
        NUOVO_OFFSET_TESTO = 30
        BAR_RATIO = 0.8
        mesi_completi = ["Gennaio", "Febbraio", "Marzo", "Aprile", "Maggio", "Giugno",
                          "Luglio", "Agosto", "Settembre", "Ottobre", "Novembre", "Dicembre"]
        if not hasattr(self, 'visualizza_saldo_totale'):
            self.visualizza_saldo_totale = False
        if not hasattr(self, 'visualizza_saldo_10_anni'):
            self.visualizza_saldo_10_anni = False
        if CHART_AREA_WIDTH < 100 or CHART_HEIGHT < 50:
            canvas.create_text(canvas_width // 2, canvas_height // 2,
                                text="Area di disegno insufficiente.",
                                font=("Arial", 12), fill="gray")
            return
        def toggle_saldo_mode():
            if not self.visualizza_saldo_totale and not self.visualizza_saldo_10_anni:
                self.visualizza_saldo_totale = True
                self.visualizza_saldo_10_anni = False
            elif self.visualizza_saldo_totale and not self.visualizza_saldo_10_anni:
                self.visualizza_saldo_totale = False
                self.visualizza_saldo_10_anni = True
            else:
                self.visualizza_saldo_totale = False
                self.visualizza_saldo_10_anni = False
            self.draw_saldo_chart()
        if self.visualizza_saldo_10_anni:
            btn_text = "üìÖ Solo anno corrente"
        elif self.visualizza_saldo_totale:
            btn_text = "üìà 10 anni (Linea)"
        else:
            btn_text = "üí∞ Tutti gli anni"
        btn_toggle = ttk.Button(canvas, text=btn_text, command=toggle_saldo_mode, style="Blu.TButton")
        canvas.create_window(canvas_width - 10, 2, window=btn_toggle, anchor="ne")
        if self.visualizza_saldo_10_anni:
            transazioni_totali = []
            for giorno, entries in self.spese.items():
                if hasattr(giorno, "year") and giorno >= self.saldo_data:
                    for entry in entries:
                        importo = float(entry[2]) if isinstance(entry, tuple) else float(entry.get("importo", 0))
                        tipo = entry[3] if isinstance(entry, tuple) else entry.get("tipo", "")
                        variazione = importo if tipo == "Entrata" else -importo
                        transazioni_totali.append({"data": giorno, "variazione": variazione})
            transazioni_totali.sort(key=lambda x: x["data"])
            saldo_cumulativo_corrente = self.saldo_iniziale
            saldi_mensili_cumulativi = {}
            if hasattr(self, 'saldo_data'):
                saldi_mensili_cumulativi[self.saldo_data] = self.saldo_iniziale
            ultima_data_registrata = self.saldo_data
            for transazione in transazioni_totali:
                data_transazione = transazione["data"]
                if data_transazione.year != ultima_data_registrata.year or data_transazione.month != ultima_data_registrata.month:
                    ultima_data_registrata = data_transazione
                saldo_cumulativo_corrente += transazione["variazione"]
                if data_transazione.month == 12:
                    data_fine_mese = datetime.date(data_transazione.year + 1, 1, 1) - datetime.timedelta(days=1)
                else:
                    data_fine_mese = datetime.date(data_transazione.year, data_transazione.month + 1, 1) - datetime.timedelta(days=1)
                saldi_mensili_cumulativi[data_fine_mese] = saldo_cumulativo_corrente
            self.data_for_chart = []
            for data, saldo in sorted(saldi_mensili_cumulativi.items()):
                 self.data_for_chart.append({
                     "label": data.strftime("%m/%Y"),
                     "saldo": saldo,
                     "data": data
                 })
        elif self.visualizza_saldo_totale:
            aggregati_anno = {}
            for giorno, entries in self.spese.items():
                if hasattr(giorno, "year"):
                    anno = giorno.year
                    if anno not in aggregati_anno:
                        aggregati_anno[anno] = 0.0
                    for entry in entries:
                        tipo = entry[3] if isinstance(entry, tuple) else entry.get("tipo", "")
                        importo = float(entry[2]) if isinstance(entry, tuple) else float(entry.get("importo", 0))
                        variazione = importo if tipo == "Entrata" else -importo
                        aggregati_anno[anno] += variazione
            self.data_for_chart = [
                {"label": str(anno), "saldo": saldo}  
                for anno, saldo in sorted(aggregati_anno.items())
            ]          
        else:
            mesi = ["Gen", "Feb", "Mar", "Apr", "Mag", "Giu", "Lug", "Ago", "Set", "Ott", "Nov", "Dic"]
            mensili_saldo = [{"label": m, "saldo": 0.0} for m in mesi]
            for giorno, entries in self.spese.items():
                if hasattr(giorno, "year") and giorno.year == anno_corrente:
                    mese_index = giorno.month - 1
                    for entry in entries:
                        tipo = entry[3] if isinstance(entry, tuple) else entry.get("tipo", "")
                        importo = float(entry[2]) if isinstance(entry, tuple) else float(entry.get("importo", 0))
                        variazione = importo if tipo == "Entrata" else -importo
                        mensili_saldo[mese_index]["saldo"] += variazione
            self.data_for_chart = mensili_saldo
        if not hasattr(self, 'data_for_chart') or not self.data_for_chart:
            canvas.create_text(canvas_width // 2, canvas_height // 2,
                                text="Nessun dato saldo disponibile.",
                                font=("Arial", 12), fill="gray")
            return
        saldi = [item["saldo"] for item in self.data_for_chart]
        max_saldo = max(saldi)
        min_saldo = min(saldi)
        buffer = (max_saldo - min_saldo) * 0.1 or 100 
        y_max = max_saldo + buffer
        y_min = min_saldo - buffer
        y_range = y_max - y_min
        def scale_y(saldo):
            if y_range == 0:
                return CHART_TOP + CHART_HEIGHT / 2
            return CHART_BOTTOM - ((saldo - y_min) / y_range) * CHART_HEIGHT
        if self.visualizza_saldo_10_anni:
            canvas.delete("y_labels", "axis")
            canvas.create_line(CHART_LEFT, CHART_BOTTOM, CHART_LEFT, CHART_TOP, fill="black", width=2, tags="axis")
            canvas.create_text(CHART_LEFT - 5, scale_y(max_saldo), text=f"‚Ç¨{max_saldo:,.0f}", anchor="e", font=("Arial", 8), fill="black", tags="y_labels")
            canvas.create_text(CHART_LEFT - 5, scale_y(min_saldo), text=f"‚Ç¨{min_saldo:,.0f}", anchor="e", font=("Arial", 8), fill="black", tags="y_labels")
            if y_min < 0 < y_max:
                ZERO_LINE_Y = scale_y(0)
                canvas.create_line(CHART_LEFT, ZERO_LINE_Y, CHART_RIGHT, ZERO_LINE_Y, fill="gray", width=1, dash=(5, 5), tags="axis")
                canvas.create_text(CHART_LEFT - 5, ZERO_LINE_Y, text="0", anchor="e", font=("Arial", 8), fill="black", tags="y_labels")
            data_min = self.data_for_chart[0]['data']
            data_max = self.data_for_chart[-1]['data']
            data_range_days = (data_max - data_min).days or 1
            def scale_x(date):
                if data_range_days == 0:
                    return CHART_LEFT + CHART_AREA_WIDTH / 2
                days_since_start = (date - data_min).days
                return CHART_LEFT + (days_since_start / data_range_days) * CHART_AREA_WIDTH
            points = []
            for i, item in enumerate(self.data_for_chart):
                x = scale_x(item['data'])
                y = scale_y(item['saldo'])
                points.append((x, y))
                point_radius = 4
                point_id = canvas.create_oval(x - point_radius, y - point_radius, 
                                              x + point_radius, y + point_radius, 
                                              fill="blue", outline="")
                tooltip_text = f"Data: {item['label']}\nSaldo: ‚Ç¨{item['saldo']:,.2f}"
                canvas.tag_bind(point_id, "<Enter>", lambda e, txt=tooltip_text: self.show_tooltip(e, txt))
                canvas.tag_bind(point_id, "<Leave>", self.hide_tooltip)
                if i == 0 or (item['data'].month == 1 and item['data'].day == 1) or i == len(self.data_for_chart) - 1:
                    canvas.create_text(x, CHART_BOTTOM + NUOVO_OFFSET_TESTO, text=item['data'].strftime("%Y"), anchor="n", angle=45, font=("Arial", 8))
            canvas.create_line(points, fill="blue", width=2, tags="line_chart")
        else:
            max_positive = max((item["saldo"] for item in self.data_for_chart if item["saldo"] >= 0), default=0) or 1
            max_negative = min((item["saldo"] for item in self.data_for_chart if item["saldo"] < 0), default=0) or -1
            ZERO_LINE_Y = CHART_TOP + CHART_HEIGHT / 2 
            canvas.delete("y_labels", "axis")
            canvas.create_line(CHART_LEFT, CHART_BOTTOM, CHART_LEFT, CHART_TOP, fill="black", width=2, tags="axis")
            canvas.create_line(CHART_LEFT, ZERO_LINE_Y, CHART_RIGHT, ZERO_LINE_Y, fill="gray", width=2, tags="axis")
            canvas.create_text(CHART_LEFT - 5, CHART_TOP, text=f"‚Ç¨{max_positive:,.0f}", anchor="e", font=("Arial", 8), fill="green", tags="y_labels")
            canvas.create_text(CHART_LEFT - 5, ZERO_LINE_Y, text="0", anchor="e", font=("Arial", 8), fill="black", tags="y_labels")
            canvas.create_text(CHART_LEFT - 5, CHART_BOTTOM, text=f"‚Ç¨{max_negative:,.0f}", anchor="e", font=("Arial", 8), fill="red", tags="y_labels")
            num_bars = len(self.data_for_chart)
            bar_space_total = CHART_AREA_WIDTH / num_bars
            bar_width = bar_space_total * BAR_RATIO
            for i, item in enumerate(self.data_for_chart):
                saldo = item["saldo"]
                if saldo >= 0:
                    bar_height = (saldo / max_positive) * (CHART_HEIGHT / 2) if max_positive else 0
                else:
                    bar_height = (abs(saldo) / abs(max_negative)) * (CHART_HEIGHT / 2) if max_negative else 0
                x_center = CHART_LEFT + (i + 0.5) * bar_space_total
                x1 = x_center - bar_width / 2
                x2 = x_center + bar_width / 2
                if saldo >= 0:
                    y1 = ZERO_LINE_Y - bar_height
                    y2 = ZERO_LINE_Y
                    color = "green"
                    text_anchor = "s"
                    text_y = y1 - 5
                else:
                    y1 = ZERO_LINE_Y
                    y2 = ZERO_LINE_Y + bar_height
                    color = "red"
                    text_anchor = "n"
                    text_y = y2 + 5
                rect_id = canvas.create_rectangle(x1, y1, x2, y2, fill=color, outline="black")
                if saldo != 0:
                    if self.visualizza_saldo_totale:
                        anno = item["label"]
                        popup_title = f"Transazioni per l'Anno {anno} (Entrate e Uscite)"
                        data_filter = {
                            "anno": anno,
                            "mese": None,
                            "categoria": None,
                            "tipo": None
                        }
                    else:
                        mese_index = i + 1  # 1-12
                        mese_nome = mesi_completi[i]
                        anno = str(anno_corrente)
                        popup_title = f"Transazioni per {mese_nome} {anno} (Entrate e Uscite)"
                        data_filter = {
                            "anno": anno,
                            "mese": mese_index,
                            "categoria": None,
                            "tipo": None
                        }
                    canvas.tag_bind(rect_id, "<Double-1>", 
                                    lambda e, f=data_filter, t=popup_title: 
                                        self.mostra_transazioni_popup(f, t))
                canvas.tag_bind(rect_id, "<Enter>", lambda e, txt=f"{item['label']}: ‚Ç¨{saldo:,.2f}": self.show_tooltip(e, txt))
                canvas.tag_bind(rect_id, "<Leave>", self.hide_tooltip)
                canvas.create_text(x_center, CHART_BOTTOM + NUOVO_OFFSET_TESTO, text=item["label"], anchor="n", angle=45, font=("Arial", 8))
                canvas.create_text(x_center, text_y, text=f"‚Ç¨{saldo:.0f}", anchor=text_anchor, font=("Arial", 8, "bold"), fill=color)
        total_entrata = 0.0
        total_uscita = 0.0
        anni_da_includere = set()
        data_min_vis = None
        data_max_vis = None
        if self.visualizza_saldo_10_anni and self.data_for_chart:
              data_min_vis = self.data_for_chart[0]['data']
              data_max_vis = self.data_for_chart[-1]['data']
        elif self.visualizza_saldo_totale:
            anni_da_includere = set([int(item["label"]) for item in self.data_for_chart if item["label"].isdigit()])
        else:
            anni_da_includere = {anno_corrente}
        for giorno, entries in self.spese.items():
            include_entry = False
            if self.visualizza_saldo_10_anni and data_min_vis and data_max_vis:
                  if hasattr(giorno, "year") and giorno >= self.saldo_data and giorno <= data_max_vis:
                      include_entry = True
            elif hasattr(giorno, "year") and giorno.year in anni_da_includere:
                  include_entry = True
            if include_entry:
                for entry in entries:
                    tipo = entry[3] if isinstance(entry, tuple) else entry.get("tipo", "")
                    importo = float(entry[2]) if isinstance(entry, tuple) else float(entry.get("importo", 0))
                    if tipo == "Entrata":
                        total_entrata += importo
                    elif tipo == "Uscita":
                        total_uscita += importo
        total_saldo = total_entrata - total_uscita
        saldo_color = "green" if total_saldo >= 0 else "red"
        if self.visualizza_saldo_10_anni and self.data_for_chart:
            primo_anno = self.data_for_chart[0]['data'].year
            ultimo_anno = self.data_for_chart[-1]['data'].year
            label_periodo = f"({primo_anno} - {ultimo_anno})"
            titolo_grafico = f"üìà Saldo Conto Corrente Cumulativo {label_periodo}"
        elif self.visualizza_saldo_totale:
            anni_presenti = sorted(list(set([int(item["label"]) for item in self.data_for_chart if item["label"].isdigit()])))
            label_periodo = f"({anni_presenti[0]} - {anni_presenti[-1]})" if anni_presenti else "(N.D.)"
            titolo_grafico = f"üí∞ Saldo Netto Annuale Aggregato {label_periodo}"
        else:
            label_periodo = f"({anno_corrente})"
            titolo_grafico = f"üìÖ Saldo Netto Mensile {label_periodo}"
        canvas.create_text(canvas_width // 2, CHART_TOP / 3, 
                            text=titolo_grafico, 
                            font=("Arial", 8, "bold"), fill="black")
        text_y_pos = canvas_height - 20 
        x_pos_1 = CHART_LEFT + CHART_AREA_WIDTH * 0.15 
        x_pos_2 = CHART_LEFT + CHART_AREA_WIDTH * 0.5  
        x_pos_3 = CHART_LEFT + CHART_AREA_WIDTH * 0.85 
        font_style = ("Arial", 10, "bold")
        canvas.create_text(x_pos_1, text_y_pos, 
                            text=f"Totale Entrate: ‚Ç¨{total_entrata:,.2f}", 
                            anchor="center", font=font_style, fill="green")
        canvas.create_text(x_pos_2, text_y_pos, 
                            text=f"Totale Uscite: ‚Ç¨{total_uscita:,.2f}", 
                            anchor="center", font=font_style, fill="red")
        canvas.create_text(x_pos_3, text_y_pos, 
                            text=f"Saldo Complessivo: ‚Ç¨{total_saldo:,.2f}", 
                            anchor="center", font=font_style, fill=saldo_color)

    # Gestione Categorie
    def mostra_categorie_popup(self):
        import datetime
        if hasattr(self, 'categorie_popup') and self.categorie_popup.winfo_exists():
            self.categorie_popup.deiconify()
            self.categorie_popup.lift()
            self.categorie_popup.focus_force()
            self.cat_mod_menu.configure(style="Border.TCombobox")
            self.reset_campi_categoria() 
            return
        self.categorie_popup = tk.Toplevel(self, bg=self.COLOR_TOPLEVEL)
        self.categorie_popup.title("Gestione Categorie")
        self.categorie_popup.resizable(False, False)
        window_width = 650
        window_height = 200
        screen_width = self.winfo_screenwidth()
        screen_height = self.winfo_screenheight()
        center_x = int(screen_width / 2 - window_width / 2)
        center_y = int(screen_height / 2 - window_height / 2)
        self.categorie_popup.geometry(f'{window_width}x{window_height}+{center_x}+{center_y}')
        self.categorie_popup.bind("<Escape>", lambda event: self.categorie_popup.withdraw())
        main_frame = ttk.Frame(self.categorie_popup)
        main_frame.pack(padx=10, pady=10, fill="both", expand=True)
        aggiungi_cat_frame = ttk.LabelFrame(main_frame, text="‚úÖ Configurazione Categorie", style="RedBold.TLabelframe")
        aggiungi_cat_frame.pack(padx=5, pady=5, fill="both", expand=True)
        aggiungi_cat_frame.columnconfigure(1, weight=1)
        if not hasattr(self, 'nuova_cat'):
            self.nuova_cat = tk.StringVar()
            self.cat_mod_sel = tk.StringVar(value=self.categorie[0] if self.categorie else "")
            self.tipo_categoria = tk.StringVar(value="Uscita")
        def convalida_categoria(valore):
            return len(valore) <= 20
        vcmd_cat = aggiungi_cat_frame.register(convalida_categoria)
        ttk.Label(aggiungi_cat_frame, text="üîç Nome:").grid(row=0, column=0, sticky="e", padx=4, pady=2)
        self.entry_nuova_cat = ttk.Entry(
            aggiungi_cat_frame,
            textvariable=self.nuova_cat,
            width=22,
            validate="key",
            validatecommand=(vcmd_cat, "%P")
        )
        self.entry_nuova_cat.grid(row=0, column=1, sticky="w", padx=2, pady=2)
        ttk.Label(aggiungi_cat_frame, text="üìÇ Tipo:").grid(row=0, column=2, sticky="e", padx=4, pady=2)
        def toggle_tipo_spesa_popup_cat():
            tipo_corrente = self.tipo_categoria.get()
            nuovo_tipo = "Entrata" if tipo_corrente == "Uscita" else "Uscita"
            self.tipo_categoria.set(nuovo_tipo)
            self._aggiorna_stile_pulsante_tipo_popup()
        self.btn_gestisci_tipo = ttk.Button(
            aggiungi_cat_frame,
            text=self.tipo_categoria.get(),
            width=10,
            command=toggle_tipo_spesa_popup_cat,
            style='RedOutline.TButton',
            takefocus=0
        )
        self.btn_gestisci_tipo.grid(row=0, column=3, sticky="w", padx=2, pady=2)
        self._aggiorna_stile_pulsante_tipo_popup()
        ttk.Label(aggiungi_cat_frame, text="‚öôÔ∏è Modifica:").grid(row=1, column=0, sticky="e", padx=4, pady=2)
        self.cat_mod_menu = ttk.Combobox(
            aggiungi_cat_frame,
            textvariable=self.cat_mod_sel,
            values=sorted(self.categorie),
            style="Border.TCombobox",
            state="readonly",
            width=22
        )
        self.cat_mod_menu.grid(row=1, column=1, sticky="w", padx=2, pady=2)
        self.cat_mod_menu.bind("<<ComboboxSelected>>", lambda e: self.on_categoria_modifica_changed_popup())
        btn_frame_cat = ttk.Frame(aggiungi_cat_frame)
        btn_frame_cat.grid(row=2, column=0, columnspan=2, pady=10)
        ttk.Button(btn_frame_cat, text="‚ûï Aggiungi", command=self.add_categoria, style="Verde.TButton").pack(side="left", padx=2)
        self.btn_modifica_categoria = ttk.Button(btn_frame_cat, text="‚öôÔ∏è Modifica", command=self.modifica_categoria, style="Verde.TButton")
        self.btn_modifica_categoria.pack(side="left", padx=2)
        self.btn_cancella_categoria = ttk.Button(btn_frame_cat, text="‚ùå Cancella", command=self.cancella_categoria, style="Rosso.TButton")
        self.btn_cancella_categoria.pack(side="left", padx=2)
        ttk.Button(btn_frame_cat, text="‚ú®", command=self.apri_categorie_suggerite, style="Arancio.TButton", width=2).pack(side="left", padx=2)
        ttk.Button(btn_frame_cat, text="üóëÔ∏è", command=self.apri_cancella_multiplo, style="Yellow.TButton").pack(side="left", padx=2)
        ttk.Button(btn_frame_cat, text="üìã Elenco", command=self.mostra_tutte_le_categorie, style="Arancio.TButton").pack(side="left", padx=2)
        ttk.Button(btn_frame_cat,text="‚Ü∫", width=2, command=self.reset_campi_categoria,style="Giallo.TButton").pack(side="left", padx=2)
        ttk.Button(main_frame, text="‚ùå Chiudi", command=self.categorie_popup.withdraw, style="Giallo.TButton").pack(side="bottom", pady=(0, 2))
        self.aggiorna_combobox_categorie()
        self.reset_campi_categoria()
        if not self.categorie:
            self.cat_mod_menu['state'] = 'disabled'

    def _aggiorna_stile_pulsante_tipo_popup(self):
        tipo = self.tipo_categoria.get()
        btn_style = 'GreenOutline.TButton' if tipo == "Entrata" else 'RedOutline.TButton'
        self.btn_gestisci_tipo.config(
            text=tipo,
            style=btn_style
        )
    def on_categoria_modifica_changed_popup(self):
        nome = self.cat_mod_sel.get()
        tipo = self.categorie_tipi.get(nome, "Uscita")
        self.nuova_cat.set(nome)
        self.tipo_categoria.set(tipo)
        self._aggiorna_stile_pulsante_tipo_popup()
    def on_categoria_modifica_changed(self):
        nome = self.cat_mod_sel.get()
        tipo = self.categorie_tipi.get(nome, "Uscita")
        self.nuova_cat.set(nome)  
        self.tipo_categoria.set(tipo)
    def reset_campi_categoria(self):
        self.nuova_cat.set("")                          
        self.cat_mod_sel.set("")                        
        self.tipo_categoria.set("Uscita")    
        self._aggiorna_stile_pulsante_tipo_popup()           
    def reset_ricorrenza_popup(self):
        oggi = datetime.date.today().strftime("%d-%m-%Y")
        self.importo_ricorrenza.set("")
        self.ricorrenza_tipo.set("Nessuna")
        self.ricorrenza_n.set(1)
        self.ricorrenza_data_inizio.set(oggi)
        self.ricorrenza_cat_sel.set(self.categorie[0])
        self.ricorrenza_desc.set("")
        self.ricorrenza_imp.set("")
        self.ricorrenza_bloccata = False
        self.ricorrenza_tipo_voce.set("Uscita")
        self.aggiorna_stile_tipo_voce_popup()
        self.ric_percentuali_label.config(text="0% Entrate / 0% Uscite")
        self.label_smartcat_ric.config(text="üõ†Ô∏è SmartCat in attesa...", foreground="gray")
        self.ric_cat_menu.configure(style="Border.TCombobox")

    # Popup gestione e pianificazione ricorrenze
    def mostra_ricorrenza_popup(self):
        oggi = datetime.date.today().strftime("%d-%m-%Y")
        if hasattr(self, 'ricorrenza_popup') and self.ricorrenza_popup.winfo_exists():
            self.reset_ricorrenza_popup()
            self.ricorrenza_popup.deiconify()
            self.ricorrenza_popup.lift()
            self.ric_cat_menu.configure(style="Border.TCombobox")
            self.ric_combo.configure(style="Border.TCombobox")
            if hasattr(self, 'ric_imp_entry'):
                self.ricorrenza_popup.after(100, self.ric_imp_entry.focus_set) 
            return
        self.ricorrenza_popup = tk.Toplevel(self, bg=self.COLOR_TOPLEVEL)
        self.ricorrenza_popup.title("Gestione Ricorrenze")
        self.ricorrenza_popup.resizable(False, False)
        self.ricorrenza_popup.protocol(
            "WM_DELETE_WINDOW", 
            lambda: (
                self.ricorrenza_popup.withdraw(), 
                (self.popup_calendario.destroy(), setattr(self, 'popup_calendario', None))
                if hasattr(self, 'popup_calendario') and self.popup_calendario and self.popup_calendario.winfo_exists()
                else None,
                setattr(self, 'ricorrenza_bloccata', False) 
            )
        )
        self.ricorrenza_bloccata = False
        self.ricorrenza_popup.bind(
            "<Escape>", 
            lambda event: (
                self.ricorrenza_popup.withdraw(),
                (self.popup_calendario.destroy(), setattr(self, 'popup_calendario', None))
                if hasattr(self, 'popup_calendario') and self.popup_calendario and self.popup_calendario.winfo_exists()
                else None,
                setattr(self, 'ricorrenza_bloccata', False) 
            )
        )
        window_width = 650
        window_height = 250
        screen_width = self.winfo_screenwidth()
        screen_height = self.winfo_screenheight()
        center_x = int(screen_width/2 - window_width/2)
        center_y = int(screen_height/2 - window_height/2)
        self.ricorrenza_popup.geometry(f'{window_width}x{window_height}+{center_x}+{center_y}')
        if not hasattr(self, 'importo_ricorrenza'):
            self.importo_ricorrenza = tk.StringVar()
            self.ricorrenza_tipo = tk.StringVar(value="Nessuna")
            self.ricorrenza_n = tk.IntVar(value=1)
            self.ricorrenza_data_inizio = tk.StringVar(value=oggi)
            self.ricorrenza_cat_sel = tk.StringVar(value=self.categorie[0])
            self.ricorrenza_desc = tk.StringVar()
            self.ricorrenza_imp = tk.StringVar()
            self.ricorrenza_tipo_voce = tk.StringVar(value="Uscita")
            self.ricorrenza_bloccata = False
        def on_ric_cat_selected(event=None, manuale=True):
            if manuale:
                self.ricorrenza_bloccata = True
                self.label_smartcat_ric.config(text="üõ†Ô∏è SmartCat disattivata", foreground="green")
                self.ric_percentuali_label.config(text="0% Entrate / 0% Uscite")
            categoria = self.ricorrenza_cat_sel.get()
            tipo = self.categorie_tipi.get(categoria, "Uscita")
            self.ricorrenza_tipo_voce.set(tipo)
            self.aggiorna_stile_tipo_voce_popup()
            if self.ricorrenza_bloccata:
                self.ric_cat_menu.configure(style="Border.TCombobox")
        def aggiorna_categoria_automatica_ricorrenza(*args):
            valore_imp = self.ricorrenza_imp.get().replace(",", ".").strip()
            if not valore_imp:
                self.ric_percentuali_label.config(text="0% Entrate / 0% Uscite")
                self.ricorrenza_bloccata = False
                self.ricorrenza_cat_sel.set("Generica")
                self.ricorrenza_tipo_voce.set("Uscita")
                self.aggiorna_stile_tipo_voce_popup()
                self.label_smartcat_ric.config(text="üõ†Ô∏è SmartCat in attesa...", foreground="gray")
                self.ric_cat_menu.configure(style="Border.TCombobox")
                return
            if self.ricorrenza_bloccata:
                return
            try:
                imp_corrente = float(valore_imp)
            except ValueError:
                self.ric_percentuali_label.config(text="0% Entrate / 0% Uscite")
                return
            oggi_ric = datetime.date.today()
            un_anno_fa = oggi_ric - datetime.timedelta(days=365)
            frequenze_per_categoria_tipo = {}
            for d, lista in self.spese.items():
                if d < un_anno_fa:
                    continue
                for voce in lista:
                    try:
                        categoria, _, importo, tipo = voce[:4]
                        if categoria not in frequenze_per_categoria_tipo:
                            frequenze_per_categoria_tipo[categoria] = {"Entrata": 0, "Uscita": 0, "importi": []}
                        frequenze_per_categoria_tipo[categoria][tipo] += 1
                        frequenze_per_categoria_tipo[categoria]["importi"].append(importo)
                    except (ValueError, IndexError):
                        continue
            if not self.suggerimenti_attivi:
                self.ricorrenza_bloccata = False
                self.label_smartcat_ric.config(text="üõ†Ô∏è SmartCat disattivata", foreground="green")
                self.ric_cat_menu.configure(style="Border.TCombobox")
                categoria_selezionata = self.ricorrenza_cat_sel.get()
                percentuale_entrate, percentuale_uscite = 0.0, 0.0
                if categoria_selezionata in frequenze_per_categoria_tipo:
                    conteggi = frequenze_per_categoria_tipo[categoria_selezionata]
                    totale = conteggi["Entrata"] + conteggi["Uscita"]
                    if totale > 0:
                        percentuale_entrate = (conteggi["Entrata"] / totale) * 100
                        percentuale_uscite = (conteggi["Uscita"] / totale) * 100
                self.ric_percentuali_label.config(text=f'{percentuale_entrate:.0f}% Entrate / {percentuale_uscite:.0f}% Uscite')
                return
            miglior_punteggio = float("inf")
            categoria_migliore = None
            if frequenze_per_categoria_tipo:
                for categoria, dati in frequenze_per_categoria_tipo.items():
                    if not dati["importi"]:
                        continue
                    media_importi = sum(dati["importi"]) / len(dati["importi"])
                    diff = abs(media_importi - imp_corrente)
                    bonus_frequenza = math.log(dati["Entrata"] + dati["Uscita"] + 1) * 0.5
                    punteggio = diff - bonus_frequenza
                    if punteggio < miglior_punteggio:
                        miglior_punteggio = punteggio
                        categoria_migliore = categoria
            if categoria_migliore and not self.ricorrenza_bloccata:
                self.ricorrenza_cat_sel.set(categoria_migliore)
                conteggi = frequenze_per_categoria_tipo.get(categoria_migliore, {"Entrata": 0, "Uscita": 0})
                totale = conteggi["Entrata"] + conteggi["Uscita"]
                if totale > 0:
                    percentuale_entrate = (conteggi["Entrata"] / totale) * 100
                    percentuale_uscite = (conteggi["Uscita"] / totale) * 100
                else:
                    percentuale_entrate, percentuale_uscite = 0.0, 0.0
                colore_percentuale = "black"
                if percentuale_entrate > percentuale_uscite:
                    colore_percentuale = "forestgreen"
                elif percentuale_uscite > percentuale_entrate:
                    colore_percentuale = "firebrick"
                self.ric_percentuali_label.config(
                    text=f'{percentuale_entrate:.0f}% Entrate / {percentuale_uscite:.0f}% Uscite',
                    foreground=colore_percentuale
                )
                on_ric_cat_selected(manuale=False)
                self.label_smartcat_ric.config(text="üí° SmartCat attiva", foreground="red")
                self.ric_cat_menu.configure(style="Highlight.TCombobox")
                self.ric_cat_menu.after(500, lambda: self.ric_cat_menu.configure(style="Border.TCombobox"))
                self.label_smartcat_ric.config(text="üí° SmartCat attiva", foreground="red")
                self.ric_cat_menu.configure(style="Highlight.TCombobox")
                self.ric_cat_menu.after(2000, lambda: self.ric_cat_menu.configure(style="Border.TCombobox"))
        self.ricorrenza_imp.trace_add("write", aggiorna_categoria_automatica_ricorrenza)
        ric_frame = ttk.LabelFrame(self.ricorrenza_popup, text="üîÑ Pianificazione Ricorrenze", style="RedBold.TLabelframe")
        ric_frame.pack(padx=10, pady=10, fill="both", expand=True)
        row = 0
        ttk.Label(ric_frame, text="üîç Categoria:").grid(row=row, column=0, sticky="e", padx=2, pady=2)
        self.ric_cat_menu = ttk.Combobox(ric_frame, textvariable=self.ricorrenza_cat_sel, values=sorted(self.categorie), state="readonly", style="Border.TCombobox", width=22, font=("Arial", 10, "bold"))
        self.ric_cat_menu.grid(row=row, column=1, sticky="w", padx=2, pady=2)
        self.ric_cat_menu.bind("<<ComboboxSelected>>", on_ric_cat_selected)
        info_frame = ttk.Frame(ric_frame)
        info_frame.grid(row=row, column=2, columnspan=5, sticky="w", padx=2, pady=2)
        self.label_smartcat_ric = ttk.Label(info_frame, text="üõ†Ô∏è SmartCat in attesa...", foreground="gray")
        self.label_smartcat_ric.pack(side="left", padx=2, pady=2)
        row += 1
        ttk.Label(ric_frame, text="üí∞ Importo (‚Ç¨):").grid(row=row, column=0, sticky="e", padx=2, pady=2)
        ttk.Button(ric_frame, text="üõ†", style="Yellow.TButton", command=self.apri_calcolatrice).grid(row=row, column=1, sticky="e", padx=2, pady=2)
        def convalida_importo(valore):
            if valore == "":
              return True  
            import re
            return len(valore) <= 7 and re.fullmatch(r"^\d*[.,]?\d{0,2}$", valore) is not None
        vcmd_importo = ric_frame.register(convalida_importo)  
        self.ric_imp_entry = ttk.Entry(ric_frame, width=20, textvariable=self.ricorrenza_imp, validate="key", validatecommand=(vcmd_importo, "%P"))  
        self.ric_imp_entry.grid(row=row, column=1, sticky="w", padx=2, pady=2)
        self.ric_imp_entry.focus_set()
        
        def start_blinking_callback_ric(event):
            if hasattr(self, 'lbl_ric_inizio'):
                self.start_blinking(self.lbl_ric_inizio)
            if self.STATO_CORRENTE != 0:
                self.mostra_treeview_statistiche()
        def stop_blinking_callback_ric(event):
            if hasattr(self, 'lbl_ric_inizio'):
                self.stop_blinking(self.lbl_ric_inizio)

        self.ric_imp_entry.bind('<FocusIn>', start_blinking_callback_ric)
        self.ric_imp_entry.bind('<FocusOut>', stop_blinking_callback_ric)
        self.ric_percentuali_label = ttk.Label(info_frame, text="0% Entrate / 0% Uscite")
        self.ric_percentuali_label.pack(side="left", padx=2, pady=2)
        row += 1
        ttk.Label(ric_frame, text="‚ÑπÔ∏è Descrizione:").grid(row=row, column=0, sticky="e", padx=2, pady=2)
        
        def convalida_descrizione(valore):
            return len(valore) <= 30
        vdesc = ric_frame.register(convalida_descrizione)
        self.ric_desc_entry = ttk.Entry(ric_frame, width=25, textvariable=self.ricorrenza_desc, validate="key", validatecommand=(vdesc, "%P"))
        self.ric_desc_entry.grid(row=row, column=1, sticky="w", padx=2, pady=2)
        row += 1
        ttk.Label(ric_frame, text="Tipo:").grid(row=row, column=0, sticky="e", padx=2, pady=2)
        self.ricorrenza_tipo_voce.set("Uscita")
        def toggle_tipo_voce():
            tipo_corrente = self.ricorrenza_tipo_voce.get()
            nuovo_tipo = "Entrata" if tipo_corrente == "Uscita" else "Uscita"
            self.ricorrenza_tipo_voce.set(nuovo_tipo)
            self.aggiorna_stile_tipo_voce_popup()
        def aggiorna_stile_tipo_voce_popup():
            tipo = self.ricorrenza_tipo_voce.get()
            if tipo == "Entrata":
                stile_da_applicare = "GreenOutline.TButton"
            else:
                stile_da_applicare = "RedOutline.TButton"
            self.btn_tipo_voce.config(
                text=tipo,
                style=stile_da_applicare
            )
        self.btn_tipo_voce = ttk.Button(
            ric_frame,
            text=self.ricorrenza_tipo_voce.get(),
            command=toggle_tipo_voce,
            style=("GreenOutline.TButton" if self.ricorrenza_tipo_voce.get() == "Entrata" else "RedOutline.TButton")
        )
        self.btn_tipo_voce.grid(row=row, column=1, sticky="w", padx=2, pady=2)
        self.aggiorna_stile_tipo_voce_popup = aggiorna_stile_tipo_voce_popup
        self.aggiorna_stile_tipo_voce_popup()
        row += 1
        ripeti_frame = ttk.Frame(ric_frame)
        ripeti_frame.grid(row=row, column=0, columnspan=6, sticky="w", padx=2, pady=2)
        ttk.Label(ripeti_frame, text="üìÖ Ripeti:").pack(side="left", padx=2, pady=2)
        self.ric_combo = ttk.Combobox(ripeti_frame, values=["Nessuna", "Ogni giorno", "Ogni mese", "Ogni anno"], width=10, state="readonly", style="Border.TCombobox", textvariable=self.ricorrenza_tipo)
        self.ric_combo.pack(side="left", padx=2, pady=2)
        ttk.Label(ripeti_frame, text="Ripeti volte:").pack(side="left", padx=10, pady=2)

        def convalida_ric_n(valore):
            if valore == "":
                self.ricorrenza_n.set(1) 
                return True
            try:
                n = int(valore)
                return True
            except ValueError:
                self.ricorrenza_n.set(1)
                return False
        self.ric_n_entry = ttk.Entry(
            ripeti_frame,
            width=4,
            textvariable=self.ricorrenza_n,
        )
        self.ric_n_entry.pack(side="left", padx=2, pady=2)
        self.ric_n_entry.bind("<FocusOut>", lambda event: convalida_ric_n(self.ricorrenza_n.get()))
        self.ric_n_entry.bind("<Return>", lambda event: convalida_ric_n(self.ricorrenza_n.get()))
        self.ric_n_entry.bind("<KP_Enter>", lambda event: convalida_ric_n(self.ricorrenza_n.get()))
        self.lbl_ric_inizio = ttk.Label(ripeti_frame, text="Data Inizio:", style="BlinkAllarme.TLabel")
        self.lbl_ric_inizio.pack(side="left", padx=10, pady=2) 
        ric_data_frame = ttk.Frame(ripeti_frame)
        ric_data_frame.pack(side="left")
        self.ric_data_entry = ttk.Entry(ric_data_frame, textvariable=self.ricorrenza_data_inizio, width=15, font=("Arial", 10, "bold"))
        self.ric_data_entry.pack(side="left") 
        btn_cal_popup = ttk.Button(
            ric_data_frame,
            text="üìÖ",
            command=lambda: self.mostra_calendario_popup(self.ric_data_entry, self.ricorrenza_data_inizio),
            style="Yellow.TButton"
        )
        btn_cal_popup.pack(side="left", padx=4)
        self.btn_reset_ric_data = ttk.Button(
            ric_data_frame,
            text="‚Ü∫",
            command=self.reset_ric_data_inizio,
            style="Yellow.TButton"
        )
        self.btn_reset_ric_data.pack(side="left", padx=4)
        row += 1 
        btn_frame = tk.Frame(self.ricorrenza_popup, bg=self.COLOR_TOPLEVEL)
        btn_frame.pack(pady=10)
        self.btn_add_ricorrenza = ttk.Button(btn_frame, text="üìÇ Aggiungi", command=self.add_ricorrenza, style="Verde.TButton")
        self.btn_add_ricorrenza.pack(side="left", padx=4)
        self.btn_reset_ricorrenza = ttk.Button(btn_frame, text="‚Ü∫", width=2, style="Giallo.TButton", command=self.reset_ricorrenza_popup)
        self.btn_reset_ricorrenza.pack(side="left", padx=4)
        self.btn_modifica_ricorrenza = ttk.Button(btn_frame, text="‚ôªÔ∏è Lista", command=self.mostra_lista_ricorrenze, style="Arancio.TButton")
        self.btn_modifica_ricorrenza.pack(side="left", padx=4)
        self.btn_chiudi_ricorrenza = ttk.Button(btn_frame, text="‚ùå Chiudi", command=self.ricorrenza_popup.withdraw, style="Giallo.TButton")
        self.btn_chiudi_ricorrenza.pack(side="left", padx=4)
 
    # Gestione Promemoria
    def gestisci_promemoria(self):
        if hasattr(self, '_promemoria_popup') and self._promemoria_popup and self._promemoria_popup.winfo_exists():
            self._promemoria_popup.lift()
            return
        def chiudi_promemoria_popup():
            try:
                promemoria_popup.grab_release()
            except:
                pass 
            promemoria_popup.destroy()
            self._promemoria_popup = None
        def salva_promemoria():
            promemoria_text = promemoria_text_widget.get("1.0", tk.END).strip()
            data = {"promemoria": promemoria_text} 
            try:
                with open(PROMEMORIA_FILE, "w", encoding="utf-8") as f:
                    json.dump(data, f, indent=4)
                self.show_custom_warning("Salvataggio", "Promemoria salvato con successo!")
                chiudi_promemoria_popup()
            except Exception as e:
                self.show_custom_warning("Errore", f"Impossibile salvare il file: {e}")
        def carica_promemoria():
            if os.path.exists(PROMEMORIA_FILE):
                try:
                    with open(PROMEMORIA_FILE, "r", encoding="utf-8") as f:
                        data = json.load(f)
                    promemoria = data.get("promemoria", "")
                    promemoria_text_widget.delete("1.0", tk.END)
                    promemoria_text_widget.insert("1.0", promemoria)
                except (json.JSONDecodeError, FileNotFoundError) as e:
                    self.show_custom_warning("Errore", f"Impossibile caricare il file promemoria.json: {e}")
                    pass
        def esporta_promemoria():
            now = datetime.date.today()
            promemoria_text = promemoria_text_widget.get("1.0", tk.END).strip()
            filename = f"Promemoria_Export_{now.day:02d}-{now.month:02d}-{now.year}.txt"
            file = filedialog.asksaveasfilename(
                defaultextension=".txt",
                filetypes=[("File di testo", "*.txt"), ("Tutti i file", "*.*")],
                initialdir=EXPORT_FILES,
                initialfile=filename,
                title="Esporta Promemoria",
                confirmoverwrite=False,
                parent=promemoria_popup
            )
            if file:
                if os.path.exists(file):
                    conferma = self.show_custom_askyesno(
                        "Sovrascrivere file?",
                        f"Il file '{os.path.basename(file)}' \nesiste gi√†. Vuoi sovrascriverlo?"
                    )
                    if not conferma:
                        return
                
                try:
                    with open(file, "w", encoding="utf-8") as f:
                        f.write(promemoria_text)  
                    self.show_custom_warning("Esportazione", "Promemoria esportato con successo!")
                except Exception as e:
                    self.show_custom_warning("Errore", f"Impossibile salvare il file: {e}")
        if hasattr(self, 'popup_calendario') and self.popup_calendario and self.popup_calendario.winfo_exists():
            self.popup_calendario.destroy()
            self.popup_calendario = None
        promemoria_popup = tk.Toplevel(self)
        self._promemoria_popup = promemoria_popup
        promemoria_popup.title("üìù Promemoria")
        promemoria_popup.resizable(True, True)
        promemoria_popup.withdraw()
        promemoria_popup.transient(self)
        promemoria_popup.protocol("WM_DELETE_WINDOW", chiudi_promemoria_popup) 
        promemoria_popup.bind('<Escape>', lambda e: chiudi_promemoria_popup())
        main_frame = ttk.Frame(promemoria_popup, padding=10)
        main_frame.pack(fill="both", expand=True)
        main_frame.columnconfigure(0, weight=1)
        main_frame.columnconfigure(1, weight=1)
        main_frame.columnconfigure(2, weight=1) 
        main_frame.rowconfigure(0, weight=1)
        promemoria_text_widget = tk.Text(
            main_frame, 
            wrap="word", 
            width=50, 
            height=15, 
            bg="#ADD8E6",
            fg="black",
            selectforeground="white",
            relief=tk.FLAT,
            borderwidth=1
        )
        promemoria_text_widget.grid(row=0, column=0, columnspan=3, pady=(0, 10), sticky="nsew") 
        scrollbar = ttk.Scrollbar(main_frame, command=promemoria_text_widget.yview)
        scrollbar.grid(row=0, column=3, sticky='ns')
        promemoria_text_widget['yscrollcommand'] = scrollbar.set
        btn_salva_promemoria = ttk.Button(main_frame, text="‚úÖ Salva", command=salva_promemoria, style="Verde.TButton")
        btn_salva_promemoria.grid(row=1, column=0, padx=5, sticky="e") 
        center_btn_frame = ttk.Frame(main_frame)
        center_btn_frame.grid(row=1, column=1, padx=5, sticky="we")
        center_btn_frame.columnconfigure(0, weight=1)
        center_btn_frame.columnconfigure(1, weight=1)
        btn_stampa_promemoria = ttk.Button(
            center_btn_frame, 
            text="üñ®Ô∏è Stampa", 
            command=lambda: self._stampa_lista_diretta(
                promemoria_text_widget.get("1.0", tk.END).strip(),
                self.show_custom_warning
            ), 
            style="Blu.TButton"
        )
        btn_stampa_promemoria.grid(row=0, column=0, sticky="we") 
        btn_esporta_promemoria = ttk.Button(center_btn_frame, text="üìÑ Esporta", command=esporta_promemoria, style="Arancio.TButton")
        btn_esporta_promemoria.grid(row=0, column=1, sticky="we", padx=(5, 0))
        btn_cancella_promemoria = ttk.Button(main_frame, text="‚ùå Chiudi", command=chiudi_promemoria_popup, style="Giallo.TButton")
        btn_cancella_promemoria.grid(row=1, column=2, padx=5, sticky="w")
        carica_promemoria()
        self.update_idletasks() 
        window_width = 800  
        window_height = 400     
        app_x = self.winfo_rootx()
        app_y = self.winfo_rooty()
        app_width = self.winfo_width()
        app_height = self.winfo_height()
        center_x = app_x + (app_width // 2) - (window_width // 2)
        center_y = app_y + (app_height // 2) - (window_height // 2)
        promemoria_popup.geometry(f'{window_width}x{window_height}+{center_x}+{center_y}')
        promemoria_popup.deiconify() 
        promemoria_popup.grab_set()
        
    # Colora Giorni Cal in base al Movimento
    def colora_giorni_spese(self):
        if not os.path.exists(DB_FILE):
            return
        self.cal.calevent_remove('all')  
        try:
            with open(DB_FILE, "r", encoding="utf-8") as f:
                db = json.load(f)
        except Exception:
            return
        giornate = db.get("spese", [])  
        for giorno in giornate:
            try:
                data_str = giorno.get("date", "")
                entries = giorno.get("entries", [])
                if not entries: 
                    continue
                data = datetime.datetime.strptime(data_str, "%d-%m-%Y").date()
                entrate_dict = {}
                uscite_dict = {}
                tot_e = 0.0
                tot_u = 0.0
                for e in entries:
                    cat = e.get("category") or e.get("categoria") or "Varie"
                    tipo = str(e.get("tipo", "")).lower()
                    try:
                        importo = float(e.get("amount") or e.get("importo") or 0)
                    except:
                        importo = 0.0
                    if tipo == "entrata":
                        tot_e += importo
                        entrate_dict[cat] = entrate_dict.get(cat, 0.0) + importo
                    else:
                        tot_u += importo
                        uscite_dict[cat] = uscite_dict.get(cat, 0.0) + importo
                linee = []
                W = 38
                if entrate_dict:
                    val_tot_e = f"‚Ç¨ {tot_e:.2f}"
                    titolo_e = "‚ñ≤ SALDO (+):"
                    linee.append(f"{titolo_e.ljust(W - len(val_tot_e))}{val_tot_e}")
                    linee.append("‚îÄ" * W)
                    for c, v in entrate_dict.items():
                        val_str = f"{v:.2f}"
                        cat_formattata = f" {c}"
                        linee.append(f"{cat_formattata.ljust(W - len(val_str))}{val_str}")
                if uscite_dict:
                    if linee: 
                        linee.append("\n" + "‚îÄ" * W)
                    val_tot_u = f"‚Ç¨ {tot_u:.2f}"
                    titolo_u = "‚ñº SALDO (-):"
                    linee.append(f"{titolo_u.ljust(W - len(val_tot_u))}{val_tot_u}")
                    linee.append("‚îÄ" * W)
                    for c, v in uscite_dict.items():
                        val_str = f"{v:.2f}"
                        cat_formattata = f" {c}"
                        linee.append(f"{cat_formattata.ljust(W - len(val_str))}{val_str}")
                testo_tooltip = "\n" + "\n".join(linee)
                if tot_e > 0 and tot_u > 0:
                    tag = "misto"
                elif tot_e > 0:
                    tag = "verde"
                elif tot_u > 0:
                    tag = "rosso"
                else:
                    continue
                self.cal.calevent_create(data, testo_tooltip, tag)
            except Exception as e:
                print(f"Errore riga {data_str}: {e}")
                continue
        oggi = datetime.date.today()
        self.cal.calevent_create(oggi, "Oggi", "today")
        
    # Sincronizza Calendari    
    def on_calendar_change(self, event=None):
        self.mostra_treeview_statistiche()
        self.after(0, self.imp_entry.focus_set)
        try:
            data = self.cal.selection_get()
            if not data:
                return
            if not self.blocca_data_var.get():
                self.data_spesa_var.set(data.strftime("%d-%m-%Y"))
            mese_corrente = self.estratto_month_var.get()
            anno_corrente = self.estratto_year_var.get()
            mese_da_cal = f"{data.month:02d}"
            anno_da_cal = str(data.year)
            if mese_corrente != mese_da_cal:
                self.estratto_month_var.set(mese_da_cal)
                self.estratto_month_var.set(self.months[data.month - 1])
            if anno_corrente != anno_da_cal:
                self.estratto_year_var.set(anno_da_cal)
                self.estratto_year_var.set(anno_da_cal)
            self.after(100, lambda: self.apply_estratto("giorno"))
        except Exception as e:
            print(f"Errore durante il cambio data: {e}")
    
    # Sincronizza Calendari/imposta data inizio mese
    def on_month_changed(self, event=None):
        m, y = self.cal.get_displayed_month()
        primo = datetime.date(y, m, 1)
        if self.cal.selection_get() != primo:
            self.cal.selection_set(primo)
        if not self.blocca_data_var.get():
           self.data_spesa_var.set(primo.strftime("%d-%m-%Y"))
        self.estratto_month_var.set(self.months[m-1])
        self.estratto_year_var.set(str(y))
        self.apply_estratto("giorno")
    
    # Imposta Titolo Finestra
    def aggiorna_titolo_finestra(self):
        current_folder = os.path.basename(os.getcwd())
        self.title(f"üí∞ {NAME} Pro v {VERSION}  ‚Äî Email: helpcasafacilepro@gmail.com ‚Äî  Utente:‚ñ∫ {current_folder}")
    
    # Bottone Movimenti Simili
    def aggiorna_bottone_spese_simili(self, visibile=True):
        if visibile:
            if not self.btn_spese_simili.winfo_ismapped():
                self.btn_spese_simili.pack(side="left", padx=(6, 0))
        else:
            if self.btn_spese_simili.winfo_ismapped():
                self.btn_spese_simili.pack_forget()
    
    # SmartCat
    def aggiorna_categoria_automatica(self, event=None):
        if not self.suggerimenti_attivi:
            self.label_smartcat.config(text="üõ†Ô∏è SmartCat disattiva", foreground="green")
            self.aggiorna_bottone_spese_simili(visibile=False)
            return
        valore = self.imp_entry.get().replace(",", ".").strip()
        if not valore:
            self.categoria_bloccata = False
            self.aggiorna_bottone_spese_simili(visibile=False)
            self.cat_sel.set("Generica") 
            self.label_smartcat.config(text="üõ†Ô∏è SmartCat in attesa...", foreground="gray") 
            self.tipo_spesa_var.set("Uscita") 
            self.aggiorna_stile_tipo_spesa()
            self.lbl_tipo_percentuale.config(text="0% Entrate / 0% Uscite ")  
            return
        try:
            imp_corrente = float(valore)
        except ValueError:
            return
        oggi = datetime.date.today()
        un_anno_fa = oggi - datetime.timedelta(days=365)
        frequenze = {}
        spese_valide = []
        for d, lista in self.spese.items():
            if d < un_anno_fa:
                continue
            for voce in lista:
                try:
                    categoria, _, importo, _ = voce[:4]
                    frequenze[categoria] = frequenze.get(categoria, 0) + 1
                    spese_valide.append((categoria, importo))
                except ValueError:
                    continue
        if not spese_valide:
            return
        miglior_punteggio = float("inf")
        categoria_migliore = None
        categorie_gia_valutate = set()
        for categoria, importo in spese_valide:
            if categoria in categorie_gia_valutate:
                continue
            categorie_gia_valutate.add(categoria)
            diff = abs(importo - imp_corrente)
            bonus_frequenza = math.log(frequenze.get(categoria, 1)) * 0.5 # Il valore 0.5 pu√≤ essere regolato
            punteggio = diff - bonus_frequenza
            if punteggio < miglior_punteggio:
                miglior_punteggio = punteggio
                categoria_migliore = categoria
        if categoria_migliore and not self.categoria_bloccata:
            self.cat_sel.set(categoria_migliore)
            self.on_categoria_changed(manuale=False)
            self.label_smartcat.config(text="üí° SmartCat attiva", foreground="red")
            self.btn_spese_simili.pack(side="left", padx=(6, 0))
            self.cat_menu.configure(style="Highlight.TCombobox")
            self.cat_menu.after(500, lambda: self.cat_menu.configure(style="Border.TCombobox"))
         
    # Popup Movimenti Simili     
    def mostra_spese_simili(self):
        if hasattr(self, "popup_simili") and self.popup_simili.winfo_exists():
            self.popup_simili.lift()
            self.popup_simili.focus_force()
            return
        valore = self.imp_entry.get().replace(",", ".").strip()
        try:
            target = float(valore)
        except ValueError:
            self.show_custom_warning("Errore", "Importo mancante o non valido.")
            return
        tolleranza = int(self.spin_tolleranza.get()) if hasattr(self, "spin_tolleranza") else 10
        limite_basso = target - tolleranza
        limite_alto = target + tolleranza
        voci_simili = [
            (d, *voce)
            for d, lista in self.spese.items()
            for voce in lista
            if len(voce) >= 4 and isinstance(voce[2], (int, float)) and limite_basso <= voce[2] <= limite_alto
        ]
        if not voci_simili:
            self.show_custom_warning("Nessuna corrispondenza", "Nessuna spesa trovata con questo importo.")
            return
        popup = tk.Toplevel(self, bg=self.COLOR_TOPLEVEL)
        popup.title(f"Movimenti simili a ‚Ç¨{target:.2f}")
        popup.resizable(False, False)
        popup.bind("<Escape>", lambda e: popup.destroy())
        larghezza, altezza = 650, 460
        x = (popup.winfo_screenwidth() // 2) - (larghezza // 2)
        y = (popup.winfo_screenheight() // 2) - (altezza // 2)
        popup.geometry(f"{larghezza}x{altezza}+{x}+{y}")
        label_range = ttk.Label(
            popup,
            text=f"üîé Movimenti compresi tra ‚Ç¨{limite_basso:.2f} e ‚Ç¨{limite_alto:.2f}",
            style="White.TLabel"
        )
        label_range.pack(pady=(10, 4))
        ttk.Label(
            popup,
            text="üéØ Margine di tolleranza (‚Ç¨):",
            style="WhiteSmall.TLabel"
        ).pack(pady=(4, 2))
        tolleranza_var = tk.StringVar(value=str(tolleranza))
        def aggiorna_auto(*args):
            try:
                nuovo_tolleranza = int(tolleranza_var.get())
            except ValueError:
                return
            limite_basso = target - nuovo_tolleranza
            limite_alto = target + nuovo_tolleranza
            label_range.config(text=f"üîé Movimenti compresi tra ‚Ç¨{limite_basso:.2f} e ‚Ç¨{limite_alto:.2f}")
            nuove_voci = [
                (d, *voce)
                for d, lista in self.spese.items()
                for voce in lista
                if len(voce) >= 4 and isinstance(voce[2], (int, float)) and limite_basso <= voce[2] <= limite_alto
            ]
            for item in tree.get_children():
                tree.delete(item)
            nuove_voci.sort(key=lambda x: x[0], reverse=True)
            for voce in nuove_voci:
                try:
                    if len(voce) == 6:
                        data, categoria, descrizione, importo, tipo, _ = voce
                    else: 
                        data, categoria, descrizione, importo, tipo = voce
                    tag = "entrata" if tipo.lower() == "entrata" else "uscita"
                    tree.insert("", tk.END, values=(
                        data.strftime("%d-%m-%Y"),
                        tipo,
                        categoria,
                        descrizione,
                        f"‚Ç¨{importo:.2f}"
                    ), tags=(tag,))
                except Exception:
                    continue
        spin_tolleranza_popup = tk.Spinbox(
            popup,
            from_=0,
            to=100,
            increment=1,
            width=6,
            font=("Arial", 10),
            justify="center",
            textvariable=tolleranza_var
        )
        spin_tolleranza_popup.pack(pady=(0, 10))
        tolleranza_var.trace_add("write", aggiorna_auto)
        columns = ("data", "tipo", "categoria", "descrizione", "importo")
        headers = {
            "data": "Data",
            "tipo": "Tipo",
            "categoria": "Categoria",
            "descrizione": "Descrizione",
            "importo": "Importo"
        }
        tree_frame = ttk.Frame(popup)
        tree_frame.pack(padx=12, pady=(0, 6), fill="both", expand=True)
        vsb = ttk.Scrollbar(tree_frame, orient="vertical")
        vsb.pack(side="right", fill="y")
        hsb = ttk.Scrollbar(tree_frame, orient="horizontal")
        hsb.pack(side="bottom", fill="x")
        tree = ttk.Treeview(
            tree_frame, 
            columns=columns, 
            show="headings", 
            height=10,
            yscrollcommand=vsb.set,
            xscrollcommand=hsb.set
        )
        tree.pack(fill="both", expand=True)
        tree.bind("<Double-1>", lambda e: usa_categoria())
        vsb.config(command=tree.yview)
        hsb.config(command=tree.xview)
        for col in columns:
            tree.heading(col, text=headers[col], command=lambda c=col: sort_column(tree, c, False))
        tree.column("data", width=90, anchor="center")
        tree.column("tipo", width=80, anchor="center")
        tree.column("categoria", width=120, anchor="w")
        tree.column("descrizione", width=220, anchor="w")
        tree.column("importo", width=80, anchor="e")
        voci_simili.sort(key=lambda x: x[0], reverse=True)
        for voce in voci_simili:
            try:
                if len(voce) == 6:
                    data, categoria, descrizione, importo, tipo, _ = voce
                else: 
                    data, categoria, descrizione, importo, tipo = voce
                
                tag = "entrata" if tipo.lower() == "entrata" else "uscita"
                tree.insert("", tk.END, values=(
                    data.strftime("%d-%m-%Y"),
                    tipo,
                    categoria,
                    descrizione,
                    f"‚Ç¨{importo:.2f}"
                ), tags=(tag,))
            except Exception as e:
                print(f"[Voce malformata]: {voce} ‚Üí {e}")
                continue
        tree.tag_configure("entrata", foreground="green")
        tree.tag_configure("uscita", foreground="red")
        def usa_categoria():
            selezione = tree.selection()
            if not selezione:
                self.show_custom_warning("Attenzione", "Seleziona una spesa per copiarne la categoria.")
                return
            valori = tree.item(selezione[0], "values")
            self.cat_sel.set(valori[2])
            self.on_categoria_changed(manuale=True)
            popup.destroy()
        btn_frame = tk.Frame(popup, bg=self.COLOR_TOPLEVEL)
        btn_frame.pack(pady=(4, 12))
        ttk.Button(btn_frame, text="üì• Usa questa categoria", style="Blu.TButton", command=usa_categoria).pack(side="left", padx=8)
        ttk.Button(btn_frame, text="‚ùå Chiudi", style="Giallo.TButton", command=popup.destroy).pack(side="left", padx=8)
        def sort_column(tv, col, reverse):
            def extract(val):
                try:
                    if col == "importo":
                        return float(val.replace("‚Ç¨", "").replace(",", "").strip())
                    elif col == "data":
                        return datetime.datetime.strptime(val, "%d-%m-%Y")
                    return str(val).lower()
                except:
                    return val
            idx = columns.index(col)
            dati = [(tv.item(k)["values"], k) for k in tv.get_children()]
            try:
                dati.sort(key=lambda x: extract(x[0][idx]), reverse=reverse)
            except Exception as e:
                print(f"[Errore ordinamento '{col}']: {e}")
                return
            for i, (valori, k) in enumerate(dati):
                tv.move(k, "", i)
            tv.heading(col, command=lambda: sort_column(tv, col, not reverse))

    # Carica Geometria Finestra
    def load_window_geometry(self):
        self._window_geometry = None 
        if not self.salva_geometria:
            return 
        if not os.path.exists(DB_FILE):
            return
        try:
            with open(DB_FILE, "r", encoding="utf-8") as f:
                data = json.load(f)
                self._window_geometry = data.get("_window_geometry", None)
        except Exception:
            self._window_geometry = None
    # Salva Geometria Finestra
    def save_window_geometry(self):
        if not self.salva_geometria:
            return
        geometry = self.geometry()
        self._window_geometry = geometry
        try:
            data = {}
            if os.path.exists(DB_FILE):
                with open(DB_FILE, "r", encoding="utf-8") as f:
                    data = json.load(f) 
            data["_window_geometry"] = geometry 
            with open(DB_FILE, "w", encoding="utf-8") as f:
                json.dump(data, f, indent=2, ensure_ascii=False)
        except Exception as e:
            print("Errore salvataggio geometria finestra:", e)

    # Rilascio del lock file e pulizia all'uscita (Non-Windows)
    def _on_close_lock(self):
        try:
            if sys.platform != "win" and _lock_file_handle:
                _lock_file_handle.close()
                lock_dir = os.path.dirname(os.path.abspath(sys.argv[0]))
                lock_file_path = os.path.join(lock_dir, 'casa_facile.lock')
                if os.path.exists(lock_file_path):
                    os.remove(lock_file_path)
                    print("üóëÔ∏è File di lock cancellato.")
        except Exception as e:
            print(f"‚ö†Ô∏è Errore durante la pulizia del lock file: {e}")

    # Gestore della chiusura pulita dell'applicazione (Cleanup e Uscita)
    def _on_close(self):
        print("üîö Chiusura dell'app in corso...")
        self.save_window_geometry()
        self.save_db()
        try:
            if hasattr(self, "server"):
                self.server.shutdown()
                self.server.server_close()
                print("üåê Web server chiuso.")
            else:
                print("üåê Nessun web server attivo.")
        except Exception as e:
            print(f"‚ö†Ô∏è Web server non attivo o errore in chiusura: {e}")
        try:
            self.destroy()
        except Exception as e:
            print(f"‚ö†Ô∏è Errore nella chiusura della GUI: {e}")
        self._on_close_lock()
        sys.exit(0)

    # Memoria Categorie per importazione Estratto
    def carica_memoria_descrizioni(self):
        if os.path.exists(MEM_CAT):
           with open(MEM_CAT, "r", encoding="utf-8") as f:
            self.memoria_descrizioni_categoria = json.load(f)
        else:
            self.memoria_descrizioni_categoria = {}

    # Caricamento del database JSON e inizializzazione dei dati applicativi 
    def load_db(self):
        if not os.path.exists(DB_FILE):
            self.db = {
                "categorie": ["Generica"],
                "categorie_tipi": {"Generica": "Uscita"},
                "spese": [],
                "ricorrenze": {},
                "_window_geometry": None
            }
            self.categorie = self.db["categorie"]
            self.categorie_tipi = self.db["categorie_tipi"]
            self.spese = {}
            self.ricorrenze = self.db["ricorrenze"]
            self._window_geometry = self.db["_window_geometry"]
            return
        try:
            with open(DB_FILE, "r", encoding="utf-8") as f:
                self.db = json.load(f)
            self.categorie = self.db.get("categorie", ["Generica"])
            self.categorie_tipi = self.db.get("categorie_tipi", {"Generica": "Uscita"})
            self.spese = {}
            for obj in self.db.get("spese", []):
                d = datetime.datetime.strptime(obj["date"], "%d-%m-%Y").date()
                entries = []
                for e in obj.get("entries", []):
                    if "id_ricorrenza" in e:
                        entries.append((e["categoria"], e["descrizione"], float(e["importo"]), e["tipo"], e["id_ricorrenza"]))
                    else:
                        entries.append((e["categoria"], e["descrizione"], float(e["importo"]), e["tipo"]))
                self.spese[d] = entries
            self.ricorrenze = self.db.get("ricorrenze", {})
            self._window_geometry = self.db.get("_window_geometry", None)
            self.carica_saldo()
        except Exception as e:
            print("Errore caricamento DB:", e)
            self.db = {
                "categorie": ["Generica"],
                "categorie_tipi": {"Generica": "Uscita"},
                "spese": [],
                "ricorrenze": {},
                "_window_geometry": None
            }
            self.categorie = self.db["categorie"]
            self.categorie_tipi = self.db["categorie_tipi"]
            self.spese = {}
            self.ricorrenze = {}
            self._window_geometry = None
            self.carica_saldo()
            
    # Salvataggio del database JSON e dei dati applicativi
    def save_db(self):
        ten_years_ago = datetime.date.today() - datetime.timedelta(days=365 * ANNI_DA_MANTENERE)
        spese_da_rimuovere = [d for d in self.spese.keys() if d < ten_years_ago]
        for d in spese_da_rimuovere:
            del self.spese[d]
        categorie_tipi_ordinati = dict(sorted(self.categorie_tipi.items()))
        CATEGORIA_PRIORITARIA = "Generica"
        categorie_temporanee = sorted([c for c in self.categorie if c != CATEGORIA_PRIORITARIA])
        categorie_ordinate = []
        if CATEGORIA_PRIORITARIA in self.categorie:
            categorie_ordinate.append(CATEGORIA_PRIORITARIA)
        categorie_ordinate.extend(categorie_temporanee)
        data = {
            "categorie": categorie_ordinate ,
            "categorie_tipi": categorie_tipi_ordinati,
            "spese": [
                {"date": d.strftime("%d-%m-%Y"), "entries": [
                    {"categoria": c, "descrizione": desc, "importo": imp, "tipo": tipo, **({"id_ricorrenza": rid} if len(entry) == 5 else {})}
                        for entry in sp
                        for c, desc, imp, tipo, *rest in [entry]
                        for rid in [rest[0] if rest else None]
                ]} for d, sp in self.spese.items()
            ],
            "ricorrenze": self.ricorrenze
        }
        if self._window_geometry is not None:
            data["_window_geometry"] = self._window_geometry
        else:
            try:
                data["_window_geometry"] = self.geometry()
            except Exception:
                pass
        with open(DB_FILE, "w", encoding="utf-8") as f:
            json.dump(data, f, indent=2, ensure_ascii=False)
        with open(MEM_CAT, "w", encoding="utf-8") as f:
            json.dump(self.memoria_descrizioni_categoria, f, ensure_ascii=False, indent=2)
            
    # Ripristino dello stato predefinito del modulo di inserimento spesa
    def reset_form(self):
        today = datetime.date.today()
        self.data_spesa_var.set(today.strftime("%d-%m-%Y"))
        self.desc_entry.delete(0, tk.END)
        self.imp_entry.delete(0, tk.END)
        self.blocca_data_var.set(False)
        self.metodo_pagamento_var.set("")
        self.cat_sel.set(self.categorie[0])
        self.suggerimenti_attivi = True
        self.categoria_bloccata = False 
        self.on_categoria_changed(manuale=False) 
        self.btn_aggiungi["state"] = tk.NORMAL
        self.after(0, self.imp_entry.focus_set)
    
    # Toggle tra tipo 'Entrata' e 'Uscita' con aggiornamento visivo
    def toggle_tipo_spesa(self):
        v = self.tipo_spesa_var.get()
        nuovo = "Entrata" if v == "Uscita" else "Uscita"
        self.tipo_spesa_var.set(nuovo)
        self.btn_tipo_spesa.config(text=nuovo)
        new_style = 'GreenOutline.TButton' if nuovo == "Entrata" else 'RedOutline.TButton'
        self.btn_tipo_spesa.config(style=new_style)

    # Riordino e Aggiornamento delle Categorie nei Combobox
    def aggiorna_combobox_categorie(self):
        altre = sorted([c for c in self.categorie if c != "Generica"], key=str.lower)
        ordinata = ["Generica"] + altre if "Generica" in self.categorie else altre
        self.categorie = ordinata
        self.cat_menu["values"] = self.categorie
        self.cat_mod_menu["values"] = self.categorie
        if "Generica" in self.categorie:
            idx = self.categorie.index("Generica")
            self.cat_menu.current(idx)
            self.cat_mod_menu.current(idx)
        elif self.categorie:
            self.cat_menu.current(0)
            self.cat_mod_menu.current(0)

    # Sincronizzazione Tipo Voce (Entrata/Uscita) e Aggiornamento Stile UI
    def on_categoria_changed(self, event=None, manuale=True):
        if manuale:
            self.categoria_bloccata = True
        cat = self.cat_sel.get()
        tipo_cat = self.categorie_tipi.get(cat, "Uscita")
        self.tipo_spesa_var.set(tipo_cat)
        self.btn_tipo_spesa.config(text=tipo_cat)
        new_style = 'GreenOutline.TButton' if tipo_cat == "Entrata" else 'RedOutline.TButton'
        self.btn_tipo_spesa.config(style=new_style)
        tipo_cat_suggerito, perc_entrate, perc_uscite = self.suggerisci_tipo_categoria(cat)
        colore_percentuale = "gray"
        if perc_entrate > perc_uscite:
            colore_percentuale = "forestgreen"
        elif perc_uscite > perc_entrate:
            colore_percentuale = "firebrick"
        self.lbl_tipo_percentuale.config(
            text=f"{perc_entrate}% Entrate / {perc_uscite}% Uscite",
            foreground=colore_percentuale
        )
        self.label_smartcat.config(text="üõ†Ô∏è SmartCat disattiva", foreground="green")
        self.aggiorna_bottone_spese_simili(visibile=False)

    # Popup Mostra Categorie Attive
    def mostra_tutte_le_categorie(self):
        popup = tk.Toplevel(self, bg=self.COLOR_TOPLEVEL)
        popup.title("üìã Elenco Categorie")
        popup.resizable(False, False)
        popup_width = 320
        popup_height = 420
        screen_width = self.winfo_screenwidth()
        screen_height = self.winfo_screenheight()
        center_x = int((screen_width / 2) - (popup_width / 2))
        center_y = int((screen_height / 2) - (popup_height / 2))
        popup.geometry(f"{popup_width}x{popup_height}+{center_x}+{center_y}")
        popup.transient(self)
        popup.lift()
        popup.focus_force()
        popup.grab_set()
        popup.bind("<Escape>", lambda e: (popup.grab_release(), popup.destroy()))
        frame = ttk.Frame(popup, padding=10)
        frame.pack(fill="both", expand=True)
        label = ttk.Label(frame, text="Categorie disponibili:", font=("Arial", 11, "bold"))
        label.pack(pady=(0, 10))
        text_frame = ttk.Frame(frame)
        text_frame.pack(fill="both", expand=True)
        vsb = ttk.Scrollbar(text_frame, orient="vertical")
        vsb.pack(side="right", fill="y")
        text = tk.Text( 
            text_frame, 
            font=("Arial", 10), 
            height=18, 
            wrap="none", 
            state="normal",
            bg=self.COLOR_TOPLEVEL,
            fg=self.TEXT_COLOR,
            insertbackground=self.TEXT_COLOR,
            highlightthickness=0,
            yscrollcommand=vsb.set
        )
        text.pack(side="left", fill="both", expand=True)
        vsb.config(command=text.yview)
        text.tag_configure("entrata", foreground="green")
        text.tag_configure("uscita", foreground="red")
        for nome in sorted(self.categorie, key=lambda x: x.lower()):
            tipo = self.categorie_tipi.get(nome, "Uscita")
            riga = f"‚Ä¢ {nome}  ("
            text.insert("end", riga)
            if tipo == "Entrata":
                text.insert("end", tipo, "entrata")
            else:
                text.insert("end", tipo, "uscita")
            text.insert("end", ")\n")
        text.config(state="disabled") 
        btn_frame = tk.Frame(popup, bg=self.COLOR_TOPLEVEL)
        btn_frame.pack(pady=10)
        ttk.Button(btn_frame, text="‚ùå Chiudi", style='Giallo.TButton', command=lambda: (popup.grab_release(), popup.destroy()),).pack()

    # Gestione Completa delle Categorie (Aggiunta, Modifica, Eliminazione e Controllo Spese)
    def add_categoria(self):
        nome = self.nuova_cat.get().strip()
        tipo = self.tipo_categoria.get()
        if not nome or nome in self.categorie or nome == self.CATEGORIA_RIMOSSA:
            self.reset_campi_categoria()
            self.show_custom_warning("Attenzione", "Nome categoria vuoto, gi√† esistente o riservato.")
            return
        self.categorie.append(nome)
        self.categorie_tipi[nome] = tipo
        self.aggiorna_combobox_categorie()
        self.save_db()
        self.refresh_gui()
        self.reset_campi_categoria()  
        if hasattr(self, 'ricorrenza_popup') and self.ricorrenza_popup.winfo_exists():
            if hasattr(self, 'ric_cat_menu'):
                self.ric_cat_menu['values'] = sorted(self.categorie)
        self.show_custom_info("Attenzione", f"La categoria '{nome}' '{tipo}' √® stata aggiunta.")
    def modifica_categoria(self):
        old_nome = self.cat_mod_sel.get()
        if not old_nome:
            self.show_custom_warning("Attenzione", "Seleziona una categoria da modificare.")
            return
        if old_nome == "Generica":
         self.show_custom_warning("Attenzione", "La categoria 'Generica' non pu√≤ essere rinominata.")
         self.reset_campi_categoria()  
         return
        new_nome = self.nuova_cat.get().strip()
        if not new_nome:
            self.show_custom_warning("Attenzione", "Inserisci il nuovo nome della categoria.")
            return
        if new_nome == old_nome:
            tipo = self.tipo_categoria.get()
            self.categorie_tipi[new_nome] = tipo
            self.save_db()
            self.refresh_gui()
            self.show_custom_info("Info", f"Tipo categoria '{new_nome}' aggiornato a ''{tipo}'.")
            self.reset_campi_categoria()  
            return
        if new_nome in self.categorie:
            self.show_custom_warning("Attenzione", "Esiste gi√† una categoria con questo nome.")
            return
        idx = self.categorie.index(old_nome)
        self.categorie[idx] = new_nome
        nuovo_tipo = self.tipo_categoria.get()
        self.categorie_tipi[new_nome] = nuovo_tipo
        if new_nome != old_nome:
            self.categorie_tipi.pop(old_nome, None)
        for d in self.spese:
            new_entries = []
            for entry in self.spese[d]:
                if entry[0] == old_nome:
                    entry = (new_nome,) + entry[1:]
                new_entries.append(entry)
            self.spese[d] = new_entries
        self.cat_menu["values"] = self.categorie
        self.cat_mod_menu["values"] = self.categorie
        self.save_db()
        self.refresh_gui()
        self.show_custom_info("Attenzione", f"Categoria '{old_nome}' rinominata in '{new_nome}' '{nuovo_tipo}' .")
        self.aggiorna_combobox_categorie()
        self.reset_campi_categoria() 
        if hasattr(self, 'ricorrenza_popup') and self.ricorrenza_popup.winfo_exists():
            if hasattr(self, 'ric_cat_menu'):
                self.ric_cat_menu['values'] = sorted(self.categorie)
    def conferma_cancella_categoria(self, cat):
        popup = tk.Toplevel(self)
        popup.title("Conferma eliminazione")
        popup.resizable(False, False)
        width, height = 320, 160
        popup.withdraw()
        popup.update_idletasks()
        parent_x = self.winfo_rootx()
        parent_y = self.winfo_rooty()
        parent_w = self.winfo_width()
        parent_h = self.winfo_height()
        x = parent_x + (parent_w // 2) - (width // 2)
        y = parent_y + (parent_h // 2) - (height // 2)
        popup.geometry(f"{width}x{height}+{x}+{y}")
        popup.deiconify()
        popup.grab_set()
        popup.configure(bg="#FFFACD")
        messaggio_var = tk.StringVar()
        messaggio_var.set(
            f"Eliminare la categoria '{cat}'?\nI Movimenti saranno Mantenuti ma etichettati\n'{self.CATEGORIA_RIMOSSA}'."
        )
        label = tk.Label(
            popup,
            textvariable=messaggio_var,
            font=("Arial", 10),
            justify="center",
            wraplength=280,
            bg="#FFFACD"
        )
        label.pack(pady=8, padx=10)
        elimina_importi_var = tk.BooleanVar()
        def aggiorna_messaggio(*_):
            if elimina_importi_var.get():
                messaggio_var.set(
                    f"Eliminare la categoria '{cat}'?\nI Movimenti e gli importi saranno eliminati."
                )
            else:
                messaggio_var.set(
                    f"Eliminare la categoria '{cat}'?\nI Movimenti saranno etichettati '{self.CATEGORIA_RIMOSSA}'."
                )
        elimina_importi_var.trace_add("write", aggiorna_messaggio)
        tk.Checkbutton(
            popup,
            text="Elimina TUTTO anche gli importi associati",
            variable=elimina_importi_var,
            bg="#FFFACD",
            anchor="w",
            selectcolor="#FFFACD",
            activebackground="#FFFACD",
            highlightthickness=0,
            relief="flat",
            borderwidth=0
        ).pack(pady=(0, 6), padx=10, anchor="w")
        frame = tk.Frame(popup, bg="#FFFACD")
        frame.pack(pady=4)
        result = {"ok": False, "elimina_importi": False}
        def do_ok():
            result["ok"] = True
            result["elimina_importi"] = elimina_importi_var.get()
            popup.destroy()
        def do_cancel():
            popup.destroy()
        b1 = ttk.Button(frame, text="Elimina", style="Rosso.TButton", command=do_ok)
        b2 = ttk.Button(frame, text="Annulla", style="Giallo.TButton", command=do_cancel)
        b1.pack(side="left", padx=8)
        b2.pack(side="right", padx=8)
        popup.wait_window()
        return result
    def cancella_categoria(self):
        cat = self.cat_mod_sel.get()
        if not cat:
            self.show_custom_warning("Attenzione", "Seleziona una categoria da cancellare.")
            return
        if cat in ("Generica", self.CATEGORIA_RIMOSSA):
            self.show_custom_warning("Attenzione", f"Non puoi cancellare la categoria '{cat}'.")
            self.reset_campi_categoria()
            return
        conferma = self.conferma_cancella_categoria(cat)
        if not conferma["ok"]:
            return
        elimina_importi = conferma["elimina_importi"]
        if cat in self.categorie:
            self.categorie.remove(cat)
        if cat in self.categorie_tipi:
            del self.categorie_tipi[cat]
        for giorno in list(self.spese):
            nuove_spese = []
            for voce in self.spese[giorno]:
                voce_cat = voce[0]
                if voce_cat == cat:
                    if not elimina_importi:
                        nuove_spese.append((self.CATEGORIA_RIMOSSA,) + voce[1:])
                else:
                    nuove_spese.append(voce)
            if nuove_spese:
                self.spese[giorno] = nuove_spese
            else:
                del self.spese[giorno]
        self.save_db()
        self.refresh_gui()
        self.on_categoria_changed()
        self.aggiorna_combobox_categorie()
        self.reset_campi_categoria()
        if hasattr(self, 'ricorrenza_popup') and self.ricorrenza_popup.winfo_exists():
            if hasattr(self, 'ric_cat_menu'):
                self.ric_cat_menu['values'] = sorted(self.categorie)
    
    # Calcolatrice Interattiva
    def apri_calcolatrice(self):
        if hasattr(self, '_calcolatrice_popup') and self._calcolatrice_popup and self._calcolatrice_popup.winfo_exists():
            self._calcolatrice_popup.lift()
            return
        def chiudi_calcolatrice():
            calcolatrice.destroy()
            self._calcolatrice_popup = None          
        def inserisci(valore):
            entry_var.set(entry_var.get() + valore)
        def cancella():
            entry_var.set("")
            cronologia_text.config(state="normal")
            cronologia_text.delete("1.0", tk.END)
            cronologia_text.config(state="disabled")
        def calcola(event=None):
            try:
                espressione = entry_var.get().replace('%', '/100')
                risultato = eval(espressione)
                cronologia_text.config(state="normal")
                cronologia_text.insert(tk.END, f"{espressione} = {risultato}\n")
                cronologia_text.config(state="disabled")
                entry_var.set(str(risultato))
            except Exception:
                entry_var.set("Errore")
        def usa_risultato_ricorrenze():
            try:
                risultato = entry_var.get()
                self.ricorrenza_imp.set(risultato)
                chiudi_calcolatrice()
            except Exception as e:
                entry_var.set("Errore")
        def usa_risultato_principale():
            try:
                risultato = entry_var.get()
                self.imp_entry.delete(0, tk.END) 
                self.imp_entry.insert(0, risultato) 
                chiudi_calcolatrice()
            except Exception as e:
                entry_var.set("Errore")
        calcolatrice = tk.Toplevel(self, bg=self.COLOR_TOPLEVEL)
        self._calcolatrice_popup = calcolatrice
        calcolatrice.withdraw()
        calcolatrice.title("Calcolatrice")
        calcolatrice.resizable(True, True)
        calcolatrice.protocol("WM_DELETE_WINDOW", chiudi_calcolatrice) 
        calcolatrice.bind("<Escape>", lambda e: chiudi_calcolatrice())
        calcolatrice.bind("<Return>", calcola)
        calcolatrice.bind("<KP_Enter>", calcola)
        larghezza, altezza = 340, 340
        calcolatrice.update_idletasks()
        x = (calcolatrice.winfo_screenwidth() // 2) - (larghezza // 2)
        y = (calcolatrice.winfo_screenheight() // 2) - (altezza // 2)
        calcolatrice.geometry(f"{larghezza}x{altezza}+{x}+{y}")
        calcolatrice.deiconify()
        entry_var = tk.StringVar()
        entry = ttk.Entry(
            calcolatrice,
            textvariable=entry_var,
            font=("Arial", 16),
            justify="right"
        )
        entry.pack(fill="x", padx=10, pady=10)
        cronologia_text = tk.Text(
            calcolatrice, 
            height=4, 
            width=30, 
            wrap="word", 
            state="disabled",
            bg=self.COLOR_WIDGET_BG,
            fg=self.TEXT_COLOR,
            borderwidth=0,
            padx=5, pady=5
        )
        cronologia_text.pack(fill="x", padx=10, pady=(0, 10))
        tasti = [
            ["7", "8", "9", "/"],
            ["4", "5", "6", "*"],
            ["1", "2", "3", "-"],
            ["0", ".", "%", "+"]
        ]
        for riga in tasti:
            frame = ttk.Frame(calcolatrice)
            frame.pack(expand=True, fill="both")
            for tasto in riga:
                comando = lambda val=tasto: inserisci(val)
                stile_bottone = "Num.TButton" if tasto.isdigit() or tasto == "." else "Arancio.TButton"
                bottone = ttk.Button(
                    frame,
                    text=tasto,
                    style=stile_bottone,
                    command=comando
                )
                bottone.pack(side="left", expand=True, fill="both", padx=1, pady=1)
        frame_finale = ttk.Frame(calcolatrice)
        frame_finale.pack(fill="x", padx=10, pady=10)
        bottone_c = ttk.Button(
            frame_finale,
            text="C",
            style="Giallo.TButton",
            command=cancella
        )
        bottone_c.pack(side="left", expand=True, fill="x", padx=1)
        bottone_usa_ricorrenze = ttk.Button(
            frame_finale,
            text="Usa in Ricorrenze",
            style="Blu.TButton",
            command=usa_risultato_ricorrenze
        )
        bottone_usa_ricorrenze.pack(side="left", expand=True, fill="x", padx=1)
        bottone_usa_normale = ttk.Button(
            frame_finale,
            text="Usa in Principale",
            style="Blu.TButton",
            command=usa_risultato_principale
        )
        bottone_usa_normale.pack(side="left", expand=True, fill="x", padx=1)
        bottone_eq = ttk.Button(
            frame_finale,
            text="=",
            style="Verde.TButton",
            command=calcola
        )
        bottone_eq.pack(side="right", expand=True, fill="x", padx=1)
        
    # Popup Messaggi di Sistema
    def show_custom_warning(self, title, message):
        self._show_custom_message(title, message, "yellow", "black", "warning")
    def show_custom_info(self, title, message):
        self._show_custom_message(title, message, "lightblue", "black", "info")
    def show_custom_askyesno(self, title, message):
        dialog = tk.Toplevel(self, bg="orange")
        dialog.withdraw()
        dialog.title(title)
        dialog.resizable(False, False)
        dialog.grab_set()
        label = tk.Label(dialog, text=message, font=("Arial", 10), justify="left", padx=16, pady=12, bg="orange")
        label.pack()
        btns = tk.Frame(dialog, bg="orange")
        btns.pack(pady=(0,10))
        result = {"value": False}
        timer_data = {"id": None}
        def timeout_close():
            if timer_data["id"]:
                dialog.after_cancel(timer_data["id"])
            result["value"] = False
            dialog.destroy()
        def yes():
            if timer_data["id"]:
                dialog.after_cancel(timer_data["id"])
            result["value"] = True
            dialog.destroy()
        def no():
            if timer_data["id"]:
                dialog.after_cancel(timer_data["id"])
            result["value"] = False
            dialog.destroy()
        def update_timer(remaining_ms):
            remaining_s = int(remaining_ms / 1000)
            if remaining_s > 0:
                dialog.title(f"{title} ({remaining_s}s rim.)")
                timer_data["id"] = dialog.after(1000, update_timer, remaining_ms - 1000)
            else:
                timeout_close()
        b1 = ttk.Button(btns, text="S√¨", style="Verde.TButton", command=yes)
        b2 = ttk.Button(btns, text="No", style="Giallo.TButton", command=no)
        b1.grid(row=0, column=0, padx=8)
        b2.grid(row=0, column=1, padx=8)
        dialog.update_idletasks()
        w = dialog.winfo_reqwidth()
        h = dialog.winfo_reqheight()
        w = max(320, w)
        parent_x = self.winfo_rootx()
        parent_y = self.winfo_rooty()
        parent_w = self.winfo_width()
        parent_h = self.winfo_height()
        x = parent_x + (parent_w // 2) - (w // 2)
        y = parent_y + (parent_h // 2) - (h // 2)
        dialog.geometry(f"{w}x{h}+{x}+{y}")
        dialog.deiconify()
        dialog.lift()
        dialog.attributes("-topmost", True)
        if not USE_WAIT_WINDOW:
            update_timer(WARN_TIMEOUT) 
        dialog.wait_window()
        return result["value"]
    def _show_custom_message(self, title, message, bg, fg, icon=None):
        dialog = tk.Toplevel(self)
        dialog.attributes("-topmost", True)
        dialog.withdraw()  
        dialog.title(title)
        dialog.grab_set()
        dialog.resizable(False, False)
        timer_data = {"id": None}
        def close_dialog():
            if timer_data["id"]:
                dialog.after_cancel(timer_data["id"]) 
            dialog.destroy()
        def update_timer(remaining_ms):
            remaining_s = int(remaining_ms / 1000)
            if remaining_s > 0:
                dialog.title(f"{title} ({remaining_s}s rim.)") 
                timer_data["id"] = dialog.after(1000, update_timer, remaining_ms - 1000)
            else:
                dialog.destroy() 
        frame = tk.Frame(dialog, bg=bg)
        frame.pack(fill="both", expand=True)
        frame.pack_propagate(False) 
        label = tk.Label(frame, text=message, font=("Arial", 10), bg=bg, fg=fg, justify="left", padx=16, pady=12)
        label.pack(fill="x", expand=True)
        btn = ttk.Button(frame, text="OK", style="Verde.TButton", command=close_dialog)
        btn.pack(pady=(0, 15))
        btn.focus_set()
        dialog.bind("<Return>", lambda e: close_dialog())
        dialog.bind("<KP_Enter>", lambda e: close_dialog())
        dialog.bind("<Escape>", lambda e: close_dialog())
        dialog.update_idletasks() 
        msg_w = label.winfo_reqwidth() + 60
        width = max(msg_w, 350) 
        height = label.winfo_reqheight() + btn.winfo_reqheight() + 30
        parent_x = self.winfo_rootx()
        parent_y = self.winfo_rooty()
        parent_w = self.winfo_width()
        parent_h = self.winfo_height()
        x = parent_x + (parent_w // 2) - (width // 2)
        y = parent_y + (parent_h // 2) - (height // 2)
        dialog.geometry(f"{width}x{height}+{x}+{y}")
        dialog.deiconify() 
        if not USE_WAIT_WINDOW:
            update_timer(WARN_TIMEOUT) 
        if USE_WAIT_WINDOW:
            dialog.wait_window()
    
    # Ripristino del campo Data Spesa alla data odierna
    def reset_data_spesa(self):
        today = datetime.date.today()
        self.data_spesa_var.set(today.strftime("%d-%m-%Y"))
        
    # Ripristino della Data di Inizio Ricorrenza alla data
    def reset_ric_data_inizio(self):
        oggi = datetime.date.today()
        self.ricorrenza_data_inizio.set(oggi.strftime("%d-%m-%Y"))

    # Programmazione e Registrazione di Transazioni Ricorrenti (Ricorrenza)
    def add_ricorrenza(self):
        self.mostra_treeview_statistiche()
        self.after(0, self.imp_entry.focus_set)
        ric_type = self.ricorrenza_tipo.get()
        if ric_type == "Nessuna":
            self.show_custom_warning("Errore", "Seleziona un tipo di ricorrenza valido.")
            return
        try:
            n = int(self.ricorrenza_n.get())
            if n <= 0 or n > 365:
                raise ValueError
        except Exception:
            self.show_custom_warning("Errore", "Numero ripetizioni non valido (1-365)")
            return
        try:
            data_inizio = datetime.datetime.strptime(self.ricorrenza_data_inizio.get(), "%d-%m-%Y").date()
        except Exception:
            self.show_custom_warning("Errore", "Data inizio ricorrenza non valida")
            return
        cat = self.ricorrenza_cat_sel.get()
        desc = self.ricorrenza_desc.get().strip()
        try:
            imp_str = self.ricorrenza_imp.get().replace(",", ".")
            imp = float(imp_str)
            if imp <= 0:
                self.show_custom_warning("Errore", "L'importo non pu√≤ essere negativo.")
                return
        except Exception:
            self.show_custom_warning("Errore", "Importo mancante o non valido.")
            return
        tipo = self.ricorrenza_tipo_voce.get()
        self.ricorrenza_tipo_voce = self.tipo_spesa_var
        ric_id = str(uuid.uuid4())
        id_visibile = ric_id[:8]
        simbolo_ricorrenza = "‚ôªÔ∏è"
        if desc:
            desc = f"{simbolo_ricorrenza} {desc} ID:{id_visibile}"
        else:
            desc = f"{simbolo_ricorrenza} ID:{id_visibile}"
        date_list = []
        for i in range(n):
            if ric_type == "Ogni giorno":
                d = data_inizio + datetime.timedelta(days=i)
            elif ric_type == "Ogni mese":
                month = (data_inizio.month - 1 + i) % 12 + 1
                year = data_inizio.year + (data_inizio.month - 1 + i) // 12
                day = min(data_inizio.day, [31,
                    29 if year % 4 == 0 and (year % 100 != 0 or year % 400 == 0) else 28,
                    31, 30, 31, 30, 31, 31, 30, 31, 30, 31][month-1])
                try:
                    d = datetime.date(year, month, day)
                except Exception:
                    d = datetime.date(year, month, 1)
            elif ric_type == "Ogni anno":
                year = data_inizio.year + i
                try:
                    d = datetime.date(year, data_inizio.month, data_inizio.day)
                except Exception:
                    d = datetime.date(year, data_inizio.month, 1)
            else:
                break
            date_list.append(d)
        for d in date_list:
            if d not in self.spese:
                self.spese[d] = []
            self.spese[d].append((cat, desc, imp, tipo, ric_id))
        self.ricorrenze[ric_id] = {
            "tipo": ric_type,
            "n": n,
            "data_inizio": data_inizio.strftime("%d-%m-%Y"),
            "cat": cat,
            "desc": desc,
            "imp": imp,
            "tipo_voce": tipo,
            "date_list": [d.strftime("%d-%m-%Y") for d in date_list]
        }
        self.save_db()
        self.refresh_gui()
        self.show_custom_info("Ricorrenza Programmata", f"Sono state generate e registrate {n} nuove transazioni future in base alla ricorrenza definita.")
        oggi = datetime.date.today().strftime("%d-%m-%Y")
        self.importo_ricorrenza.set("")
        self.ricorrenza_tipo.set("Nessuna")
        self.ricorrenza_n.set(1)
        self.ricorrenza_data_inizio.set(oggi)
        self.ricorrenza_cat_sel.set(self.categorie[0])
        self.ricorrenza_desc.set("")
        self.ricorrenza_imp.set("")
        self.ricorrenza_tipo_voce.set("Uscita")
        self.btn_tipo_voce.config(text="Uscita", bg="#f2dede", fg="red")
      
    # Visualizzazione Dettagliata (Popup) delle Scadenze di una Ricorrenza
    def on_ricorrenza_double_click(self, event):
        tree = event.widget
        parent_window = tree.winfo_toplevel()
        item_id = tree.focus()
        if not item_id or item_id not in self.ricorrenze:
            return
        ricorrenza_dati = self.ricorrenze.get(item_id, {})
        if not ricorrenza_dati:
            return
        descrizione_ricorrenza = ricorrenza_dati.get("cat", "N/D")
        importo_ricorrenza = ricorrenza_dati.get("imp", 0.0)
        popup_movimenti = tk.Toplevel(parent_window)
        popup_movimenti.title(f"Movimenti di '{descrizione_ricorrenza}'")
        parent_x = parent_window.winfo_rootx()
        parent_y = parent_window.winfo_rooty()
        parent_width = parent_window.winfo_width()
        parent_height = parent_window.winfo_height()
        popup_width = 800
        popup_height = 500
        center_x = parent_x + (parent_width // 2) - (popup_width // 2)
        center_y = parent_y + (parent_height // 2) - (popup_height // 2)
        popup_movimenti.geometry(f"{popup_width}x{popup_height}+{center_x}+{center_y}")
        popup_movimenti.transient(parent_window)
        tree_movimenti = ttk.Treeview(
            popup_movimenti,
            columns=("data", "descrizione", "importo", "pagato", "da_pagare"),
            show="headings"
        )
        tree_movimenti.pack(fill="both", expand=True, padx=10, pady=10)
        tree_movimenti.heading("data", text="Data")
        tree_movimenti.heading("descrizione", text="Categoria")
        tree_movimenti.heading("importo", text="Importo")
        tree_movimenti.heading("pagato", text="Pagato")
        tree_movimenti.heading("da_pagare", text="Da Pagare")
        tree_movimenti.column("data", width=100)
        tree_movimenti.column("descrizione", width=300)
        tree_movimenti.column("importo", width=80)
        tree_movimenti.column("pagato", width=80)
        tree_movimenti.column("da_pagare", width=80)
        tree_movimenti.tag_configure("giallo", background="yellow", foreground="black")
        tree_movimenti.tag_configure("verde", foreground="darkgreen")
        tree_movimenti.tag_configure("rosso", foreground="darkred")
        tree_movimenti.tag_configure("grigio", foreground="gray", background="#f2f2f2")
        tree_movimenti.bind("<Double-1>", self.on_scadenza_doppio_click)
        oggi = datetime.date.today()
        ric_periodo = ricorrenza_dati.get("tipo", "").lower()
        n_volte = ricorrenza_dati.get("n", 0)
        data_inizio_str = ricorrenza_dati.get("data_inizio", "")
        data_inizio_obj = datetime.datetime.strptime(data_inizio_str, "%d-%m-%Y").date()
        for i in range(n_volte):
            if ric_periodo == "ogni mese":
                data_movimento = (data_inizio_obj.replace(day=1) + datetime.timedelta(days=32 * i)).replace(day=data_inizio_obj.day)
            elif ric_periodo == "ogni anno":
                anno_movimento = data_inizio_obj.year + i
                try:
                    data_movimento = data_inizio_obj.replace(year=anno_movimento)
                except ValueError:
                    data_movimento = data_inizio_obj.replace(year=anno_movimento, day=28)
            else:
                data_movimento = data_inizio_obj + datetime.timedelta(days=i)
            desc = ricorrenza_dati['cat']
            importo_effettivo = importo_ricorrenza
            voce_trovata = False
            if data_movimento in self.spese:
                for voce in self.spese[data_movimento]:
                    if len(voce) == 5 and voce[4] == item_id:
                        importo_effettivo = voce[2]
                        voce_trovata = True
                        break
            if voce_trovata:
                valore_importo = f"{importo_effettivo:,.2f} ‚Ç¨"
                tag = "rosso" if ricorrenza_dati['tipo_voce'] == "Uscita" else "verde"
            elif data_movimento <= oggi:
                valore_importo = "‚Äî"
                tag = "grigio"
            else:
                valore_importo = "‚Äî"
                tag = "giallo"
            tree_movimenti.insert(
                "",
                "end",
                values=(
                    data_movimento.strftime("%d-%m-%Y"),
                    desc,
                    valore_importo,
                    ricorrenza_dati['tipo_voce'] if voce_trovata else "‚ùå",
                    "‚ùå" if data_movimento <= oggi else ricorrenza_dati['tipo_voce']
                ),
                tags=(tag,)
            )
        info_frame = ttk.Frame(popup_movimenti, padding=(10, 5))
        info_frame.pack(fill="x", expand=False)
        info_text = (
            f"Dettagli ricorrenza: {descrizione_ricorrenza} - "
            f"Importo: {importo_ricorrenza:,.2f} ‚Ç¨ - "
            f"Periodo: {ricorrenza_dati.get('tipo', 'N/D')} - "
            f"Durata: {n_volte} volte"
        )
        ttk.Label(info_frame, text=info_text, font=("Arial", 10)).pack(side="left")
        ttk.Button(info_frame, text="‚ùå Chiudi", command=popup_movimenti.destroy, style='Giallo.TButton').pack(side="right", padx=5)
        popup_movimenti.bind("<Escape>", lambda e: popup_movimenti.destroy())
    
    # Gestore dell'Inserimento di una Singola Transazione
    def add_spesa(self):
        self.mostra_treeview_statistiche()
        self.after(0, self.imp_entry.focus_set)
        if hasattr(self, 'ricorrenza_tipo') and self.ricorrenza_tipo.get() != "Nessuna":
            self.add_ricorrenza()
            return
        data = self.data_spesa_var.get()
        cat = self.cat_sel.get()
        desc = self.desc_entry.get().strip()
        try:
            imp = float(self.imp_entry.get().replace(",", "."))
        except ValueError:
            self.show_custom_warning("Errore", "Importo mancante o non valido.")
            return
        tipo = self.tipo_spesa_var.get()
        try:
            d = datetime.datetime.strptime(data, "%d-%m-%Y").date()
        except ValueError:
            self.show_custom_warning("Errore", "Formato data non valido.")
            return
        if d not in self.spese:
            self.spese[d] = []
        self.spese[d].append((cat, desc, imp, tipo))
        self.desc_entry.delete(0, tk.END)
        self.imp_entry.delete(0, tk.END)
        self.save_db()
        self.reset_modifica_form()
        self.refresh_gui()
        if not self.blocca_data_var.get():
            self.data_spesa_var.set(datetime.date.today().strftime("%d-%m-%Y"))
        self.categoria_bloccata = False
        self.label_smartcat.config(text="üõ†Ô∏è SmartCat attiva", foreground="red")
        self.metodo_pagamento_var.set("")
        def destroy_window_and_cleanup():
            if hasattr(self, 'lista_window_ref') and self.lista_window_ref.winfo_exists():
                self.lista_window_ref.destroy() 
                delattr(self, 'lista_window_ref')
            self.refresh_gui() 
            self.ricorrenza_cat_sel.set(self.categorie[0]) 
            self.ricorrenza_tipo_voce.set("Uscita")
            self.btn_tipo_voce.config(text="Uscita", bg="#f2dede", fg="red")

    # Visualizzazione e Gestione di Tutte le Ricorrenze Programmate (Dashboard)
    def mostra_lista_ricorrenze(self):
        if hasattr(self, 'lista_window_ref') and self.lista_window_ref.winfo_exists():
            self.lista_window_ref.lift()
            self.lista_window_ref.focus_force()
            return
        def parse_data(data_str):
            if isinstance(data_str, datetime.date):
                return data_str
            try:
                return datetime.datetime.strptime(data_str, "%d-%m-%Y").date()
            except (ValueError, TypeError):
                return None
        def calcola_data_fine(data_inizio, n_volte, periodo):
            if not data_inizio or not isinstance(n_volte, int) or n_volte < 1:
                return "N/D"
            periodo = periodo.lower().strip()
            if periodo == "ogni giorno":
                data_fine_obj = data_inizio + datetime.timedelta(days=n_volte - 1)
            elif periodo == "ogni mese":
                total_months = data_inizio.month + n_volte - 1
                anno_fine = data_inizio.year + (total_months - 1) // 12
                mese_fine = (total_months - 1) % 12 + 1
                giorno_inizio = data_inizio.day
                try:
                    data_fine_obj = datetime.date(anno_fine, mese_fine, giorno_inizio)
                except ValueError:
                    if mese_fine == 12:
                        primo_giorno_mese_successivo = datetime.date(anno_fine + 1, 1, 1)
                    else:
                        primo_giorno_mese_successivo = datetime.date(anno_fine, mese_fine + 1, 1)
                    ultimo_giorno_mese_fine = (primo_giorno_mese_successivo - datetime.timedelta(days=1)).day
                    data_fine_obj = datetime.date(anno_fine, mese_fine, ultimo_giorno_mese_fine)
            elif periodo == "ogni anno":
                anno_fine = data_inizio.year + n_volte - 1
                try:
                    data_fine_obj = data_inizio.replace(year=anno_fine)
                except ValueError:
                    data_fine_obj = data_inizio.replace(year=anno_fine, day=28)
            else:
                return "N/D"
            return data_fine_obj.strftime("%d-%m-%Y")
        def destroy_window_and_cleanup():
            if hasattr(self, 'lista_window_ref') and self.lista_window_ref.winfo_exists():
                self.lista_window_ref.destroy() 
                delattr(self, 'lista_window_ref')
        def _delete_selected_ricorrenze():
            selected_ids = tree.selection()
            if not selected_ids:
                self.show_custom_warning("Attenzione", "Seleziona almeno una ricorrenza da cancellare.")
                return
            response = self.show_custom_askyesno(
                "Conferma Cancellazione", 
                f"Sei sicuro di voler cancellare {len(selected_ids)} ricorrenza/e selezionata/e?"
            )
            if not response:
                return
            ids_to_delete = list(selected_ids)
            deleted_count = 0
            for ric_id in ids_to_delete:
                if ric_id not in self.ricorrenze:
                    continue
                keys_to_delete = []
                for data_key, voci in list(self.spese.items()):
                    nuove_voci = [
                        voce for voce in voci 
                        if not (len(voce) >= 5 and voce[4] == ric_id)
                    ]
                    if nuove_voci:
                        self.spese[data_key] = nuove_voci
                    else:
                        keys_to_delete.append(data_key)
                for data_key in keys_to_delete:
                    del self.spese[data_key]
                del self.ricorrenze[ric_id]
                try:
                    tree.delete(ric_id) 
                    deleted_count += 1
                except tk.TclError:
                    pass
            if deleted_count > 0:
                if hasattr(self, "db"):
                    self.db["spese"] = self.spese
                    self.db["ricorrenze"] = self.ricorrenze
                self.save_db()
                self.show_custom_info("Cancellazione Eseguita", f"Sono state rimosse con successo {deleted_count} transazione/i dal registro.")
            self.refresh_gui() 
            self.ricorrenza_cat_sel.set(self.categorie[0]) 
            self.ricorrenza_tipo_voce.set("Uscita")
            self.btn_tipo_voce.config(text="Uscita", bg="#f2dede", fg="red")
        def treeview_sort_column(tv, col, reverse):
            l = [(tv.set(k, col), k) for k in tv.get_children('')]
            try:
                l.sort(key=lambda t: float(t[0].replace(' ‚Ç¨', '').replace(',', '.').strip()), reverse=reverse)
            except (ValueError, IndexError):
                l.sort(key=lambda t: t[0], reverse=reverse)
            for index, (val, k) in enumerate(l):
                tv.move(k, '', index)
            tv.heading(col, command=lambda: treeview_sort_column(tv, col, not reverse))
        lista_window = tk.Toplevel(self)
        self.lista_window_ref = lista_window
        lista_window.withdraw()
        self.update_idletasks()
        main_x = self.winfo_rootx()
        main_y = self.winfo_rooty()
        main_width = self.winfo_width()
        main_height = self.winfo_height()
        lista_window_width = 1200
        lista_window_height = 600
        center_x = main_x + (main_width // 2) - (lista_window_width // 2)
        center_y = main_y + (main_height // 2) - (lista_window_height // 2)
        lista_window.geometry(f"{lista_window_width}x{lista_window_height}+{center_x}+{center_y}")
        lista_window.transient(self)
        lista_window.title("Lista delle Ricorrenze Programmate")
        lista_window.deiconify()
        lista_window.lift()
        lista_window.bind("<Escape>", lambda e: lista_window.after(50, destroy_window_and_cleanup))
        lista_window.protocol("WM_DELETE_WINDOW", lambda: lista_window.after(50, destroy_window_and_cleanup))
        main_frame = ttk.Frame(lista_window, padding=10)
        main_frame.pack(fill="both", expand=True)
        columns = ("Categoria", "Tipo", "Importo", "Durata", "Pagate", "Data Inizio", "Data Fine", "Importo Totale", "Gi√† Pagato", "Rimanente", "ID")
        tree = ttk.Treeview(main_frame, columns=columns, show="headings", height=12)
        tree.tag_configure("uscita", foreground="red")
        tree.tag_configure("entrata", foreground="green")
        larghezze = {"Categoria": 110, "Tipo": 50, "Importo": 60, "Durata": 30, "Pagate": 30, "Data Inizio": 60, "Data Fine": 60, "Importo Totale": 80, "Gi√† Pagato": 60, "Rimanente": 60, "ID": 250}
        for col in columns:
            tree.heading(col, text=col, command=lambda _col=col: treeview_sort_column(tree, _col, False))
            tree.column(col, width=larghezze[col], anchor="center")
        tree.pack(fill="both", expand=True)
        oggi = datetime.date.today()
        bilancio_mensile = 0.0
        evasi_per_ricorrenza = {id_ric: [] for id_ric in self.ricorrenze.keys()}
        for id_ricorrenza, dati in self.ricorrenze.items():
            data_inizio_str = dati.get("data_inizio", "N/D")
            data_inizio_obj = parse_data(data_inizio_str)
            if data_inizio_obj:
                 if dati.get("tipo", "").lower() == "ogni mese":
                    volte_passate = (oggi.year - data_inizio_obj.year) * 12 + (oggi.month - data_inizio_obj.month)
                    for i in range(volte_passate + 1):
                        data_movimento = (data_inizio_obj.replace(day=1) + datetime.timedelta(days=32 * i)).replace(day=data_inizio_obj.day)
                        if data_movimento <= oggi:
                            evasi_per_ricorrenza[id_ricorrenza].append({
                                'data': data_movimento.strftime("%d-%m-%Y"),
                                'descrizione': f"{dati['cat']} del {data_movimento.strftime('%B')}",
                                'importo': dati['imp'],
                                'tipo': dati['tipo_voce']
                            })
        for i, (id_ricorrenza, dati) in enumerate(self.ricorrenze.items()):
            cat = dati.get("cat", "Sconosciuta")
            tipo_voce = dati.get("tipo_voce", dati.get("tipo", "N/D"))
            imp = dati.get("imp", 0.0)
            n_volte = dati.get("n", 0)
            ric_periodo = dati.get("tipo", "N/D")
            data_inizio_str = dati.get("data_inizio", "N/D")
            data_inizio_obj = parse_data(data_inizio_str)
            data_fine = calcola_data_fine(data_inizio_obj, n_volte, ric_periodo)
            importo_totale = imp * n_volte if isinstance(n_volte, int) else 0.0
            volte_passate = 0
            if data_inizio_obj:
                if oggi >= data_inizio_obj:
                    if ric_periodo.lower() == "ogni mese":
                        diff_mesi = (oggi.year - data_inizio_obj.year) * 12 + (oggi.month - data_inizio_obj.month)
                        volte_passate = diff_mesi + 1
                    elif ric_periodo.lower() == "ogni anno":
                        volte_passate = (oggi.year - data_inizio_obj.year) + 1
                    elif ric_periodo.lower() == "ogni giorno":
                        diff_giorni = (oggi - data_inizio_obj).days
                        volte_passate = diff_giorni + 1
            volte_passate = min(volte_passate, n_volte)
            importo_gia_pagato = imp * volte_passate
            importo_rimasto = importo_totale - importo_gia_pagato
            tag = "uscita" if tipo_voce == "Uscita" else "entrata"
            values = (cat, tipo_voce, f"{imp:,.2f} ‚Ç¨", n_volte, volte_passate, data_inizio_str, data_fine, f"{importo_totale:,.2f} ‚Ç¨", f"{importo_gia_pagato:,.2f} ‚Ç¨", f"{importo_rimasto:,.2f} ‚Ç¨", id_ricorrenza)
            tree.insert("", "end", iid=id_ricorrenza, values=values, tags=(tag,))
            if ric_periodo.lower() == "ogni mese":
                bilancio_mensile += imp if tipo_voce == "Entrata" else -imp
        tree.bind("<Double-1>", self.on_ricorrenza_double_click)
        summary_frame = ttk.Frame(main_frame, padding=(0, 10))
        summary_frame.pack(fill="x", expand=False)
        bilancio_colore = "darkgreen" if bilancio_mensile >= 0 else "darkred"
        ttk.Label(summary_frame, text="Impatto Mensile Stimato (su base 'Mese'):", font=("Arial", 10)).pack(side="left")
        ttk.Label(summary_frame, text=f"{bilancio_mensile:,.2f} ‚Ç¨", font=("Arial", 11, "bold"), foreground=bilancio_colore).pack(side="left", padx=5)
        button_frame = ttk.Frame(main_frame, padding=(0, 10))
        button_frame.pack(fill="x", expand=False)
        cancel_button = ttk.Button(button_frame, text="‚ùå Cancella Selezionate", command=_delete_selected_ricorrenze, style="Verde.TButton")
        cancel_button.pack(side="left", padx=5)
        close_button = ttk.Button(button_frame, text="‚úÖ Chiudi", command=lambda: lista_window.after(50, destroy_window_and_cleanup), style="Giallo.TButton")
        close_button.pack(side="right", padx=5)
        
    # Abilita/Disabilita l'interazione con il pulsante Tipo Transazione    
    def set_tipo_spesa_editable(self, editable=True):
        if editable:
            self.btn_tipo_spesa.state(["!disabled"])
        else:
            self.btn_tipo_spesa.state(["disabled"])
            
    # Inserimento forzato del valore Importo (bypassando la validazione)
    def _inserisci_importo_senza_validazione(self, imp_value):
        self.imp_entry.config(validate="none") 
        self.imp_entry.delete(0, tk.END)
        self.imp_entry.insert(0, imp_value)
        vcmd = self.imp_entry.cget('validatecommand')
        self.imp_entry.config(validate="key", validatecommand=vcmd)

    # Caricamento Voce di Spesa nel Modulo (Preparazione per Modifica/Cancellazione)
    def on_table_click(self, event):
        self.label_smartcat.config(text="üõ†Ô∏è SmartCat disattiva", foreground="green")
        self.aggiorna_bottone_spese_simili(visibile=False)
        mode = self.stats_mode.get()
        if mode != "giorno":
            return
        region = self.stats_table.identify("region", event.x, event.y)
        if region != "cell":
            return
        col = self.stats_table.identify_column(event.x)
        if col != "#6":
            return
        self.suggerimenti_attivi = False 
        rowid = self.stats_table.identify_row(event.y)
        if not rowid:
            return
        vals = self.stats_table.item(rowid, "values")
        giorno_str, cat, desc, imp, tipo, _ = vals
        giorno = datetime.datetime.strptime(giorno_str, "%d-%m-%Y").date()
        idx = self.stats_table.index(rowid)
        voce = self.spese[giorno][idx]
        self.modifica_idx = (giorno, idx)
        self.cat_sel.set(cat)
        self.desc_entry.delete(0, tk.END)
        self.desc_entry.insert(0, desc)
        self.imp_entry.delete(0, tk.END)
        self.imp_entry.insert(0, imp)
        self.after(0, lambda: self._inserisci_importo_senza_validazione(imp))
        self.tipo_spesa_var.set(tipo)
        self.btn_tipo_spesa.config(text=tipo)
        self.btn_modifica["state"] = tk.NORMAL
        self.btn_aggiungi["state"] = tk.DISABLED
        self.btn_cancella["state"] = tk.NORMAL
        self.data_spesa_var.set(giorno.strftime("%d-%m-%Y"))
        self.btn_reset_form["state"] = tk.DISABLED
        self.set_tipo_spesa_editable(True) #Modifica Tipo entrata/uscita consentita
        new_style = 'GreenOutline.TButton' if tipo == "Entrata" else 'RedOutline.TButton'
        self.btn_tipo_spesa.config(style=new_style)
        if len(voce) == 5:
            ric_id = voce[4]
            if ric_id in self.ricorrenze:
                ric = self.ricorrenze[ric_id]
                self.show_custom_info("Voce ricorrente", f"Questa voce √® parte di una ricorrenza: {ric['tipo']} x{ric['n']} da {ric['data_inizio']}.\nPuoi cancellare tutta la ricorrenza dal pannello Ricorrenze sotto.\nIn alternativa puoi modificare la singola voce o cancellarla")

    # Sincronizzazione visiva (colore/testo) del pulsante Tipo Spesa
    def aggiorna_stile_tipo_spesa(self):
        tipo = self.tipo_spesa_var.get()
        btn_style = 'GreenOutline.TButton' if tipo == "Entrata" else 'RedOutline.TButton'
        self.btn_tipo_spesa.config(
            text=tipo,
            style=btn_style
        )
        
    # Gestione delle Transazioni Esistenti (Modifica e Cancellazione di Singole Voci)
    def reset_modifica_form(self):
        self.suggerimenti_attivi = True  
        self.label_smartcat.config(text="üõ†Ô∏è SmartCat attiva", foreground="red")
        self.modifica_idx = None
        self.btn_modifica["state"] = tk.DISABLED
        self.btn_aggiungi["state"] = tk.NORMAL
        self.btn_cancella["state"] = tk.DISABLED
        self.desc_entry.delete(0, tk.END)
        self.imp_entry.delete(0, tk.END)
        self.cat_sel.set("Generica")
        self.metodo_pagamento_var.set("")
        self.on_categoria_changed()
        self.set_tipo_spesa_editable(True)
        if not self.blocca_data_var.get():
         self.data_spesa_var.set(datetime.date.today().strftime("%d-%m-%Y"))
        self.categoria_bloccata = False  
        self.btn_reset_form["state"] = tk.NORMAL
        self.btn_aggiungi["state"] = tk.NORMAL
    def salva_modifica(self):
        if not self.modifica_idx:
            return
        old_dt, idx = self.modifica_idx
        new_data = self.data_spesa_var.get()
        new_dt = datetime.datetime.strptime(new_data, "%d-%m-%Y").date()
        cat = self.cat_sel.get()
        desc = self.desc_entry.get().strip()
        try:
            imp = float(self.imp_entry.get().replace(",", "."))
        except Exception:
            self.show_custom_warning("Errore", "Importo mancante o non valido.")
            return
        tipo = self.tipo_spesa_var.get()
        if old_dt not in self.spese or idx >= len(self.spese[old_dt]):
            self.show_custom_warning("Errore", "La voce selezionata non esiste pi√π.")
            self.reset_modifica_form()
            return
        voce_old = self.spese[old_dt][idx]
        id_ric = voce_old[4] if len(voce_old) == 5 else None
        del self.spese[old_dt][idx]
        if not self.spese[old_dt]:
            del self.spese[old_dt]
        if new_dt not in self.spese:
            self.spese[new_dt] = []
        voce_new = (cat, desc, imp, tipo)
        if id_ric is not None:
            voce_new += (id_ric,)
        self.spese[new_dt].append(voce_new)
        self.save_db()
        self.refresh_gui()
        self.reset_modifica_form()
        self.suggerimenti_attivi = True 
        self.btn_aggiungi["state"] = tk.NORMAL
    def cancella_voce(self):
        if not self.modifica_idx:
            return
        dt, idx = self.modifica_idx
        if dt in self.spese and 0 <= idx < len(self.spese[dt]):
            del self.spese[dt][idx]
            if not self.spese[dt]:
                del self.spese[dt]
            self.save_db()
            self.refresh_gui()
        self.reset_modifica_form()
        self.colora_giorni_spese()
        self.suggerimenti_attivi = True 
        self.btn_aggiungi["state"] = tk.NORMAL
        
    # Popolamento della Tabella Riepilogo Transazioni del Mese Corrente    
    def update_spese_mese_corrente(self):
        for i in self.spese_mese_tree.get_children():
            self.spese_mese_tree.delete(i)
        now = datetime.date.today()
        year, month = now.year, now.month
        spese_mese = []
        for d in sorted(self.spese.keys()):
            if d.year == year and d.month == month:
                for entry in self.spese[d]:
                    cat, desc, imp, tipo = entry[:4]
                    spese_mese.append((d, cat, desc, imp, tipo))
        for d, cat, desc, imp, tipo in spese_mese:
            tag = 'entrata' if tipo == 'Entrata' else 'uscita'
            self.spese_mese_tree.insert("", "end", values=(
                d.strftime("%d-%m-%Y"), cat, desc, f"{imp:.2f}", tipo
            ), tags=(tag,))
 
    # Applicazione Filtro Mese/Anno (Estratto Conto) e Aggiornamento Viste Statistiche
    def apply_estratto(self, forza_modalita=None):
        try:
            month_str = self.estratto_month_var.get()
            match = re.match(r'(\d+)\s*-\s*', month_str)
            if match:
                m = int(match.group(1))
            else:
                try:
                    m = int(month_str)
                except ValueError:
                    raise ValueError("Il formato del mese non √® corretto o √® vuoto.")
            y = int(self.estratto_year_var.get())
            d = datetime.date(y, m, 1)
            self.stats_refdate = d
            if not forza_modalita:
                self.toggle_stats_view("tabella")
            if not hasattr(self, 'stats_table') or not self.stats_table.winfo_exists():
                return 
            if forza_modalita:
                self.set_stats_mode(forza_modalita)
            self.update_totalizzatore_anno_corrente()
            self.update_totalizzatore_mese_corrente()
            self.update_spese_mese_corrente()           
        except Exception:
            self.show_custom_warning("Errore", "Mese o anno non validi")
            
    # Reconfigurazione Dinamica della Tabella Statistiche per Modalit√† di Visualizzazione
    def set_stats_mode(self, mode):
        if hasattr(self, 'stats_mode'):
            self.stats_mode.set(mode)
        self.stats_table["displaycolumns"] = ("A", "B", "C", "D", "E", "F")
        if mode == "giorno":
            try:
                data_corrente = self.cal.selection_get()
            except:
                data_corrente = datetime.date.today()
            
            self.stats_label.config(text=f"Riepilogo Giornaliero - {data_corrente.strftime('%d-%m-%Y')}", 
                                  foreground="purple", font=("Arial", 10, "bold"))
            cols = {
                "A": (80, "center", "Data"),
                "B": (150, "w", "Categoria"),
                "C": (240, "w", "Descrizione"),
                "D": (100, "center", "Importo (‚Ç¨)"),
                "E": (80, "center", "Tipo"),
                "F": (60, "center", "Modifica")
            }
        else:
            if mode == "mese":
                ref = getattr(self, 'stats_refdate', datetime.date.today())
                m_name = self.get_month_name(ref.month) if hasattr(self, 'get_month_name') else str(ref.month)
                self.stats_label.config(text=f"Riepilogo Mensile {m_name} {ref.year}", foreground="dodgerblue", font=("Arial", 10, "bold"))
            elif mode == "anno":
                ref = getattr(self, 'stats_refdate', datetime.date.today())
                self.stats_label.config(text=f"Riepilogo Annuale {ref.year}", foreground="forest green", font=("Arial", 10, "bold"))
            else:
                self.stats_label.config(text="Riepilogo Totale Categorie", foreground="firebrick", font=("Arial", 10, "bold"))
            self.stats_table["displaycolumns"] = ("A", "B", "C")
            cols = {
                "A": (300, "w", "Categoria"),
                "B": (200, "center", "Totale (‚Ç¨)"),
                "C": (150, "center", "Tipo")
            }
        for col_id, (width, anchor, txt) in cols.items():
            self.stats_table.column(col_id, width=width, anchor=anchor)
            self.stats_table.heading(col_id, text=txt)
        funcs = [self.update_stats, self.update_totalizzatore_anno_corrente, 
                 self.update_totalizzatore_mese_corrente, self.update_spese_mese_corrente]
        for f in funcs:
            try: f()
            except: pass
        if hasattr(self, 'vsb_stats'):
            self.stats_table.configure(yscrollcommand=self.vsb_stats.set)
            self.vsb_stats.config(command=self.stats_table.yview)
            self.vsb_stats.lift() 
            self.stats_table.yview_moveto(0)
    def treeview_sort_column(self, tv, col, reverse):
        items = [(tv.set(k, col), k) for k in tv.get_children('')]
        try:  
            items.sort(key=lambda t: float(str(t[0]).replace(",", ".").replace("‚Ç¨", "")), reverse=reverse)
        except Exception:
            items.sort(key=lambda t: t[0], reverse=reverse)
        for index, (val, k) in enumerate(items):
            tv.move(k, '', index)
        tv.heading(col, command=lambda: self.treeview_sort_column(tv, col, not reverse))
    def get_month_name(self, month):
        mesi = [
            "Gennaio", "Febbraio", "Marzo", "Aprile", "Maggio", "Giugno",
            "Luglio", "Agosto", "Settembre", "Ottobre", "Novembre", "Dicembre"
        ]
        return mesi[month-1] if 1 <= month <= 12 else str(month)
    def update_stats(self):
        for i in self.stats_table.get_children():
            self.stats_table.delete(i)
        mode = self.stats_mode.get()
        tot_entrate, tot_uscite = 0.0, 0.0
        oggi = datetime.date.today()
        ref = self.stats_refdate
        if mode == "giorno":
            try:
                giorno = datetime.datetime.strptime(self.cal.get_date(), "%d-%m-%Y").date()
            except Exception:
                giorno = oggi
            spese = self.spese.get(giorno, [])
            for idx, entry in enumerate(spese):
                cat, desc, imp, tipo = entry[:4]
                tag = "entrata" if tipo == "Entrata" else "uscita"
                self.stats_table.insert(
                    "", "end",
                    values=(giorno.strftime("%d-%m-%Y"), cat, desc, f"{imp:.2f}", tipo, "Modifica"),
                    tags=(f"{giorno.strftime('%d-%m-%Y')}|{idx}", tag)
                )
                if tipo == "Entrata":
                    tot_entrate += imp
                else:
                    tot_uscite += imp
        else:
            totali = {}
            for d, sp in self.spese.items():
                if mode == "mese":
                    if not (d.year == ref.year and d.month == ref.month):
                        continue
                elif mode == "anno":
                    if d.year != ref.year:
                        continue
                for entry in sp:
                    data_voce = d
                    if not self.considera_ricorrenze_var.get():
                        if mode == "totali":
                            if data_voce > oggi:
                                continue
                        elif mode == "anno":
                            if ref.year == oggi.year:
                                if data_voce > oggi:
                                    continue    
                        elif mode == "mese":
                            if ref.year == oggi.year and ref.month == oggi.month:
                                if data_voce > oggi:
                                    continue
                    cat, desc, imp, tipo = entry[:4]
                    if cat not in totali:
                        totali[cat] = {"Entrata": 0.0, "Uscita": 0.0}
                    totali[cat][tipo] += imp
            for cat in sorted(totali.keys()):
                for tipo in ("Entrata", "Uscita"):
                    if totali[cat][tipo] > 0:
                        tag = "entrata" if tipo == "Entrata" else "uscita"
                        self.stats_table.insert(
                            "", "end",
                            values=(cat, f"{totali[cat][tipo]:.2f}", tipo),
                            tags=(tag,)
                        )
                        if tipo == "Entrata":
                            tot_entrate += totali[cat][tipo]
                        else:
                            tot_uscite += totali[cat][tipo]
        diff = tot_entrate - tot_uscite
        colore_fg = "dodgerblue" if diff >= 0 else "red" 
        txt_tot = f"Totale Entrate: {tot_entrate:.2f}    Totale Uscite: {tot_uscite:.2f}    Differenza: {diff:.2f}"
        self.totali_label.config(text=txt_tot, foreground=colore_fg, font=("Arial", 10, "bold"))

    # Calcolo e Visualizzazione Totali Riassuntivi (Annuali e Mensili)
    def update_totalizzatore_anno_corrente(self):
        anno = datetime.date.today().year
        totale_entrate = 0.0
        totale_uscite = 0.0
        for d, sp in self.spese.items():
            if d.year == anno:
                for entry in sp:
                    if hasattr(self, "considera_ricorrenze_var") and not self.considera_ricorrenze_var.get() and len(entry) == 5:
                        if d > datetime.date.today():
                            continue
                    tipo = entry[3]
                    imp = entry[2]
                    if tipo == "Entrata":
                        totale_entrate += imp
                    else:
                        totale_uscite += imp
        differenza = totale_entrate - totale_uscite
        self.totalizzatore_entrate_label.config(text=f"{totale_entrate:.2f} ‚Ç¨")
        self.totalizzatore_uscite_label.config(text=f"{totale_uscite:.2f} ‚Ç¨")
        self.totalizzatore_diff_label.config(
            text=f"{differenza:.2f} ‚Ç¨",
            foreground="dodgerblue" if differenza >= 0 else "red"
        )
    def update_totalizzatore_mese_corrente(self):
        now = datetime.date.today()
        year, month = now.year, now.month
        totale_entrate = 0.0
        totale_uscite = 0.0
        for d, sp in self.spese.items():
            if d.year == year and d.month == month:
                for entry in sp:
                    if hasattr(self, "considera_ricorrenze_var") and not self.considera_ricorrenze_var.get() and len(entry) == 5:
                        if d > now:
                            continue
                    tipo = entry[3]
                    imp = entry[2]
                    if tipo == "Entrata":
                        totale_entrate += imp
                    else:
                        totale_uscite += imp
        differenza = totale_entrate - totale_uscite
        self.totalizzatore_mese_entrate_label.config(text=f"{totale_entrate:.2f} ‚Ç¨")
        self.totalizzatore_mese_uscite_label.config(text=f"{totale_uscite:.2f} ‚Ç¨")
        self.totalizzatore_mese_diff_label.config(
            text=f"{differenza:.2f} ‚Ç¨",
            foreground="dodgerblue" if differenza >= 0 else "red"
        )
 
    # Dialogo di Reset Avanzato Dati e Configurazioni (Database, Categorie, Password)
    def show_reset_dialog(self):
        dialog = tk.Toplevel(self, bg=self.COLOR_TOPLEVEL)
        dialog.title("Reset Database")
        dialog.grab_set()
        dialog.resizable(False, False)
        dialog.transient(self)
        screen_width = self.winfo_screenwidth()
        screen_height = self.winfo_screenheight()
        window_width = 600  
        window_height = 250 
        x_coordinate = (screen_width - window_width) // 2
        y_coordinate = (screen_height - window_height) // 2
        dialog.geometry(f"{window_width}x{window_height}+{x_coordinate}+{y_coordinate}")
        dialog.bind("<Escape>", lambda e: dialog.destroy())
        label = tk.Label(dialog, text=(
            "Vuoi cancellare tutti Movimenti e/o le categorie?\n\n"
            "Scegli 'S√¨' per cancellare tutto (Movimenti + categorie, rester√† solo la categoria di default)\n\n"
            "'No' per cancellare solo i Movimenti.\n\n"
            "'Password' per cancellare la password\n\n"
            "'Reset' Azzera tutti i Dati\n"
        ),bg=self.COLOR_TOPLEVEL, fg=self.TEXT_COLOR, font=("Arial", 10), justify="left", padx=12, pady=10)
        label.pack()
        btns = tk.Frame(dialog, bg=self.COLOR_TOPLEVEL)
        btns.pack(pady=(0, 10))
        def show_custom_warning(titolo, messaggio, duration_ms=2500):
            parent = self
            width = 350
            height = 80
            parent.update_idletasks()
            parent_width = parent.winfo_width()
            parent_height = parent.winfo_height()
            x_pos = (parent_width // 2) - (width // 2)
            y_pos = (parent_height // 2) - (height // 2)
            popup_frame = tk.Frame(parent, bg="orange", bd=3, relief="raised")
            popup_frame.place(x=x_pos, y=y_pos, width=width, height=height)
            popup_frame.lift() 
            label = tk.Label(popup_frame, text=messaggio, font=("Arial", 10, "bold"), 
                              justify="center", padx=10, pady=10, bg="orange", fg="black")
            label.pack(expand=True, fill='both')
            popup_frame.update()
            parent.after(duration_ms, popup_frame.destroy)
        def do_yes():           
            try:
                dialog.destroy()
                self.spese = {}
                self.categorie = ["Generica"]
                self.categorie_tipi = {"Generica": "Uscita"}
                self.ricorrenze = {}
                self.save_db()
                self.update_stats()
                self.update_totalizzatore_anno_corrente()
                self.update_totalizzatore_mese_corrente()
                self.update_spese_mese_corrente()
                try:
                    self.cat_menu["values"] = self.categorie
                    self.cat_mod_menu["values"] = self.categorie
                    self.cat_sel.set(self.categorie[0])
                    self.cat_mod_sel.set(self.categorie[0])
                except Exception as widget_error:
                    pass 
                show_custom_warning("Movimenti", "Movimenti e Categorie azzerate")
            except Exception as e:
                print(f"Errore durante il reset: {e}")
        def do_no():
            dialog.destroy()
            self.spese = {}
            self.ricorrenze = {}
            self.save_db()
            self.update_stats()
            self.update_totalizzatore_anno_corrente()
            self.update_totalizzatore_mese_corrente()
            self.update_spese_mese_corrente()
            show_custom_warning("Movimenti", "Movimenti azzerati")
        def do_password():
            dialog.destroy()
            if os.path.exists(PW_FILE):
             os.remove(PW_FILE)
            show_custom_warning("Password", "Password azzerata")
        def do_reset():
            import subprocess, sys, os
            dialog.destroy()
            shutil.rmtree(DB_DIR) 
            shutil.rmtree(EXPORT_FILES)
            show_custom_warning("Ripristino", "Riavvio in corso. Dati azzerati allo stato predefinito!")
            self._on_close_lock()
            def restart_application():
                script_path = os.path.abspath(sys.argv[0])
                args = [sys.executable, script_path] + sys.argv[1:]
                subprocess.Popen(args, start_new_session=True, close_fds=True)
                os._exit(0)
            self.after(2600, restart_application)
        def do_cancel():
            dialog.destroy()
        ttk.Button(btns, text="‚úÖ S√¨", command=do_yes, style="Rosso.TButton").grid(row=0, column=0, padx=5)
        ttk.Button(btns, text="‚ùå No", command=do_no, style="Rosso.TButton").grid(row=0, column=1, padx=5)
        ttk.Button(btns, text="üìÖ Password", command=do_password, style="Blu.TButton").grid(row=0, column=4, padx=5)
        ttk.Button(btns, text="‚ùå RESET", command=do_reset, style="Giallo.TButton").grid(row=0, column=5, padx=5)
        ttk.Button(btns, text="‚ùå Annulla", command=do_cancel, style="Giallo.TButton").grid(row=0, column=6, padx=5)
        btns.focus_set()
        dialog.bind("<Escape>", lambda e: do_cancel())
        dialog.bind("<Return>", lambda e: do_yes())
        dialog.bind("<KP_Enter>", lambda e: do_yes())

    # Esportazione Forzata delle Statistiche in Modalit√† Giornaliera
    def export_giorno_forzato(self):
        old_mode = self.stats_mode.get()
        self.stats_mode.set("giorno")
        self.export_stats()
        self.stats_mode.set(old_mode)

    # Generazione di Report Testuale Formattato per Esportazione Statistiche
    def export_stats(self):
        mode = self.stats_mode.get()
        lines = []
        label_width = 20
        desc_width = 30
        value_width = 14
        tipo_width = 10
        tot_entrate, tot_uscite = 0.0, 0.0
        if mode == "giorno":
            try:
                giorno = datetime.datetime.strptime(self.cal.get_date(), "%d-%m-%Y").date()
            except Exception:
                giorno = datetime.date.today()
            spese = self.spese.get(giorno, []) or self.spese.get(giorno.strftime("%d-%m-%Y"), [])
            header = f"{'Categoria':<{label_width}} {'Descrizione':<{desc_width}} {'Importo (‚Ç¨)':>{value_width}}  {'Tipo':<{tipo_width}}"
            sep = "-" * len(header)
            lines.append("=" * len(header))
            lines.append(f"{('Riepilogo Giornaliero - ' + giorno.strftime('%d-%m-%Y')).center(len(header))}")
            lines.append("=" * len(header))
            lines.append("")
            lines.append(header)
            lines.append(sep)
            if not spese:
                lines.append("Nessuna spesa trovata per il giorno selezionato.")
            else:
                for entry in spese:
                    cat, desc, imp, tipo = entry[:4]
                    lines.append(f"{cat:<{label_width}.{label_width}} {desc:<{desc_width}.{desc_width}} {imp:>{value_width}.2f}  {tipo:<{tipo_width}}")
                    if tipo == "Entrata":
                        tot_entrate += imp
                    else:
                        tot_uscite += imp
            lines.append(sep)
        else:
            totali = {}
            tipo_cat = {}
            ref = self.stats_refdate
            if mode == "mese":
                year, month = ref.year, ref.month
                monthname = self.get_month_name(month)
                title = f"Riepilogo Mensile - {monthname} {year}"
            elif mode == "anno":
                year = ref.year
                title = f"Riepilogo Anno {year}"
            else:
                title = "Riepilogo Categorie"
            header = f"{'Categoria':<{label_width}} {'Totale (‚Ç¨)':>{value_width}}  {'Tipo':<{tipo_width}}"
            sep = "-" * len(header)
            lines.append("=" * len(header))
            lines.append(title.center(len(header)))
            lines.append("=" * len(header))
            lines.append("")
            lines.append(header)
            lines.append(sep)
            for d, sp in self.spese.items():
                try:
                    d2 = datetime.datetime.strptime(d, "%d-%m-%Y").date() if isinstance(d, str) else d
                except:
                    continue
                if (mode == "mese" and d2.year == year and d2.month == month) or \
                   (mode == "anno" and d2.year == year) or \
                   (mode == "totali"):
                    for entry in sp:
                        cat, desc, imp, tipo = entry[:4]
                        totali[cat] = totali.get(cat, 0.0) + imp
                        tipo_cat[cat] = self.categorie_tipi.get(cat, tipo)
            for cat in sorted(totali.keys()):
                val = totali[cat]
                tipo = tipo_cat.get(cat, "Uscita")
                lines.append(f"{cat:<{label_width}.{label_width}} {val:>{value_width}.2f}  {tipo:<{tipo_width}}")
                if tipo == "Entrata":
                    tot_entrate += val
                else:
                    tot_uscite += val
            lines.append(sep)
        diff = tot_entrate - tot_uscite
        lines.append(f"{'Totale Entrate:':<{label_width}} {tot_entrate:>{value_width}.2f}")
        lines.append(f"{'Totale Uscite:':<{label_width}} {tot_uscite:>{value_width}.2f}")
        lines.append(f"{'Differenza:':<{label_width}} {diff:>{value_width}.2f} ‚Ç¨")
        lines.append("=" * max(len(header), label_width + value_width + tipo_width + 3))
        now = datetime.date.today()
        filename = ""
        if mode == "giorno":
            try:
                giorno = datetime.datetime.strptime(self.cal.get_date(), "%d-%m-%Y").date()
            except Exception:
                giorno = now
            filename = f"Riepilogo_Giorno_{giorno.strftime('%d-%m-%Y')}.txt"
        elif mode == "mese":
            monthname = self.get_month_name(ref.month)
            filename = f"Riepilogo_Mese_{monthname}_{ref.year}.txt"
        elif mode == "anno":
            filename = f"Riepilogo_Anno_{ref.year}.txt"
        else:
            filename = f"Riepilogo_Per_Categoria.txt"
        self.show_export_preview("\n".join(lines), default_filename=filename)
        
    # Generazione di Report Mensile Dettagliato con Ripartizione Giornaliera   
    def export_month_detail(self):
        ref = self.stats_refdate
        month = ref.month
        year = ref.year
        monthname = self.get_month_name(month)
        oggi = datetime.date.today()
        giorni_settimana = [
            "Luned√¨", "Marted√¨", "Mercoled√¨", "Gioved√¨",
            "Venerd√¨", "Sabato", "Domenica"
        ]
        lines = []
        tot_entrate, tot_uscite = 0.0, 0.0
        lines.append("=" * 100)
        lines.append(f"{('Riepilogo Mensile ' + monthname + ' ' + str(year)).center(100)}")
        lines.append("=" * 100 + "\n")
        days_in_month = [
            d for d in sorted(self.spese.keys())
            if d.year == year and d.month == month
        ]
        if not days_in_month:
            lines.append("Nessuna spesa registrata in questo mese.\n")
        else:
            for d in days_in_month:
                giorno_it = giorni_settimana[d.weekday()]
                lines.append(f"{giorno_it:<10} {d.strftime('%d/%m/%Y')}")
                lines.append("-" * 100)
                lines.append(f"{'':2}{'Categoria':<20}{'Descrizione':<40}{'Tipo':<10}{'Importo (‚Ç¨)':>14}")
                ent_giorno, usc_giorno = 0.0, 0.0
                for entry in self.spese.get(d, []):
                    is_ricorrenza = len(entry) == 5
                    if not self.considera_ricorrenze_var.get():
                        if d > oggi:
                            continue
                    if len(entry) >= 4:
                        cat, desc, imp, tipo = entry[:4]
                        lines.append(f"{'':2}{cat:<20.20}{desc:<40.40}{tipo:<10}{imp:14.2f}")
                        if tipo == "Entrata":
                            ent_giorno += imp
                            tot_entrate += imp
                        else:
                            usc_giorno += imp
                            tot_uscite += imp
                lines.append(f"\n{'':2}Totale giorno ‚Üí Entrate: {ent_giorno:8.2f} ‚Ç¨   Uscite: {usc_giorno:8.2f} ‚Ç¨\n")
        lines.append("-" * 100)
        lines.append(f"{'Totale entrate mese:':<60}{tot_entrate:14.2f} ‚Ç¨")
        lines.append(f"{'Totale uscite mese:':<60}{tot_uscite:14.2f} ‚Ç¨")
        lines.append(f"{'Saldo finale:':<60}{(tot_entrate - tot_uscite):14.2f} ‚Ç¨")
        now = datetime.date.today()
        month = now.strftime("%m-%Y")
        filename = f"Riepilogo_Mese_{month}.txt"
        self.show_export_preview("\n".join(lines), default_filename=filename)

    # Finestra di Anteprima, Salvataggio e Stampa del Report Testuale
    def show_export_preview(self, content, default_filename=None):
        preview = tk.Toplevel(self, bg=self.COLOR_TOPLEVEL )
        preview.withdraw()  
        preview.title("Anteprima Esportazione Riepilogo")
        larghezza_finestra = 1300
        altezza_finestra = 600
        def centra_finestra():
                screen_width = preview.winfo_screenwidth()
                screen_height = preview.winfo_screenheight()
                x = (screen_width - larghezza_finestra) // 2
                y = (screen_height - altezza_finestra) // 2
                preview.geometry(f"{larghezza_finestra}x{altezza_finestra}+{x}+{y}")
                preview.deiconify()
                preview.lift()
                preview.focus_force()
        preview.after(0, centra_finestra)
        preview.bind("<Escape>", lambda e: preview.destroy())
        text = tk.Text(preview, wrap="none", font=("Courier new", 10))
        text.insert("1.0", content)
        text.config(state="disabled")
        text.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        def save_file():
            now = datetime.date.today()
            filename = default_filename or f"Riepilogo_Export_{now.day:02d}-{now.month:02d}-{now.year}.txt"
            file = filedialog.asksaveasfilename(
                defaultextension=".txt",
                filetypes=[("File txt", "*.txt")],
                initialdir=EXPORT_FILES,
                initialfile=filename,
                title="Salva Riepilogo",
                confirmoverwrite=False,
                parent=preview)
            if file:
                if os.path.exists(file):
                    conferma = self.show_custom_askyesno(
                        "Sovrascrivere file?",
                        f"Il file '{os.path.basename(file)}' \nesiste gi√†. Vuoi sovrascriverlo?"
                    )
                    if not conferma:
                        return  
                with open(file, "w", encoding="utf-8") as f:
                    f.write(content)
                preview.destroy()
                self.show_custom_warning("Esportazione completata", f"Riepilogo esportato in {file}")
        btn_frame = tk.Frame(preview, bg=self.COLOR_TOPLEVEL )
        btn_frame.pack(fill=tk.X, pady=8)
        btn_salva = ttk.Button(btn_frame, text="üíæ Esporta", command=save_file, style="Verde.TButton")
        btn_salva.pack(side=tk.LEFT, padx=10)
        btn_stampa = ttk.Button(
            btn_frame, 
            text="üñ®Ô∏è Stampa", command=lambda: self._stampa_lista_diretta(content, self.show_custom_warning),
            style="Blu.TButton"
        )
        btn_stampa.pack(side=tk.LEFT, padx=5)
        btn_chiudi = ttk.Button(btn_frame, text="‚ùå Chiudi", command=preview.destroy, style="Giallo.TButton")
        btn_chiudi.pack(side=tk.RIGHT, padx=10)
        preview.update() 
        
    # Gestione del Database: Importazione e Esportazione del File di Dati    
    def import_db(self):
        file = filedialog.askopenfilename(
            title="Importa Database",
            defaultextension=".json",
            initialdir=EXP_DB,
            filetypes=[("File JSON", "*.json"), ("Tutti i file", "*.*")]
        )
        if file:
            try:
                with open(file, "r", encoding="utf-8") as fsrc:
                    dbdata = fsrc.read()
                with open(DB_FILE, "w", encoding="utf-8") as fdst:
                    fdst.write(dbdata)
                self.load_db()
                if hasattr(self, 'cat_menu'):
                    self.cat_menu["values"] = self.categorie
                    if self.categorie:
                        self.cat_sel.set(self.categorie[0])
                if hasattr(self, 'cat_mod_menu'):
                    self.cat_mod_menu["values"] = self.categorie
                    if self.categorie:
                        self.cat_mod_sel.set(self.categorie[0])
                self.update_stats()
                self.update_totalizzatore_anno_corrente()
                self.update_totalizzatore_mese_corrente()
                self.update_spese_mese_corrente()
                self.show_custom_warning("Importazione completata", f"Database importato da {file}")
            except Exception as e:
                print(f"Errore durante l'importazione: {e}")
                self.show_custom_warning("Errore", f"Errore durante l'importazione: {e}")
    def export_db(self):
        now = datetime.date.today()
        default_dir = EXP_DB
        default_filename = f"Export_Database{now.day:02d}-{now.month:02d}-{now.year}.json"
        file = filedialog.asksaveasfilename(
            title="Esporta Database",
            defaultextension=".json",
            initialdir=default_dir,
            initialfile=default_filename,
            confirmoverwrite=False,
            filetypes=[("File JSON", "*.json"), ("Tutti i file", "*.*")]
        )
        if file:
            try:
                with open(DB_FILE, "r", encoding="utf-8") as fsrc:
                    dbdata = fsrc.read()
                with open(file, "w", encoding="utf-8") as fdst:
                    fdst.write(dbdata)
                self.show_custom_warning("Esportazione completata", f"Database esportato in {file}")
            except Exception as e:
                self.show_custom_warning("Errore", "Errore durante l'esportazione:", f"{e}")
                
    # Esportazione di un Report Annuale Dettagliato (Matrice Categoria vs. Mese)
    def export_anno_dettagliato(self):
        try:
            year = int(self.estratto_year_var.get())
        except Exception:
            year = datetime.date.today().year

        mesi = ["Gen", "Feb", "Mar", "Apr", "Mag", "Giu",
                "Lug", "Ago", "Set", "Ott", "Nov", "Dic"]
        label_width = 22
        categorie = sorted(
            set(
                entry[0]
                for sp in self.spese.values()
                for entry in sp
                if isinstance(entry, (list, tuple)) and len(entry) >= 4
            ).union(self.categorie)
        )
        tot_entrate_mese = [0.0] * 12
        tot_uscite_mese = [0.0] * 12
        cat_entrate = {cat: [0.0] * 12 for cat in categorie}
        cat_uscite = {cat: [0.0] * 12 for cat in categorie}
        tot_entrate_anno = 0.0
        tot_uscite_anno = 0.0
        oggi = datetime.date.today()
        def date_from_key(d):
            if isinstance(d, datetime.date):
                return d
            try:
                return datetime.datetime.strptime(d, "%d-%m-%Y").date()
            except:
                return None
        for d, sp in self.spese.items():
            d2 = date_from_key(d)
            if d2 and d2.year == year:
                m = d2.month - 1
                for entry in sp:
                    is_ricorrenza = len(entry) == 5
                    if hasattr(self, "considera_ricorrenze_var") and not self.considera_ricorrenze_var.get():
                        if year == oggi.year:
                            if d2 > oggi:
                                continue
                    if len(entry) >= 4:
                        cat, desc, imp, tipo = entry[:4]
                        if tipo == "Entrata":
                            tot_entrate_mese[m] += imp
                            tot_entrate_anno += imp
                            cat_entrate[cat][m] += imp
                        else:
                            tot_uscite_mese[m] += imp
                            tot_uscite_anno += imp
                            cat_uscite[cat][m] += imp
        def format_row(label, values):
            label_fmt = f"{label:<{label_width}.{label_width}}"
            numeri = "".join(f"{v:10.2f}" for v in values)
            return f"{label_fmt}{numeri}{sum(values):12.2f}"
        header = f"{'Categoria':<{label_width}}" + "".join(f"{m:>10}" for m in mesi) + f"{'Totale':>12}"
        sep = "-" * len(header)
        lines = []
        lines.append("=" * len(header))
        lines.append(f"{('RIEPILOGO ENTRATE/USCITE ANNO ' + str(year)).center(len(header))}")
        lines.append("=" * len(header))
        lines.append("")
        lines.append(header)
        lines.append(sep)
        lines.append("")
        lines.append("ENTRATE PER CATEGORIA:")
        lines.append(header)
        for cat in categorie:
            if any(cat_entrate[cat]):
                lines.append(format_row(cat, cat_entrate[cat]))
        lines.append(sep)
        lines.append(format_row("‚Ä¢ Totale Entrate", tot_entrate_mese))
        lines.append(sep)
        lines.append("")
        lines.append("USCITE PER CATEGORIA:")
        lines.append(header)
        for cat in categorie:
            if any(cat_uscite[cat]):
                lines.append(format_row(cat, cat_uscite[cat]))
        lines.append("")
        lines.append(sep)
        lines.append(format_row("‚Ä¢ Totale Uscite", tot_uscite_mese))
        lines.append("-" * len(header))
        saldo = tot_entrate_anno - tot_uscite_anno
        lines.append(f"{'SALDO FINALE:':<{label_width}}{saldo:>{len(header) - label_width}.2f} ‚Ç¨")
        lines.append("=" * len(header))
        text = "\n".join(lines)
        now = datetime.date.today()
        self.show_export_preview(text, default_filename=f"Riepilogo_Anno_{year}.txt")

    # Analisi e Suggerimento del Tipo Prevalente (Entrata/Uscita) per Categoria
    def suggerisci_tipo_categoria(self, categoria):
        n_entrate = 0
        n_uscite = 0
        for voci in self.spese.values():
            for voce in voci:
                if len(voce) >= 4 and voce[0] == categoria:
                    tipo = voce[3]
                    if tipo == "Entrata":
                        n_entrate += 1
                    elif tipo == "Uscita":
                        n_uscite += 1
        totale = n_entrate + n_uscite
        if totale == 0:
            return ("Uscita", 0, 0)
        perc_entrate = int(n_entrate / totale * 100)
        perc_uscite = int(n_uscite / totale * 100)
        tipo_prevalente = "Entrata" if n_entrate >= n_uscite else "Uscita"
        return (tipo_prevalente, perc_entrate, perc_uscite)

    # Finestra Interattiva per l'Analisi Dettagliata per Categoria e Periodo
    def open_analisi_categoria(self):
        popup = tk.Toplevel(self, bg=self.COLOR_TOPLEVEL)
        popup.title("Analisi Categoria")
        popup.geometry("700x600")
        popup.transient(self)
        popup.bind("<Escape>", lambda e: popup.destroy())
        self.update_idletasks()
        x = self.winfo_rootx() + (self.winfo_width() // 2) - 350
        y = self.winfo_rooty() + (self.winfo_height() // 2) - 300
        popup.geometry(f"+{x}+{y}")
        frame_top = tk.Frame(popup, bg=self.COLOR_TOPLEVEL)
        frame_top.pack(padx=18, pady=10, fill=tk.X)
        tk.Label(frame_top, text="üîç Seleziona modalit√†:",bg=self.COLOR_TOPLEVEL ,fg=self.TEXT_COLOR).pack(side=tk.LEFT)
        mode_var = tk.StringVar(value="Giorno")
        mode_combo = ttk.Combobox(frame_top, values=["Giorno", "Mese", "Anno", "Totale"], style="Border.TCombobox", textvariable=mode_var, state="readonly", width=10)
        mode_combo.pack(side=tk.LEFT, padx=10)
        frame_period = tk.Frame(popup, bg=self.COLOR_TOPLEVEL)
        frame_period.pack(padx=18, pady=2, fill=tk.X)
        months = [
            "Gennaio", "Febbraio", "Marzo", "Aprile", "Maggio", "Giugno",
            "Luglio", "Agosto", "Settembre", "Ottobre", "Novembre", "Dicembre"
        ]
        today = datetime.date.today()
        anni_presenti = sorted({d.year for d in self.spese.keys()}, reverse=True)
        if not anni_presenti:
            anni_presenti = [today.year]
        year_var_initial = str(anni_presenti[0]) if anni_presenti else str(today.year)
        year_var = tk.StringVar(value=today.year)
        day_var = tk.StringVar(value=str(today.day))
        month_var = tk.StringVar(value=months[today.month - 1]) 
        def get_years_presenti():
            return [str(y) for y in anni_presenti]
        year_combo = ttk.Combobox(frame_period, values=get_years_presenti(), textvariable=year_var, style="Border.TCombobox", state="readonly", width=8)
        month_combo = ttk.Combobox(frame_period, values=months, textvariable=month_var, style="Border.TCombobox", state="readonly", width=16)
        day_combo = ttk.Combobox(frame_period, values=[str(d) for d in range(1, 32)], textvariable=day_var, style="Border.TCombobox", state="readonly", width=4)
        year_combo_only = ttk.Combobox(frame_period, values=get_years_presenti(), textvariable=year_var, style="Border.TCombobox", state="readonly", width=8)
        def update_days(*_):
            try:
                m = months.index(month_var.get()) + 1
                y = int(year_var.get())
            except Exception:
                m = today.month
                y = today.year
            n_days = calendar.monthrange(y, m)[1]
            days = [str(d) for d in range(1, n_days+1)]
            day_combo['values'] = days
            if day_var.get() not in days:
                day_var.set(days[-1])
        month_var.trace_add("write", update_days)
        year_var.trace_add("write", update_days)
        def reset_period():
            oggi = datetime.date.today()
            day_var.set(str(oggi.day))
            month_var.set(months[oggi.month - 1])
            year_var.set(str(oggi.year))
        def update_period_inputs(*_):
            for widget in frame_period.winfo_children():
                widget.pack_forget()
            mode = mode_var.get()
            reset_btn = ttk.Button(frame_period, text="‚Ü∫", style='Yellow.TButton', command=reset_period)
            if mode == "Giorno":
                day_combo.pack(side=tk.LEFT)
                month_combo.pack(side=tk.LEFT, padx=(4,8))
                year_combo.pack(side=tk.LEFT)
                reset_btn.pack(side=tk.LEFT, padx=(10, 0))
                update_days()
            elif mode == "Mese":
                month_combo.pack(side=tk.LEFT, padx=(0,8))
                year_combo.pack(side=tk.LEFT)
                reset_btn.pack(side=tk.LEFT, padx=(10, 0))
            elif mode == "Anno":
                year_combo_only.pack(side=tk.LEFT)
                reset_btn.pack(side=tk.LEFT, padx=(10, 0))
        mode_combo.bind("<<ComboboxSelected>>", update_period_inputs)
        update_period_inputs()
        frame_cat = tk.Frame(popup, bg=self.COLOR_TOPLEVEL)
        frame_cat.pack(padx=18, pady=12, fill=tk.X)
        tk.Label(frame_cat, bg=self.COLOR_TOPLEVEL ,fg=self.TEXT_COLOR, text="Categoria:").pack(side=tk.LEFT)
        def get_catlist():
            return ["Tutte le categorie"] + sorted(self.categorie)
        cat_var = tk.StringVar(value="Tutte le categorie")
        cat_combo = ttk.Combobox(frame_cat, values=get_catlist(), textvariable=cat_var, style="Border.TCombobox", state="readonly", width=25)
        cat_combo.pack(side=tk.LEFT, padx=10)
        main_result_frame = ttk.Frame(popup)
        main_result_frame.pack(padx=18, fill=tk.BOTH, expand=True) 
        main_result_frame.grid_rowconfigure(0, weight=1)
        main_result_frame.grid_columnconfigure(0, weight=1)
        scroll_y = ttk.Scrollbar(main_result_frame, orient=tk.VERTICAL, style="Vertical.TScrollbar")
        scroll_y.grid(row=0, column=1, sticky="ns")
        text_result = tk.Text(
            main_result_frame, 
            height=22, 
            width=90, 
            font=("Courier New", 10), 
            wrap='none',
            yscrollcommand=scroll_y.set, 
            bg=self.COLOR_TOPLEVEL, 
            fg=self.TEXT_COLOR 
        )
        text_result.grid(row=0, column=0, sticky="nsew") 
        scroll_y.config(command=text_result.yview)
        frame_buttons = ttk.Frame(popup)
        frame_buttons.pack(fill=tk.X, padx=18, pady=8) 
        export_btn = ttk.Button(frame_buttons, text="üíæ Esporta", style='Verde.TButton')
        export_btn.pack(side=tk.LEFT, padx=4)
        close_btn = ttk.Button(frame_buttons, text="‚ùå Chiudi", command=popup.destroy, style='Giallo.TButton')
        close_btn.pack(side=tk.RIGHT, padx=4)
        def aggiorna_cat_combo():
            cat_combo['values'] = get_catlist()
            if cat_var.get() not in cat_combo['values']:
                cat_var.set("Tutte le categorie")
        aggiorna_cat_combo()
        def mostra_dettagli(*_):
            cat = cat_var.get()
            mode = mode_var.get()
            result_lines = []
            today = datetime.date.today()
            def calcola_totali(entries):
                entrate = sum(e[2] for _, e in filtered if "entrata" in e[3].lower())
                uscite = sum(e[2] for _, e in filtered if "entrata" not in e[3].lower())
                return entrate, uscite, entrate - uscite
            filtered = []
            label_intestazione = ""
            if mode == "Giorno":
                try:
                    m = months.index(month_var.get()) + 1
                    d = int(day_var.get())
                    y = int(year_var.get())
                    giorno = datetime.date(y, m, d)
                except Exception:
                    giorno = today
                spese = self.spese.get(giorno, [])
                filtered = [(giorno, e) for e in spese if cat == "Tutte le categorie" or e[0] == cat]
                label_intestazione = f"{'Entrate/Uscite' if cat == 'Tutte le categorie' else 'Spese ' + cat} per il giorno {giorno.strftime('%d-%m-%Y')}"
            elif mode == "Mese":
                try:
                    m = months.index(month_var.get()) + 1
                    y = int(year_var.get())
                except Exception:
                    m = today.month
                    y = today.year
                for d, sp in self.spese.items():
                    if d.year == y and d.month == m:
                        for e in sp:
                            if cat == "Tutte le categorie" or e[0] == cat:
                                filtered.append((d, e))
                label_intestazione = f"{'Entrate/Uscite' if cat == 'Tutte le categorie' else 'Spese ' + cat} per {self.get_month_name(m)} {y}"
            elif mode == "Anno":
                try:
                    y = int(year_var.get())
                except Exception:
                    y = today.year
                for d, sp in self.spese.items():
                    if d.year == y:
                        for e in sp:
                            if cat == "Tutte le categorie" or e[0] == cat:
                                filtered.append((d, e))
                label_intestazione = f"{'Entrate/Uscite' if cat == 'Tutte le categorie' else 'Spese ' + cat} per l'anno {y}"
            elif mode == "Totale":
                for d, sp in self.spese.items():
                    for e in sp:
                        if cat == "Tutte le categorie" or e[0] == cat:
                            filtered.append((d, e))
                label_intestazione = f"{'Entrate/Uscite' if cat == 'Tutte le categorie' else 'Spese ' + cat} totali"
            text_result.configure(font=("Courier New", 10))
            result_lines.clear()
            if not filtered:
                result_lines.append(f"Nessuna spesa per '{cat}'.")
            else:
                result_lines.append("=" * 80)
                result_lines.append(label_intestazione)
                result_lines.append("-" * 80)
                result_lines.append(f"{'Data':<12}  {'Categoria':<20}  {'Descrizione':<15}  {'Importo':>10}")
                result_lines.append("-" * 80)
                for d, e in sorted(filtered, key=lambda x: x[0], reverse=True):
                    valore = abs(e[2])
                    categoria = e[0][:20]
                    descrizione = e[1][:15]
                    result_lines.append(
                        f"{d.strftime('%d-%m-%Y'):<12}  {categoria:<20}  {descrizione:<15}  {valore:>9.2f} ‚Ç¨ ({e[3]})"
                    )
                result_lines.append("-" * 80)
                entrate, uscite, saldo = calcola_totali([e for _, e in filtered])
                result_lines.append(f"{'Totale entrate':<54}  {entrate:>9.2f} ‚Ç¨")
                result_lines.append(f"{'Totale uscite':<54}  {uscite:>9.2f} ‚Ç¨")
                result_lines.append(f"{'Saldo finale':<54}  {saldo:+9.2f} ‚Ç¨")
                result_lines.append("=" * 80)
            text_result.delete("1.0", tk.END)
            text_result.insert("end", "\n".join(result_lines))
        def esporta_analisi():
            contenuto = text_result.get("1.0", tk.END).strip()
            if not contenuto:
                self.show_custom_warning("Esporta", "Nulla da esportare.")
                return
            preview = tk.Toplevel(popup, bg=self.COLOR_TOPLEVEL)
            preview.title("Preview esportazione")
            larghezza_finestra = 800
            altezza_finestra = 500
            x = popup.winfo_rootx() + (popup.winfo_width() // 2) - (larghezza_finestra // 2)
            y = popup.winfo_rooty() + (popup.winfo_height() // 2) - (altezza_finestra // 2)
            preview.geometry(f"{larghezza_finestra}x{altezza_finestra}+{x}+{y}")
            preview.transient(popup)
            preview.grab_set()
            preview.focus_set()
            preview.bind("<Escape>", lambda e: preview.destroy())
            tx = tk.Text(preview, font=("Courier new", 10), wrap="none")
            tx.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
            contenuto_preview = "\n".join(" " + l for l in contenuto.splitlines())
            tx.insert(tk.END, contenuto_preview)
            tx.config(state="disabled")
            frm = tk.Frame(preview, bg=self.COLOR_TOPLEVEL)
            frm.pack(fill=tk.X, padx=10, pady=8)
            def do_save():
                now = datetime.date.today()
                default_filename = f"Analisi_Export_{now.day:02d}-{now.month:02d}-{now.year}.txt"
                file = filedialog.asksaveasfilename(
                    defaultextension=".txt",
                    filetypes=[("File txt", "*.txt")],
                    initialdir=EXPORT_FILES,
                    title="Esporta Analisi Categoria",
                    initialfile=default_filename,
                    confirmoverwrite=False,
                    parent=preview)
                if file:
                    if os.path.exists(file):
                        conferma = self.show_custom_askyesno(
                            "Sovrascrivere file?",
                            f"Il file '{os.path.basename(file)}' \nesiste gi√†. Vuoi sovrascriverlo?"
                        )
                        if not conferma:
                            return  
                    with open(file, "w", encoding="utf-8") as f:
                        f.write(contenuto_preview)
                        self.show_custom_warning("Esporta", f"Analisi esportata in {file}")
                    preview.destroy()
            ttk.Button(frm, text="üíæ Salva", command=do_save, style="Verde.TButton").pack(side=tk.LEFT, padx=6)
            ttk.Button(frm, text="üñ®Ô∏è Stampa", style="Blu.TButton", command=lambda: self._stampa_lista_diretta(
                    contenuto_preview.rstrip('\n'),self.show_custom_warning)).pack(side=tk.LEFT, padx=6)
            ttk.Button(frm, text="‚ùå Chiudi", command=preview.destroy, style="Giallo.TButton").pack(side=tk.RIGHT, padx=6)
            preview.lift()
            preview.attributes('-topmost', True)
            preview.after(100, lambda: preview.attributes('-topmost', False))
            preview.bind("<Escape>", lambda e: preview.destroy())
        export_btn.config(command=esporta_analisi)
        mode_var.trace_add("write", mostra_dettagli)
        month_var.trace_add("write", mostra_dettagli)
        year_var.trace_add("write", mostra_dettagli)
        day_var.trace_add("write", mostra_dettagli)
        cat_var.trace_add("write", mostra_dettagli)
        mostra_dettagli()

    # Apertura Diretta del Link Bancario nel Browser di Sistema
    def chiama_banca(self):
        if not LINK_BANCA or LINK_BANCA.strip() == "":
            messaggio_istruzioni = (
                "L'indirizzo del link bancario non √® stato configurato.\n\n"
                "Per risolvere:\n"
                "1. Vai al menu *Opzioni*.\n"
                "2. Seleziona *Impostazioni App*.\n"
                "3. Inserisci l'URL completo della tua banca nel campo dedicato."
            )
            self.show_custom_warning(
                "Link Bancario Mancante", 
                messaggio_istruzioni
            )
            return
        try:
            webbrowser.open_new_tab(LINK_BANCA)
        except Exception as e:
            self.show_custom_warning(
                "‚ùå Errore di Apertura", 
                f"Impossibile aprire il link: {LINK_BANCA}\nErrore: {e}"
            )
            print(f"Errore durante l'apertura del link: {e}")

    def calcola_saldo(self, filtro):
        saldo = self.saldo_iniziale if hasattr(self, 'saldo_iniziale') else 0.0
        data_saldo = self.saldo_data if hasattr(self, 'saldo_data') else datetime.date.today()
        saldo_totale = saldo
        saldo_mese = 0.0
        saldo_anno = 0.0
        oggi = datetime.date.today()
        mese = oggi.month
        anno = oggi.year
        for d in sorted(self.spese.keys()):
            for entry in self.spese[d]:
                imp = entry[2]
                tipo = entry[3]
                valore = imp if tipo == "Entrata" else -imp
                saldo_totale += valore
                if d >= data_saldo:
                    if d.year == anno:
                        saldo_anno += valore
                        if d.month == mese:
                            saldo_mese += valore
        return {"mese": saldo_mese, "anno": saldo_anno + saldo, "totale": saldo_totale}[filtro]

    def carica_saldo(self):
        self.saldo_iniziale = 0.0
        self.saldo_data = datetime.date.today()
        if os.path.exists(SALDO_FILE):
            try:
                with open(SALDO_FILE, "r", encoding="utf-8") as f:
                    saldo_db = json.load(f)
                self.saldo_iniziale = float(saldo_db.get("saldo", 0.0))
                self.saldo_data = datetime.datetime.strptime(
                    saldo_db.get("saldo_data", self.saldo_data.strftime("%d-%m-%Y")),
                    "%d-%m-%Y"
                ).date()
            except Exception as e:
                print("Errore caricamento saldo:", e)
        self.saldo_attuale = self.calcola_saldo("anno")
        self.saldo_previsto = self.calcola_saldo("totale")

    # Calcolo Dinamico del Saldo Finanziario per Periodo
    def open_saldo_conto(self):
        if hasattr(self, '_saldo_popup') and self._saldo_popup and self._saldo_popup.winfo_exists():
            self._saldo_popup.lift()
            return
        def valida_saldo(valore):
            if len(valore) > 8:
                return False
            if valore == "":
                return True
            return valore.replace(",", "").replace(".", "").isdigit()
        popup = tk.Toplevel(self, bg=self.COLOR_TOPLEVEL)
        self._saldo_popup = popup
        popup.title("Saldo Conto Corrente")
        popup.withdraw()
        larghezza_finestra = 480
        altezza_finestra = 500
        larghezza_schermo = self.winfo_screenwidth()
        altezza_schermo = self.winfo_screenheight()
        x = (larghezza_schermo // 2) - (larghezza_finestra // 2)
        y = (altezza_schermo // 2) - (altezza_finestra // 2)
        popup.geometry(f"{larghezza_finestra}x{altezza_finestra}+{x}+{y}")
        popup.resizable(False, False)
        popup.transient(self)
        popup.deiconify()
        popup.bind("<Escape>", lambda e: popup.destroy())
        saldo_data = {"saldo": 0.0, "data": datetime.date.today().strftime("%d-%m-%Y")}
        if os.path.exists(SALDO_FILE):
            try:
                with open(SALDO_FILE, "r", encoding="utf-8") as f:
                    db = json.load(f)
                saldo_data["saldo"] = db.get("saldo", 0.0)
                saldo_data["data"] = db.get("saldo_data", saldo_data["data"])
            except Exception:
                pass
        frame = tk.Frame(popup, bg=self.COLOR_TOPLEVEL)
        frame.pack(padx=28, pady=18, fill=tk.BOTH, expand=True)
        lastframe = ttk.LabelFrame(frame, text="Ultimo saldo inserito", padding=10)
        lastframe.pack(fill=tk.X, padx=0, pady=(0, 18))
        last_saldo_var = tk.StringVar(value=f"{saldo_data['saldo']:.2f}")
        last_data_var = tk.StringVar(value=saldo_data["data"])
        ttk.Label(lastframe, text="üí∞ Ultimo saldo:", font=("Arial", 11)).grid(row=0, column=0, sticky="e", padx=(0,8), pady=2)
        ttk.Entry(lastframe, textvariable=last_saldo_var, width=15, font=("Arial", 11), state="readonly").grid(row=0, column=1, padx=(0,8), pady=2)
        ttk.Label(lastframe, text="‚Ç¨", font=("Arial", 11)).grid(row=0, column=2, sticky="w", pady=2)
        ttk.Label(lastframe, text="üìÖ Data inserimento:", font=("Arial", 11)).grid(row=1, column=0, sticky="e", padx=(0,8), pady=2)
        ttk.Entry(lastframe, textvariable=last_data_var, width=12, font=("Arial", 11), state="readonly").grid(row=1, column=1, pady=2, sticky="w")
        btmframe = ttk.LabelFrame(frame, text="üîÑ Aggiorna saldo bancario", padding=10)
        btmframe.pack(fill=tk.X, padx=0, pady=(0, 0))
        ttk.Label(btmframe, text="Data saldo:", font=("Arial", 10, "bold")).grid(row=0, column=0, sticky="e", padx=(0,8), pady=2)
        data_var = tk.StringVar(value=datetime.date.today().strftime("%d-%m-%Y"))
        data_entry = ttk.Entry(btmframe, textvariable=data_var, width=15, font=("Arial", 11), state="normal")
        data_entry.grid(row=0, column=1, sticky="w", padx=(0,2))
        ttk.Button(
            btmframe, 
            text="üìÖ", 
            width=3, 
            command=lambda: self.mostra_calendario_popup(data_entry, data_var)
        ).grid(row=0, column=2, padx=2)
        ttk.Button(
            btmframe,
            text="‚Ü∫",
            style='Yellow.TButton',
            width=3,
            command=lambda: data_var.set(datetime.date.today().strftime("%d-%m-%Y"))
        ).grid(row=0, column=3, padx=2)

        ttk.Label(btmframe, text="Nuovo saldo:", font=("Arial", 11)).grid(row=1, column=0, sticky="e", pady=(14,2))
        saldo_var = tk.StringVar()
        vcmd = (popup.register(valida_saldo), "%P")
        ttk.Entry(
            btmframe,
            textvariable=saldo_var,
            width=15,
            font=("Arial", 11),
            validate="key",
            validatecommand=vcmd
        ).grid(row=1, column=1, sticky="w", padx=4, pady=(14,2))
        ttk.Label(btmframe, text="‚Ç¨", font=("Arial", 11)).grid(row=1, column=2, sticky="w", pady=(14,2))
        lbl_saldo_mese = tk.Label(frame, bg=self.COLOR_TOPLEVEL, fg=self.TEXT_COLOR, font=("Courier New", 9))
        lbl_saldo_anno = tk.Label(frame, bg=self.COLOR_TOPLEVEL, fg=self.TEXT_COLOR, font=("Courier New", 9))
        lbl_saldo_tot  = tk.Label(frame, bg=self.COLOR_TOPLEVEL, fg=self.TEXT_COLOR, font=("Courier New", 9, "bold"))
        lbl_saldo_mese.pack(anchor="w", pady=(20, 0))
        lbl_saldo_anno.pack(anchor="w")
        lbl_saldo_tot.pack(anchor="w", pady=(0, 12))
        def get_selected_date():
            try:
                return datetime.datetime.strptime(data_var.get(), "%d-%m-%Y").date()
            except Exception:
                return datetime.date.today()
        def calcola_saldo_popup(filtro):
            try:
                saldo = float(last_saldo_var.get())
            except Exception:
                saldo = 0.0
            data_saldo = get_selected_date()
            saldo_totale = saldo
            saldo_mese = 0.0
            saldo_anno = 0.0
            oggi = datetime.date.today()
            mese = oggi.month
            anno = oggi.year
            for d in sorted(self.spese.keys()):
                for entry in self.spese[d]:
                    imp = entry[2]
                    tipo = entry[3]
                    valore = imp if tipo == "Entrata" else -imp
                    saldo_totale += valore
                    if d >= data_saldo:
                        if d.year == anno:
                            saldo_anno += valore
                            if d.month == mese:
                                saldo_mese += valore
            return {"mese": saldo_mese, "anno": saldo_anno + saldo, "totale": saldo_totale}[filtro]
        def aggiorna_saldi(*_):
            W = 38 
            sm = f"{calcola_saldo_popup('mese'):>10.2f} ‚Ç¨"
            sa = f"{calcola_saldo_popup('anno'):>10.2f} ‚Ç¨"
            st = f"{calcola_saldo_popup('totale'):>10.2f} ‚Ç¨"
            lbl_saldo_mese.config(text=f"{'Saldo nel mese:'.ljust(W-len(sm))}{sm}")
            lbl_saldo_anno.config(text=f"{'Saldo nell''anno:'.ljust(W-len(sa))}{sa}")
            lbl_saldo_tot.config(text=f"{'Saldo totale:'.ljust(W-len(st))}{st}")
        data_var.trace_add("write", aggiorna_saldi)
        aggiorna_saldi()

        def salva_saldo():
            try:
                nuovo_saldo = float(saldo_var.get().replace(",", "."))
                nuova_data = data_var.get()
                last_saldo_var.set(f"{nuovo_saldo:.2f}")
                last_data_var.set(nuova_data)
                db = {}
                if os.path.exists(SALDO_FILE):
                    try:
                        with open(SALDO_FILE, "r", encoding="utf-8") as f:
                            db = json.load(f)
                    except json.JSONDecodeError:
                        db = {}
                db["saldo"] = nuovo_saldo
                db["saldo_data"] = nuova_data
                with open(SALDO_FILE, "w", encoding="utf-8") as f:
                    json.dump(db, f, indent=2, ensure_ascii=False)
                saldo_var.set("")
                aggiorna_saldi()
                self.show_custom_warning("Salvataggio","‚úÖ Saldo aggiornato correttamente.")
                self.carica_saldo()
                self.aggiorna_treeview()
                self.aggiorna_riepilogo()
            except ValueError:
                self.show_custom_warning("Salvataggio", "‚ùå Inserisci un numero valido.")
        def esporta():
            sm = calcola_saldo_popup("mese")
            sa = calcola_saldo_popup("anno")
            st = calcola_saldo_popup("totale")
            lines = [
                f"Saldo inserito il {last_data_var.get()}: {last_saldo_var.get()} ‚Ç¨",
                f"Saldo nel mese: {sm:.2f} ‚Ç¨",
                f"Saldo nell'anno: {sa:.2f} ‚Ç¨",
                f"Saldo totale: {st:.2f} ‚Ç¨",
            ]
            preview = tk.Toplevel(popup, bg=self.COLOR_TOPLEVEL )
            preview.title("Esporta saldo")
            preview.geometry("420x250")
            preview.transient(popup)
            preview.grab_set()
            preview.resizable(False, False)
            preview.bind("<Escape>", lambda e: preview.destroy())
            txt = tk.Text(preview, font=("Arial", 10), wrap="word", height=6)
            txt.insert("1.0", "\n".join(lines))
            txt.configure(state="disabled")
            txt.pack(fill="both", expand=True, padx=10, pady=10)
            def do_save():
                default_filename = f"Saldo_Export_{datetime.date.today().strftime('%d-%m-%Y')}.txt"
                path = filedialog.asksaveasfilename(
                    initialfile= default_filename,
                    initialdir=EXPORT_FILES,
                    defaultextension=".txt",
                    title="Salva Saldo",
                    confirmoverwrite=False,
                    filetypes=[("File di testo", "*.txt")],
                    parent=preview
                )
                if path:
                    if os.path.exists(path):
                        conferma = self.show_custom_askyesno(
                            "Sovrascrivere file?",
                            f"Il file '{os.path.basename(path)}' \nesiste gi√†. Vuoi sovrascriverlo?"
                        )
                        if not conferma: return
                    with open(path, "w", encoding="utf-8") as f:
                        f.write("\n".join(lines))
                    self.show_custom_warning("Salvataggio","‚úÖ Esportazione completata.")
                    preview.destroy()
            btns = tk.Frame(preview, bg=self.COLOR_TOPLEVEL )
            btns.pack(pady=10)
            ttk.Button(btns, text="üíæ Salva", command=do_save, style="Verde.TButton").pack(side="left", padx=6)
            ttk.Button(btns, text="‚ùå Chiudi", command=preview.destroy, style="Giallo.TButton").pack(side="right", padx=6)
        btn_frame = tk.Frame(popup, bg=self.COLOR_TOPLEVEL)
        btn_frame.pack(pady=(12, 10))
        ttk.Button(btn_frame, text="üíæ Salva saldo", command=salva_saldo, style="Verde.TButton").pack(side="left", padx=6)
        ttk.Button(btn_frame, text="üìÑ Preview Esporta", command=esporta, style="Arancio.TButton").pack(side="left", padx=6)
        ttk.Button(btn_frame, text="‚ùå Chiudi", command=popup.destroy, style="Giallo.TButton").pack(side="right", padx=6)
    def show_tooltip_saldo(self, event):
        self.carica_saldo()
        if hasattr(self, "tooltip_label"):
            self.tooltip_label.destroy()
        tooltip_text = (
            "üíº Saldo conto corrente\n\n"
            f"{'Saldo iniziale:':<18} ‚Ç¨ {self.saldo_iniziale:>10.2f}\n"
            f"{'Saldo attuale:':<18} ‚Ç¨ {self.saldo_attuale:>10.2f}\n"
            f"{'Saldo previsto:':<18} ‚Ç¨ {self.saldo_previsto:>10.2f}\n"
            f"{'Data saldo:':<18}   {self.saldo_data.strftime('%d-%m-%Y'):>12}\n"
        )
        self.tooltip_label = ttk.Label(
            self, 
            text=tooltip_text, 
            style="Tooltip.TLabel",
            font=("Courier New", 9)
        )
        self.update_idletasks()
        x = self.winfo_width() - 280
        y = 50
        self.tooltip_label.place(x=x, y=y)
    def hide_tooltip_saldo(self,event):
        if hasattr(self, "tooltip_label"):
            self.tooltip_label.destroy()
            del self.tooltip_label
            
    # Ripristino della Visualizzazione alla Data Attuale        
    def goto_today(self):
        today = datetime.date.today()
        if hasattr(self, "cal"):
            self.cal.selection_set(today)
            self.cal._sel_date = today
        self.stats_refdate = today
        mesi = [
            "Gennaio", "Febbraio", "Marzo", "Aprile", "Maggio", "Giugno",
            "Luglio", "Agosto", "Settembre", "Ottobre", "Novembre", "Dicembre"
        ]
        self.estratto_month_var.set(mesi[today.month - 1])
        self.estratto_year_var.set(str(today.year))
        self.set_stats_mode("giorno")
        self.after_idle(self.update_stats)
        self.update_totalizzatore_anno_corrente()
        self.update_totalizzatore_mese_corrente()
        self.update_spese_mese_corrente()
        self.stats_label.config(
            text=f"Riepilogo Giornaliero - {today.strftime('%d-%m-%Y')}", foreground="purple",
    font=("Arial", 10, "bold"))

    # Confronto Avanzato Delle Spese/Entrate per Categoria (Mese vs Mese / Anno vs Anno)
    def open_compare_window(self):
        today = datetime.date.today()
        mese_oggi = f"{today.month:02d}"
        anno_oggi = str(today.year)
        compare_by_year = tk.BooleanVar(value=False)
        mostra_future_var = tk.BooleanVar(value=True)
        def parse_date(d):
            if isinstance(d, datetime.date):
                return d
            try:
                if len(d.split("-")[0]) == 4:
                    return datetime.datetime.strptime(d, "%Y-%m-%d").date()
                else:
                    return datetime.datetime.strptime(d, "%d-%m-%Y").date()
            except Exception:
                return None
        def get_rows(mese, anno, per_anno=False):
            rows = []
            oggi = datetime.date.today()
            for d_raw in sorted(self.spese):
                d = parse_date(d_raw)
                if not d:
                    continue
                if not mostra_future_var.get() and d > oggi:
                    continue
                if (per_anno and d.year == anno) or \
                   (not per_anno and d.month == mese and d.year == anno):
                    for voce in self.spese[d_raw]:
                        try:
                            if len(voce) >= 4:
                                if len(voce) == 5:
                                    cat, desc, imp, tipo, _ = voce 
                                else: 
                                    cat, desc, imp, tipo = voce
                                data_pagamento = d.strftime("%d-%m-%Y")
                                entrata = imp if tipo == "Entrata" else 0
                                uscita = imp if tipo == "Uscita" else 0
                                rows.append((cat, data_pagamento, entrata, uscita))
                        except Exception as e:
                            continue
            return rows
        def aggregate_rows_by_category(raw_rows, date_placeholder="Totale"):
            aggregated_data = defaultdict(lambda: [0.0, 0.0])
            for cat, _, ent, usc in raw_rows:
                aggregated_data[cat][0] += ent
                aggregated_data[cat][1] += usc
            result_rows = []
            for cat in sorted(aggregated_data.keys()):
                 ent, usc = aggregated_data[cat]
                 result_rows.append((cat, date_placeholder, ent, usc)) 
            return result_rows
        popup = tk.Toplevel(self, bg=self.COLOR_TOPLEVEL)
        popup.withdraw()
        self.update_idletasks()
        main_x = self.winfo_rootx()
        main_y = self.winfo_rooty()
        main_width = self.winfo_width()
        main_height = self.winfo_height()
        popup_width = 1030    
        popup_height = 560
        center_x = main_x + (main_width // 2) - (popup_width // 2)
        center_y = main_y + (main_height // 2) - (popup_height // 2)
        popup.geometry(f"{popup_width}x{popup_height}+{center_x}+{center_y}")
        popup.transient(self)
        popup.title("Confronta mesi/anni per categoria")
        popup.deiconify()
        popup.bind("<Escape>", lambda e: popup.destroy())
        frame = ttk.Frame(popup)
        frame.pack(fill=tk.BOTH, expand=True, padx=14, pady=14)
        frame.columnconfigure(0, weight=1)
        frame.columnconfigure(1, weight=1)
        anni_presenti_nel_db = set()
        for d_raw in self.spese.keys():
            d = parse_date(d_raw)
            if d:
                anni_presenti_nel_db.add(d.year)
        anni_correnti_e_db = sorted(list(anni_presenti_nel_db.union({today.year, today.year - 1, today.year + 1})), reverse=True) 
        anni = anni_correnti_e_db 
        mesi = [f"{i:02d}" for i in range(1, 13)]

        mode_frame = tk.Frame(frame, bg=self.COLOR_TOPLEVEL)
        mode_frame.grid(row=0, column=0, columnspan=2, sticky="ew", pady=(0, 8))
        tk.Label(mode_frame, text="Modalit√† confronto:", bg=self.COLOR_TOPLEVEL ,fg=self.TEXT_COLOR, font=("Arial", 10, "bold")).pack(side=tk.LEFT, padx=(0, 10))
        ttk.Radiobutton(mode_frame, text="Mese", style="Custom.TRadiobutton", variable=compare_by_year, value=False, command=lambda: update_tables()).pack(side=tk.LEFT)
        ttk.Radiobutton(mode_frame, text="Anno", style="Custom.TRadiobutton", variable=compare_by_year, value=True, command=lambda: update_tables()).pack(side=tk.LEFT)
        ttk.Checkbutton(mode_frame, text="Includi movimenti futuri nei totali", variable=mostra_future_var).pack(side=tk.LEFT, padx=(30, 0))
        left_select_frame = ttk.Frame(frame)
        left_select_frame.grid(row=1, column=0, sticky="ew", padx=(0, 16), pady=(0, 6))
        ttk.Label(left_select_frame, text="Mese/Anno 1", font=("Arial", 10, "bold")).pack(side=tk.LEFT, padx=(0, 8))
        left_mese = tk.StringVar(value=mese_oggi)
        left_anno = tk.StringVar(value=anno_oggi)
        cb_lm = ttk.Combobox(left_select_frame, textvariable=left_mese, values=mesi, width=4, style="Border.TCombobox", state="readonly", font=("Arial", 10))
        cb_la = ttk.Combobox(left_select_frame, textvariable=left_anno, values=[str(a) for a in anni], width=7, style="Border.TCombobox", state="readonly", font=("Arial", 10))
        cb_lm.pack(side="left", padx=(0, 3))
        cb_la.pack(side="left")
        def reset_left():
            left_mese.set(mese_oggi)
            left_anno.set(anno_oggi)
        ttk.Button(left_select_frame, text="‚Ü∫", command=reset_left, style='Yellow.TButton').pack(side="right", padx=7)
        left_container = ttk.Frame(frame)
        left_container.grid(row=2, column=0, sticky="nswe", padx=(0, 16))
        left_container.grid_rowconfigure(0, weight=1)
        left_container.grid_columnconfigure(0, weight=1)
        left_vsb = ttk.Scrollbar(left_container, orient="vertical")
        left_vsb.grid(row=0, column=1, sticky="ns")
        left_tree = ttk.Treeview(left_container, columns=("Categoria", "Data", "Entrata", "Uscita"), show="headings", height=14,
                                 yscrollcommand=left_vsb.set)
        left_tree.grid(row=0, column=0, sticky="nswe")
        left_vsb.config(command=left_tree.yview)
        left_tree.tag_configure('entrata', foreground='green')
        left_tree.tag_configure('uscita', foreground='red')
        for col, w, anchor in [("Categoria", 180, "center"), ("Data", 110, "center"), ("Entrata", 100, "center"), ("Uscita", 100, "center")]:
            left_tree.heading(col, text=col, anchor=anchor, command=lambda _col=col: treeview_sort_column(left_tree, _col, False))
            left_tree.column(col, width=w, anchor=anchor, stretch=False)
        left_diff_frame = tk.Frame(left_container, bg=self.COLOR_TOPLEVEL)
        left_diff_frame.grid(row=1, column=0, columnspan=2, pady=(4, 0), sticky=tk.W+tk.E)
        tk.Label(left_diff_frame, bg=self.COLOR_TOPLEVEL ,fg=self.TEXT_COLOR, text="Entrate:", font=("Arial", 10, "bold")).pack(side=tk.LEFT)
        left_total_ent_lbl = tk.Label(left_diff_frame, bg=self.COLOR_TOPLEVEL ,fg=self.TEXT_COLOR, text="", font=("Arial", 10, "bold"))
        left_total_ent_lbl.pack(side=tk.LEFT, padx=(2, 10))
        tk.Label(left_diff_frame, bg=self.COLOR_TOPLEVEL ,fg=self.TEXT_COLOR, text="Uscite:", font=("Arial", 10, "bold")).pack(side=tk.LEFT)
        left_total_usc_lbl = tk.Label(left_diff_frame, bg=self.COLOR_TOPLEVEL ,fg=self.TEXT_COLOR, text="", font=("Arial", 10, "bold"))
        left_total_usc_lbl.pack(side=tk.LEFT, padx=(2, 10))
        tk.Label(left_diff_frame, bg=self.COLOR_TOPLEVEL ,fg=self.TEXT_COLOR, text="Differenza:", font=("Arial", 10, "bold")).pack(side=tk.LEFT)
        left_diff_val_lbl = tk.Label(left_diff_frame, bg=self.COLOR_TOPLEVEL ,fg=self.TEXT_COLOR, text="", font=("Arial", 10, "bold"))
        left_diff_val_lbl.pack(side=tk.LEFT, padx=(2, 0))
        right_select_frame = ttk.Frame(frame)
        right_select_frame.grid(row=1, column=1, sticky="ew", pady=(0, 6))
        ttk.Label(right_select_frame, text="Mese/Anno 2", font=("Arial", 10, "bold")).pack(side=tk.LEFT, padx=(0, 8))
        right_mese = tk.StringVar(value=mese_oggi)
        right_anno = tk.StringVar(value=anno_oggi)
        cb_rm = ttk.Combobox(right_select_frame, textvariable=right_mese, values=mesi, width=4, style="Border.TCombobox", state="readonly", font=("Arial", 10))
        cb_ra = ttk.Combobox(right_select_frame, textvariable=right_anno, values=[str(a) for a in anni], width=7, style="Border.TCombobox", state="readonly", font=("Arial", 10))
        cb_rm.pack(side="left", padx=(0, 3))
        cb_ra.pack(side="left")
        def reset_right():
            right_mese.set(mese_oggi)
            right_anno.set(anno_oggi)
        ttk.Button(right_select_frame, text="‚Ü∫", command=reset_right, style='Yellow.TButton').pack(side="right", padx=7)
        right_container = ttk.Frame(frame)
        right_container.grid(row=2, column=1, sticky="nswe")
        right_container.grid_rowconfigure(0, weight=1)
        right_container.grid_columnconfigure(0, weight=1)
        right_vsb = ttk.Scrollbar(right_container, orient="vertical")
        right_vsb.grid(row=0, column=1, sticky="ns")
        right_tree = ttk.Treeview(right_container, columns=("Categoria", "Data", "Entrata", "Uscita"), show="headings", height=14,
                                  yscrollcommand=right_vsb.set)
        right_tree.grid(row=0, column=0, sticky="nswe")
        right_vsb.config(command=right_tree.yview)
        right_tree.tag_configure('entrata', foreground='green')
        right_tree.tag_configure('uscita', foreground='red')
        for col, w, anchor in [("Categoria", 180, "center"), ("Data", 110, "center"), ("Entrata", 100, "center"), ("Uscita", 100, "center")]:
            right_tree.heading(col, text=col, anchor=anchor, command=lambda _col=col: treeview_sort_column(right_tree, _col, False))
            right_tree.column(col, width=w, anchor=anchor, stretch=False)
        right_diff_frame = tk.Frame(right_container, bg=self.COLOR_TOPLEVEL)
        right_diff_frame.grid(row=1, column=0, columnspan=2, pady=(4, 0), sticky=tk.W+tk.E)
        tk.Label(right_diff_frame, bg=self.COLOR_TOPLEVEL ,fg=self.TEXT_COLOR, text="Entrate:", font=("Arial", 10, "bold")).pack(side=tk.LEFT)
        right_total_ent_lbl = tk.Label(right_diff_frame, bg=self.COLOR_TOPLEVEL ,fg=self.TEXT_COLOR, text="", font=("Arial", 10, "bold"))
        right_total_ent_lbl.pack(side=tk.LEFT, padx=(2, 10))
        tk.Label(right_diff_frame, bg=self.COLOR_TOPLEVEL ,fg=self.TEXT_COLOR, text="Uscite:", font=("Arial", 10, "bold")).pack(side=tk.LEFT)
        right_total_usc_lbl = tk.Label(right_diff_frame, bg=self.COLOR_TOPLEVEL ,fg=self.TEXT_COLOR, text="", font=("Arial", 10, "bold"))
        right_total_usc_lbl.pack(side=tk.LEFT, padx=(2, 10))
        tk.Label(right_diff_frame, bg=self.COLOR_TOPLEVEL ,fg=self.TEXT_COLOR, text="Differenza:", font=("Arial", 10, "bold")).pack(side=tk.LEFT)
        right_diff_val_lbl = tk.Label(right_diff_frame, bg=self.COLOR_TOPLEVEL ,fg=self.TEXT_COLOR, text="", font=("Arial", 10, "bold"))
        right_diff_val_lbl.pack(side=tk.LEFT, padx=(2, 0))
        def treeview_sort_column(tv, col, reverse):
            l = [(tv.set(k, col), k) for k in tv.get_children('')]
            if col == "Data":
                try:
                    l.sort(key=lambda t: datetime.datetime.strptime(t[0], "%d-%m-%Y"), reverse=reverse)
                except ValueError:
                    l.sort(key=lambda t: t[0].lower(), reverse=reverse)
            else:
                try:
                    l.sort(key=lambda t: float(t[0].replace('‚Ç¨', '').replace('.', '').replace(',', '.').strip()), reverse=reverse)
                except (ValueError, IndexError):
                    l.sort(key=lambda t: t[0].lower(), reverse=reverse)
            for index, (val, k) in enumerate(l):
                tv.move(k, '', index)
            tv.heading(col, command=lambda: treeview_sort_column(tv, col, not reverse))
        def create_double_click_wrapper(treeview, mese_var, anno_var, per_anno_mode):
            def wrapper(event):
                item_id = treeview.identify_row(event.y)
                if not item_id:
                    return
                values = treeview.item(item_id, "values")
                if not values or len(values) < 1:
                    return
                categoria = values[0] 
                original_stats_table = getattr(self, 'stats_table', None)
                original_mode = getattr(self, 'stats_mode', None)
                original_refdate = getattr(self, 'stats_refdate', None)
                try:
                    self.stats_table = treeview
                    mode_str = "anno" if per_anno_mode.get() else "mese"
                    self.stats_mode = tk.StringVar(value=mode_str)
                    mese_val = int(mese_var.get())
                    anno_val = int(anno_var.get())
                    self.stats_refdate = datetime.date(anno_val, mese_val, 1)
                    simulated_values = [categoria, categoria] 
                    if hasattr(self, 'on_stats_table_double_click'):
                        self.on_stats_table_double_click(event)
                    else:
                        print("Errore: Funzione di dettaglio (on_stats_table_double_click) non trovata.")
                except Exception as e:
                    print(f"Errore critico durante l'esecuzione del wrapper: {e}") 
                if original_stats_table is not None:
                    self.stats_table = original_stats_table
                elif hasattr(self, 'stats_table'):
                    del self.stats_table
                if original_mode is not None:
                    self.stats_mode = original_mode
                elif hasattr(self, 'stats_mode'):
                    del self.stats_mode
                if original_refdate is not None:
                    self.stats_refdate = original_refdate
                elif hasattr(self, 'stats_refdate'):
                    del self.stats_refdate
            return wrapper
        def update_month_visibility():
            is_annual = compare_by_year.get()
            if is_annual:
                cb_lm.pack_forget()
                cb_rm.pack_forget()
            else:
                cb_la.pack_forget() 
                cb_lm.pack(side="left", padx=(0, 3)) 
                cb_la.pack(side="left") 
                
                cb_ra.pack_forget()
                cb_rm.pack(side="left", padx=(0, 3))
                cb_ra.pack(side="left")
        def update_tables():
            update_month_visibility()
            per_anno = compare_by_year.get()
            a1, a2 = int(left_anno.get()), int(right_anno.get())
            m1 = int(left_mese.get()) if not per_anno else 1
            m2 = int(right_mese.get()) if not per_anno else 1
            rows1_raw, rows2_raw = get_rows(m1, a1, per_anno), get_rows(m2, a2, per_anno)
            date_placeholder = "Totale Anno" if per_anno else "Totale Mese"
            rows1 = aggregate_rows_by_category(rows1_raw, date_placeholder)
            rows2 = aggregate_rows_by_category(rows2_raw, date_placeholder)
            left_tree.delete(*left_tree.get_children())
            tot_ent1, tot_usc1 = 0, 0
            for cat, data, ent, usc in sorted(rows1, key=lambda x: x[0].lower()): 
                tag = 'entrata' if ent > 0 else ('uscita' if usc > 0 else '')
                left_tree.insert("", "end", values=(cat, data, f"{ent:,.2f} ‚Ç¨", f"{usc:,.2f} ‚Ç¨"), tags=(tag,))
                tot_ent1, tot_usc1 = tot_ent1 + ent, tot_usc1 + usc
            diff1 = tot_ent1 - tot_usc1
            left_total_ent_lbl.config(text=f"{tot_ent1:,.2f} ‚Ç¨", fg="green")
            left_total_usc_lbl.config(text=f"{tot_usc1:,.2f} ‚Ç¨", fg="red")
            left_diff_val_lbl.config(
                text=f"{diff1:,.2f} ‚Ç¨",
                fg="green" if diff1 >= 0 else "red"
            )
            right_tree.delete(*right_tree.get_children())
            tot_ent2, tot_usc2 = 0, 0
            for cat, data, ent, usc in sorted(rows2, key=lambda x: x[0].lower()):
                tag = 'entrata' if ent > 0 else ('uscita' if usc > 0 else '')
                right_tree.insert("", "end", values=(cat, data, f"{ent:,.2f} ‚Ç¨", f"{usc:,.2f} ‚Ç¨"), tags=(tag,))
                tot_ent2, tot_usc2 = tot_ent2 + ent, tot_usc2 + usc
            diff2 = tot_ent2 - tot_usc2
            right_total_ent_lbl.config(text=f"{tot_ent2:,.2f} ‚Ç¨", fg="green")
            right_total_usc_lbl.config(text=f"{tot_usc2:,.2f} ‚Ç¨", fg="red")
            right_diff_val_lbl.config(
                text=f"{diff2:,.2f} ‚Ç¨",
                fg="green" if diff2 >= 0 else "red"
            )
            left_tree.unbind('<Double-1>')
            right_tree.unbind('<Double-1>')
            left_tree.bind('<Double-1>', create_double_click_wrapper(left_tree, left_mese, left_anno, compare_by_year))
            right_tree.bind('<Double-1>', create_double_click_wrapper(right_tree, right_mese, right_anno, compare_by_year))
        for var in [left_mese, left_anno, right_mese, right_anno, compare_by_year, mostra_future_var]:
            var.trace_add("write", lambda *a: update_tables())
        update_tables()
        def do_preview_export():
            per_anno = compare_by_year.get()
            a1, a2 = int(left_anno.get()), int(right_anno.get())
            m1 = int(left_mese.get()) if not per_anno else 1
            m2 = int(right_mese.get()) if not per_anno else 1
            rows1_raw, rows2_raw = get_rows(m1, a1, per_anno), get_rows(m2, a2, per_anno)
            label1 = f"{m1:02d}/{str(a1)[-2:]}" if not per_anno else str(a1)
            label2 = f"{m2:02d}/{str(a2)[-2:]}" if not per_anno else str(a2)
            lines = [f"Confronto tra {label1} e {label2}\n"]
            lines.append(f"{'Categoria':<33}{'Entrate ' + label1:>13}{'Uscite ' + label1:>13} |{'Entrate ' + label2:>13}{'Uscite ' + label2:>13} |{'Œî Entrate':>13}{'Œî Uscite':>13}")
            lines.append("-" * 130)
            data1 = defaultdict(lambda: [0.0, 0.0])
            for cat, _, ent, usc in rows1_raw:
                data1[cat][0] += ent
                data1[cat][1] += usc
            data2 = defaultdict(lambda: [0.0, 0.0])
            for cat, _, ent, usc in rows2_raw:
                data2[cat][0] += ent
                data2[cat][1] += usc
            tutte_le_categorie = sorted(set(data1.keys()) | set(data2.keys()))
            for cat in tutte_le_categorie:
                ent1, usc1 = data1[cat]
                ent2, usc2 = data2[cat]
                diff_ent, diff_usc = ent2 - ent1, usc2 - usc1
                lines.append(f"{cat:<20.20} {'':<12} {ent1:12,.2f} {usc1:12,.2f} | {ent2:12,.2f} {usc2:12,.2f} | {diff_ent:12,.2f} {diff_usc:12,.2f}")
            tot_ent1, tot_usc1 = sum(v[0] for v in data1.values()), sum(v[1] for v in data1.values())
            diff1 = tot_ent1 - tot_usc1
            tot_ent2, tot_usc2 = sum(v[0] for v in data2.values()), sum(v[1] for v in data2.values())
            diff2 = tot_ent2 - tot_usc2
            diff_ent_tot, diff_usc_tot = tot_ent2 - tot_ent1, tot_usc2 - tot_usc1
            lines.append("-" * 130)
            lines.append(f"{'TOTALI GENERALI':<33} {tot_ent1:12,.2f} {tot_usc1:12,.2f} | {tot_ent2:12,.2f} {tot_usc2:12,.2f} | {diff_ent_tot:12,.2f} {diff_usc_tot:12,.2f}")
            saldo1_str = f"{diff1:,.2f} ‚Ç¨"
            saldo2_str = f"{diff2:,.2f} ‚Ç¨"
            lines.append(f"{'RISPARMIO NETTO (Saldo)':<33} {saldo1_str:>25} | {saldo2_str:>25} |")
            miglioramento = diff2 - diff1
            lines.append("-" * 130)
            text = "\n".join(lines)
            prev = tk.Toplevel(popup, bg=self.COLOR_TOPLEVEL)
            prev.title("Preview Esporta confronto")
            popup_width = 1100
            popup_height = 580
            screen_width = self.winfo_screenwidth()
            screen_height = self.winfo_screenheight()
            center_x = int((screen_width / 2) - (popup_width / 2))
            center_y = int((screen_height / 2) - (popup_height / 2))
            prev.geometry(f"{popup_width}x{popup_height}+{center_x}+{center_y}")
            prev.transient(popup)
            prev.bind("<Escape>", lambda e: prev.destroy())
            text_frame = tk.Frame(prev)
            text_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=(10, 0))
            text_frame.grid_rowconfigure(0, weight=1)
            text_frame.grid_columnconfigure(0, weight=1)
            vsb_text = ttk.Scrollbar(text_frame, orient="vertical")
            vsb_text.grid(row=0, column=1, sticky="ns")
            t = tk.Text(text_frame, font=("Courier New", 10), wrap="none", yscrollcommand=vsb_text.set)
            t.grid(row=0, column=0, sticky="nswe")
            vsb_text.config(command=t.yview)
            t.insert(tk.END, text)
            t.config(state="disabled")
            def do_save():
                now = datetime.date.today()
                default_filename = f"Confronto_Export_{now.day:02d}-{now.month:02d}-{now.year}.txt"
                file = filedialog.asksaveasfilename(defaultextension=".txt", filetypes=[("File txt", "*.txt")], initialdir=EXPORT_FILES, initialfile=default_filename, title="Esporta confronto", confirmoverwrite=False, parent=prev)
                if file:
                    if os.path.exists(file) and not hasattr(self, 'show_custom_askyesno') or not self.show_custom_askyesno("Sovrascrivere file?", f"Il file '{os.path.basename(file)}' \nesiste gi√†. Vuoi sovrascriverlo?"):
                        return
                    with open(file, "w", encoding="utf-8") as f:
                        f.write(text)
                    if hasattr(self, "show_custom_warning"):
                        self.show_custom_warning("Esportazione completata", f"Tabella confronti esportata in:\n{file}")
            frm = tk.Frame(prev, bg=self.COLOR_TOPLEVEL)
            frm.pack(fill=tk.X, padx=10, pady=8)
            ttk.Button(frm, text="üíæ Esporta", command=do_save, style="Verde.TButton").pack(side=tk.LEFT, padx=6)
            if hasattr(self, '_stampa_lista_diretta'):
                ttk.Button(frm, text="üñ®Ô∏è Stampa", command=lambda: self._stampa_lista_diretta(text, self.show_custom_warning), style="Blu.TButton").pack(side=tk.LEFT, padx=6)
            ttk.Button(frm, text="‚ùå Chiudi", command=prev.destroy, style="Giallo.TButton").pack(side=tk.RIGHT, padx=6)
            prev.lift()
            prev.focus_force()
            prev.attributes('-topmost', True)
            prev.after(100, lambda: prev.attributes('-topmost', False))
        btnframe = tk.Frame(popup, bg=self.COLOR_TOPLEVEL)
        btnframe.pack(side=tk.BOTTOM, fill=tk.X, pady=(10, 7))
        ttk.Button(btnframe, text="üìÑ Esporta", command=do_preview_export, style="Verde.TButton").pack(side=tk.LEFT, padx=8)
        ttk.Button(btnframe, text="üìà Mostra Grafico", command=lambda: self.crea_grafico_confronto(
                left_mese.get(), left_anno.get(), right_mese.get(), right_anno.get(), compare_by_year.get()), style="Blu.TButton").pack(side=tk.LEFT, padx=8)
        ttk.Button(btnframe, text="‚ùå Chiudi", command=popup.destroy, style="Giallo.TButton").pack(side=tk.RIGHT, padx=8)
    def crea_grafico_confronto(self, m1_str, a1_str, m2_str, a2_str, per_anno, categoria_sel=None):
        try:
            m1, a1, m2, a2 = int(m1_str), int(a1_str), int(m2_str), int(a2_str)
            p1_color = "#1f77b4"
            p2_color = "#ff7f0e"
            bg_color = getattr(self, "COLOR_TOPLEVEL", None)
            text_color = getattr(self, "TEXT_COLOR", "#000000")
            def parse_amount(s):
                if s is None: return 0.0
                if isinstance(s, (int, float)): return float(s)
                s = str(s).strip().replace('‚Ç¨', '').replace('\xa0', ' ')
                s = re.sub(r'\s+', '', s)
                if '.' in s and ',' in s: s = s.replace('.', '').replace(',', '.')
                elif ',' in s: s = s.replace(',', '.')
                elif '.' in s:
                    last_dot_idx = s.rfind('.')
                    if len(s) - last_dot_idx - 1 != 2: s = s.replace('.', '')
                try: return float(s)
                except Exception:
                    s2 = re.sub(r'[^0-9\-\.+]', '', s)
                    try: return float(s2) if s2 not in ('', '-', '+') else 0.0
                    except Exception: return 0.0
            def format_euro(val, decimals=2):
                neg = val < 0
                val_abs = abs(val)
                formatted = f"{val_abs:,.{decimals}f}"
                formatted = formatted.replace(',', 'X').replace('.', ',').replace('X', '.')
                return ("-" if neg else "") + formatted + ""
            def get_rows_confronto(mese, anno_param, per_anno_mode, categoria_filter):
                def parse_date_obj(d):
                    if isinstance(d, datetime.date): return d
                    if d is None: return None
                    d_str = str(d).strip()
                    try:
                        if re.match(r'^\d{4}-\d{1,2}-\d{1,2}$', d_str): return datetime.datetime.strptime(d_str, "%Y-%m-%d").date()
                        if re.match(r'^\d{1,2}-\d{1,2}-\d{4}$', d_str): return datetime.datetime.strptime(d_str, "%d-%m-%Y").date()
                        for fmt in ("%d/%m/%Y", "%Y/%m/%d", "%d.%m.%Y"):
                            try: return datetime.datetime.strptime(d_str, fmt).date()
                            except Exception: pass
                    except Exception: pass
                    return None
                rows_grouped = defaultdict(lambda: [0.0, 0.0])
                categories_list_raw = getattr(self, "_saved_info", {}).get("categorie", [])
                if not categories_list_raw:
                    categories_list_raw = getattr(self, "categorie", [])
                categorie_known = [c.strip().lower() for c in categories_list_raw if isinstance(c, str)]
                for d_raw, entries in getattr(self, "spese", {}).items():
                    d = d_raw if isinstance(d_raw, datetime.date) else parse_date_obj(d_raw)
                    if not d: continue
                    if per_anno_mode:
                        if d.year != int(anno_param): continue
                        key = f"{d.month:02d}"
                    else:
                        if d.year != int(anno_param) or d.month != int(mese): continue
                        key = f"{d.year}-{d.month:02d}-{d.day:02d}"
                    for entry in entries:
                        try:
                            categoria_val = None
                            if isinstance(entry, (list, tuple)):
                                if len(entry) >= 1 and isinstance(entry[0], str) and entry[0].strip().lower() in categorie_known: categoria_val = entry[0].strip()
                                elif len(entry) >= 5 and isinstance(entry[4], str): categoria_val = entry[4].strip()
                                elif len(entry) >= 2 and isinstance(entry[1], str): categoria_val = entry[1].strip()
                            elif isinstance(entry, dict):
                                c = entry.get('categoria') or entry.get('category') or entry.get('cat')
                                if isinstance(c, str): categoria_val = c.strip()
                            if categoria_filter and categoria_filter != "Tutte le Categorie":
                                if categoria_val is None or categoria_val.strip().lower() != str(categoria_filter).strip().lower(): continue
                            if isinstance(entry, (list, tuple)):
                                if len(entry) >= 4:
                                    imp = entry[2]; tipo = entry[3]
                                elif len(entry) == 3:
                                    imp = entry[1]; tipo = entry[2]
                                else: continue
                            elif isinstance(entry, dict):
                                imp = entry.get('importo') or entry.get('import') or entry.get('amount')
                                tipo = entry.get('tipo') or entry.get('type')
                            else: continue
                            importo_f = parse_amount(imp)
                            if str(tipo).strip().lower() == "entrata": rows_grouped[key][0] += importo_f
                            else: rows_grouped[key][1] += importo_f
                        except Exception: continue
                return rows_grouped
            popup_width = 1100
            popup_height = 600
            popup_grafico = tk.Toplevel(self)
            popup_grafico.title("Grafico Confronto Periodi")
            popup_grafico.transient(self)
            popup_grafico.minsize(600, 300)
            popup_grafico.configure(bg=bg_color)
            popup_grafico.withdraw()
            self.update_idletasks()
            main_x = self.winfo_rootx() 
            main_y = self.winfo_rooty() 
            main_width = self.winfo_width()
            main_height = self.winfo_height()
            center_x = main_x + (main_width // 2) - (popup_width // 2)
            center_y = main_y + (main_height // 2) - (popup_height // 2)
            center_x = max(0, center_x)
            center_y = max(0, center_y)
            popup_grafico.geometry(f"{popup_width}x{popup_height}+{center_x}+{center_y}")
            main_frame = tk.Frame(popup_grafico, bg=bg_color)
            main_frame.pack(fill=tk.BOTH, expand=True)
            controls_frame = tk.Frame(main_frame, bg=bg_color)
            controls_frame.pack(fill=tk.X, side=tk.TOP, padx=6, pady=6)
            categories_list_raw = getattr(self, "_saved_info", {}).get("categorie", [])
            if not categories_list_raw and getattr(self, "categorie", None):
                categories_list_raw = getattr(self, "categorie", [])
            categories_list = sorted([c for c in categories_list_raw if isinstance(c, str) and c])
            if "Tutte le Categorie" not in categories_list: categories_list.insert(0, "Tutte le Categorie")
            initial_categoria = categoria_sel if categoria_sel and categoria_sel in categories_list else "Tutte le Categorie"
            categoria_var = tk.StringVar(value=initial_categoria)
            combobox_cat = ttk.Combobox(controls_frame, textvariable=categoria_var, values=categories_list, state="readonly", style="Border.TCombobox", width=30)
            combobox_cat.pack(side=tk.RIGHT, padx=(0, 6))
            lbl_filter = tk.Label(controls_frame, text="Filtra Categoria:", bg=bg_color, fg=text_color)
            lbl_filter.pack(side=tk.RIGHT, padx=(4, 2))
            title_frame = tk.Frame(main_frame, bg=bg_color)
            title_frame.pack(fill=tk.X, side=tk.TOP)
            title_lbl = tk.Label(title_frame, text=f"Andamento Saldo Netto ({'Mensile' if per_anno else 'Giornaliero'})", bg=bg_color, fg=text_color, font=("Arial", 12, "bold"))
            title_lbl.pack(side=tk.LEFT, padx=8, pady=(0, 4))
            subtitle_frame = tk.Frame(title_frame, bg=bg_color)
            subtitle_frame.pack(side=tk.LEFT, padx=8)
            subtitle_p1_label = tk.Label(subtitle_frame, text="", bg=bg_color, fg=p1_color, font=("Arial", 9, "bold"))
            subtitle_p1_label.pack(side=tk.LEFT, padx=(0,4))
            subtitle_sep_label = tk.Label(subtitle_frame, text="|", bg=bg_color, fg=text_color, font=("Arial", 9))
            subtitle_sep_label.pack(side=tk.LEFT, padx=(0,4))
            subtitle_p2_label = tk.Label(subtitle_frame, text="", bg=bg_color, fg=p2_color, font=("Arial", 9, "bold"))
            subtitle_p2_label.pack(side=tk.LEFT, padx=(0,8))
            subtitle_cat_label = tk.Label(subtitle_frame, text="", bg=bg_color, fg=text_color, font=("Arial", 9))
            subtitle_cat_label.pack(side=tk.LEFT)
            canvas = tk.Canvas(main_frame, bg="white")
            canvas.pack(fill=tk.BOTH, expand=True, padx=6, pady=6)
            bottom_frame = tk.Frame(main_frame, bg=bg_color)
            bottom_frame.pack(fill=tk.X, side=tk.BOTTOM, padx=6, pady=6)
            legenda_frame = tk.Frame(bottom_frame, bg=bg_color)
            legenda_frame.pack(side=tk.LEFT)
            btn_container = tk.Frame(bottom_frame, bg=bg_color)
            btn_container.pack(side=tk.LEFT, padx=(6, 8))
            ttk.Button(btn_container, text="‚ùå Chiudi", command=popup_grafico.destroy, style="Giallo.TButton").pack(side=tk.LEFT)
            right_diff_frame = tk.Frame(bottom_frame, bg=bg_color)
            right_diff_frame.pack(side=tk.RIGHT, padx=(6, 8))
            p1_totals_lbl = tk.Label(right_diff_frame, bg=bg_color, fg=p1_color, text="", font=("Arial", 10, "bold"))
            p1_totals_lbl.pack(anchor="e")
            p2_totals_lbl = tk.Label(right_diff_frame, bg=bg_color, fg=p2_color, text="", font=("Arial", 10, "bold"))
            p2_totals_lbl.pack(anchor="e")
            delta_lbl = tk.Label(right_diff_frame, bg=bg_color, fg=text_color, text="", font=("Arial", 10, "bold"))
            delta_lbl.pack(anchor="e", pady=(6,0))
            saldos1 = []
            saldos2 = []
            labels_x = []
            keys_all = []
            data1_raw_cache = {}
            data2_raw_cache = {}
            month_abbr_it = {'01':'Gen','02':'Feb','03':'Mar','04':'Apr','05':'Mag','06':'Giu','07':'Lug','08':'Ago','09':'Set','10':'Ott','11':'Nov','12':'Dic'}
            def update_totals_display(d1, d2):
                ent_p1 = sum(v[0] for v in d1.values()); usc_p1 = sum(v[1] for v in d1.values()); diff_p1 = ent_p1 - usc_p1
                ent_p2 = sum(v[0] for v in d2.values()); usc_p2 = sum(v[1] for v in d2.values()); diff_p2 = ent_p2 - usc_p2
                p1_totals_lbl.config(text=f"P1 ‚Äî Entrate: {format_euro(ent_p1,2)}  Uscite: {format_euro(usc_p1,2)}  Saldo: {format_euro(diff_p1,2)}")
                p2_totals_lbl.config(text=f"P2 ‚Äî Entrate: {format_euro(ent_p2,2)}  Uscite: {format_euro(usc_p2,2)}  Saldo: {format_euro(diff_p2,2)}")
                delta = diff_p2 - diff_p1
                fg = "#2ca02c" if delta > 0 else ("#d62728" if delta < 0 else text_color)
                delta_lbl.config(text=f"Variazione Saldo (P2 vs P1): {format_euro(delta,2)}", fg=fg)
            def update_data(categoria_choice):
                nonlocal saldos1, saldos2, labels_x, keys_all, data1_raw_cache, data2_raw_cache
                data1_raw_cache = get_rows_confronto(m1, a1, per_anno, categoria_choice)
                data2_raw_cache = get_rows_confronto(m2, a2, per_anno, categoria_choice)
                keys_all = sorted(set(data1_raw_cache.keys()) | set(data2_raw_cache.keys()))
                saldos1 = []; saldos2 = []; labels_x = []
                for key in keys_all:
                    ent1, usc1 = data1_raw_cache.get(key, (0.0, 0.0)); ent2, usc2 = data2_raw_cache.get(key, (0.0, 0.0))
                    saldos1.append(ent1 - usc1); saldos2.append(ent2 - usc2)
                    if per_anno: labels_x.append(key)
                    else:
                        parts = key.split('-'); labels_x.append(parts[2] if len(parts) == 3 else key)
                update_totals_display(data1_raw_cache, data2_raw_cache)
            def update_subtitle(categoria_choice):
                periodo_p1 = f"{a1}" if per_anno else f"{m1:02d}/{a1}"; periodo_p2 = f"{a2}" if per_anno else f"{m2:02d}/{a2}"
                subtitle_p1_label.config(text=f"P1: {periodo_p1}"); subtitle_p2_label.config(text=f"P2: {periodo_p2}"); subtitle_cat_label.config(text=f"Categoria: {categoria_choice}")
            def draw_chart():
                try:
                    MIN_BAR_HEIGHT_PX = 4 # Altezza minima per la cliccabilit√†
                    canvas_width = max(200, canvas.winfo_width()); canvas_height = max(120, canvas.winfo_height())
                    canvas.delete("all")
                    side_padding_factor = 0.035
                    side_padding = max(50, int(canvas_width * side_padding_factor))
                    right_padding = max(20, int(canvas_width * side_padding_factor))
                    top_padding_plot = max(12, int(canvas_height * 0.08))
                    bottom_padding_plot = max(48, int(canvas_height * 0.15))
                    plot_width = canvas_width - side_padding - right_padding
                    plot_height = canvas_height - top_padding_plot - bottom_padding_plot
                    if plot_width <= 0 or plot_height <= 10: return
                    plot_vals1 = [abs(v) for v in saldos1]
                    plot_vals2 = [abs(v) for v in saldos2]
                    all_plot_vals = plot_vals1 + plot_vals2
                    max_val = max(all_plot_vals) if any(all_plot_vals) else 100.0
                    min_val = 0.0
                    y_range = max_val - min_val
                    if y_range == 0: max_val = max_val + 50; y_range = max_val - min_val
                    margin = y_range * 0.15
                    max_val += margin; y_range = max_val - min_val
                    def scale_y_plot(val):
                        normalized = (val - min_val) / y_range
                        return top_padding_plot + plot_height * (1 - normalized)
                    canvas_y_top = top_padding_plot; canvas_y_end = top_padding_plot + plot_height
                    canvas.create_line(side_padding, canvas_y_top, side_padding, canvas_y_end, fill="gray", width=2)
                    canvas.create_text(side_padding - 6, scale_y_plot(max_val), anchor="e", text=format_euro(max_val,0), font=("Arial", 9))
                    canvas.create_text(side_padding - 6, scale_y_plot(min_val), anchor="e", text=format_euro(min_val,0), font=("Arial", 9))
                    num_points = len(labels_x)
                    if num_points == 0: return
                    x_step = plot_width / num_points
                    bar_w = max(6, int(min(40, x_step * 0.35)))
                    gap = max(4, int(bar_w * 0.2))
                    y_base = scale_y_plot(0)
                    month_abbr_it_local = month_abbr_it
                    small_font = ("Arial", 8)
                    y_base_tic = canvas_y_end + 6
                    def _clamp(v, lo, hi): return max(lo, min(hi, v))
                    label_offset = 10
                    for i, label in enumerate(labels_x):
                        x_center = side_padding + x_step * (i + 0.5)
                        x0_p1 = x_center - (bar_w + gap//2); x1_p1 = x_center - (gap//2)
                        x0_p2 = x_center + (gap//2); x1_p2 = x_center + (bar_w + gap//2)
                        v1 = plot_vals1[i] if i < len(plot_vals1) else 0.0; v2 = plot_vals2[i] if i < len(plot_vals2) else 0.0
                        yv1 = scale_y_plot(v1); yv2 = scale_y_plot(v2)
                        top1 = yv1; bottom1 = y_base
                        if v1 > 0 and (bottom1 - top1) < MIN_BAR_HEIGHT_PX:
                            top1 = bottom1 - MIN_BAR_HEIGHT_PX
                        top1 = _clamp(top1, canvas_y_top, canvas_y_end); bottom1 = _clamp(bottom1, canvas_y_top, canvas_y_end)
                        canvas.create_rectangle(x0_p1, top1, x1_p1, bottom1, fill=p1_color, outline="", tags=(f"bar_p1_{i}", "bar_p1", "bar"))
                        signed_v1 = saldos1[i] if i < len(saldos1) else 0.0
                        tx1 = (x0_p1 + x1_p1) / 2
                        ty1 = _clamp(top1 - label_offset, canvas_y_top + 4, canvas_y_end - 4)
                        color_v1 = "#d62728" if signed_v1 < 0 else ("#2ca02c" if signed_v1 > 0 else text_color)
                        canvas.create_text(tx1, ty1, text=format_euro(signed_v1,0), fill=color_v1, font=("Arial", 8))
                        top2 = yv2; bottom2 = y_base
                        if v2 > 0 and (bottom2 - top2) < MIN_BAR_HEIGHT_PX:
                            top2 = bottom2 - MIN_BAR_HEIGHT_PX
                        top2 = _clamp(top2, canvas_y_top, canvas_y_end); bottom2 = _clamp(bottom2, canvas_y_top, canvas_y_end)
                        canvas.create_rectangle(x0_p2, top2, x1_p2, bottom2, fill=p2_color, outline="", tags=(f"bar_p2_{i}", "bar_p2", "bar"))
                        signed_v2 = saldos2[i] if i < len(saldos2) else 0.0
                        tx2 = (x0_p2 + x1_p2) / 2
                        ty2 = _clamp(top2 - label_offset, canvas_y_top + 4, canvas_y_end - 4)
                        color_v2 = "#d62728" if signed_v2 < 0 else ("#2ca02c" if signed_v2 > 0 else text_color)
                        canvas.create_text(tx2, ty2, text=format_euro(signed_v2,0), fill=color_v2, font=("Arial", 8))
                        if per_anno:
                            month_abbr = month_abbr_it_local.get(label, label)
                            canvas.create_text(x_center, y_base_tic, anchor="n", text=month_abbr, font=small_font)
                        else:
                            key_full = keys_all[i] if i < len(keys_all) else None
                            if key_full:
                                parts = key_full.split('-')
                                if len(parts) == 3:
                                    giorno, mese_abbr = parts[2], parts[1]
                                    canvas.create_text(x_center, y_base_tic, anchor="n", text=f"{giorno}/{mese_abbr}", font=small_font)
                                else:
                                    canvas.create_text(x_center, y_base_tic, anchor="n", text=labels_x[i], font=small_font)
                            else:
                                canvas.create_text(x_center, y_base_tic, anchor="n", text=labels_x[i], font=small_font)
                except Exception as e:
                    print("Errore draw_chart:", e)
            def on_bar_double_click(event):
                item_id = canvas.find_closest(event.x, event.y)[0]
                tags = canvas.gettags(item_id)
                index = -1
                period = None
                for tag in tags:
                    if tag.startswith("bar_p1_"):
                        index = int(tag.split("_")[2])
                        period = 1
                        break
                    elif tag.startswith("bar_p2_"):
                        index = int(tag.split("_")[2])
                        period = 2
                        break
                if index == -1 or index >= len(keys_all):
                    return
                key_clicked = keys_all[index]
                categoria_choice = categoria_var.get()
                if per_anno:
                    mese_val = key_clicked
                    anno_val = a1 if period == 1 else a2
                    data_filter = {
                        "anno": str(anno_val),
                        "mese": mese_val,
                        "categoria": categoria_choice if categoria_choice != "Tutte le Categorie" else None
                    }
                    title = f"Dettaglio Mensile - Mese {mese_val} {anno_val}"
                else:
                    try:
                        anno_str, mese_str, giorno_str = key_clicked.split('-')
                        mese_val = mese_str
                        anno_val = anno_str
                        giorno_val = giorno_str
                    except ValueError:
                        print(f"Errore nel parsing della chiave data: {key_clicked}")
                        return
                    data_filter = {
                        "anno": anno_val,
                        "mese": mese_val,
                        "giorno": giorno_val,
                        "categoria": categoria_choice if categoria_choice != "Tutte le Categorie" else None
                    }
                    title = f"Dettaglio Giornaliero - {giorno_val} {mese_val} {anno_val}"
                if categoria_choice != "Tutte le Categorie":
                    title += f" ({categoria_choice})"
                self.mostra_transazioni_popup(data_filter, title)
            update_data(initial_categoria)
            update_subtitle(initial_categoria)
            def finalizza_apertura():
                popup_grafico.update()
                draw_chart()
                popup_grafico.deiconify()
            popup_grafico.after(100, finalizza_apertura)
            resize_after_id = None
            def on_resize(event):
                nonlocal resize_after_id
                if resize_after_id: canvas.after_cancel(resize_after_id)
                resize_after_id = canvas.after(120, draw_chart)
            popup_grafico.bind("<Configure>", on_resize)
            canvas.bind("<Configure>", on_resize)
            def on_categoria_change(event=None):
                scelta = categoria_var.get()
                update_data(scelta)
                update_subtitle(scelta)
                draw_chart()
            combobox_cat.bind("<<ComboboxSelected>>", on_categoria_change)
            popup_grafico.bind("<Escape>", lambda e: popup_grafico.destroy())
            canvas.tag_bind("bar", "<Double-Button-1>", on_bar_double_click)
            for child in legenda_frame.winfo_children(): child.destroy()
            tk.Label(legenda_frame, text=f"P1 (Blu): {a1 if per_anno else f'{m1:02d}/{a1}'}", bg=bg_color, fg=p1_color, font=("Arial", 10, "bold")).pack(side=tk.LEFT, padx=(2, 8))
            tk.Label(legenda_frame, text=f"P2 (Arancione): {a2 if per_anno else f'{m2:02d}/{a2}'}", bg=bg_color, fg=p2_color, font=("Arial", 10, "bold")).pack(side=tk.LEFT, padx=(2, 8))
        except Exception as e:
            self.show_custom_warning("Errore Grafico", f"Si √® verificato un errore critico durante la generazione del grafico: {e}")
            
    # Gestione e Visualizzazione delle Scadenze/Ricorrenze Mensili
    def scadenze_mese(self):
        if hasattr(self, '_scadenze_popup') and self._scadenze_popup and self._scadenze_popup.winfo_exists():
            self._scadenze_popup.lift()
            return
        def ordina_colonna(treeview, col, reverse):
            def converti(valore):
                if col in ("data", "scadenza"):
                    try:
                        return datetime.datetime.strptime(valore, "%d-%m-%Y")
                    except:
                        return datetime.datetime.max
                elif col == "importo":
                    try:
                        return float(valore.replace("‚Ç¨", "").replace(".", "").replace(",", ".").strip())
                    except:
                        return 0
                else:
                    return valore.lower() if isinstance(valore, str) else valore
            dati = [(treeview.set(k, col), k) for k in treeview.get_children("")]
            dati.sort(key=lambda t: converti(t[0]), reverse=reverse)
            for index, (val, k) in enumerate(dati):
                treeview.move(k, "", index)
            treeview.heading(col, command=(lambda c=col: lambda: ordina_colonna(treeview, c, not reverse))())
        oggi = datetime.date.today()
        mese_corrente = oggi.month
        anno_corrente = oggi.year
        mesi_italiani = [
            "Gennaio", "Febbraio", "Marzo", "Aprile", "Maggio", "Giugno",
            "Luglio", "Agosto", "Settembre", "Ottobre", "Novembre", "Dicembre"
        ]
        mese_nome = mesi_italiani[mese_corrente - 1]
        popup_mensile = tk.Toplevel(self, bg=self.COLOR_TOPLEVEL)
        self._scadenze_popup = popup_mensile
        def on_scadenze_close():
            try:
                popup_mensile.grab_release() 
            except:
                pass
            popup_mensile.destroy()
            self._scadenze_popup = None
        popup_mensile.title(f"Scadenze di {mese_nome} {anno_corrente}")
        larghezza_finestra = 1000
        altezza_finestra = 420
        larghezza_schermo = self.winfo_screenwidth()
        altezza_schermo = self.winfo_screenheight()
        x = (larghezza_schermo // 2) - (larghezza_finestra // 2)
        y = (altezza_schermo // 2) - (altezza_finestra // 2)
        popup_mensile.geometry(f"{larghezza_finestra}x{altezza_finestra}+{x}+{y}")
        popup_mensile.transient(self)
        popup_mensile.focus_force()
        popup_mensile.resizable(False, False)
        popup_mensile.protocol("WM_DELETE_WINDOW", on_scadenze_close)
        popup_mensile.bind("<Escape>", lambda e: on_scadenze_close())
        colonne = ("data", "categoria", "descrizione", "importo", "tipo_voce", "scadenza", "pagato", "progressione")
        tree_mensile = ttk.Treeview(popup_mensile, columns=colonne, show="headings")
        tree_mensile.pack(fill="both", expand=True, padx=10, pady=(10, 0))
        tree_mensile.bind("<Double-1>", self.on_scadenza_doppio_click)
        for col in colonne:
            tree_mensile.heading(col, text=col.capitalize(), command=(lambda c=col: lambda: ordina_colonna(tree_mensile, c, False))())
        tree_mensile.column("data", width=80, anchor="center", stretch=False)
        tree_mensile.column("categoria", width=180, anchor="center", stretch=False)
        tree_mensile.column("descrizione", width=307, anchor="w", stretch=False)
        tree_mensile.column("importo", width=100, anchor="e", stretch=False)
        tree_mensile.column("tipo_voce", width=80, anchor="center", stretch=False)
        tree_mensile.column("scadenza", width=80, anchor="center", stretch=False)
        tree_mensile.column("pagato", width=60, anchor="center", stretch=False)
        tree_mensile.column("progressione", width=90, anchor="center", stretch=False)
        tree_mensile.tag_configure("verde", foreground="green")
        tree_mensile.tag_configure("rosso", foreground="red")
        tree_mensile.tag_configure("grigio", foreground="gray")
        for item_id, dati in self.ricorrenze.items():
            try:
                ric_type = dati.get("tipo", "").lower()
                n = dati.get("n", 0)
                data_inizio = datetime.datetime.strptime(dati.get("data_inizio", ""), "%d-%m-%Y").date()
                categoria = dati.get("cat", "N/D")
                descrizione_base = dati.get("desc", "‚Äî")
                tipo_voce = dati.get("tipo_voce", "N/D")
                importo_base = float(str(dati.get("imp", "0")).replace(",", "."))
                date_nel_mese = []
                for i in range(n):
                    if ric_type == "ogni mese":
                        mese = (data_inizio.month - 1 + i) % 12 + 1
                        anno = data_inizio.year + (data_inizio.month - 1 + i) // 12
                        giorno = min(
                            data_inizio.day,
                            [31, 29 if anno % 4 == 0 and (anno % 100 != 0 or anno % 400 == 0) else 28,
                             31, 30, 31, 30, 31, 31, 30, 31, 30, 31][mese - 1]
                        )
                        data_movimento = datetime.date(anno, mese, giorno)
                    elif ric_type == "ogni anno":
                        data_movimento = data_inizio.replace(year=data_inizio.year + i)
                    else:
                        data_movimento = data_inizio + datetime.timedelta(days=i)
                    if data_movimento.month == mese_corrente and data_movimento.year == anno_corrente:
                        date_nel_mese.append((i + 1, data_movimento))
                for indice, data_movimento in date_nel_mese:
                    voce_trovata = False
                    importo_effettivo = importo_base
                    if data_movimento in self.spese:
                        for voce in self.spese[data_movimento]:
                            if len(voce) == 5 and voce[4] == item_id:
                                importo_effettivo = voce[2]
                                voce_trovata = True
                                break
                    valore_importo = f"{importo_effettivo:,.2f} ‚Ç¨" if voce_trovata else "‚Äî"
                    pagato = "‚úîÔ∏è" if data_movimento <= oggi and voce_trovata else "‚ùå"
                    progressione = f"{indice}/{n}"
                    descrizione = descrizione_base
                    tag = "rosso" if tipo_voce == "Uscita" else "verde" if voce_trovata else "grigio"
                    data_scadenza = date_nel_mese[-1][1].strftime("%d-%m-%Y") if date_nel_mese else "N/D"
                    tree_mensile.insert(
                        "",
                        "end",
                        values=(
                            data_movimento.strftime("%d-%m-%Y"),
                            categoria,
                            descrizione,
                            valore_importo,
                            tipo_voce,
                            data_scadenza,
                            pagato,
                            progressione
                        ),
                        tags=(tag,)
                    )
            except Exception as e:
                print(f"Errore nella ricorrenza con ID {item_id}: {e}")
                continue
        fine_mese = datetime.date(anno_corrente, mese_corrente, 28)
        while True:
            try:
                fine_mese = fine_mese.replace(day=fine_mese.day + 1)
            except ValueError:
                break
        for data_voce in sorted(self.spese.keys()):
            if oggi <= data_voce <= fine_mese:
                for voce in self.spese[data_voce]:
                    if len(voce) < 5 or voce[4] not in self.ricorrenze:
                        try:
                            categoria, descrizione, importo, tipo_voce = voce[:4]
                            valore_importo = f"{importo:,.2f} ‚Ç¨"
                            pagato = "‚úîÔ∏è" if data_voce <= oggi else "‚ùå"
                            progressione = "‚Äî"
                            data_scadenza = data_voce.strftime("%d-%m-%Y")
                            tag = "rosso" if tipo_voce == "Uscita" else "verde"
                            tree_mensile.insert(
                                "",
                                "end",
                                values=(
                                    data_voce.strftime("%d-%m-%Y"),
                                    categoria,
                                    descrizione,
                                    valore_importo,
                                    tipo_voce,
                                    data_scadenza,
                                    pagato,
                                    progressione
                                ),
                                tags=(tag,)
                            )
                        except Exception as e:
                            print(f"Errore nella voce normale del {data_voce}: {e}")
                            continue
        ordina_colonna(tree_mensile, "data", False)
        button_frame = tk.Frame(popup_mensile, bg=self.COLOR_TOPLEVEL)
        button_frame.pack(fill="x", pady=10)
        ttk.Button(button_frame, text="üîÑ Calcola Mancanti", command=self.calcola_mancanti, style='Verde.TButton').pack(side="left", padx=20, pady=5)
        ttk.Button(button_frame, text="‚ùå Chiudi", command=on_scadenze_close, style='Giallo.TButton').pack(side="right", padx=20, pady=5)
    def on_scadenza_doppio_click(self, event):
        tree = event.widget
        item_id = tree.focus()
        if not item_id:
            return
        valori = tree.item(item_id, "values")
        if not valori or len(valori) < 1:
            return
        data_str = valori[0]  
        try:
            giorno = datetime.datetime.strptime(data_str, "%d-%m-%Y").date()
        except Exception:
            return
        self.set_stats_mode("giorno")
        if hasattr(self, "cal"):
            self.cal.selection_set(giorno)
            self.cal._sel_date = giorno
            self.stats_refdate = giorno

        self.update_stats()
        self.estratto_month_var.set(f"{giorno.month:02d}")
        self.estratto_year_var.set(str(giorno.year))
        self.stats_label.config(text=f"Riepilogo Giornaliero - {giorno.strftime('%d-%m-%Y')}", foreground="purple",
    font=("Arial", 10, "bold"))

    # Gestione dell'Aggiornamento Forzato e Riavvio dell'Applicazione
    def forza_aggiorna(self):
        messaggio_conferma = (
            "Forzare l'aggiornamento del software?\n\n"
            "L'applicazione verr√† chiusa e riavviata\n"
        )
        risposta = self.show_custom_askyesno(
            title="Aggiornamento",
            message=messaggio_conferma
        )
        if risposta:
            self.aggiorna(GITHUB_FILE_URL, NOME_FILE)
        else:
            self.show_custom_warning("Annullato", "‚ùå Aggiornamento forzato annullato dall'utente.")

    # Esecuzione dell'Aggiornamento del Software con Backup e Riavvio Automatico
    def aggiorna(self, url, nome_file):
        import subprocess, sys, os
        import time
        import os
        global APRI_BROWSER 
        nome_backup = f"{nome_file}.bak"
        try:
            if os.path.exists(nome_file):
                try:
                    shutil.copy2(nome_file, nome_backup)
                except Exception as backup_err:
                    print(f"ERRORE backup: {backup_err}")
                    self.show_custom_warning("Attenzione", "Impossibile creare il backup. Aggiornamento annullato.")
                    return
            try:
                urllib.request.urlretrieve(url, nome_file)
                print(f"Download completato! {nome_file} √® stato aggiornato.")
            except Exception as download_err:
                print(f"ERRORE download: {download_err}")
                if os.path.exists(nome_backup):
                    shutil.copy2(nome_backup, nome_file)
                    os.remove(nome_backup)
                self.show_custom_warning("Attenzione", "‚ùå Aggiornamento NON completato! \n\n Problema di rete/download. üòï")
                return
            if APRI_BROWSER:
                webbrowser.open(URL_QST) 
                APRI_BROWSER = False
            self.save_db()
            self._on_close_lock() 
            messaggio = "Riavvio in corso. File aggiornato! ATTENDERE..."
            duration_s = 2
            width = 350
            height = 80
            parent = self
            parent.update_idletasks()
            parent_width = parent.winfo_width()
            parent_height = parent.winfo_height()
            x_pos = (parent_width // 2) - (width // 2)
            y_pos = (parent_height // 2) - (height // 2)
            popup_frame = tk.Frame(parent, bg="orange", bd=3, relief="raised")
            popup_frame.place(x=x_pos, y=y_pos, width=width, height=height)
            popup_frame.lift()
            label = tk.Label(popup_frame, text=messaggio, font=("Arial", 10, "bold"), 
                              justify="center", padx=10, pady=10, bg="orange", fg="black")
            label.pack(expand=True, fill='both')
            parent.update() 
            time.sleep(duration_s)
            try:
               popup_frame.destroy()
            except:
               pass
            script_path = os.path.abspath(sys.argv[0])
            args = [sys.executable, script_path] + sys.argv[1:]
            subprocess.Popen(args, start_new_session=True, close_fds=True)
            os._exit(0)            
        except Exception as e:
            print(f"ERRORE FATALE nell'aggiornamento: {str(e)}")
            self.show_custom_warning("Errore Grave", "Si √® verificato un errore inatteso durante l'aggiornamento.")
            return
 
    # Implementazione di Calcolo, Simulazione e Analisi Comparativa di Mutui/Prestiti (Sistema Francese)
    def calcolo_mutuo_prestito(self):
        def popola_piano(tree_widget, capitale_iniziale, anni, mesi, rata_base, spese_mensili, tasso_mensile, title_label, ammortamento_extra=0):
            import datetime
            oggi = datetime.date.today()
            if capitale_iniziale is None or anni is None or mesi is None:
                for row in tree_widget.get_children():
                    tree_widget.delete(row)
                title_label.config(text="Nessun dato disponibile")
                return
            for row in tree_widget.get_children():
                tree_widget.delete(row)
            debito_res = capitale_iniziale
            if ammortamento_extra > 0:
                debito_res -= ammortamento_extra
            capitale_res_dopo_extra = debito_res
            try:
                if tasso_mensile > 0:
                    rata_base_nuova = capitale_res_dopo_extra * (tasso_mensile * (1 + tasso_mensile) ** mesi) / ((1 + tasso_mensile) ** mesi - 1)
                else:
                    rata_base_nuova = capitale_res_dopo_extra / mesi
            except (ZeroDivisionError, OverflowError):
                rata_base_nuova = 0
            totale_capitale = ammortamento_extra
            totale_interessi = 0
            for mese in range(1, mesi + 1):
                m_rata = (oggi.month + mese - 1) % 12 + 1
                a_rata = oggi.year + (oggi.month + mese - 1) // 12
                data_str = f"{oggi.day:02d}-{m_rata:02d}-{a_rata}"
                label_periodo = f"Rata {mese} ({data_str})"
                interessi_rata = debito_res * tasso_mensile
                capitale_rata = rata_base_nuova - interessi_rata
                debito_res -= capitale_rata
                totale_capitale += capitale_rata
                totale_interessi += interessi_rata
                tree_widget.insert("", "end", values=(
                   label_periodo,
                   f"{rata_base_nuova + spese_mensili:.2f} ‚Ç¨",
                   f"{capitale_rata:.2f} ‚Ç¨",
                   f"{interessi_rata:.2f} ‚Ç¨",
                   f"{debito_res if debito_res > 0.005 else 0.0:.2f} ‚Ç¨"
                ))
            totale_rata_pagata = totale_capitale + totale_interessi + (spese_mensili * mesi)
            riepilogo_text = (
                f"Capitale: {capitale_iniziale:.2f} ‚Ç¨\n"
                f"Durata: {anni} anni ({mesi} mesi)\n"
                f"Tasso: {tasso_mensile * 100 * 12:.2f} %\n"
                f"Metodo: Ammortamento Francese (Rata Costante)\n"
                f"Ammortamento Extra: {ammortamento_extra:.2f} ‚Ç¨\n"
                f"Importo Totale Restituito: {totale_rata_pagata:.2f} ‚Ç¨\n"
                f"Interessi Totali: {totale_interessi:.2f} ‚Ç¨"
            )
            title_label.config(text=riepilogo_text, wraplength=1000)
            tree_widget.insert("", "end", values=("TOTALE", f"{totale_rata_pagata:,.2f} ‚Ç¨", f"{totale_capitale:,.2f} ‚Ç¨", f"{totale_interessi:,.2f} ‚Ç¨", "-"), tags=('total_row',))
            tree_widget.tag_configure('total_row', font=('Arial', 10, 'bold'))
        def crea_tab_piano_ammortamento(notebook_widget, title):
            frame = ttk.Frame(notebook_widget, padding=10)
            notebook_widget.add(frame, text=title)
            title_label = ttk.Label(frame, text="Nessun dato disponibile", font=("Arial", 9, "bold"))
            title_label.pack(pady=10, fill=tk.X)
            tree_frame = ttk.Frame(frame)
            tree_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
            tree = ttk.Treeview(tree_frame, columns=("Rata", "Rata Mensile", "Quota Capitale", "Quota Interessi", "Debito Residuo"), show="headings")
            tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
            scrollbar = ttk.Scrollbar(tree_frame, orient="vertical", command=tree.yview)
            scrollbar.pack(side='right', fill='y')
            tree.configure(yscrollcommand=scrollbar.set)
            tree.heading("Rata", text="Rata")
            tree.heading("Rata Mensile", text="Rata Mensile")
            tree.heading("Quota Capitale", text="Quota Capitale")
            tree.heading("Quota Interessi", text="Quota Interessi")
            tree.heading("Debito Residuo", text="Debito Residuo")            
            tree.column("Rata", width=50, anchor="center")
            tree.column("Rata Mensile", width=120, anchor="center")
            tree.column("Quota Capitale", width=120, anchor="center")
            tree.column("Quota Interessi", width=120, anchor="center")
            tree.column("Debito Residuo", width=120, anchor="center")            
            return tree, title_label
        def calcola_scenario_singolo(capitale_iniziale, anni_simulazione, tasso_annuo, spese_mensili, ammortamento_extra=0):
            try:
                if ammortamento_extra > capitale_iniziale:
                    raise ValueError("L'ammortamento extra non pu√≤ essere maggiore del capitale.")
                tasso_mensile = tasso_annuo / 100 / 12
                mesi_simulazione = anni_simulazione * 12
                if mesi_simulazione <= 0:
                    return {
                        "rata_mensile_totale": 0,
                        "interessi_totali": 0,
                        "importo_totale": ammortamento_extra,
                        "capitale": capitale_iniziale,
                        "anni": 0,
                        "mesi": 0,
                        "rata_base": 0,
                        "spese_mensili": spese_mensili,
                        "tasso_mensile": tasso_mensile,
                        "tasso_annuo": tasso_annuo,
                        "ammortamento_extra": ammortamento_extra
                    }
                debito_res = capitale_iniziale - ammortamento_extra
                if debito_res <= 0:
                    return {
                        "rata_mensile_totale": 0,
                        "interessi_totali": 0,
                        "importo_totale": ammortamento_extra,
                        "capitale": capitale_iniziale,
                        "anni": 0,
                        "mesi": 0,
                        "rata_base": 0,
                        "spese_mensili": spese_mensili,
                        "tasso_mensile": tasso_mensile,
                        "tasso_annuo": tasso_annuo,
                        "ammortamento_extra": ammortamento_extra
                    }
                if tasso_mensile > 0:
                    rata_base = debito_res * (tasso_mensile * (1 + tasso_mensile) ** mesi_simulazione) / ((1 + tasso_mensile) ** mesi_simulazione - 1)
                else:
                    rata_base = debito_res / mesi_simulazione
                interessi_totali_nuovi = (rata_base * mesi_simulazione) - debito_res
                importo_totale_nuovo = debito_res + interessi_totali_nuovi + (spese_mensili * mesi_simulazione) + ammortamento_extra
                return {
                    "rata_mensile_totale": rata_base + spese_mensili,
                    "interessi_totali": interessi_totali_nuovi,
                    "importo_totale": importo_totale_nuovo,
                    "capitale": capitale_iniziale,
                    "anni": anni_simulazione,
                    "mesi": mesi_simulazione,
                    "rata_base": rata_base,
                    "spese_mensili": spese_mensili,
                    "tasso_mensile": tasso_mensile,
                    "tasso_annuo": tasso_annuo,
                    "ammortamento_extra": ammortamento_extra
                }
            except (ValueError, OverflowError):
                return None
        def aggiorna_simulazione_singola(i):
            campi_input = [entry.get().replace(",", ".").strip() for entry in entry_scenari[i]]
            if not campi_input[0] or not campi_input[1] or not campi_input[2]:
                for lbl in lbl_scenari_risultati[i]: lbl.config(text="N/A", foreground=self.TEXT_COLOR )
                popola_piano(trees_piani[i], None, None, None, None, None, None, labels_piani[i])
                self.tutti_i_risultati[i] = None
                return
            try:
                capitale_simulazione = float(campi_input[0])
                anni_simulazione = int(campi_input[1])
                tasso_annuo = float(campi_input[2])
                spese = float(campi_input[3] or 0)
                ammortamento_extra = float(campi_input[4] or 0)
                if (capitale_simulazione <= 0 or anni_simulazione <= 0 or tasso_annuo < 0 or
                    capitale_simulazione > 500000 or anni_simulazione > 35 or tasso_annuo > 35):
                    self.show_custom_warning("Attenzione", "Assicurati che siano positivi e rientrino in un intervallo ragionevole.\ncapitale_simulazione > 500000 or anni_simulazione > 35 or tasso_annuo > 35")
                    raise ValueError("Uno o pi√π valori non sono validi. Assicurati che siano positivi e rientrino in un intervallo ragionevole.")
                if ammortamento_extra > capitale_simulazione:
                    self.show_custom_warning("Attenzione", "L'ammortamento extra non pu√≤ essere maggiore del capitale.")
                    raise ValueError("L'ammortamento extra non pu√≤ essere maggiore del capitale.")
                risultati_scenario = calcola_scenario_singolo(capitale_simulazione, anni_simulazione, tasso_annuo, spese, ammortamento_extra)
                if risultati_scenario is not None:
                    self.tutti_i_risultati[i] = risultati_scenario
                    risultati_principali = self.tutti_i_risultati[0]
                    lbl_scenari_risultati[i][0].config(text=f"{risultati_scenario['mesi']}")
                    lbl_scenari_risultati[i][1].config(text=f"{risultati_scenario['tasso_mensile'] * 100:.4f} %")
                    lbl_scenari_risultati[i][2].config(text=f"{risultati_scenario['rata_mensile_totale']:.2f} ‚Ç¨")
                    lbl_scenari_risultati[i][3].config(text=f"{risultati_scenario['interessi_totali']:.2f} ‚Ç¨")
                    costo_totale_cap_int = risultati_scenario['capitale'] + risultati_scenario['interessi_totali']
                    lbl_scenari_risultati[i][4].config(text=f"{costo_totale_cap_int:.2f} ‚Ç¨")
                    if risultati_principali:
                        risparmio = risultati_principali["interessi_totali"] - risultati_scenario["interessi_totali"]
                        lbl_scenari_risultati[i][5].config(
                            text=f"{risparmio:.2f} ‚Ç¨", 
                            foreground='green' if risparmio > 0 else ('#E53935' if risparmio < 0 else self.TEXT_COLOR)
                        )
                    else:
                        lbl_scenari_risultati[i][5].config(text="N/A", foreground=self.TEXT_COLOR)
                    popola_piano(
                        trees_piani[i], risultati_scenario["capitale"], risultati_scenario["anni"],
                        risultati_scenario["mesi"], risultati_scenario["rata_base"],
                        risultati_scenario["spese_mensili"], risultati_scenario["tasso_mensile"],
                        labels_piani[i], risultati_scenario["ammortamento_extra"]
                    )
                else:
                    for lbl in lbl_scenari_risultati[i]: lbl.config(text="N/A", foreground=self.TEXT_COLOR)
                    popola_piano(trees_piani[i], None, None, None, None, None, None, labels_piani[i])
                    self.tutti_i_risultati[i] = None
            except ValueError as ve:
                for lbl in lbl_scenari_risultati[i]: lbl.config(text="N/A", foreground=self.TEXT_COLOR)
                popola_piano(trees_piani[i], None, None, None, None, None, None, labels_piani[i])
                self.tutti_i_risultati[i] = None
        def calcola_tutte_simulazioni():
            self.tutti_i_risultati = [None] * 6
            for i in range(6):
                aggiorna_simulazione_singola(i)
            aggiorna_tab_analisi(self.tutti_i_risultati)
        def aggiorna_tab_analisi(risultati):
            for row in tree_analisi.get_children():
                tree_analisi.delete(row)
            risultati_principali = risultati[0] if risultati and risultati[0] else None
            for i, res in enumerate(risultati):
                if res:
                    risparmio = 0.0
                    if risultati_principali:
                        risparmio = risultati_principali["interessi_totali"] - res["interessi_totali"]
                    tree_analisi.insert("", "end", values=(
                        f"Simulazione {i+1}", 
                        f"{res['capitale']:,.2f} ‚Ç¨",
                        f"{res['anni']} anni ({res['mesi']} rate)", 
                        f"{res['tasso_annuo']:,.2f} %",
                        f"{res['ammortamento_extra']:,.2f} ‚Ç¨",
                        f"{res['rata_mensile_totale']:,.2f} ‚Ç¨", 
                        f"{res['importo_totale']:,.2f} ‚Ç¨",
                        f"{res['interessi_totali']:,.2f} ‚Ç¨",
                        f"{risparmio:,.2f} ‚Ç¨"
                    ), tags=('all_rows',))
            tree_analisi.tag_configure('all_rows', font=('Arial', 10, 'bold'))
        def resetta_tutti_i_campi_simulazione():
            for i in range(6):
                for entry_widget in entry_scenari[i]:
                    entry_widget.delete(0, tk.END)
                for lbl in lbl_scenari_risultati[i]:
                    lbl.config(text="N/A", foreground=self.TEXT_COLOR)
                popola_piano(trees_piani[i], None, None, None, None, None, None, labels_piani[i])
                self.tutti_i_risultati[i] = None
            aggiorna_tab_analisi(self.tutti_i_risultati)
        def esporta_dati_con_preview():
            import datetime
            oggi = datetime.date.today()
            try:
                idx_notebook = notebook.index(notebook.select())
            except:
                try:
                    idx_notebook = self.notebook.index(self.notebook.select())
                except:
                    return

            has_sim = hasattr(self, 'tutti_i_risultati') and any(self.tutti_i_risultati)
            has_killer = hasattr(self, 'killer_stats') and self.killer_stats
            if not has_sim and not has_killer:
                self.show_custom_warning("Dati mancanti", "Esegui una simulazione o un Piano Killer per esportare i dati.")
                return
            preview_window = tk.Toplevel(root, bg=self.COLOR_TOPLEVEL)
            preview_window.title("Report di Analisi e Proiezione Finanziaria")
            window_width, window_height = 1250, 800
            preview_window.geometry(f"{window_width}x{window_height}+{int(preview_window.winfo_screenwidth()/2 - window_width/2)}+{int(preview_window.winfo_screenheight()/2 - window_height/2)}")
            preview_window.bind("<Escape>", lambda e: preview_window.destroy())
            preview_window.transient(root)
            preview_window.focus_set()
            contenuto_testo = (
                "=====================================================================================================================\n"
                "           REPORT FINANZIARIO COMPLETO - RIEPILOGO STATISTICHE E PIANO KILLER (AMMORTAMENTO FRANCESE)\n"
                "=====================================================================================================================\n"
            )

            if has_sim:
                contenuto_testo += "Categoria            | Simulazione 1 | Simulazione 2 | Simulazione 3 | Simulazione 4 | Simulazione 5 | Simulazione 6\n"
                contenuto_testo += "---------------------+---------------+---------------+---------------+---------------+---------------+---------------\n"
                
                sim_data = {
                    "Capitale (‚Ç¨)": [], "Durata (anni)": [], "N¬∞ Rate": [], "Scadenza Prevista": [],
                    "Tasso (%)": [], "Spese Incasso (‚Ç¨)": [], "Ammort. Extra (‚Ç¨)": [], 
                    "Rata Mensile (‚Ç¨)": [], "Interessi Totali (‚Ç¨)": [], "Costo Totale (‚Ç¨)": [], 
                    "Risparmio Int. (‚Ç¨)": []
                }
                
                risultati_principali = self.tutti_i_risultati[0] if self.tutti_i_risultati[0] else None
                for i, res in enumerate(self.tutti_i_risultati):
                    if res:
                        mesi_res = int(res['mesi'])
                        target_date = oggi + datetime.timedelta(days=int(mesi_res * 30.44))
                        data_stringa = target_date.strftime('%m/%Y')
                        sim_data["Capitale (‚Ç¨)"].append(f"{res['capitale']:.2f}")
                        sim_data["Durata (anni)"].append(f"{res['anni']}")
                        sim_data["N¬∞ Rate"].append(f"{res['mesi']}")
                        sim_data["Scadenza Prevista"].append(data_stringa)
                        sim_data["Tasso (%)"].append(f"{res['tasso_annuo']:.2f}")
                        sim_data["Spese Incasso (‚Ç¨)"].append(f"{res['spese_mensili']:.2f}")
                        sim_data["Ammort. Extra (‚Ç¨)"].append(f"{res['ammortamento_extra']:.2f}")
                        sim_data["Rata Mensile (‚Ç¨)"].append(f"{res['rata_mensile_totale']:.2f}")
                        sim_data["Interessi Totali (‚Ç¨)"].append(f"{res['interessi_totali']:.2f}")
                        sim_data["Costo Totale (‚Ç¨)"].append(f"{res['capitale'] + res['interessi_totali']:.2f}")
                        risparmio = risultati_principali["interessi_totali"] - res["interessi_totali"] if risultati_principali and i > 0 else 0.0
                        sim_data["Risparmio Int. (‚Ç¨)"].append(f"{risparmio:.2f}")
                    else:
                        for key in sim_data: sim_data[key].append("")
                max_len_cat = max(len(cat) for cat in sim_data.keys())
                for cat, values in sim_data.items():
                    formatted_cat = f"{cat}{' ' * (max_len_cat - len(cat))}"
                    formatted_values = " | ".join(f"{val:<13}" for val in values)
                    contenuto_testo += f"{formatted_cat} | {formatted_values}\n"
                    if cat in ["Ammort. Extra (‚Ç¨)", "Costo Totale (‚Ç¨)", "Risparmio Int. (‚Ç¨)"]:
                        contenuto_testo += "---------------------+---------------+---------------+---------------+---------------+---------------+---------------\n"

            if 2 <= idx_notebook <= 5:
                idx_sim = idx_notebook - 2
                res_sel = self.tutti_i_risultati[idx_sim]
                if res_sel:
                    contenuto_testo += f"\nüìã PIANO AMMORTAMENTO DETTAGLIATO: SIMULAZIONE {idx_sim + 1}\n"
                    linea = "-" * 117
                    contenuto_testo += linea + "\n"
                    contenuto_testo += f"{'Periodo':<30} | {'Rata (‚Ç¨)':>12} | {'Cap. (‚Ç¨)':>12} | {'Int. (‚Ç¨)':>12} | {'Residuo (‚Ç¨)':>15}\n"
                    contenuto_testo += linea + "\n"
                    res_p = res_sel['capitale'] - res_sel.get('ammortamento_extra', 0)
                    tasso_m = res_sel['tasso_mensile']
                    rata_tot = res_sel['rata_mensile_totale']
                    data_inizio = datetime.date.today()
                    for m in range(1, res_sel['mesi'] + 1):
                        mese_rata = (data_inizio.month + m - 1) % 12 + 1
                        anno_rata = data_inizio.year + (data_inizio.month + m - 1) // 12
                        giorno_rata = min(data_inizio.day, 28)
                        data_corrente = f"{giorno_rata:02d}-{mese_rata:02d}-{anno_rata}"
                        q_i = res_p * tasso_m
                        q_c = res_sel['rata_base'] - q_i
                        res_p -= q_c
                        etichetta = f"Rata {m:>3} ({data_corrente})"
                        contenuto_testo += (
                            f"{etichetta:<30} | "
                            f"{rata_tot:>12.2f} | "
                            f"{q_c:>12.2f} | "
                            f"{q_i:>12.2f} | "
                            f"{max(0, res_p):>15.2f}\n"
                        )
                    contenuto_testo += linea + "\n"
                    
            elif idx_notebook >= 6:
                if has_killer:
                    import datetime
                    try:
                        def get_val_local(entry):
                            val = entry.get().strip().replace(",", ".")
                            return float(val) if val else 0.0
                        capitale_input = get_val_local(ent_k_residuo)
                        mesi_input     = int(get_val_local(ent_k_mesi))
                        rata_input     = get_val_local(ent_k_rata)
                        tasso_input    = get_val_local(ent_k_tasso)
                        extra_s_input  = get_val_local(ent_k_extra_subito)
                    except:
                        capitale_input = rata_input = tasso_input = extra_s_input = 0.0
                        mesi_input = 0
                    k_tot = getattr(self, 'killer_totali', {})
                    int_senza_k = k_tot.get('interessi_senza_killer', 0.0)
                    totale_senza_k = capitale_input + int_senza_k
                    risparmio_k = k_tot.get('risparmio', 0.0)
                    mesi_risp = int(k_tot.get('mesi_risparmiati', 0))
                    strat = k_tot.get('strategia', 'N/D')
                    total_int_k = sum(item['quota_int'] for item in self.killer_stats)
                    total_vers_k = sum(item['versato'] for item in self.killer_stats)
                    durata_effettiva = max(0, mesi_input - mesi_risp)
                    oggi = datetime.date.today()
                    def get_date_str(m):
                        if m <= 0: return "IMMEDIATA"
                        target = oggi + datetime.timedelta(days=int(m * 30.44))
                        return target.strftime('%m/%Y')
                    d_fine_std = get_date_str(mesi_input)
                    d_fine_k   = get_date_str(durata_effettiva)
                    contenuto_testo += "\n\nüéØ " + "="*45 + " PIANO KILLER " + "="*55 + "\n"
                    contenuto_testo += f"Sintesi: {getattr(self, 'killer_summary', 'Analisi Estinzione Strategica')}\n"
                    contenuto_testo += f"{'-'*117}\n"
                    contenuto_testo += " SITUAZIONE ATTUALE (DATI INSERITI)\n"
                    contenuto_testo += f"{'-'*117}\n"
                    contenuto_testo += f"{' > Debito Residuo Iniziale:':<45} {capitale_input:>20.2f} ‚Ç¨\n"
                    if extra_s_input > 0:
                        contenuto_testo += f"{' > Abbattimento Immediato:':<45} {extra_s_input:>20.2f} ‚Ç¨\n"
                    contenuto_testo += f"{' > Rata Mensile Attuale:':<45} {rata_input:>20.2f} ‚Ç¨\n"
                    contenuto_testo += f"{' > Durata Residua Dichiarata:':<45} {mesi_input:>20} rate\n"
                    contenuto_testo += f"{' > Tasso Applicato:':<45} {tasso_input:>20.2f} %\n"
                    contenuto_testo += f"{'-'*117}\n"
                    contenuto_testo += " PROIEZIONE SENZA INTERVENTO (PIANO ORIGINARIO)\n"
                    contenuto_testo += f"{'-'*117}\n"
                    contenuto_testo += f"{' > Scadenza Prevista:':<45} {d_fine_std:>20}\n"
                    contenuto_testo += f"{' > Interessi Totali Previsti:':<45} {int_senza_k:>20.2f} ‚Ç¨\n"
                    contenuto_testo += f"{' > Totale Montante (Cap+Int):':<45} {totale_senza_k:>20.2f} ‚Ç¨\n"
                    contenuto_testo += f"{'-'*117}\n"
                    contenuto_testo += " RISULTATI DOPO IL PIANO KILLER\n"
                    contenuto_testo += f"{'-'*117}\n"
                    contenuto_testo += f" Metodo: Ricalcolo interessi su debito residuo (Ammortamento Francese)\n"
                    contenuto_testo += f"{' > Strategia Selezionata:':<45} {strat.upper():>20}\n"
                    contenuto_testo += f"{'-'*117}\n"
                    contenuto_testo += f"{' > Risparmio Interessi Netto:':<45} {risparmio_k:>20.2f} ‚Ç¨\n"
                    contenuto_testo += f"{' > Totale Interessi da Pagare:':<45} {total_int_k:>20.2f} ‚Ç¨\n"
                    contenuto_testo += f"{'-'*117}\n"
                    contenuto_testo += f"{' > Nuova Scadenza (Killer):':<45} {d_fine_k:>20}\n"
                    contenuto_testo += f"{' > Numero Rate Residue:':<45} {durata_effettiva:>20} rate\n"
                    contenuto_testo += f"{' > Anticipo su Estinzione:':<45} {mesi_risp:>20} mesi\n"
                    contenuto_testo += f"{'-'*117}\n"
                    contenuto_testo += f"{' > TOTALE VERSATO FINALE:':<45} {total_vers_k:>20.2f} ‚Ç¨\n"
                    contenuto_testo += f"{'='*117}\n"
                    if hasattr(self, 'killer_annuali') and self.killer_annuali:
                        import datetime
                        oggi = datetime.date.today()
                        
                        contenuto_testo += "\n--- Piano di Recupero Cash-Flow Annuale (Auto-Finanziamento) ---\n"
                        contenuto_testo += "-"*117 + "\n"
                        contenuto_testo += f"{'ANNO':<10} | {'ANNO SOLARE':<12} | {'Extra Previsto':>18} | {'Risparmio Rate':>18} | {'Impatto Reale':>20}\n"
                        contenuto_testo += "-"*117 + "\n"
                        anticipo_val = 0.0
                        if self.killer_stats and "Anticipo" in str(self.killer_stats[0]['mese']):
                            anticipo_val = self.killer_stats[0]['versato']
                            contenuto_testo += (
                                f"{'ANTICIPO':<10} | "
                                f"{oggi.year:<12} | "
                                f"{anticipo_val:>18.2f} | "
                                f"{0.0:>18.2f} | "
                                f"{anticipo_val:>20.2f}\n"
                            )
                        try:
                            val_extra_ricorrente = float(ent_k_extra_annuo.get().replace(",", "."))
                        except:
                            val_extra_ricorrente = 0.0
                        for ann in self.killer_annuali:
                            anno_solare = oggi.year + ann['anno']
                            extra_anno = val_extra_ricorrente
                            risparmio = ann.get('risparmio_rate', 0.0)
                            impatto_reale = extra_anno - risparmio
                            
                            contenuto_testo += (
                                f"Anno {ann['anno']:<5} | "
                                f"{anno_solare:<12} | "
                                f"{extra_anno:>18.2f} | "
                                f"{risparmio:>18.2f} | "
                                f"{impatto_reale:>20.2f}\n"
                            )
                        if self.killer_stats:
                            ultima_r = self.killer_stats[-1]
                            mesi_totali = len(self.killer_stats)
                            data_fine = oggi + datetime.timedelta(days=int(mesi_totali * 30.44))
                            contenuto_testo += (
                                f"{'CHIUSURA':<10} | "
                                f"{data_fine.year:<12} | "
                                f"{ultima_r['versato']:>18.2f} | "
                                f"{'---':>18} | "
                                f"{ultima_r['versato']:>20.2f} (Saldo Finale)\n"
                            )
                        contenuto_testo += "-"*117 + "\n"
                        contenuto_testo += "* ANTICIPO: Versamento una tantum effettuato oggi per abbattere il capitale.\n"
                        contenuto_testo += "* Extra Previsto: Somma degli extra versati nell'anno solare (esclusa la quota capitale della rata).\n"
                        contenuto_testo += "* Impatto Reale: Sforzo finanziario netto (Extra versato - Risparmio generato dalla riduzione della rata).\n"
                    contenuto_testo += "\nDettaglio Piano Di Ammortamento Killer:\n"
                    contenuto_testo += "-"*117 + "\n"
                    contenuto_testo += f"{'Periodo':<30} | {'Versato (‚Ç¨)':>15} | {'Quota Cap. (‚Ç¨)':>15} | {'Quota Int. (‚Ç¨)':>15} | {'Residuo (‚Ç¨)':>15}\n"
                    contenuto_testo += "-"*117 + "\n"
                    for row in self.killer_stats:
                        contenuto_testo += (
                            f"{str(row['mese']):<30} | "
                            f"{row['versato']:>15.2f} | "
                            f"{row['quota_cap']:>15.2f} | "
                            f"{row['quota_int']:>15.2f} | "
                            f"{row['residuo']:>15.2f}\n"
                        )
                    contenuto_testo += "="*117 + "\n"
            contenuto_testo += f"\nReport generato il: {datetime.datetime.now().strftime('%d/%m/%Y %H:%M:%S')}\n"
            text_frame = ttk.Frame(preview_window, padding=10)
            text_frame.pack(fill=tk.BOTH, expand=True)
            txt_preview = tk.Text(text_frame, wrap=tk.NONE, height=30, width=140, font=('Courier New', 9))
            txt_preview.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
            v_scroll = ttk.Scrollbar(text_frame, orient="vertical", command=txt_preview.yview)
            v_scroll.pack(side=tk.RIGHT, fill='y')
            h_scroll = ttk.Scrollbar(preview_window, orient="horizontal", command=txt_preview.xview)
            h_scroll.pack(side=tk.BOTTOM, fill=tk.X)
            txt_preview.config(yscrollcommand=v_scroll.set, xscrollcommand=h_scroll.set)
            txt_preview.insert(tk.END, contenuto_testo)
            txt_preview.config(state="disabled")
            def salva_effettivamente():
                now = datetime.date.today()
                default_filename = f"Analisi_Mutuo_Killer_{now.strftime('%d-%m-%Y')}.txt"
                file = filedialog.asksaveasfilename(
                    defaultextension=".txt",
                    filetypes=[("File di testo", "*.txt")],
                    initialdir=EXPORT_FILES,
                    initialfile=default_filename,
                    title="Salva Report Finanziario",
                    confirmoverwrite=False,
                    parent=preview_window
                )
                if file:
                    if os.path.exists(file):
                        conferma = self.show_custom_askyesno(
                            "Sovrascrivere file?",
                            f"Il file '{os.path.basename(file)}' \nesiste gi√†. Vuoi sovrascriverlo?"
                        )
                        if not conferma:
                            return
                    try:
                        with open(file, "w", encoding="utf-8") as f:
                            f.write(contenuto_testo)
                        self.show_custom_warning("Successo", "Report salvato correttamente!")
                    except Exception as e:
                        self.show_custom_warning("Errore", f"Impossibile salvare il file: {e}")
                    
            button_frame = tk.Frame(preview_window, bg=self.COLOR_TOPLEVEL, pady=10)
            button_frame.pack()
            ttk.Button(button_frame, text="üíæ Salva Report", command=salva_effettivamente, style='Verde.TButton').pack(side=tk.LEFT, padx=5)
            ttk.Button(button_frame, text="üñ®Ô∏è Stampa", style='Blu.TButton', command=lambda: self._stampa_lista_diretta(contenuto_testo, self.show_custom_warning)).pack(side=tk.LEFT, padx=5)
            ttk.Button(button_frame, text="‚ùå Chiudi", command=preview_window.destroy, style='Giallo.TButton').pack(side=tk.LEFT, padx=5)

        def calcola_ammortamento_killer():
            try:
                import datetime
                oggi = datetime.date.today()
                self.killer_stats = []
                self.killer_annuali = []
                for row in tree_k_piano.get_children():
                    tree_k_piano.delete(row)
                def get_val(entry):
                    val = entry.get().strip().replace(",", ".")
                    return float(val) if val else 0.0
                if not ent_k_residuo.get().strip() or not ent_k_mesi.get().strip() or not ent_k_tasso.get().strip():
                    self.show_custom_warning("Dati Mancanti", "Compila almeno Debito, Mesi e Tasso!")
                    return
                residuo_iniziale = get_val(ent_k_residuo)
                mesi_rimanenti = int(get_val(ent_k_mesi))
                tasso_annuo = get_val(ent_k_tasso)
                rata_originale = get_val(ent_k_rata)
                extra_annuo = get_val(ent_k_extra_annuo)
                extra_subito = get_val(ent_k_extra_subito)
                if (residuo_iniziale <= 0 or mesi_rimanenti <= 0 or tasso_annuo < 0 or
                    residuo_iniziale > 1000000 or mesi_rimanenti > 600 or tasso_annuo > 25):
                    msg = ("Controlla i dati inseriti:\n"
                           "- Il debito deve essere tra 1 e 1.000.000 ‚Ç¨\n"
                           "- I mesi devono essere tra 1 e 600\n"
                           "- Il tasso deve essere tra 0% e 25%")
                    self.show_custom_warning("Dati non validi", msg)
                    return
                if extra_subito > residuo_iniziale:
                    self.show_custom_warning("Attenzione", "L'Abbattimento Iniziale non pu√≤ superare il debito residuo.")
                    return
                if rata_originale <= (residuo_iniziale * (tasso_annuo/100/12)) + 0.01:
                    self.show_custom_warning("Errore Calcolo", "La rata √® troppo bassa per coprire gli interessi mensili!")
                    return
                mese_versamento = int(combo_k_mese.get())
                strategia = combo_k_strategia.get()
                self.killer_strategia_usata = strategia
                tasso_mensile = tasso_annuo / 100 / 12
                interessi_teorici_standard = (rata_originale * mesi_rimanenti) - residuo_iniziale
                debito = residuo_iniziale
                tot_versato_killer = 0
                tot_interessi_killer = 0
                risparmio_rate_anno_corrente = 0
                if extra_subito > 0:
                    data_subito = oggi.strftime("%d-%m-%Y")
                    abbattimento = min(extra_subito, debito)
                    debito -= abbattimento
                    tot_versato_killer += abbattimento
                    tree_k_piano.insert("", "end", values=(
                        f"Anticipo ({data_subito})",
                        f"{abbattimento:.2f} ‚Ç¨", 
                        f"{abbattimento:.2f} ‚Ç¨", 
                        "0.00 ‚Ç¨", 
                        f"{debito:.2f} ‚Ç¨"
                    ), tags=('extra_row',))
                    self.killer_stats.append({
                    'mese': f"Anticipo ({data_subito})", 
                    'versato': abbattimento, 
                    'quota_cap': abbattimento, 
                    'quota_int': 0, 
                    'residuo': debito
                    })
                mese_corrente = 0
                rata_corrente = rata_originale
                if strategia == "Ricalcola Rata" and extra_subito > 0:
                    if tasso_mensile > 0:
                        rata_corrente = debito * (tasso_mensile * (1 + tasso_mensile) ** mesi_rimanenti) / ((1 + tasso_mensile) ** mesi_rimanenti - 1)
                    else:
                        rata_corrente = debito / mesi_rimanenti
                oggi = datetime.date.today()
                mese_corrente = 0
                while debito > 0.01 and mese_corrente < 600:
                    mese_corrente += 1
                    m_rata = (oggi.month + mese_corrente - 1) % 12 + 1
                    a_rata = oggi.year + (oggi.month + mese_corrente - 1) // 12
                    data_str = f"{oggi.day:02d}-{m_rata:02d}-{a_rata}"
                    interessi_mese = debito * tasso_mensile
                    tot_interessi_killer += interessi_mese
                    risparmio_rate_anno_corrente += (rata_originale - rata_corrente)
                    versamento_extra = extra_annuo if (mese_corrente % 12 == mese_versamento % 12) else 0
                    if versamento_extra > 0 and strategia == "Ricalcola Rata":
                        m_res = mesi_rimanenti - mese_corrente
                        if m_res > 0:
                            dp = debito - (rata_corrente - interessi_mese)
                            dn = max(0, dp - versamento_extra)
                            if dn > 0 and tasso_mensile > 0:
                                rata_corrente = dn * (tasso_mensile * (1 + tasso_mensile) ** m_res) / ((1 + tasso_mensile) ** m_res - 1)
                            elif dn > 0:
                                rata_corrente = dn / m_res
                            else:
                                rata_corrente = 0
                    abb_pot = (rata_corrente - interessi_mese) + versamento_extra
                    if abb_pot >= debito:
                        versato_reale = debito + interessi_mese
                        abb_eff = debito
                        debito = 0
                    else:
                        versato_reale = rata_corrente + versamento_extra
                        abb_eff = abb_pot
                        debito -= abb_eff
                        
                    tot_versato_killer += versato_reale
                    label_periodo = f"Rata {mese_corrente:>3} ({data_str})"
                    tree_k_piano.insert("", "end", values=(
                        label_periodo,
                        f"{versato_reale:.2f} ‚Ç¨", 
                        f"{abb_eff:.2f} ‚Ç¨", 
                        f"{interessi_mese:.2f} ‚Ç¨", 
                        f"{max(debito,0):.2f} ‚Ç¨"
                    ), tags=('extra_row' if versamento_extra > 0 else ''))
                    self.killer_stats.append({
                        'mese': label_periodo,
                        'versato': versato_reale, 
                        'quota_cap': abb_eff, 
                        'quota_int': interessi_mese, 
                        'residuo': max(debito, 0)
                    })
                    if mese_corrente % 12 == 0 or debito <= 0:
                        self.killer_annuali.append({
                            'anno': (mese_corrente + 11) // 12,
                            'risparmio_rate': risparmio_rate_anno_corrente,
                            'sforzo_netto': extra_annuo - risparmio_rate_anno_corrente if extra_annuo > 0 else 0
                        })
                        risparmio_rate_anno_corrente = 0
                        if debito <= 0: break
                oggi = datetime.date.today()
                anno_f = oggi.year + (oggi.month + mese_corrente - 1) // 12
                mese_f = (oggi.month + mese_corrente - 1) % 12 + 1
                mesi_ita = ["", "Gennaio", "Febbraio", "Marzo", "Aprile", "Maggio", "Giugno", 
                            "Luglio", "Agosto", "Settembre", "Ottobre", "Novembre", "Dicembre"]
                freedom_date = f"{mesi_ita[mese_f]} {anno_f}"
                risparmio_interessi = interessi_teorici_standard - tot_interessi_killer
                tree_k_piano.tag_configure('extra_row', background='#e1f5fe')
                self.killer_totali = {
                    'tot_versato': tot_versato_killer,
                    'tot_interessi': tot_interessi_killer,
                    'interessi_senza_killer': interessi_teorici_standard,
                    'risparmio': risparmio_interessi,
                    'mesi_risparmiati': mesi_rimanenti - mese_corrente,
                    'freedom_date': freedom_date,
                    'strategia': strategia
                }
                testo_risultato = (
                    f"Strategia: {strategia}  üìÖ Termine: {freedom_date.upper()}\n"
                    f"üéØ Estinzione in {mese_corrente} Mesi (Risparmiati {self.killer_totali['mesi_risparmiati']} mesi)\n"
                    f"üí∞ Tot. Versato: {tot_versato_killer:.2f} ‚Ç¨  üìâ Interessi: {tot_interessi_killer:.2f} ‚Ç¨  üöÄ Risparmio: {max(0, risparmio_interessi):.2f} ‚Ç¨"
                )
                lbl_k_risultato.config(text=testo_risultato, foreground="#2e7d32")
                dati_per_pop = self.killer_annuali.copy()
                ex_val = extra_annuo
                f_date_pop = freedom_date

                def comando_popup():
                    pop = tk.Toplevel(root)
                    pop.title(f"Analisi Impatto - Termine previsto: {f_date_pop}")
                    pop.transient(root)
                    pop.focus_set()
                    w_pop, h_pop = 650, 520 
                    sw = pop.winfo_screenwidth(); sh = pop.winfo_screenheight()
                    x_c = int((sw/2) - (w_pop/2)); y_c = int((sh/2) - (h_pop/2))
                    pop.geometry(f"{w_pop}x{h_pop}+{x_c}+{y_c}")
                    pop.bind("<Escape>", lambda e: pop.destroy())
                    main_container = ttk.Frame(pop, padding="15")
                    main_container.pack(fill=tk.BOTH, expand=True)
                    ttk.Label(main_container, text="Riepilogo Impatto e Cash-Flow Reale", 
                              font=("Arial", 11, "bold")).pack(pady=(0,10))
                    table_frame = ttk.Frame(main_container)
                    table_frame.pack(fill=tk.BOTH, expand=True)
                    tree = ttk.Treeview(table_frame, columns=("a","as","e","r","s"), show="headings", height=12)
                    tree.heading("a", text="Anno"); tree.heading("as", text="Solare")
                    tree.heading("e", text="Extra"); tree.heading("r", text="Risparmio Rate")
                    tree.heading("s", text="Impatto Reale")
                    tree.column("a", width=70, anchor="center")
                    tree.column("as", width=80, anchor="center")
                    tree.column("e", width=100, anchor="e")
                    tree.column("r", width=120, anchor="e")
                    tree.column("s", width=140, anchor="e")
                    oggi = datetime.date.today()
                    if extra_subito > 0:
                        tree.insert("", "end", values=(
                            "ANTICIPO", 
                            f"{oggi.year}",
                            f"{extra_subito:.2f} ‚Ç¨",
                            "0.00 ‚Ç¨",
                            f"{extra_subito:.2f} ‚Ç¨"
                        ), tags=("evidenza",))
                    for r in dati_per_pop:
                        data_target = oggi + datetime.timedelta(days=int(r['anno'] * 12 * 30.44))
                        anno_solare_reale = data_target.year
                        tree.insert("", "end", values=(
                            f"Anno {r['anno']}", 
                            f"{anno_solare_reale}",
                            f"{ex_val:.2f} ‚Ç¨", 
                            f"{r['risparmio_rate']:.2f} ‚Ç¨", 
                            f"{r['sforzo_netto']:.2f} ‚Ç¨"
                        ))
                    if self.killer_stats:
                        ultima_riga = self.killer_stats[-1]
                        mesi_totali = len(self.killer_stats)
                        data_fine = oggi + datetime.timedelta(days=int(mesi_totali * 30.44))
                        tree.tag_configure("saldo", background="#D4EDDA", foreground="#155724")
                        tree.tag_configure("evidenza", background="#FFF9C4", foreground="#856404")
                        tree.insert("", "end", values=(
                            "ESTINZIONE", 
                            f"{data_fine.year}", 
                            f"{ultima_riga['versato']:.2f} ‚Ç¨", 
                            "---", 
                            f"{ultima_riga['versato']:.2f} ‚Ç¨"
                        ), tags=("saldo",))
                    sb = ttk.Scrollbar(table_frame, orient="vertical", command=tree.yview)
                    tree.configure(yscrollcommand=sb.set)
                    tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
                    sb.pack(side=tk.RIGHT, fill=tk.Y)
                    
                    note_testo = (
                            "* ANTICIPO: Versamento una tantum effettuato oggi per abbattere il capitale.\n"
                            "* ANNO SOLARE: Indica l'anno in cui si generano i risparmi e i versamenti extra.\n"
                            "* IMPATTO REALE: L'extra versato meno il risparmio accumulato sulle rate (Auto-finanziamento)."
                    )
                    ttk.Label(main_container, text=note_testo).pack(pady=5, anchor="w")
                    ttk.Button(main_container, text="‚ùå Chiudi", 
                               command=pop.destroy, style='Giallo.TButton').pack(pady=10)
                btn_vidi_sforzo.config(state="normal", command=comando_popup)
            except Exception as e:
                self.show_custom_warning("Errore", f"Controlla i dati: {str(e)}")
                
        def reset_killer():
            ent_k_residuo.delete(0, tk.END)
            ent_k_mesi.delete(0, tk.END)
            ent_k_tasso.delete(0, tk.END)
            ent_k_rata.delete(0, tk.END)
            ent_k_extra_annuo.delete(0, tk.END)
            ent_k_extra_subito.delete(0, tk.END)
            combo_k_mese.set("1")
            combo_k_strategia.set("Ricalcola Rata")
            for row in tree_k_piano.get_children():
                tree_k_piano.delete(row)
            lbl_k_risultato.config(text="Pronto per il calcolo")
            self.killer_stats = []
            self.killer_annuali = []
            btn_vidi_sforzo.config(state="disabled", command=None)
            
        self.killer_stats = []
        root = tk.Toplevel(bg=self.COLOR_TOPLEVEL)
        root.title("Gestore Finanziario - Calcolo Finanziamento e Simulazioni - Ammortamento Francese")
        root.geometry("1200x650")
        screen_width = root.winfo_screenwidth()
        screen_height = root.winfo_screenheight()
        window_width = 1200
        window_height = 650
        position_top = int(screen_height / 2 - window_height / 2)
        position_right = int(screen_width / 2 - window_width / 2)
        root.geometry(f'{window_width}x{window_height}+{position_right}+{position_top}')
        root.protocol("WM_DELETE_WINDOW", lambda: (self.deiconify(), self.after(0, self.imp_entry.focus_set), root.destroy()))
        root.bind("<Escape>", lambda e: (self.deiconify(), self.after(0, self.imp_entry.focus_set), root.destroy()))
        self.withdraw()
        self.tutti_i_risultati = [None] * 6
        notebook = ttk.Notebook(root)
        notebook.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        simulazioni_frame = ttk.Frame(notebook, padding=10)
        notebook.add(simulazioni_frame, text="Simulazioni")
        titoli_simulazioni = ["Scenario", "Capitale (‚Ç¨)", "Durata (anni)", "Tasso (%)", "Spese Incasso (‚Ç¨)", "Ammort. Extra (‚Ç¨)", "N¬∞ Rate", "Tasso Mensile", "Rata Mensile", "Interessi Totali", "Costo Totale", "Risparmio Interessi"]
        for i, titolo in enumerate(titoli_simulazioni):
            ttk.Label(simulazioni_frame, text=titolo, font=("Arial", 9, "bold")).grid(row=0, column=i, padx=5, pady=5, sticky="w")
        entry_scenari, lbl_scenari_risultati = [], []
        for i in range(6):
            entry_row, lbl_row = [], []
            ttk.Label(simulazioni_frame, text=f"Simulazione {i+1}").grid(row=i+1, column=0, pady=5, sticky="w")
            entry_capitale_scen = ttk.Entry(simulazioni_frame, width=9); entry_capitale_scen.grid(row=i+1, column=1, padx=5); entry_row.append(entry_capitale_scen)
            entry_durata_scen = ttk.Entry(simulazioni_frame, width=9); entry_durata_scen.grid(row=i+1, column=2, padx=5); entry_row.append(entry_durata_scen)
            entry_tasso_scen = ttk.Entry(simulazioni_frame, width=5); entry_tasso_scen.grid(row=i+1, column=3, padx=5); entry_row.append(entry_tasso_scen)
            entry_spese_scen = ttk.Entry(simulazioni_frame, width=9); entry_spese_scen.grid(row=i+1, column=4, padx=5); entry_row.append(entry_spese_scen)
            entry_ammortamento_extra_scen = ttk.Entry(simulazioni_frame, width=9); entry_ammortamento_extra_scen.grid(row=i+1, column=5, padx=5); entry_row.append(entry_ammortamento_extra_scen)
            lbl_rate_scen = ttk.Label(simulazioni_frame, text="N/A", width=5, anchor="w"); lbl_rate_scen.grid(row=i+1, column=6, padx=5); lbl_row.append(lbl_rate_scen)
            lbl_tasso_mensile_scen = ttk.Label(simulazioni_frame, text="N/A", width=9, anchor="w"); lbl_tasso_mensile_scen.grid(row=i+1, column=7, padx=5); lbl_row.append(lbl_tasso_mensile_scen)
            lbl_rata_scen = ttk.Label(simulazioni_frame, text="N/A", width=12, anchor="w"); lbl_rata_scen.grid(row=i+1, column=8, padx=5); lbl_row.append(lbl_rata_scen)
            lbl_interessi_scen = ttk.Label(simulazioni_frame, text="N/A", width=12, anchor="w"); lbl_interessi_scen.grid(row=i+1, column=9, padx=5); lbl_row.append(lbl_interessi_scen)
            lbl_costo_totale = ttk.Label(simulazioni_frame, text="N/A", width=12, anchor="w"); lbl_costo_totale.grid(row=i+1, column=10, padx=5); lbl_row.append(lbl_costo_totale)
            lbl_risparmiati_scen = ttk.Label(simulazioni_frame, text="N/A", width=15, anchor="w", font=("Arial", 9, "bold")); lbl_risparmiati_scen.grid(row=i+1, column=11, padx=5); lbl_row.append(lbl_risparmiati_scen)
            entry_scenari.append(entry_row)
            lbl_scenari_risultati.append(lbl_row)
        btn_calcola_simulazioni = ttk.Button(simulazioni_frame, text="üìÑ Calcola Tutte le Simulazioni", command=calcola_tutte_simulazioni, style='Verde.TButton')
        btn_calcola_simulazioni.grid(row=7, column=0, columnspan=11, pady=10)
        btn_reset_simulazioni = ttk.Button(
            simulazioni_frame,
            text="‚Ü∫",
            command=resetta_tutti_i_campi_simulazione,
            style='Yellow.TButton'
        )
        btn_reset_simulazioni.grid(row=7, column=7, pady=10, padx=5)
        analisi_frame = ttk.Frame(notebook, padding=10)
        notebook.add(analisi_frame, text="Riepilogo Analisi")
        tree_analisi = ttk.Treeview(analisi_frame, columns=("Scenario", "Capitale", "Durata", "Tasso", "Ammortamento Extra", "Rata Mensile", "Importo Totale", "Interessi Totali", "Risparmio Interessi"), show="headings")
        tree_analisi.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        headings = {"Scenario": 120, "Capitale": 120, "Durata": 150, "Tasso": 80, "Ammortamento Extra": 140, "Rata Mensile": 120, "Importo Totale": 150, "Interessi Totali": 120, "Risparmio Interessi": 140}
        for col, width in headings.items():
            tree_analisi.heading(col, text=col)
            tree_analisi.column(col, width=width, anchor="center")
        trees_piani, labels_piani = [], []
        for i in range(6):
            tree, label = crea_tab_piano_ammortamento(notebook, f"Simulazione {i+1}")
            trees_piani.append(tree); labels_piani.append(label)
        killer_frame = ttk.Frame(notebook, padding=10)
        notebook.add(killer_frame, text="üéØ Piano KILLER")
        k_input_frame = ttk.LabelFrame(killer_frame, text=" Parametri Estinzione Anticipata Strategica ", padding=10)
        k_input_frame.pack(fill=tk.X, pady=5)
        ttk.Label(k_input_frame, text="Debito Residuo (‚Ç¨):").grid(row=0, column=0, padx=5, sticky="w")
        ent_k_residuo = ttk.Entry(k_input_frame, width=12); ent_k_residuo.grid(row=0, column=1, padx=5, pady=2)
        ttk.Label(k_input_frame, text="Mesi Rimanenti:").grid(row=0, column=2, padx=5, sticky="w")
        ent_k_mesi = ttk.Entry(k_input_frame, width=8); ent_k_mesi.grid(row=0, column=3, padx=5, pady=2)
        ttk.Label(k_input_frame, text="Tasso Annuo (%):").grid(row=0, column=4, padx=5, sticky="w")
        ent_k_tasso = ttk.Entry(k_input_frame, width=8); ent_k_tasso.grid(row=0, column=5, padx=5, pady=2)
        ttk.Label(k_input_frame, text="Rata Mensile Attuale (‚Ç¨):").grid(row=0, column=6, padx=5, sticky="w")
        ent_k_rata = ttk.Entry(k_input_frame, width=12); ent_k_rata.grid(row=0, column=7, padx=5, pady=2)
        ttk.Label(k_input_frame, text="Extra Annuale (‚Ç¨):").grid(row=1, column=0, padx=5, sticky="w")
        ent_k_extra_annuo = ttk.Entry(k_input_frame, width=12); ent_k_extra_annuo.grid(row=1, column=1, padx=5, pady=2)
        ttk.Label(k_input_frame, text="Extra Anticipo (‚Ç¨):").grid(row=1, column=2, padx=5, sticky="w")
        ent_k_extra_subito = ttk.Entry(k_input_frame, width=8); ent_k_extra_subito.grid(row=1, column=3, padx=5, pady=2)
        ttk.Label(k_input_frame, text="Mese Versamento:").grid(row=1, column=4, padx=5, sticky="w")
        combo_k_mese = ttk.Combobox(k_input_frame, values=[str(i) for i in range(1, 13)], width=5, style="Border.TCombobox"); combo_k_mese.set("12"); combo_k_mese.grid(row=1, column=5, padx=5, pady=2)
        ttk.Label(k_input_frame, text="Strategia:").grid(row=1, column=6, padx=5, sticky="w")
        combo_k_strategia = ttk.Combobox(k_input_frame, values=["Mantieni Rata", "Ricalcola Rata"], width=15, style="Border.TCombobox"); combo_k_strategia.set("Ricalcola Rata"); combo_k_strategia.grid(row=1, column=7, padx=5, pady=2)
        ttk.Button(k_input_frame, text="üöÄ Calcola Piano Killer", 
                   command=calcola_ammortamento_killer, 
                   style='Verde.TButton').grid(row=2, column=0, columnspan=4, pady=10)
        global btn_vidi_sforzo
        btn_vidi_sforzo = ttk.Button(k_input_frame, text="üí° Analisi Esborso", state="disabled", style='Verde.TButton')
        btn_vidi_sforzo.grid(row=2, column=4, columnspan=4, pady=10)
        ttk.Button(k_input_frame, text="üîÑ Reset", 
           command=reset_killer, style='Blu.TButton').grid(row=2, column=6, columnspan=2, pady=10, padx=2)
           
        lbl_k_risultato = ttk.Label(killer_frame, text="Pronto per il calcolo", style="Verde.TLabel")
        lbl_k_risultato.pack(pady=5)
        tree_k_frame = ttk.Frame(killer_frame)
        tree_k_frame.pack(fill=tk.BOTH, expand=True)
        tree_k_piano = ttk.Treeview(tree_k_frame, columns=("Mese", "Versato", "Quota Capitale", "Quota Interessi", "Debito Residuo"), show="headings")
        tree_k_piano.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        for col in tree_k_piano["columns"]:
            tree_k_piano.heading(col, text=col)
            tree_k_piano.column(col, width=120, anchor="center")
        sb_k = ttk.Scrollbar(tree_k_frame, orient="vertical", command=tree_k_piano.yview)
        sb_k.pack(side=tk.RIGHT, fill=tk.Y)
        tree_k_piano.configure(yscrollcommand=sb_k.set)

        common_button_frame = tk.Frame(root,bg=self.COLOR_TOPLEVEL, padx=10, pady=10)
        common_button_frame.pack()  
        ttk.Button(common_button_frame, text="üìÑ Esporta Riepilogo", command=esporta_dati_con_preview, style='Arancio.TButton').pack(side=tk.LEFT, padx=5)  
        ttk.Button(common_button_frame, text="‚ùå Chiudi", command=lambda: (self.deiconify(), self.after(0, self.imp_entry.focus_set), common_button_frame.winfo_toplevel().destroy()), 
           style='Giallo.TButton').pack(side=tk.LEFT, padx=5)
    
    # Gestione Interfaccia Statistiche e Grafici Categorie Aggregate (Handler Click Destro)
    def on_stats_table_right_click(self, event):
        try:
            item_id = self.stats_table.identify_row(event.y)
            selezioni_correnti = self.stats_table.selection()
            if item_id and item_id not in selezioni_correnti:
                self.stats_table.selection_set(item_id)
            final_selections = self.stats_table.selection()
            if not final_selections:
                return
            mode = self.stats_mode.get() 
            if mode == "giorno":
                first_item_id = final_selections[0] 
                values = self.stats_table.item(first_item_id, "values") 
                if values and len(values) >= 5:
                    initial_date_str = str(values[0]).strip()
                    initial_category = str(values[1]).strip()
                    initial_description = str(values[2]).strip()
                    initial_amount = str(values[3]).strip().replace('‚Ç¨', '').replace(',', '.')
                    initial_type = str(values[4]).strip().lower()
                    self.launch_qr_svg_generator(
                        initial_category=initial_category,
                        initial_amount=initial_amount,
                        initial_date=initial_date_str,
                        initial_description=initial_description, 
                        initial_type=initial_type                
                    )
                    return 
            self.after(1, lambda: self.crea_grafico_categorie(final_selections))
        except Exception as e:
            print(f"‚ùå Errore critico durante l'elaborazione del click destro: {e}")
    def crea_grafico_categorie(self, id_righe_selezionate):
        anno_filtro = None
        mese_filtro = None
        giorno_filtro = None
        entrate_count = 0
        uscite_count = 0
        tipo_transazione_ricercato = "saldo"
        colore_barra_base = None
        tooltip_window = None 
        stats_mode = getattr(self, 'stats_mode', tk.StringVar(value="totali")).get() 
        stats_refdate = getattr(self, 'stats_refdate', None) 
        categorie_da_elaborare = []
        for item_id in id_righe_selezionate:
            try:
                cat_name_raw = str(self.stats_table.item(item_id, "values")[0]).strip()
                cat_name = ' '.join(cat_name_raw.split()) 
                if cat_name not in categorie_da_elaborare:
                    categorie_da_elaborare.append(cat_name)
            except:
                continue
        if not categorie_da_elaborare:
            self.show_custom_info("Errore", "Nessuna categoria valida trovata.")
            return
        if stats_mode == "giorno" and stats_refdate:
            anno_filtro = str(stats_refdate.year)
            mese_filtro = str(stats_refdate.month).zfill(2)
            giorno_filtro = str(stats_refdate.day).zfill(2)
        elif stats_mode == "mese" and stats_refdate:
            anno_filtro = str(stats_refdate.year)
            mese_filtro = str(stats_refdate.month).zfill(2)
        elif stats_mode == "anno" and stats_refdate:
            anno_filtro = str(stats_refdate.year)
        for data_oggetto, entries in self.spese.items():
            data_anno_str = str(data_oggetto.year)
            data_mese_pad = str(data_oggetto.month).zfill(2)
            if anno_filtro and data_anno_str != anno_filtro: continue
            if mese_filtro and data_mese_pad != mese_filtro: continue
            for entry in entries:
                if len(entry) < 4: continue 
                cat_raw, desc, imp, tipo = entry[:4]
                cat = ' '.join(str(cat_raw).strip().split())
                tipo_lower = str(tipo).lower()
                
                if cat in categorie_da_elaborare:
                    if "entrata" in tipo_lower:
                        entrate_count += 1
                    elif "uscita" in tipo_lower:
                        uscite_count += 1
        if entrate_count > 0 and uscite_count > 0:
            tipo_transazione_ricercato = "misto"
        elif entrate_count > 0:
            tipo_transazione_ricercato = "entrata"
            colore_barra_base = "#28A745"
        else:
            tipo_transazione_ricercato = "uscita"
            colore_barra_base = "#DC3545"
        spese_combinate = defaultdict(lambda: {
            'Entrata': 0.0, 
            'Uscita': 0.0,
            'Dettaglio_Entrata': defaultdict(float),
            'Dettaglio_Uscita': defaultdict(float)
        })
        saldo_aggregato_totale = 0.0 
        for data_objeto, entries in self.spese.items():
            try:
                data_anno_str = str(data_objeto.year)
                data_mese_pad = str(data_objeto.month).zfill(2)
                data_giorno_pad = str(data_objeto.day).zfill(2)
            except:
                continue
            if anno_filtro and data_anno_str != anno_filtro: continue
            if mese_filtro and data_mese_pad != mese_filtro: continue
            if giorno_filtro and data_giorno_pad != giorno_filtro: continue
            if stats_mode == "giorno" or stats_mode == "mese":
                chiave_aggregazione = f"{data_giorno_pad} {data_mese_pad} {data_anno_str}"
            else:
                chiave_aggregazione = f"{data_anno_str}-{data_mese_pad}"
            for entry in entries:
                if len(entry) < 4: continue
                cat_raw, desc, imp, tipo = entry[:4]
                cat = ' '.join(str(cat_raw).strip().split())
                tipo_lower = str(tipo).lower()
                if cat in categorie_da_elaborare:
                    try:
                        importo_numerico = float(imp)
                        
                        if tipo_transazione_ricercato == "misto":
                            if "entrata" in tipo_lower:
                                spese_combinate[chiave_aggregazione]['Entrata'] += importo_numerico
                                spese_combinate[chiave_aggregazione]['Dettaglio_Entrata'][cat] += importo_numerico
                                saldo_aggregato_totale += importo_numerico
                            elif "uscita" in tipo_lower:
                                spese_combinate[chiave_aggregazione]['Uscita'] += abs(importo_numerico)
                                spese_combinate[chiave_aggregazione]['Dettaglio_Uscita'][cat] += abs(importo_numerico)
                                saldo_aggregato_totale -= abs(importo_numerico)
                        elif tipo_transazione_ricercato == "entrata" and "entrata" in tipo_lower:
                            spese_combinate[chiave_aggregazione]['Entrata'] += importo_numerico
                            spese_combinate[chiave_aggregazione]['Dettaglio_Entrata'][cat] += importo_numerico
                            saldo_aggregato_totale += importo_numerico
                        elif tipo_transazione_ricercato == "uscita" and "uscita" in tipo_lower:
                            spese_combinate[chiave_aggregazione]['Uscita'] += abs(importo_numerico)
                            spese_combinate[chiave_aggregazione]['Dettaglio_Uscita'][cat] += abs(importo_numerico)
                            saldo_aggregato_totale -= abs(importo_numerico)
                    except (ValueError, TypeError):
                        continue
        dati_filtrati_non_zero = {}
        totale_entrate_periodo = 0.0
        totale_uscite_periodo = 0.0
        for k, v in spese_combinate.items():
            if v['Entrata'] != 0.0 or v['Uscita'] != 0.0:
                totale_entrate_periodo += v['Entrata']
                totale_uscite_periodo += v['Uscita']
                if tipo_transazione_ricercato == "misto":
                    dati_filtrati_non_zero[k] = v
                else:
                    valore_unico = v['Entrata'] + v['Uscita']
                    if tipo_transazione_ricercato == "entrata":
                        dati_filtrati_non_zero[k] = {'Totale': valore_unico, 'Dettaglio': v['Dettaglio_Entrata']}
                    else:
                        dati_filtrati_non_zero[k] = {'Totale': valore_unico, 'Dettaglio': v['Dettaglio_Uscita']}
        saldo_netto_periodo = totale_entrate_periodo - totale_uscite_periodo
        if not dati_filtrati_non_zero:
            self.show_custom_info("Nessun Dato", "Nessun dato di transazione con importo non zero trovato per il filtro e il periodo selezionati.")
            return
        dati_ordinati = sorted(dati_filtrati_non_zero.items())
        dati_per_grafico = list(reversed(dati_ordinati)) 
        mesi_completi = ["Gennaio", "Febbraio", "Marzo", "Aprile", "Maggio", "Giugno",
                         "Luglio", "Agosto", "Settembre", "Ottobre", "Novembre", "Dicembre"] 
        totale_aggregato = 0.0
        if tipo_transazione_ricercato == "misto":
            tipo_transazione_base = "Entrate vs Uscite"
            totale_copertura_desc_saldo = "Saldo Netto"
            totale_aggregato = saldo_netto_periodo
        elif tipo_transazione_ricercato == "entrata":
            tipo_transazione_base = "Entrate"
            totale_copertura_desc_saldo = "Totale Entrate"
            totale_aggregato = totale_entrate_periodo
        else:
            tipo_transazione_base = "Uscite"
            totale_copertura_desc_saldo = "Totale Uscite"
            totale_aggregato = totale_uscite_periodo
        if len(categorie_da_elaborare) > 1:
            tipo_titolo = "Combinata"
        else:
            tipo_titolo = "Categoria"
        if stats_mode == "giorno" and stats_refdate: 
            data_str = stats_refdate.strftime('%d/%m/%Y')
            etichetta_tempo = "Giornaliero"
            filtro_titolo = f" - Giorno {data_str}"
            totale_copertura_desc = f"{totale_copertura_desc_saldo} Giorno {data_str}"
        elif stats_mode == "mese" and anno_filtro and mese_filtro: 
            mese_nome = ""
            try:
                mese_num = int(mese_filtro)
                if 1 <= mese_num <= 12:
                    mese_nome = mesi_completi[mese_num - 1]
                else:
                    mese_nome = str(mese_filtro) 
            except ValueError:
                mese_nome = str(mese_filtro)
            etichetta_tempo = "Giornalieri" 
            filtro_titolo = f" - Mese {mese_nome} {anno_filtro}"
            totale_copertura_desc = f"{totale_copertura_desc_saldo} Mese {mese_nome} {anno_filtro}"
        elif stats_mode == "anno" and anno_filtro: 
            etichetta_tempo = "Mensili"  
            filtro_titolo = f" - Anno {anno_filtro}"
            totale_copertura_desc = f"{totale_copertura_desc_saldo} Anno {anno_filtro}"
        elif not anno_filtro:
            etichetta_tempo = "Annuale"  
            filtro_titolo = " - Totale Storico"
            totale_copertura_desc = f"{totale_copertura_desc_saldo} Totale Storico"
        else:
            etichetta_tempo = "Generale"  
            filtro_titolo = " - Periodo Non Specificato"
            totale_copertura_desc = f"{totale_copertura_desc_saldo} Generale"
        titolo_grafico = f"{tipo_transazione_base} {tipo_titolo} {etichetta_tempo}{filtro_titolo}"
        popup_width, popup_height = 1200, 600 
        self.popup_grafico = tk.Toplevel(self, bg=self.COLOR_TOPLEVEL)
        self.popup_grafico.title(f"üìä {titolo_grafico}")
        screen_width = self.winfo_screenwidth()
        screen_height = self.winfo_screenheight()
        center_x = int(screen_width/2 - popup_width/2)
        center_y = int(screen_height/2 - popup_height/2)
        self.popup_grafico.geometry(f'{popup_width}x{popup_height}+{center_x}+{center_y}')
        self.popup_grafico.bind('<Escape>', lambda e: self.popup_grafico.destroy())
        main_frame = tk.Frame(self.popup_grafico, bg=self.COLOR_TOPLEVEL)
        main_frame.pack(fill="both", expand=True, padx=10, pady=10)
        tk.Label(main_frame, bg=self.COLOR_TOPLEVEL , fg=self.TEXT_COLOR, text=titolo_grafico, font=("Arial", 12, "bold")).pack(pady=(0, 5))
        saldo_netto_periodo = totale_entrate_periodo - totale_uscite_periodo
        colore_entrate = "green"
        colore_uscite = "red"
        colore_saldo = "green" if saldo_netto_periodo >= 0 else "red"
        colore_testo = self.TEXT_COLOR
        riepilogo_frame = tk.Frame(main_frame, bg=self.COLOR_TOPLEVEL)
        riepilogo_frame.pack(pady=(0, 15))
        font_riepilogo = ("Arial", 10, "bold")
        tk.Label(riepilogo_frame, bg=self.COLOR_TOPLEVEL , fg=colore_testo, text=" Totale Entrate: ", font=font_riepilogo).pack(side=tk.LEFT)
        tk.Label(riepilogo_frame, bg=self.COLOR_TOPLEVEL , fg=colore_entrate, text=f"{totale_entrate_periodo:,.2f}", font=font_riepilogo).pack(side=tk.LEFT)
        tk.Label(riepilogo_frame, bg=self.COLOR_TOPLEVEL , fg=colore_testo, text=" ‚Ç¨ ", font=font_riepilogo).pack(side=tk.LEFT, padx=(0, 10))
        tk.Label(riepilogo_frame, bg=self.COLOR_TOPLEVEL , fg=colore_testo, text=" Totale Uscite: ", font=font_riepilogo).pack(side=tk.LEFT)
        tk.Label(riepilogo_frame, bg=self.COLOR_TOPLEVEL , fg=colore_uscite, text=f"{totale_uscite_periodo:,.2f}", font=font_riepilogo).pack(side=tk.LEFT)
        tk.Label(riepilogo_frame, bg=self.COLOR_TOPLEVEL , fg=colore_testo, text=" ‚Ç¨ ", font=font_riepilogo).pack(side=tk.LEFT, padx=(0, 10))
        tk.Label(riepilogo_frame, bg=self.COLOR_TOPLEVEL , fg=colore_testo, text=" Saldo Netto: ", font=font_riepilogo).pack(side=tk.LEFT)
        tk.Label(riepilogo_frame, bg=self.COLOR_TOPLEVEL , fg=colore_saldo, text=f"{saldo_netto_periodo:,.2f}", font=font_riepilogo).pack(side=tk.LEFT)
        tk.Label(riepilogo_frame, bg=self.COLOR_TOPLEVEL , fg=colore_testo, text=" ‚Ç¨", font=font_riepilogo).pack(side=tk.LEFT)
        canvas_frame_scroll = ttk.Frame(main_frame)
        canvas_frame_scroll.pack(fill="both", expand=True)
        scrollbar_h = ttk.Scrollbar(canvas_frame_scroll, orient="horizontal")
        canvas = tk.Canvas(
            canvas_frame_scroll, 
            bg="white",
            xscrollcommand=scrollbar_h.set 
        )
        canvas.pack(side="top", fill="both", expand=True)
        scrollbar_h.config(command=canvas.xview)
        canvas.bind("<Configure>", lambda e: disegna_barre_scroll(canvas, dati_per_grafico))
        def hide_tooltip_local(event=None):
            nonlocal tooltip_window
            if tooltip_window:
                tooltip_window.destroy()
                tooltip_window = None
        def show_tooltip_local(event, text):
            nonlocal tooltip_window
            hide_tooltip_local()
            root_x = canvas.winfo_rootx()
            root_y = canvas.winfo_rooty()
            screen_x = root_x + event.x + 15
            screen_y = root_y + event.y + 10
            tooltip_window = tk.Toplevel(canvas)
            tooltip_window.wm_overrideredirect(True)
            tooltip_window.wm_geometry(f"+{screen_x}+{screen_y}")
            tooltip_window.wm_attributes("-topmost", True)
            label = ttk.Label(tooltip_window, text=text, style="Tooltip.TLabel")
            label.pack(padx=1, pady=1)
        self.popup_grafico.bind("<Destroy>", lambda e: hide_tooltip_local(), add="+")
        def disegna_barre_scroll(c, dati_tuple):
            hide_tooltip_local()
            c.delete("all")
            LARGHEZZ_STANDARD = 100
            LARGHEZZ_MISTA = 140
            BAR_FACTOR = 0.7
            margine_superiore = 40
            margine_inferiore = 90
            SPAZIO_EXTRA_MINIMO = 200
            altezza = c.winfo_height()
            canvas_larghezza = c.winfo_width()
            if altezza < 50:
                altezza = c.winfo_reqheight()
                if altezza < 50: altezza = popup_height - 150 
            if canvas_larghezza < 50:
                canvas_larghezza = c.winfo_reqwidth()
                if canvas_larghezza < 50: canvas_larghezza = popup_width - 40
            if altezza <= 50 or canvas_larghezza <= 50:
                return
            y_base = altezza - margine_inferiore
            importi_entrate = []
            importi_uscite = []
            for _, val in dati_tuple:
                if isinstance(val, dict):
                    if 'Totale' in val:
                        if tipo_transazione_ricercato == "entrata":
                            importi_entrate.append(val.get('Totale', 0))
                        else:
                            importi_uscite.append(abs(val.get('Totale', 0)))
                    else:
                        importi_entrate.append(val.get('Entrata', 0))
                        importi_uscite.append(val.get('Uscita', 0))
                else:
                    if tipo_transazione_ricercato == "entrata":
                        importi_entrate.append(val)
                    else:
                        importi_uscite.append(abs(val))
            def calculate_capped_max(abs_importi):
                if not abs_importi or max(abs_importi) == 0: return 0
                abs_importi_sorted = sorted([i for i in abs_importi if i > 0], reverse=True)
                if len(abs_importi_sorted) <= 1: return abs_importi_sorted[0]
                valore_base = abs_importi_sorted[1]
                max_val_cap = valore_base * 2
                if abs_importi_sorted[0] / max_val_cap > 2.5: return max_val_cap
                else: return abs_importi_sorted[0]
            max_e = calculate_capped_max(importi_entrate)
            max_u = calculate_capped_max(importi_uscite)
            max_val = max(max_e, max_u)
            altezza_utilizzabile = altezza - (margine_superiore + margine_inferiore)
            scala = altezza_utilizzabile / max(max_val * 1.05, 0.01)
            y_zero = y_base
            x_current = margine_inferiore
            dati_posizioni = []
            anno_per_titolo = ""
            try:
                if stats_mode == "anno" and hasattr(self, 'stats_anno') and self.stats_anno != "Tutti":
                    anno_per_titolo = self.stats_anno
            except NameError:
                pass
            for periodo, dati_valore in dati_tuple:
                is_misto = isinstance(dati_valore, dict) and 'Entrata' in dati_valore and 'Uscita' in dati_valore and 'Totale' not in dati_valore
                barra_width = LARGHEZZ_MISTA if is_misto else LARGHEZZ_STANDARD
                larghezza_gruppo = barra_width if stats_mode != "giorno" else LARGHEZZ_STANDARD 
                dati_posizioni.append({
                    'periodo': periodo,
                    'dati_valore': dati_valore,
                    'x_start': x_current,
                    'barra_width': barra_width
                })
                x_current += larghezza_gruppo
            if dati_tuple:
                larghezza_contenuto_barre = x_current + margine_inferiore
            else:
                larghezza_contenuto_barre = canvas_larghezza
            larghezza_contenuto = max(larghezza_contenuto_barre, canvas_larghezza + SPAZIO_EXTRA_MINIMO) if stats_mode != "giorno" else canvas_larghezza
            c.config(scrollregion=(0, 0, larghezza_contenuto, altezza))
            c.create_line(margine_inferiore/2, y_zero, larghezza_contenuto, y_zero, fill="gray", dash=(4, 2))
            c.bind("<Leave>", hide_tooltip_local)
            def formatta_dettaglio(dettagli_dict):
                if not dettagli_dict:
                    return "  Nessun dettaglio categoria."
                dettaglio_lines = []
                dati_ordinati = sorted(dettagli_dict.items(), key=lambda item: item[0], reverse=False)
                for cat, importo in dati_ordinati:
                    if importo > 0:
                        importo_f = f"{importo:,.2f}"
                        dettaglio_lines.append(f"  {cat}: {importo_f} ‚Ç¨")
                return "\n".join(dettaglio_lines)
            for item in dati_posizioni:
                periodo_originale = item['periodo']
                dati_valore = item['dati_valore']
                LARGHEZZA_BARRA_DINAMICA = item['barra_width']
                x_start_base = item['x_start']
                x_start = x_start_base
                if stats_mode == "giorno":
                    x_center = canvas_larghezza / 2
                    bar_group_width = LARGHEZZA_BARRA_DINAMICA * BAR_FACTOR
                    x_start = x_center - (bar_group_width / 2)
                is_misto = isinstance(dati_valore, dict) and 'Entrata' in dati_valore and 'Uscita' in dati_valore and 'Totale' not in dati_valore
                titolo_per_popup = periodo_originale
                if stats_mode == "anno" and anno_per_titolo:
                    titolo_per_popup = f"{periodo_originale} {anno_per_titolo}"
                if is_misto:
                    valore_e = dati_valore.get('Entrata', 0)
                    valore_u = dati_valore.get('Uscita', 0)
                    dettaglio_e = dati_valore.get('Dettaglio_Entrata', {})
                    dettaglio_u = dati_valore.get('Dettaglio_Uscita', {})
                    barra_singola_w = (LARGHEZZA_BARRA_DINAMICA * BAR_FACTOR) / 2
                    if valore_e > 0:
                        valore_e_scalato = min(valore_e, max_val)
                        altezza_barra_e = valore_e_scalato * scala
                        x0_e, x1_e = x_start, x_start + barra_singola_w
                        rect_e = c.create_rectangle(x0_e, y_zero - altezza_barra_e, x1_e, y_zero, fill="#28A745")
                        testo_etichetta = f"{valore_e:,.2f}".replace(",", "_TEMP_").replace(".", ",").replace("_TEMP_", ".")
                        c.create_text(
                            (x0_e + x1_e) / 2, y_zero - altezza_barra_e - 6,
                            text=testo_etichetta, font=("Arial", 9), fill="#28A745"
                        )
                        dettaglio_cat_e = formatta_dettaglio(dettaglio_e)
                        tooltip_text_e = (
                            f"Totale Entrata: {valore_e:,.2f} ‚Ç¨\n"
                            f"\n"
                            f"{dettaglio_cat_e}"
                        ).replace(",", "_TEMP_").replace(".", ",").replace("_TEMP_", ".")
                        c.tag_bind(rect_e, "<Enter>", lambda e, t=tooltip_text_e: show_tooltip_local(e, t))
                        c.tag_bind(rect_e, "<Leave>", hide_tooltip_local)
                        
                        tipo_bind_e = 'Entrata'
                        titolo_e_popup = f"Entrate aggregate {titolo_per_popup}"
                        c.tag_bind(rect_e, "<Double-1>", 
                            lambda e, p=periodo_originale, t=tipo_bind_e, tit=titolo_e_popup: 
                                self.mostra_transazioni_popup(
                                    self.get_filter_data(p, t, categorie_da_elaborare, stats_mode),
                                    tit
                                )
                        )
                    if valore_u > 0:
                        valore_u_scalato = min(valore_u, max_val)
                        altezza_barra_u = valore_u_scalato * scala
                        x0_u, x1_u = x_start + barra_singola_w, x_start + barra_singola_w * 2
                        rect_u = c.create_rectangle(x0_u, y_zero - altezza_barra_u, x1_u, y_zero, fill="#DC3545")
                        testo_etichetta = f"{valore_u:,.2f}".replace(",", "_TEMP_").replace(".", ",").replace("_TEMP_", ".")
                        c.create_text(
                            (x0_u + x1_u) / 2, y_zero - altezza_barra_u - 6,
                            text=testo_etichetta, font=("Arial", 9), fill="#DC3545"
                        )
                        dettaglio_cat_u = formatta_dettaglio(dettaglio_u)
                        tooltip_text_u = (
                            f"Totale Uscita: {valore_u:,.2f} ‚Ç¨\n"
                            f"\n"
                            f"{dettaglio_cat_u}"
                        ).replace(",", "_TEMP_").replace(".", ",").replace("_TEMP_", ".")
                        c.tag_bind(rect_u, "<Enter>", lambda e, t=tooltip_text_u: show_tooltip_local(e, t))
                        c.tag_bind(rect_u, "<Leave>", hide_tooltip_local)

                        tipo_bind_u = 'Uscita'
                        titolo_u_popup = f"Uscite aggregate {titolo_per_popup}"
                        c.tag_bind(rect_u, "<Double-1>", 
                            lambda e, p=periodo_originale, t=tipo_bind_u, tit=titolo_u_popup: 
                                self.mostra_transazioni_popup(
                                    self.get_filter_data(p, t, categorie_da_elaborare, stats_mode),
                                    tit
                                )
                        )
                        
                    x_center_text = x_start + (LARGHEZZA_BARRA_DINAMICA * BAR_FACTOR) / 2
                else: 
                    if isinstance(dati_valore, dict):
                        valore = dati_valore.get('Totale', 0)
                        dettaglio = dati_valore.get('Dettaglio', {})
                    else:
                        valore = dati_valore
                        dettaglio = {}
                    colore_barra = "#28A745" if tipo_transazione_ricercato == "entrata" else "#DC3545"
                    valore_scalato = min(abs(valore), max_val)
                    altezza_barra_pix = valore_scalato * scala
                    x0 = x_start
                    x1 = x0 + LARGHEZZA_BARRA_DINAMICA * BAR_FACTOR
                    rect = c.create_rectangle(x0, y_zero - altezza_barra_pix, x1, y_zero, fill=colore_barra)
                    importo_formattato = f"{valore:,.2f} ‚Ç¨".replace(",", "_TEMP_").replace(".", ",").replace("_TEMP_", ".")
                    c.create_text((x0 + x1) / 2, y_zero - altezza_barra_pix - 6, text=importo_formattato, font=("Arial", 9), fill=colore_barra)
                    x_center_text = (x0 + x1) / 2
                    tipo_testo = "Entrata" if tipo_transazione_ricercato == "entrata" else "Uscita"
                    dettaglio_cat = formatta_dettaglio(dettaglio)
                    tooltip_text = (
                        f"Totale {tipo_testo}: {valore:,.2f} ‚Ç¨\n"
                        f"\n"
                        f"{dettaglio_cat}"
                    ).replace(",", "_TEMP_").replace(".", ",").replace("_TEMP_", ".")
                    c.tag_bind(rect, "<Enter>", lambda e, t=tooltip_text: show_tooltip_local(e, t))
                    c.tag_bind(rect, "<Leave>", hide_tooltip_local)
                    
                    tipo_bind = tipo_transazione_ricercato.capitalize()
                    titolo_s_popup = f"{tipo_bind} aggregate {titolo_per_popup}"
                    c.tag_bind(rect, "<Double-1>", 
                        lambda e, p=periodo_originale, t=tipo_bind, tit=titolo_s_popup: 
                            self.mostra_transazioni_popup(
                                self.get_filter_data(p, t, categorie_da_elaborare, stats_mode),
                                tit
                            )
                    )
                label_y = altezza - margine_inferiore + 40
                if stats_mode == "giorno": label_y = altezza - 20
                c.create_text(
                    x_center_text,
                    label_y,
                    text=periodo_originale,
                    font=("Arial", 8),
                    angle=45 if stats_mode != "giorno" else 0
                )
        self.get_filter_data = lambda periodo, tipo, categories, mode: self._build_filter_data(periodo, tipo, categories, mode)
        if stats_mode == "giorno":
             scrollbar_h.pack_forget()
        else:
             scrollbar_h.pack(side="bottom", fill="x")
        self.popup_grafico.update_idletasks()
        disegna_barre_scroll(canvas, dati_per_grafico)
        self.popup_grafico.after(100, lambda: disegna_barre_scroll(canvas, dati_per_grafico)) 
        self.popup_grafico.transient(self)
        if stats_mode != "giorno":
            self.popup_grafico.after(200, lambda: canvas.xview_moveto(0)) 
        def chiudi_popup():
            self.popup_grafico.destroy()
        totale_formattato = f"{totale_aggregato:,.2f} ‚Ç¨".replace(",", "_TEMP_").replace(".", ",").replace("_TEMP_", ".")
        colore_totale = "black"
        if tipo_transazione_ricercato == "misto":
              if totale_aggregato > 0:
                  colore_totale = "#28A745"
              elif totale_aggregato < 0:
                  colore_totale = "#DC3545"
              else:
                  colore_totale = "gray"
        elif tipo_transazione_ricercato == "entrata":
            colore_totale = "#28A745"
        elif tipo_transazione_ricercato == "uscita":
            colore_totale = "#DC3545"
        totale_frame = tk.Frame(main_frame, bg=self.COLOR_TOPLEVEL)
        totale_frame.pack(fill='x', pady=(10, 5), padx=20) 
        tk.Label(
            totale_frame,
            bg=self.COLOR_TOPLEVEL,
            fg=self.TEXT_COLOR,
            text=f"{totale_copertura_desc}:",
            font=("Arial", 10),
            anchor="w"
        ).pack(side="left")
        tk.Label(
            totale_frame,
            bg=self.COLOR_TOPLEVEL,
            text=totale_formattato,
            font=("Arial", 10, "bold"),
            anchor="w", 
            padx=5,
            fg=colore_totale 
        ).pack(side="left") 
        ttk.Button(
            main_frame, 
            text="‚úñ Chiudi", 
            command=chiudi_popup,
            style="Giallo.TButton"
        ).pack(pady=10)
        self.popup_grafico.bind("<Escape>", lambda event: chiudi_popup())

    def _build_filter_data(self, periodo, tipo, categories_to_elaborate, stats_mode):
        mesi_abbr = {
            "Gen": 1, "Feb": 2, "Mar": 3, "Apr": 4, 
            "Mag": 5, "Giu": 6, "Lug": 7, "Ago": 8, 
            "Set": 9, "Ott": 10, "Nov": 11, "Dic": 12
        }
        anno_bind = None
        mese_bind = None
        giorno_bind = None
        try:
            if stats_mode == "anno" and periodo in mesi_abbr:
                mese_bind = mesi_abbr[periodo] 
                if hasattr(self, 'stats_anno') and self.stats_anno != "Tutti":
                    anno_bind = self.stats_anno
                giorno_bind = None
            elif ' ' in periodo and len(periodo.split(' ')) == 3:
                g, m, a = periodo.split(' ')
                anno_bind = a
                mese_bind = int(m)
                giorno_bind = int(g)
            elif '-' in periodo and len(periodo.split('-')) == 2:
                a, m = periodo.split('-')
                anno_bind = a
                mese_bind = int(m)
                giorno_bind = None
            elif len(periodo) == 4 and periodo.isdigit():
                anno_bind = periodo
                mese_bind = None
                giorno_bind = None
        except Exception:
            pass
        return {
            "anno": anno_bind, 
            "mese": mese_bind, 
            "giorno": giorno_bind,
            "tipo": tipo,
            "categorie": categories_to_elaborate
        }

    # Sistema di Analisi Statistica e Grafici Interattivi (Finanziari)
    def mostra_analisi_grafici(self):
        def bind_popup(canvas, item, filter_data, title):
            canvas.tag_bind(item, "<Double-1>", 
                            lambda e: self.mostra_transazioni_popup(filter_data, title))
        def disegna_barre(canvas, dati, colori, mostra_anno=False, mostra_tipo=False, centro=False):
            canvas.delete("all")
            canvas.update_idletasks()
            larghezza = canvas.winfo_width()
            altezza = canvas.winfo_height()
            margine = 50
            if isinstance(dati, dict):
                elementi = list(dati.items())
            else:
                elementi = dati
            max_val = max(abs(val) for _, val in elementi) if elementi else 1
            scala = (altezza - margine * 2) / (max_val * 1.5)
            larghezza_barra = (larghezza - margine * 2) // max(len(elementi), 1)
            y_base = altezza // 2 if centro else altezza - margine
            anno_selezionato = canvas.selettore_rif.get()
            mesi_abbr = ["Gen", "Feb", "Mar", "Apr", "Mag", "Giu", "Lug", "Ago", "Set", "Ott", "Nov", "Dic"]
            nomi_completi_mesi = ["Gennaio", "Febbraio", "Marzo", "Aprile", "Maggio", "Giugno", 
                                  "Luglio", "Agosto", "Settembre", "Ottobre", "Novembre", "Dicembre"]
            for i, (etichetta, valore) in enumerate(elementi):
                x0 = margine + i * larghezza_barra
                x1 = x0 + larghezza_barra * 0.6
                colore = colori.get(etichetta, "gray")
                parts = etichetta.split(" ")
                tipo = parts[-1] if mostra_tipo else None
                if anno_selezionato == "Tutti":
                    anno_filter = parts[0]
                    mese_filter = None
                    periodo_title = f"l'anno {anno_filter}"
                else:
                    anno_filter = anno_selezionato
                    nome_mese_abbr = parts[0]
                    try:
                        mese_index = mesi_abbr.index(nome_mese_abbr)
                        mese_filter = mese_index + 1
                        nome_mese_completo = nomi_completi_mesi[mese_index]
                    except ValueError:
                        mese_filter = None
                        nome_mese_completo = nome_mese_abbr
                    periodo_title = f"{nome_mese_completo} {anno_filter}"
                filter_data = {"anno": anno_filter, "mese": mese_filter, "tipo": tipo}
                title_text = f"Transazioni {tipo} per {periodo_title}"
                if valore >= 0:
                    y1 = y_base - valore * scala
                    rect = canvas.create_rectangle(x0, y_base, x1, y1, fill=colore)
                    canvas.create_text((x0 + x1) / 2, y1 - 10, text=f"{int(valore)}", font=("Arial", 8))
                else:
                    y1 = y_base + abs(valore) * scala
                    rect = canvas.create_rectangle(x0, y_base, x1, y1, fill=colore)
                    canvas.create_text((x0 + x1) / 2, y1 + 10, text=f"{int(valore)}", font=("Arial", 8))
                bind_popup(canvas, rect, filter_data, title_text)
                if mostra_tipo and " " in etichetta:
                    tipo_label = etichetta.split(" ")[1]
                    canvas.create_text((x0 + x1) / 2, y_base + 15, text=tipo_label, font=("Arial", 8))
                if not mostra_anno and " " in etichetta:
                    mese_label = etichetta.split(" ")[0]
                    canvas.create_text((x0 + x1) / 2, y_base + 30, text=mese_label, font=("Arial", 8))
                elif mostra_anno:
                    anno_label = etichetta.split(" ")[0] if " " in etichetta else etichetta
                    canvas.create_text((x0 + x1) / 2, y_base + 30, text=anno_label, font=("Arial", 8))
        def disegna_barre_categorie(canvas, dati, colori):
            if hasattr(canvas, "tooltip") and canvas.tooltip:
                canvas.tooltip.destroy()
                canvas.tooltip = None
            canvas.delete("all")
            canvas.update_idletasks()
            LARGHEZZA_BARRA_FISSA = 80
            margine = 50
            larghezza_visualizzata = canvas.winfo_width()
            altezza = canvas.winfo_height()
            y_base = altezza - margine
            totale = sum(val for _, val in dati) if dati else 1
            max_val = max(val for _, val in dati) if dati else 1
            scala = (altezza - margine * 2) / (max_val * 1.2)
            numero_barre = max(len(dati), 1)
            larghezza_contenuto = margine * 2 + numero_barre * LARGHEZZA_BARRA_FISSA
            x_offset = max(0, (larghezza_visualizzata - larghezza_contenuto) // 2)
            anno_selezionato = canvas.anno_corrente
            for i, (categoria, valore) in enumerate(dati):
                x0 = x_offset + margine + i * LARGHEZZA_BARRA_FISSA
                x1 = x0 + LARGHEZZA_BARRA_FISSA * 0.6
                y1 = y_base - valore * scala
                colore = colori.get(categoria, "#888888")
                rect = canvas.create_rectangle(x0, y_base, x1, y1, fill=colore)
                filter_data = {"anno": anno_selezionato, "categoria": categoria, "tipo": "Uscita"}
                title_text = f"Movimenti Categoria '{categoria}' ({anno_selezionato})"
                bind_popup(canvas, rect, filter_data, title_text)
                percentuale = (valore / totale) * 100
                canvas.create_text((x0 + x1) / 2, y1 - 12, text=f"{valore:,.2f}", font=("Arial", 9))
                canvas.create_text((x0 + x1) / 2, y1 - 26, text=f"{percentuale:.1f}%", font=("Arial", 8), fill="gray")
                limite = 10
                nome_visualizzato = categoria if len(categoria) <= limite else categoria[:limite] + "..."
                canvas.create_text((x0 + x1) / 2, y_base + 20, text=nome_visualizzato, font=("Arial", 9))
                def show_tooltip(event, text=categoria):
                    if hasattr(canvas, "tooltip") and canvas.tooltip:
                        canvas.tooltip.destroy()
                        canvas.tooltip = None
                    canvas.tooltip = tk.Toplevel(canvas)
                    canvas.tooltip.wm_overrideredirect(True)
                    try:
                        canvas.tooltip.wm_geometry(f"+{event.x_root + 10}+{event.y_root + 10}")
                    except: pass
                    label = ttk.Label(canvas.tooltip, text=text, style="Tooltip.TLabel")
                    label.pack(ipadx=4)
                def hide_tooltip(event):
                    if hasattr(canvas, "tooltip") and canvas.tooltip:
                        canvas.tooltip.destroy()
                        canvas.tooltip = None
                canvas.tag_bind(rect, "<Enter>", show_tooltip)
                canvas.tag_bind(rect, "<Leave>", hide_tooltip)
            canvas.create_text(
                larghezza_visualizzata // 2,
                y_base + 40,
                text=f"Totale uscite: ‚Ç¨ {totale:,.2f}",
                font=("Arial", 10, "bold"),
                fill="black"
            )
            canvas.config(scrollregion=(0, 0, larghezza_contenuto, altezza))
        def aggiorna_legenda_treeview(tree, dati, colori):
                for item in tree.get_children():
                        tree.delete(item)
                dati_ordinati = sorted(dati, key=lambda x: x[1], reverse=True)
                for cat, val in dati_ordinati:
                        colore = colori.get(cat, "#888888")
                        r = int(colore[1:3], 16)
                        g = int(colore[3:5], 16)
                        b = int(colore[5:7], 16)
                        luminosita = (0.2126 * r + 0.7152 * g + 0.0722 * b)
                        colore_testo = "black" if luminosita > 150 else "white"
                        tag_name = cat.replace(" ", "_").replace("(", "").replace(")", "")
                        tree.insert("", "end", values=(cat, f"‚Ç¨ {val:,.2f}"), tags=(tag_name,))
                        try:
                                tree.tag_configure(tag_name, background=colore, foreground=colore_testo)
                        except TclError:
                                pass
        def disegna_barre_saldo(canvas, dati):
            nomi_completi_mesi = ["Gennaio", "Febbraio", "Marzo", "Aprile", "Maggio", "Giugno", 
                                  "Luglio", "Agosto", "Settembre", "Ottobre", "Novembre", "Dicembre"]
            canvas.delete("all")
            canvas.update_idletasks()
            larghezza = canvas.winfo_width()
            altezza = canvas.winfo_height()
            margine = 50
            mesi_ordinati_abbr = ["Gen", "Feb", "Mar", "Apr", "Mag", "Giu", "Lug", "Ago", "Set", "Ott", "Nov", "Dic"]
            chiavi = mesi_ordinati_abbr if set(mesi_ordinati_abbr).issubset(dati.keys()) else list(dati.keys())
            max_val = max(abs(dati[k]) for k in chiavi) if dati else 1
            scala = (altezza - margine * 2) / (max_val * 1.5)
            larghezza_barra = (larghezza - margine * 2) // max(len(chiavi), 1)
            y_base = altezza - margine
            anno_selezionato_selettore = canvas.selettore_rif.get()
            for i, etichetta in enumerate(chiavi):
                    valore = dati.get(etichetta, 0)
                    x0 = margine + i * larghezza_barra
                    x1 = x0 + larghezza_barra * 0.6
                    if abs(valore) < 0.01:
                            y1 = y_base
                    else:
                            y1 = y_base - abs(valore) * scala
                    colore = "green" if valore >= 0 else "red"
                    segno = "+" if valore >= 0 else "‚àí"
                    rect = canvas.create_rectangle(x0, y_base, x1, y1, fill=colore)
                    mese_num = None
                    anno_filtro = anno_selezionato_selettore
                    title_text_base = "Tutte le transazioni"
                    nome_mese_per_titolo = etichetta
                    if anno_selezionato_selettore == "Tutti":
                            anno_filtro = etichetta
                            title_text = f"{title_text_base} per l'anno {anno_filtro}"
                    else:
                            if etichetta in mesi_ordinati_abbr:
                                    try:
                                        mese_index = mesi_ordinati_abbr.index(etichetta)
                                        mese_num = mese_index + 1
                                        nome_mese_per_titolo = nomi_completi_mesi[mese_index]
                                    except ValueError:
                                        pass
                            title_text = f"{title_text_base} per {nome_mese_per_titolo} {anno_filtro}" 
                    filter_data = {"anno": anno_filtro, "mese": mese_num}
                    bind_popup(canvas, rect, filter_data, title_text)
                    testo_y = y1 - 10
                    valore_formattato = f"{abs(valore):,.2f}"
                    canvas.create_text(
                            (x0 + x1) / 2,
                            testo_y,
                            text=f"{segno}{valore_formattato}",
                            font=("Arial", 9)
                    )
                    canvas.create_text((x0 + x1) / 2, y_base + 20, text=etichetta, font=("Arial", 9))
        def aggiorna_tab3(event=None):
            selezione = selettore_anno3.get()
            entrate = defaultdict(float)
            uscite = defaultdict(float)
            for data, voci in self.spese.items():
                anno = data.year
                mese = data.month
                if selezione != "Tutti" and str(anno) != selezione:
                    continue
                for voce in voci:
                    tipo = voce[3].strip().lower()
                    importo = voce[2]
                    chiave = str(anno) if selezione == "Tutti" else mese
                    if tipo == "entrata":
                        entrate[chiave] += importo
                    elif tipo == "uscita":
                        uscite[chiave] += importo
            total_entrate = sum(entrate.values())
            total_uscite = sum(uscite.values())
            saldo_totale = total_entrate - total_uscite
            self.lbl_entrate_tab3.config(text=f"Entrate: ‚Ç¨ {total_entrate:,.2f}")
            self.lbl_uscite_tab3.config(text=f"Uscite: ‚Ç¨ {total_uscite:,.2f}")
            if saldo_totale >= 0:
                self.lbl_saldo_tab3.config(text=f"Saldo: ‚Ç¨ {saldo_totale:,.2f}", style="GSaldoPositivo.TLabel")
            else:
                self.lbl_saldo_tab3.config(text=f"Saldo: ‚Ç¨ {saldo_totale:,.2f}", style="GSaldoNegativo.TLabel")
            saldo_per_grafico = defaultdict(float)
            for chiave, importo in entrate.items():
                saldo_per_grafico[chiave] += importo
            for chiave, importo in uscite.items():
                saldo_per_grafico[chiave] -= importo
            if selezione == "Tutti":
                grafico = {str(a): saldo_per_grafico.get(a, 0) for a in sorted(saldo_per_grafico)}
            else:
                mesi = ["Gen", "Feb", "Mar", "Apr", "Mag", "Giu", "Lug", "Ago", "Set", "Ott", "Nov", "Dic"]
                grafico = {mesi[m - 1]: saldo_per_grafico.get(m, 0) for m in range(1, 13)}
            canvas3.dati_cache = grafico
            ridisegna_tab3()
        def ridisegna_tab3(event=None):
            if hasattr(canvas3, "dati_cache"):
                disegna_barre_saldo(canvas3, canvas3.dati_cache)
        def aggiorna_tab2(event=None):
            anno = selettore_anno2.get()
            canvas2.anno_corrente = anno
            categories = defaultdict(float)
            for data, voci in self.spese.items():
                if anno == "Tutti" or str(data.year) == anno:
                    for voce in voci:
                        if voce[3].strip().lower() == "uscita":
                            categories[voce[0]] += float(voce[2])
            tutte_categorie = sorted(categories.items(), key=lambda x: x[1], reverse=True)
            colore = {}
            for cat, _ in tutte_categorie:
                colore[cat] = f'#{random.randint(50,200):02x}{random.randint(50,200):02x}{random.randint(50,200):02x}'
            canvas2.tutte_categorie = tutte_categorie
            canvas2.colori = colore
            canvas2.dati_cache = tutte_categorie
            canvas2.colori_cache = colore
            ridisegna_tab2()
            aggiorna_legenda_treeview(self.tree_legenda, tutte_categorie, colore)
        def ridisegna_tab2(event=None):
            if hasattr(canvas2, "dati_cache"):
                canvas2.delete("all")
                canvas2.update_idletasks()
                disegna_barre_categorie(canvas2, canvas2.dati_cache, canvas2.colori_cache)
        def aggiorna_tab1(event=None):
            anno_selezionato = selettore_anno1.get()
            entrate = defaultdict(float)
            uscite = defaultdict(float)
            for data, voci in self.spese.items():
                anno = data.year
                mese = data.month
                if anno_selezionato != "Tutti" and str(anno) != anno_selezionato:
                    continue
                for voce in voci:
                    tipo = voce[3].strip().lower()
                    importo = voce[2]
                    chiave = str(anno) if anno_selezionato == "Tutti" else mese
                    if tipo == "entrata":
                        entrate[chiave] += importo
                    elif tipo == "uscita":
                        uscite[chiave] += importo
            total_entrate = sum(entrate.values())
            total_uscite = sum(uscite.values())
            saldo = total_entrate - total_uscite
            lbl_entrate.config(text=f"Entrate: ‚Ç¨ {total_entrate:,.2f}")
            lbl_uscite.config(text=f"Uscite: ‚Ç¨ {total_uscite:,.2f}")
            if saldo >= 0:
                lbl_saldo_tab1.config(text=f"Saldo: ‚Ç¨ {saldo:,.2f}", style="GSaldoPositivo.TLabel")
            else:
                lbl_saldo_tab1.config(text=f"Saldo: ‚Ç¨ {saldo:,.2f}", style="GSaldoNegativo.TLabel")
            grafico = {}
            colore = {}
            if anno_selezionato == "Tutti":
                for anno in sorted(set(entrate.keys()) | set(uscite.keys())):
                    grafico[f"{anno} Entrata"] = entrate[anno]
                    grafico[f"{anno} Uscita"] = uscite[anno]
                    colore[f"{anno} Entrata"] = "green"
                    colore[f"{anno} Uscita"] = "red"
            else:
                mesi = ["Gen", "Feb", "Mar", "Apr", "Mag", "Giu", "Lug", "Ago", "Set", "Ott", "Nov", "Dic"]
                for m in range(1, 13):
                    nome_mese = mesi[m - 1]
                    grafico[f"{nome_mese} Entrata"] = entrate.get(m, 0)
                    grafico[f"{nome_mese} Uscita"] = uscite.get(m, 0)
                    colore[f"{nome_mese} Entrata"] = "green"
                    colore[f"{nome_mese} Uscita"] = "red"
            canvas1.dati_cache = grafico
            canvas1.colori_cache = colore
            canvas1.mostra_anno_cache = (anno_selezionato == "Tutti")
            ridisegna_tab1()
        def ridisegna_tab1(event=None):
            if hasattr(canvas1, "dati_cache"):
                disegna_barre(canvas1, canvas1.dati_cache, canvas1.colori_cache, 
                              mostra_anno=canvas1.mostra_anno_cache, mostra_tipo=True, centro=False)
        larghezza_finestra = 1230
        altezza_finestra = 600
        larghezza_schermo = self.winfo_screenwidth()
        altezza_schermo = self.winfo_screenheight()
        x = (larghezza_schermo // 2) - (larghezza_finestra // 2)
        y = (altezza_schermo // 2) - (altezza_finestra // 2)
        self.grafico_analisi_popup = tk.Toplevel(self)
        self.grafico_analisi_popup.configure(bg=self.COLOR_TOPLEVEL)
        self.grafico_analisi_popup.title("Grafico Analisi Movimenti")
        self.grafico_analisi_popup.geometry(f"{larghezza_finestra}x{altezza_finestra}+{x}+{y}")
        self.grafico_analisi_popup.bind("<Escape>", lambda e: self.grafico_analisi_popup.destroy())
        notebook = ttk.Notebook(self.grafico_analisi_popup)
        notebook.pack(fill="both", expand=True, padx=10, pady=(10, 5))
        anni = sorted({d.year for d in self.spese.keys()}, reverse=True)
        anno_corrente = str(datetime.date.today().year)
        tab1 = ttk.Frame(notebook)
        notebook.add(tab1, text="Entrate/Uscite")
        frame_totali = ttk.Frame(tab1)
        frame_totali.pack(side="bottom", pady=10)
        lbl_entrate = ttk.Label(frame_totali, text="Entrate: ‚Ç¨ 0.00", style="GSaldoPositivo.TLabel")
        lbl_entrate.pack(side="left", padx=10)
        lbl_uscite = ttk.Label(frame_totali, text="Uscite: ‚Ç¨ 0.00", style="GSaldoNegativo.TLabel")
        lbl_uscite.pack(side="left", padx=10)
        lbl_saldo_tab1 = ttk.Label(frame_totali, text="Saldo: ‚Ç¨ 0.00", style="GSaldo.TLabel")
        lbl_saldo_tab1.pack(side="left", padx=10)
        ttk.Label(tab1, text="‚ñ† Seleziona periodo *Dettaglio (Clicca üñ±Ô∏è)*", style="Verde.TLabel", font=("Arial", 10)).pack(side="top", padx=10)
        selettore_anno1 = ttk.Combobox(tab1, values=["Tutti"] + [str(a) for a in anni], style="Border.TCombobox", state='readonly')
        selettore_anno1.set("Tutti")
        selettore_anno1.pack(pady=10)
        selettore_anno1.bind("<<ComboboxSelected>>", aggiorna_tab1)
        canvas1 = tk.Canvas(tab1, bg="white")
        canvas1.pack(fill="both", expand=True, padx=10, pady=10)
        canvas1.selettore_rif = selettore_anno1
        canvas1.bind("<Configure>", ridisegna_tab1)
        tab2 = ttk.Frame(notebook)
        tab2.grid_columnconfigure(0, weight=3)
        tab2.grid_columnconfigure(1, weight=1)
        tab2.grid_rowconfigure(1, weight=1)
        notebook.add(tab2, text="Categorie")
        ttk.Label(tab2, text="‚ñ† Seleziona periodo *Dettaglio (Clicca üñ±Ô∏è)*", style="Verde.TLabel", font=("Arial", 10)).grid(row=0, column=0, sticky="w", padx=10, pady=5)
        selettore_anno2 = ttk.Combobox(tab2, values=["Tutti"] + [str(a) for a in anni], style="Border.TCombobox", state='readonly')
        selettore_anno2.set(anno_corrente if anno_corrente in [str(a) for a in anni] else "Tutti")
        selettore_anno2.grid(row=0, column=0, sticky="n", pady=10)
        selettore_anno2.bind("<<ComboboxSelected>>", aggiorna_tab2)
        canvas_frame_scroll = ttk.Frame(tab2)
        canvas_frame_scroll.grid(row=1, column=0, sticky="nsew", padx=5, pady=(0, 10))
        scrollbar_h = ttk.Scrollbar(canvas_frame_scroll, orient="horizontal")
        scrollbar_h.pack(side="bottom", fill="x")
        canvas2 = tk.Canvas(canvas_frame_scroll, bg="white", xscrollcommand=scrollbar_h.set)
        canvas2.pack(side="top", fill="both", expand=True)
        scrollbar_h.config(command=canvas2.xview)
        canvas2.tooltip = None
        canvas2.anno_corrente = selettore_anno2.get()
        canvas2.bind("<Configure>", ridisegna_tab2)
        frame_legenda = ttk.Frame(tab2)
        frame_legenda.grid(row=1, column=1, sticky="nsew", padx=5, pady=(0, 10))
        lbl_leg = tk.Label(frame_legenda, text="Legenda Categorie", bg=self.COLOR_TOPLEVEL, fg=self.TEXT_COLOR, font=("Arial", 10, "bold"))
        lbl_leg.pack(pady=5)
        columns = ("Categoria", "Importo")
        self.tree_legenda = ttk.Treeview(frame_legenda, columns=columns, show="headings", selectmode="none")
        self.tree_legenda.heading("Categoria", text="Categoria")
        self.tree_legenda.heading("Importo", text="Importo")
        self.tree_legenda.column("Categoria", width=120, anchor="w")
        self.tree_legenda.column("Importo", width=80, anchor="e")
        sb_legenda = ttk.Scrollbar(frame_legenda, orient="vertical", command=self.tree_legenda.yview)
        self.tree_legenda.configure(yscrollcommand=sb_legenda.set)
        sb_legenda.pack(side="right", fill="y")
        self.tree_legenda.pack(side="left", fill="both", expand=True)
        tab3 = ttk.Frame(notebook)
        notebook.add(tab3, text="Saldo Mensile/Annuale")
        frame_totali_tab3 = ttk.Frame(tab3)
        frame_totali_tab3.pack(side="bottom", pady=10)
        self.lbl_entrate_tab3 = ttk.Label(frame_totali_tab3, text="Entrate: ‚Ç¨ 0.00", style="GSaldoPositivo.TLabel")
        self.lbl_entrate_tab3.pack(side="left", padx=10)
        self.lbl_uscite_tab3 = ttk.Label(frame_totali_tab3, text="Uscite: ‚Ç¨ 0.00", style="GSaldoNegativo.TLabel")
        self.lbl_uscite_tab3.pack(side="left", padx=10)
        self.lbl_saldo_tab3 = ttk.Label(frame_totali_tab3, text="Saldo: ‚Ç¨ 0.00", style="GSaldo.TLabel")
        self.lbl_saldo_tab3.pack(side="left", padx=10)
        ttk.Label(tab3, text="‚ñ† Seleziona periodo", style="Verde.TLabel", font=("Arial", 10)).pack(side="top", padx=10)
        selettore_anno3 = ttk.Combobox(tab3, values=["Tutti"] + [str(a) for a in anni], style="Border.TCombobox", state='readonly')
        selettore_anno3.set(anno_corrente if anno_corrente in [str(a) for a in anni] else "Tutti")
        selettore_anno3.pack(pady=10)
        selettore_anno3.bind("<<ComboboxSelected>>", aggiorna_tab3)
        canvas3 = tk.Canvas(tab3, bg="white")
        canvas3.pack(fill="both", expand=True, padx=10, pady=10)
        canvas3.selettore_rif = selettore_anno3
        canvas3.bind("<Configure>", ridisegna_tab3)
        frame_footer = ttk.Frame(self.grafico_analisi_popup)
        frame_footer.pack(side="bottom", fill="x", pady=(0, 15), padx=20)
        btn_chiudi = ttk.Button(
                frame_footer, 
                text="‚úñ Chiudi", 
                style="Giallo.TButton", 
                command=self.grafico_analisi_popup.destroy
        )
        btn_chiudi.pack(side="right")
        aggiorna_tab3()
        aggiorna_tab2()
        aggiorna_tab1()

    def mostra_transazioni_popup(self, data_filter, title):
        MESI_NOME_COMPLETO = {
            1: "Gennaio", 2: "Febbraio", 3: "Marzo", 4: "Aprile", 
            5: "Maggio", 6: "Giugno", 7: "Luglio", 8: "Agosto", 
            9: "Settembre", 10: "Ottobre", 11: "Novembre", 12: "Dicembre"
        }
        anno = data_filter.get("anno")
        mese_filtro_raw = data_filter.get("mese") 
        giorno = data_filter.get("giorno")
        tipo_filtro = data_filter.get("tipo")
        categorie_filtro_list = data_filter.get("categorie", []) 
        categoria_singola_raw = data_filter.get("categoria")
        if categoria_singola_raw and categoria_singola_raw != "Tutti":
            if categoria_singola_raw not in categorie_filtro_list:
                categorie_filtro_list.append(categoria_singola_raw)
        categorie_filtro_normalizzate_aggressive = [str(cat).replace(' ', '').lower() for cat in categorie_filtro_list]
        devo_filtrare_categorie = bool(categorie_filtro_normalizzate_aggressive)
        mese_filtro_num = None
        if mese_filtro_raw and mese_filtro_raw != "Tutti":
            try:
                mese_filtro_num = int(mese_filtro_raw)
            except (ValueError, TypeError):
                pass 
        new_title = title
        if mese_filtro_num is not None and anno and anno != "Tutti":
            nome_mese = MESI_NOME_COMPLETO.get(mese_filtro_num, f"{mese_filtro_num:02d}")
            mese_str = str(mese_filtro_num).zfill(2)
            identificatore1 = f"{anno}-{mese_str}"
            identificatore2 = mese_str
            if identificatore1 in title:
                new_title = title.replace(identificatore1, f"{nome_mese} {anno}")
            elif identificatore2 in title and nome_mese not in title:
                new_title = title.replace(identificatore2, nome_mese)
        title = new_title
        spese_filtrate = []
        for data, voci in self.spese.items():
            if anno and anno != "Tutti" and str(data.year) != anno: continue
            if mese_filtro_num is not None and data.month != mese_filtro_num: continue
            if giorno and giorno != "Tutti":
                try:
                    if data.day != int(giorno): continue
                except: continue
            for entry in voci:
                try:
                    cat_originale, desc, imp_str, entry_tipo = entry[:4]
                    cat_normalized_aggressive = str(cat_originale).replace(' ', '').lower()
                    cat_normalized_display = ' '.join(str(cat_originale).strip().split()).title() 
                    entry_imp = float(imp_str)
                    entry_tipo = entry_tipo.strip().capitalize()
                except (ValueError, TypeError, IndexError): 
                    continue 
                if devo_filtrare_categorie and cat_normalized_aggressive not in categorie_filtro_normalizzate_aggressive:
                    continue
                if tipo_filtro and entry_tipo != tipo_filtro.capitalize():
                    continue
                spese_filtrate.append((data, cat_normalized_display, desc, entry_imp, entry_tipo))
        if not spese_filtrate:
            self.show_custom_info("Nessuna transazione", f"Nessuna transazione trovata per {title}.")
            return
        popup_width, popup_height = 800, 450
        popup = tk.Toplevel(self, bg=self.COLOR_TOPLEVEL)
        popup.title(f"Dettaglio Transazioni - {title}")
        popup.resizable(True, True)
        popup.withdraw()
        self.update_idletasks()
        main_x = self.winfo_rootx()
        main_y = self.winfo_rooty()
        main_width = self.winfo_width()
        main_height = self.winfo_height()
        center_x = main_x + (main_width // 2) - (popup_width // 2)
        center_y = main_y + (main_height // 2) - (popup_height // 2)
        popup.geometry(f"{popup_width}x{popup_height}+{center_x}+{center_y}")
        popup.transient(self)
        popup.deiconify() 
        popup.lift()
        popup.focus_force()
        popup.bind("<Escape>", lambda event: popup.destroy()) 
        tk.Label(popup, bg=self.COLOR_TOPLEVEL , fg=self.TEXT_COLOR, text=title, font=("Arial", 12, "bold")).pack(pady=10)
        tree_frame = ttk.Frame(popup)
        tree_frame.pack(fill="both", expand=True, padx=10, pady=6)
        vsb = ttk.Scrollbar(tree_frame, orient="vertical")
        vsb.pack(side="right", fill="y")
        columns = ("Data", "Categoria", "Descrizione", "Importo", "Tipo")
        tree = ttk.Treeview(
            tree_frame, 
            columns=columns, 
            show="headings", 
            height=10,
            yscrollcommand=vsb.set
        )
        tree.pack(fill="both", expand=True, side="left") 
        vsb.config(command=tree.yview)
        widths = (90, 150, 250, 100, 100)
        anchors = ("center", "w", "w", "e", "center")
        def treeview_sort_column(tv, col, reverse):
            try:
                data = [(tv.set(k, col), k) for k in tv.get_children('')]
                if col == "Data":
                    data.sort(key=lambda t: datetime.datetime.strptime(t[0], "%d-%m-%Y"), reverse=reverse)
                elif col == "Importo":
                    data.sort(key=lambda t: float(t[0].replace(' ‚Ç¨', '').replace('.', '').replace(',', '.')), reverse=reverse)
                else:
                    data.sort(key=lambda t: t[0].lower(), reverse=reverse)
                
                for index, (_, k) in enumerate(data):
                    tv.move(k, '', index)
                
                tv.heading(col, command=lambda c=col: treeview_sort_column(tv, c, not reverse))
            except Exception as e:
                print(f"Errore ordinamento: {e}")
        for col, w, a in zip(columns, widths, anchors):
            initial_reverse = False 
            tree.heading(
                col,
                text=col,
                command=lambda c=col: treeview_sort_column(tree, c, initial_reverse)
            )
            tree.column(col, width=w, anchor=a)
        tot_entrate = tot_uscite = 0.0
        for d, cat, desc, imp, tipo in sorted(spese_filtrate, key=lambda x: x[0], reverse=True):
            imp_formattato = f"{imp:,.2f}".replace(',', 'X').replace('.', ',').replace('X', '.') 
            tag_name = "green_row" if tipo == "Entrata" else "red_row"
            tree.insert("", "end", values=(d.strftime("%d-%m-%Y"), cat, desc, f"{imp_formattato} ‚Ç¨", tipo), tags=(tag_name,))
            if tipo == "Entrata":
                tot_entrate += imp
            else:
                tot_uscite += imp
        tree.tag_configure("green_row", foreground="green")
        tree.tag_configure("red_row", foreground="red")
        saldo = tot_entrate - tot_uscite
        lbl = tk.Text(
            popup, 
            bg=self.COLOR_TOPLEVEL, 
            fg=self.TEXT_COLOR, 
            height=1, 
            borderwidth=0, 
            font=("Arial", 10, "bold"), 
            wrap="none", 
            background=popup.cget("background"),
            highlightthickness=0,
            relief="flat"
        )
        lbl.pack(pady=7)
        lbl.tag_config("entrate_color", foreground="green")
        lbl.tag_config("uscite_color", foreground="red")
        lbl.tag_config("saldo_pos_color", foreground="green")
        lbl.tag_config("saldo_neg_color", foreground="red")
        tot_entrate_str = f"{tot_entrate:,.2f}".replace(',', 'X').replace('.', ',').replace('X', '.')
        tot_uscite_str = f"{tot_uscite:,.2f}".replace(',', 'X').replace('.', ',').replace('X', '.')
        saldo_str = f"{saldo:,.2f}".replace(',', 'X').replace('.', ',').replace('X', '.')
        text_full = f"Totale Entrate: {tot_entrate_str} ‚Ç¨  Totale Uscite: {tot_uscite_str} ‚Ç¨  Saldo: {saldo_str} ‚Ç¨"
        lbl.config(state="normal")
        lbl.insert("end", text_full)
        entrate_start = text_full.find(tot_entrate_str)
        entrate_end = entrate_start + len(tot_entrate_str)
        lbl.tag_add("entrate_color", f"1.{entrate_start}", f"1.{entrate_end}")
        uscite_start = text_full.find(tot_uscite_str)
        uscite_end = uscite_start + len(tot_uscite_str)
        lbl.tag_add("uscite_color", f"1.{uscite_start}", f"1.{uscite_end}")
        saldo_start = text_full.find(saldo_str)
        saldo_end = saldo_start + len(saldo_str)
        if saldo >= 0:
            lbl.tag_add("saldo_pos_color", f"1.{saldo_start}", f"1.{saldo_end}")
        else:
            lbl.tag_add("saldo_neg_color", f"1.{saldo_start}", f"1.{saldo_end}")
        lbl.config(state="disabled")
        tree.bind("<Double-1>", lambda evt: self.goto_day_from_popup(tree, popup))
        ttk.Button(popup, text="‚ùå Chiudi", command=popup.destroy, style="Giallo.TButton").pack(pady=10)

    # Gestione e Visualizzazione Guida Utente (Help)
    def mostra_help(self):
        if hasattr(self, '_filter_help_popup') and self._filter_help_popup.winfo_exists():
            self._filter_help_popup.destroy()
        testo_stampa_completo = "Guida: Filtri, Tabelle e Grafici\n\n"
        help_content = [
            ("Totali ", "Aggrega e mostra il totale per categoria per TUTTO il periodo storico disponibile."),
            ("Anno ", "Aggrega i dati dell'ANNO selezionato, mostrando le singole categorie totalizzate."),
            ("Mese ", "Aggrega i dati del MESE selezionato, mostrando le singole categorie totalizzate."),
            ("Giorno (Punto Singolo)", "Mostra i Movimenti solo per il GIORNO selezionato."),
        ]
        testo_stampa_completo += "# Filtri Temporali: Controllano l'Aggregazione dei Dati nella Tabella Statistiche.\n"
        for title, description in help_content:
            clean_description = description.replace('', '') 
            testo_stampa_completo += f"‚Ä¢ Filtro {title}: {clean_description}\n"

        testo_stampa_completo += "\n# Interazioni con le Tabelle Dati (Treeview):\n"
        testo_stampa_completo += "‚Ä¢ Scroll e Navigazione: Utilizza la Rotella del Mouse per scorrere verticalmente in qualsiasi Treeview o area.\n"
        testo_stampa_completo += "‚Ä¢ Ordinamento (Sort): Clicca sull'intestazione di qualsiasi colonna per ordinare i dati. Clicca di nuovo per invertire (crescente/decrescente).\n"
        testo_stampa_completo += "‚Ä¢ Selezione Righe (CTRL/SHIFT): Utilizza CTRL + Click per selezionare righe sparse (selezione mista), o SHIFT + Click per selezionare un intervallo continuo di righe.\n"

        testo_stampa_completo += "\n‚Ä¢ Dettaglio Transazioni:\n"
        testo_stampa_completo += "  1. Doppio Clic sulla riga (Treeview Statistiche): Apre il pop-up con il Dettaglio di tutte le transazioni aggregate.\n"
        testo_stampa_completo += "  2. Interazione nel Pop-up Dettaglio (Transazioni Individuali):\n"
        testo_stampa_completo += "    ‚Ä¢ Doppio Clic (Modalit√† Totali/Mese/Categoria): Seleziona la riga della transazione e ti reindirizza alla transazione corrispondente nella Treeview principale.\n"
        testo_stampa_completo += "    ‚Ä¢ Modalit√† Giorno (Transazioni Quotidiane):\n"
        testo_stampa_completo += "        ‚Ä¢ Doppio Clic: Apre l'Archivio PDF correlato alla transazione (se presente).\n"
        testo_stampa_completo += "        ‚Ä¢ Clic Destro: Avvia il Generatore Promemoria Google Calendar (pre-popolato).\n"

        testo_stampa_completo += "\n# Avvio e Interazioni del Grafico a Barre:\n"
        testo_stampa_completo += "‚Ä¢ Navigazione Grafici: Usa le Frecce Destra/Sinistra per scorrere tra le diverse visualizzazioni (Tabella, Grafico, Mensile, Saldo). Premi ESC per tornare alla Treeview.\n"
        testo_stampa_completo += "‚Ä¢ Avvio Archivio PDF: Clicca con il Tasto Destro su una riga (spesa o entrata) per avviare l'Archivio Documenti, pre-filtrato per la categoria selezionata.\n"
        testo_stampa_completo += "‚Ä¢ Avvio Grafico Multiplo: Dopo aver selezionato una o pi√π categorie dalla Treeview (usando CTRL/SHIFT), clicca con il Tasto Destro del mouse sulle righe selezionate per avviare il grafico.\n"
        testo_stampa_completo += "‚Ä¢ Dettaglio Grafico (Tooltip): Passa il mouse sopra una barra per visualizzare un Tooltip che mostra il totale e il dettaglio delle singole categorie aggregate in quella barra.\n"
        testo_stampa_completo += "‚Ä¢ Dettaglio Spesa (Drill-Down): Doppio Clic su una barra del grafico per aprire il dettaglio delle transazioni relative a quel periodo (Giorno/Mese).\n"
        testo_stampa_completo += "  Da questo pop-up, un ulteriore Doppio Clic sulla transazione ti porta alla spesa nella Treeview principale e imposta il giorno nel Calendario."

        popup_aiuto = tk.Toplevel(self, bg=self.COLOR_TOPLEVEL)
        popup_aiuto.withdraw()
        larghezza_finestra = 1200
        altezza_finestra = 630
        self.update_idletasks() 
        screen_w = self.winfo_screenwidth()
        screen_h = self.winfo_screenheight()
        x = (screen_w // 2) - (larghezza_finestra // 2)
        y = (screen_h // 2) - (altezza_finestra // 2)
        popup_aiuto.geometry(f"{larghezza_finestra}x{altezza_finestra}+{x}+{y}")
        popup_aiuto.resizable(False, False)
        popup_aiuto.transient(self)
        popup_aiuto.deiconify() 
        popup_aiuto.focus_set()
        popup_aiuto.bind("<Escape>", lambda e: popup_aiuto.destroy())
        main_frame = ttk.Frame(popup_aiuto, padding="15")
        main_frame.pack(fill="both", expand=True)
        content_frame = ttk.Frame(main_frame)
        content_frame.pack(fill="both", expand=True)
        ttk.Label(
            content_frame, 
            text="Filtri Temporali: Controllano l'Aggregazione dei Dati nella Tabella Statistiche.",
            font=("Arial", 11, "bold"),
            anchor='w'
        ).pack(pady=(5, 5), fill='x')
        for title, description in help_content:
            title_label = ttk.Label(
                content_frame, 
                text=f"‚Ä¢ Filtro {title}:",
                font=("Arial", 10, "bold"),
                justify=tk.LEFT,
                anchor='w'
            )
            title_label.pack(fill='x', pady=(2, 0))
            desc_label = ttk.Label(
                content_frame, 
                text=description,
                font=("Arial", 9),
                justify=tk.LEFT,
                anchor='w',
                wraplength=1150
            )
            desc_label.pack(fill='x', padx=15, pady=(0, 2))
        ttk.Label(
            content_frame, 
            text="Interazioni con le Tabelle Dati (Treeview):",
            font=("Arial", 11, "bold"),
            anchor='w'
        ).pack(pady=(10, 5), fill='x')
        ttk.Label(
            content_frame,
            text="‚Ä¢ Scroll e Navigazione: Utilizza la Rotella del Mouse per scorrere verticalmente in qualsiasi Treeview o area.\n"
                 "‚Ä¢ Ordinamento (Sort): Clicca sull'intestazione di qualsiasi colonna per ordinare i dati. Clicca di nuovo per invertire (crescente/decrescente).\n"
                 "‚Ä¢ Selezione Righe (CTRL/SHIFT): Utilizza CTRL + Click per selezionare righe sparse (selezione mista), o SHIFT + Click per selezionare un intervallo continuo di righe.",
            font=("Arial", 9),
            justify=tk.LEFT,
            anchor='w',
            wraplength=1150
        ).pack(fill='x', padx=5, pady=(0, 5))

        ttk.Label(
            content_frame,
            text="‚Ä¢ Dettaglio Transazioni:\n"
                 "  1. Doppio Clic sulla riga (Treeview Statistiche): Apre il pop-up con il Dettaglio di tutte le transazioni aggregate.\n"
                 "  2. Interazione nel Pop-up Dettaglio (Transazioni Individuali):\n"
                 "    ‚Ä¢ Doppio Clic (Modalit√† Totali/Mese/Categoria): Seleziona la riga della transazione e ti reindirizza alla transazione corrispondente nella Treeview principale.\n"
                 "    ‚Ä¢ Modalit√† Giorno (Transazioni Quotidiane):\n"
                 "        ‚Ä¢ Doppio Clic: Apre l'Archivio PDF correlato alla transazione (se presente).\n"
                 "        ‚Ä¢ Clic Destro: Avvia il Generatore Promemoria Google Calendar (pre-popolato).\n",
            font=("Arial", 9),
            justify=tk.LEFT,
            anchor='w',
            wraplength=1150
        ).pack(fill='x', padx=5, pady=(0, 5))
        ttk.Label(
            content_frame, 
            text="Avvio e Interazioni del Grafico a Barre:",
            font=("Arial", 11, "bold"),
            anchor='w'
        ).pack(pady=(10, 5), fill='x')

        ttk.Label(
            content_frame,
            text="‚Ä¢ Navigazione Grafici: Usa le Frecce Destra/Sinistra per scorrere tra le diverse visualizzazioni (Tabella, Grafico, Mensile, Saldo). Premi ESC per tornare alla Treeview.\n"
                 "‚Ä¢ Avvio Archivio PDF: Clicca con il Tasto Destro su una riga (spesa o entrata) per avviare l'Archivio Documenti, pre-filtrato per la categoria selezionata.\n"
                 "‚Ä¢ Avvio Grafico Multiplo: Dopo aver selezionato una o pi√π categorie dalla Treeview (usando CTRL/SHIFT), clicca con il Tasto Destro del mouse sulle righe selezionate per avviare il grafico.\n"
                 "‚Ä¢ Dettaglio Grafico (Tooltip): Passa il mouse sopra una barra per visualizzare un Tooltip che mostra il totale e il dettaglio delle singole categorie aggregate in quella barra.\n"
                 "‚Ä¢ Dettaglio Spesa (Drill-Down): Doppio Clic su una barra del grafico per aprire il dettaglio delle transazioni relative a quel periodo (Giorno/Mese).\n"
                 "  Da questo pop-up, un ulteriore Doppio Clic sulla transazione ti porta alla spesa nella Treeview principale e imposta il giorno nel Calendario.",
            font=("Arial", 9),
            justify=tk.LEFT,
            anchor='w',
            wraplength=1150
        ).pack(fill='x', padx=5, pady=(0, 5))
        bottom_frame = ttk.Frame(popup_aiuto)
        bottom_frame.pack(side=tk.BOTTOM, fill=tk.X, pady=(0, 10), padx=15)
        ttk.Button(
            bottom_frame, 
            text="üñ®Ô∏è Stampa Guida", 
            command=lambda: self._stampa_lista_diretta(
                testo_stampa_completo, 
                self.show_custom_warning
            ), 
            style='Blu.TButton'
        ).pack(side=tk.LEFT, pady=5, padx=10)
        ttk.Button(
            bottom_frame, 
            text="Ho Capito (OK)", 
            command=popup_aiuto.destroy,
            style="Giallo.TButton" 
        ).pack(side=tk.RIGHT, pady=5, padx=10)

    # Finestra Informativa e Dettagli dell'Applicazione (About Box)
    def show_info_app(self):
        def apri_email(event):
            webbrowser.open("mailto:helpcasafacilepro@gmail.com")
        def apri_link_python(event):
            webbrowser.open("https://www.python.org/downloads/")
        info_win = tk.Toplevel(self, bg=self.COLOR_TOPLEVEL)
        info_win.title("Informazioni sull'applicazione e Interazioni")
        info_win.resizable(False, False)
        text = tk.Text(info_win, wrap="word", bg="white", font=("Courier New", 10))
        text.pack(fill="both", expand=True, padx=20, pady=10)
        text.insert("end", f"{NAME}  ", "titolo")
        text.insert("end", f"Versione v.{VERSION}\n", "versione")
        text.insert("end", "¬© 2025 Casa Facile Pro - Sviluppo Python/Tkinter (2023-2025)    ")
        text.insert("end", "Email Supporto: ")
        text.insert("end", "helpcasafacilepro@gmail.com\n", "email")
        text.insert("end", "Progetto Python: ")
        text.insert("end", "https://www.python.org/downloads/\n", "link")
        text.insert("end", "\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ FUNZIONALIT√Ä PRINCIPALI ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n", "sezione")
        text.insert("end", "‚Ä¢ Inserimento, modifica e cancellazione di spese ed entrate per categoria.\n")
        text.insert("end", "‚Ä¢ Gestione Categorie personalizzate e Ricorrenze (spese/entrate ripetute).\n")
        text.insert("end", "‚Ä¢ Analisi: Giornaliere, Mensili, Annuali, Totali, Grafici, Time Machine, Confronta, Documenti, Supermarket.\n")
        text.insert("end", "‚Ä¢ Esportazione Dati e Riepilogo dettagliato in formato stampabile (Giorno, Mese, Anno, Utenze).\n")
        text.insert("end", "‚Ä¢ Strumenti Integrati: Saldo Conto, Calcolatrice, Rubrica, Gestione Utenze, Cerca, Report, Finanziamenti.\n")
        text.insert("end", "‚Ä¢ Database: Backup (Automatico e Manuale) , Import/Export database e Reset.\n")
        text.insert("end", "‚Ä¢ L'applicazione integra un WebServer sulla porta 8080 per consentire l'accesso remoto ai dati.\n")
        text.insert("end", "  Questo accesso √® protetto da password per garantirne la sicurezza, consentendo la gestione dell'app tramite\n  browser (PC, SMARTPHONE) solo agli utenti autorizzati.\n")
        text.insert("end", "‚Ä¢ Calendario interattivo con caselle colorate che indicano l'attivit√† del giorno.\n")
        text.insert("end", "\nIl tasto Esc chiude istantaneamente qualsiasi finestra secondaria aperta.\n" "Dopo 20 minuti di inattivit√†, la finestra principale viene iconizzata e un popup di notifica appare ogni 5 minuti; ")
        text.insert("end", "\npassando il mouse sull'icona o sul popup, l'applicazione si riapre.\n")
        text.insert("end", "\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ INTERAZIONE TABELLE DATI ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n", "sezione")
        text.insert("end", "Le tabelle che mostrano le tue operazioni (Treeview) sono progettate per l'efficienza:\n\n")
        text.insert("end", "1. Ordinamento delle Colonne (Sortby):\n", "sottosezione")
        text.insert("end", "   ‚Ä¢ Clicca sull'intestazione di qualsiasi colonna (Data, Importo, Categoria, tipo, descrizione) per ordinare i dati.\n")
        text.insert("end", "   ‚Ä¢ L'ordinamento gestisce correttamente date e numeri, e alterna la direzione (Ascendente/Discendente).\n\n")
        text.insert("end", "   ‚Ä¢ Funzione Universale (Dettaglio): Fai doppio click su una riga in Qualsiasi Treeview\n     (es. Ricorrenze, Report Mese Dettagliato, Mese/Anno Totali, Grafici, etc.) per ottenere l'azione di dettaglio logica\n     per quel contesto. Ad esempio, aprire il dettaglio del record in un sottomenu o visualizzare la sua posizione\n     nel Treeview principale.\n")
        text.insert("end", "2. Scorrimento con Mouse (Scroll):\n", "sottosezione")
        text.insert("end", "   ‚Ä¢ Tutte le tabelle e le aree di testo scorribili supportano lo scorrimento ovunque tramite la rotella del mouse,\n     senza la necessit√† di cliccare prima sulla barra di scorrimento.\n\n")
        text.tag_config("titolo", foreground="darkblue", font=("Courier New", 12, "bold"))
        text.tag_config("versione", foreground="blue", font=("Courier New", 10, "italic"))
        text.tag_config("sezione", foreground="darkgreen", font=("Courier New", 10, "bold"))
        text.tag_config("sottosezione", foreground="darkorange", font=("Courier New", 10, "bold"))
        text.tag_config("email", foreground="blue", underline=1)
        text.tag_bind("email", "<Button-1>", apri_email)
        text.tag_config("link", foreground="blue", underline=1)
        text.tag_bind("link", "<Button-1>", apri_link_python)
        text.config(state="disabled")    
        text.pack(fill="both", expand=True, padx=20, pady=(10, 0)) 
        text.config(state="disabled")
        button_frame = ttk.Frame(info_win, padding=(10, 10, 10, 10))
        button_frame.pack(fill="x", pady=0) 
        btn_stampa = ttk.Button(
            button_frame, 
            text="üñ®Ô∏è Stampa Info", 
            command=lambda: self._stampa_lista_diretta(
                text.get("1.0", "end-1c"), 
                self.show_custom_warning
            ), 
            style='Blu.TButton'
        )
        btn_stampa.pack(side=tk.LEFT, padx=5)
        btn_chiudi = ttk.Button(button_frame, text="‚ùå Chiudi", command=info_win.destroy, style='Giallo.TButton')
        btn_chiudi.pack(side=tk.RIGHT, padx=5)
        info_win.withdraw()
        info_win.update_idletasks()
        min_w, min_h = 1160, 650
        w = max(info_win.winfo_width(), min_w)
        h = max(info_win.winfo_height(), min_h)
        x = self.winfo_rootx() + (self.winfo_width() // 2) - (w // 2)
        y = self.winfo_rooty() + (self.winfo_height() // 2) - (h // 2)
        info_win.geometry(f"{w}x{h}+{x}+{y}")
        info_win.grab_set()
        info_win.transient(self)
        info_win.focus_set()
        info_win.deiconify()
        info_win.bind("<Escape>", lambda e: info_win.destroy())

    # Popup Gestione Utenze          
    def check_UTENZE_DB(self):
         if not os.path.exists(UTENZE_DB):
            with open(UTENZE_DB, "w") as file:
                file.write("")  
                self.utenze()

    def utenze(self):
        self.check_UTENZE_DB()
        def get_consumi_per_anno(anno):
            return {
                "Acqua": [(f"{m:02d}/{anno}", 0.0, 0.0, 0.0) for m in range(1, 13)],
                "Luce":  [(f"{m:02d}/{anno}", 0.0, 0.0, 0.0) for m in range(1, 13)],
                "Gas":   [(f"{m:02d}/{anno}", 0.0, 0.0, 0.0) for m in range(1, 13)],
            }
        utenze = ["Acqua", "Luce", "Gas"]
        def carica_db():
            if os.path.exists(UTENZE_DB):
                try:
                    with open(UTENZE_DB, "r", encoding="utf-8") as f:
                        data = json.load(f)
                    letture = data.get("letture_salvate", {u: {} for u in utenze})
                    for utenza, per_anno in letture.items():
                        for anno, righe in per_anno.items():
                            letture_norm = []
                            for r in righe:
                                if len(r) == 4:
                                   mese, prec, att, _ = r
                                   try:
                                       consumo = max(0.0, float(att) - float(prec))
                                   except:
                                       prec, att, consumo = 0.0, 0.0, 0.0
                                       letture_norm.append((mese, prec, att, consumo))
                                else:
                                   letture_norm.append(tuple(r))
                                   letture[utenza][anno] = letture_norm
                    anagrafiche = data.get("anagrafiche", {u: {
                        "Ragione sociale": "",
                        "Telefono": "",
                        "Email": "",
                        "Numero contratto": "",
                        "POD": "",
                        "Note": ""
                    } for u in utenze})
                    for utenza in utenze:
                        if utenza not in anagrafiche:
                            anagrafiche[utenza] = {
                                "Ragione sociale": "",
                                "Telefono": "",
                                "Email": "",
                                "Numero contratto": "",
                                "POD": "",
                                "Note": ""
                            }
                        else:
                            for campo in ["Ragione sociale", "Telefono", "Email", "Numero contratto", "POD", "Note"]:
                                if campo not in anagrafiche[utenza]:
                                    anagrafiche[utenza][campo] = ""
                    return letture, anagrafiche
                except Exception as e:
                    return {u: {} for u in utenze}, {u: {
                        "Ragione sociale": "",
                        "Telefono": "",
                        "Email": "",
                        "Numero contratto": "",
                        "POD": "",
                        "Note": ""
                    } for u in utenze}
            else:
                return {u: {} for u in utenze}, {u: {
                    "Ragione sociale": "",
                    "Telefono": "",
                    "Email": "",
                    "Numero contratto": "",
                    "POD": "",
                    "Note": ""
                } for u in utenze}

        def scrivi_db():
            try:
                data = {
                    "letture_salvate": {
                        u: {a: [list(r) for r in anni] for a, anni in letture_salvate[u].items()}
                        for u in utenze
                    },
                    "anagrafiche": anagrafiche
                }
                with open(UTENZE_DB, "w", encoding="utf-8") as f:
                    json.dump(data, f, indent=1, ensure_ascii=False)
            except Exception as e:
                 self.show_custom_warning("Errore", "Errore scrittura dati")
        letture_salvate, anagrafiche = carica_db()
        self.letture_salvate_utenze = letture_salvate
        self.anagrafiche_salvate_utenze = anagrafiche
        anno_corrente = str(datetime.datetime.now().year)
        year_current = int(anno_corrente)
        anni = [str(a) for a in range(year_current, year_current-11, -1)]
        consumi = get_consumi_per_anno(anno_corrente)
        win = tk.Toplevel(self, bg=self.COLOR_TOPLEVEL)
        win.withdraw() 
        larghezza = 1200
        altezza = 660
        self.update_idletasks()
        self_x = self.winfo_rootx()
        self_y = self.winfo_rooty()
        self_width = self.winfo_width()
        self_height = self.winfo_height()
        x = self_x + (self_width // 2) - (larghezza // 2)
        y = self_y + (self_height // 2) - (altezza // 2)
        win.geometry(f"{larghezza}x{altezza}+{x}+{y}")
        win.title("Gestione Consumi Utenze")
        win.protocol("WM_DELETE_WINDOW", lambda: (self.deiconify(), self.after(0, self.imp_entry.focus_set), win.destroy()))
        win.grab_set()
        win.deiconify() 
        self.withdraw() 
        menu_win = tk.Menu(win, background=BACKGROUND_DARK, foreground=FOREGROUND_LIGHT, activebackground=ACCENT_COLOR, activeforeground='black')
        menu_funzioni = tk.Menu(menu_win, tearoff=0, bg=MENU_BG, fg=FOREGROUND_LIGHT, activebackground=ACCENT_COLOR, activeforeground='black')
        menu_funzioni.add_command(label="üìÇ Esporta Preview", command=lambda: esporta_preview())
        menu_funzioni.add_command(label="‚öôÔ∏è Analizza", command=lambda: crea_tabella_consumi(win, UTENZE_DB))
        menu_funzioni.add_separator()
        menu_funzioni.add_command(label="üì• Tabella Consumi PDF", command=lambda: self.scarica_tabella())
        menu_funzioni.add_separator()
        menu_funzioni.add_command(label="‚ùå Chiudi (ESC)", command=lambda: (self.deiconify(), self.after(0, self.imp_entry.focus_set), win.destroy()))
        menu_win.add_cascade(label="üìÇ Opzioni", menu=menu_funzioni)
        menu_database = tk.Menu(menu_win, tearoff=0, bg=MENU_BG, fg=FOREGROUND_LIGHT, activebackground=ACCENT_COLOR, activeforeground='black')
        menu_database.add_command(label="üì§ Esporta Consumi", command=lambda: esporta_letture_data(UTENZE_DB))
        menu_database.add_command(label="üì• Importa Consumi", command=lambda: importa_letture_data(letture_salvate, anagrafiche))
        menu_database.add_separator()
        menu_database.add_command(label="üì• Azzera Consumi", command=lambda: reset_utenze_letture())
        menu_win.add_cascade(label="üóÑÔ∏è Database", menu=menu_database)
        win.config(menu=menu_win)
        win.bind("<Escape>", lambda e: (self.deiconify(), self.after(0, self.imp_entry.focus_set), win.destroy()))
        top_controls = tk.Frame(win, bg=self.COLOR_TOPLEVEL )
        top_controls.pack(pady=(0, 6))
        tk.Label(top_controls, text="Gestione Consumi Utenze", bg=self.COLOR_TOPLEVEL, fg=self.TEXT_COLOR, font=("Arial", 14, "bold")).pack(side=tk.LEFT, padx=(0, 25))
        tk.Label(top_controls, text="Anno: ", bg=self.COLOR_TOPLEVEL, fg=self.TEXT_COLOR).pack(side=tk.LEFT)
        anno_var = tk.StringVar(value=anno_corrente)
        def reset_utenze_letture():
            conferma = self.show_custom_askyesno(
                "Azzeramento Letture",
                "Sei sicuro di voler azzerare TUTTE le letture delle utenze?\n"
                "Questa azione eliminer√† lo storico delle letture."
            )
            if conferma:
                try:
                    if os.path.exists(UTENZE_DB):
                        os.remove(UTENZE_DB)
                    if not os.path.exists(UTENZE_DB):
                        with open(UTENZE_DB, "w") as file:
                            file.write("{\n}\n")  
                    self.deiconify()
                    win.destroy()
                    self.utenze()
                    self.show_custom_warning("Letture", "Letture utenze azzerate con successo.")      
                except Exception as e:
                    self.show_custom_warning("Errore Azzeramento", f"Si √® verificato un errore durante l'azzeramento:\n{e}")
        def salva_letture_preview(txt, preview_win):
            now = datetime.date.today()
            default_filename = f"Letture_Export_{now.day:02d}-{now.month:02d}-{now.year}.txt"
            preview_win.wm_attributes('-topmost', 1)
            file = filedialog.asksaveasfilename(
                defaultextension=".txt",
                filetypes=[("File txt", "*.txt")],
                initialdir=EXPORT_FILES,
                initialfile=default_filename,
                title="Salva Preview",
                confirmoverwrite=False,
                parent=preview_win)
            preview_win.wm_attributes('-topmost', 0)
            if file:
                if os.path.exists(file):
                    conferma = self.show_custom_askyesno(
                        "Sovrascrivere file?",
                        f"Il file '{os.path.basename(file)}' \nesiste gi√†. Vuoi sovrascriverlo?"
                    )
                    if not conferma:
                        return 
                with open(file, "w", encoding="utf-8") as f:
                    lines = txt.get("1.0", tk.END)
                    f.write(lines)
                preview_win.destroy()
                self.show_custom_warning("Esportazione completata", f"Riepilogo esportate in\n{file}")
        def esporta_preview():
            preview_win = tk.Toplevel(win, bg=self.COLOR_TOPLEVEL)
            preview_win.title("Preview Esportazione")
            preview_win.geometry("1050x600")
            screen_width = preview_win.winfo_screenwidth()
            screen_height = preview_win.winfo_screenheight()
            x = (screen_width - 1050) // 2
            y = (screen_height - 600) // 2
            preview_win.geometry(f"1050x600+{x}+{y}")
            preview_win.after(10, lambda: preview_win.focus_force())
            txt = tk.Text(preview_win, font=("Courier New", 10), wrap="none")
            txt.pack(fill=tk.BOTH, expand=True)
            anno_x = anno_var.get()
            txt.insert(tk.END, f"Consumi utenze per anno {anno_x}\n\n")
            header = f"{'Mese':<10}"
            for utenza in utenze:
                header += f"{utenza:^30}"
            txt.insert(tk.END, header + "\n")
            sub_header = f"{'':<10}"
            for _ in utenze:
                sub_header += f"{'Prec':>8}{'Att':>10}{'Cons':>10}  "
            txt.insert(tk.END, sub_header + "\n")
            txt.insert(tk.END, "-" * len(header) + "\n")
            mesi = [self.trees[utenze[0]].item(iid)['values'][0] for iid in self.trees[utenze[0]].get_children()]
            for i, mese in enumerate(mesi):
                riga = f"{mese:<10}"
                for utenza in utenze:
                    values = self.trees[utenza].item(self.trees[utenza].get_children()[i])['values']
                    prec, att, cons = float(values[1]), float(values[2]), float(values[3])
                    riga += f"{prec:8.2f}{att:10.2f}{cons:10.2f}  "
                txt.insert(tk.END, riga + "\n")
            txt.insert(tk.END, "-" * len(header) + "\n")
            tot_riga = f"{'Totale':<10}"
            for utenza in utenze:
                somma = sum(float(self.trees[utenza].item(iid)['values'][3]) for iid in self.trees[utenza].get_children())
                tot_riga += f"{'':8}{'':10}{somma:10.2f}  "
            txt.insert(tk.END, tot_riga + "\n")
            txt.config(state="disabled")
            btn_frame = tk.Frame(preview_win, bg=self.COLOR_TOPLEVEL)
            btn_frame.pack(fill=tk.X, pady=12)
            ttk.Button(btn_frame, text="üíæ Esporta", command=lambda: salva_letture_preview(txt, preview_win), style="Verde.TButton").pack(side=tk.LEFT, padx=10)
            ttk.Button(
            btn_frame,
            text="üñ®Ô∏è Stampa",
            command=lambda: self._stampa_lista_diretta(
                txt.get("1.0", tk.END),
                self.show_custom_warning
            ),
            style="Blu.TButton" 
        ).pack(side=tk.LEFT, padx=10)
            ttk.Button(btn_frame, text="‚ùå Chiudi", command=preview_win.destroy, style="Giallo.TButton").pack(side=tk.RIGHT, padx=10)
            preview_win.lift()
            preview_win.attributes('-topmost', True)
            preview_win.after(200, lambda: preview_win.attributes('-topmost', False))
            preview_win.bind("<Escape>", lambda e: preview_win.destroy())
        def chiudi():
            win.destroy()
            self.deiconify()
            self.after(0, self.imp_entry.focus_set)
        def cambia_anno(*args):
            nonlocal consumi
            for utenza in utenze:
                if self.trees[utenza].get_children():
                    anno_attuale = self.trees[utenza].item(self.trees[utenza].get_children()[0])['values'][0].split("/")[1]
                    letture_salvate[utenza][anno_attuale] = [
                        tuple(self.trees[utenza].item(iid)['values']) for iid in self.trees[utenza].get_children()
                    ]
            scrivi_db()
            for utenza in utenze:
                self.trees[utenza].delete(*self.trees[utenza].get_children())
            anno_sel = anno_var.get()
            consumi = get_consumi_per_anno(anno_sel)
            for utenza in utenze:
                if (anno_sel not in letture_salvate[utenza]) or (not letture_salvate[utenza][anno_sel]):
                    letture_salvate[utenza][anno_sel] = [
                        (f"{m:02d}/{anno_sel}", 0.0, 0.0, 0.0) for m in range(1, 13)
                    ]
                righe = letture_salvate[utenza][anno_sel]
                righe_norm = []
                for r in righe:
                    if len(r) == 4:
                        mese, prec, att, consumo = r
                        consumo = max(0.0, float(att) - float(prec))
                        righe_norm.append((mese, float(prec), float(att), float(consumo)))
                    else:
                        righe_norm.append(tuple(r))
                letture_salvate[utenza][anno_sel] = righe_norm
                for mese, prec, att, consumo in righe_norm:
                    self.trees[utenza].insert("", "end", values=(mese, float(prec), float(att), float(consumo)))
        anno_cb = ttk.Combobox(top_controls, values=anni, textvariable=anno_var, style="Border.TCombobox", state="readonly", width=8)
        anno_cb.pack(side=tk.LEFT)
        def reset_anno():
            anno_var.set(anno_corrente)
        ttk.Button(top_controls, text="üîÑ", style="Giallo.TButton", width=2, command=reset_anno).pack(side=tk.LEFT, padx=2)
        ttk.Button(top_controls, text="‚ùå Chiudi", style="Giallo.TButton", command=chiudi).pack(side=tk.LEFT, padx=7)
        anno_var.trace_add("write", cambia_anno)
        main_frame = ttk.Frame(win)
        main_frame.pack(fill=tk.BOTH, expand=True, padx=18, pady=6)
        for c in range(len(utenze)):
            main_frame.grid_columnconfigure(c, weight=1)
        colori = {"Acqua": "#ccefff", "Luce": "#fff9cc", "Gas": "#ffe0cc"}
        self.trees = {}
        anag_entries = {}
        def importa_letture_data(letture_salvate, anagrafiche):
            now = datetime.date.today()
            default_dir = EXP_DB
            default_filename = f"Letture_import_{now.day:02d}-{now.month:02d}-{now.year}.json"
            file = filedialog.askopenfilename(
                defaultextension=".json",
                filetypes=[("File JSON", "*.json")],
                initialdir=default_dir,
                initialfile=default_filename,
                title="Importa utenze",
            )
            if file:
                try:
                    with open(file, "r", encoding="utf-8") as f:
                        data = json.load(f)
                    letture = data.get("letture_salvate", {})
                    anagrafiche = data.get("anagrafiche", {})
                    self.letture_salvate_utenze.update(letture)
                    self.anagrafiche_salvate_utenze.update(anagrafiche)     
                    scrivi_db()
                    self.deiconify()
                    win.destroy()
                    self.utenze()
                    self.show_custom_warning("Importazione riuscita", "Utenze importate correttamente!")
                except Exception as e:
                    self.show_custom_warning("Errore", f"Errore durante l'importazione:\n{e}")
        def esporta_letture_data(UTENZE_DB):
            now = datetime.date.today()
            default_dir = EXP_DB
            default_filename = f"Letture_Export_{now.day:02d}-{now.month:02d}-{now.year}.json"
            file = filedialog.asksaveasfilename(
                defaultextension=".json",
                filetypes=[("File JSON", "*.json")],
                initialdir=default_dir,
                initialfile=default_filename,
                confirmoverwrite=False,
                title="Esporta utenze",
            )
            if file:
                try:
                    data = {
                        "letture_salvate": self.letture_salvate_utenze,
                        "anagrafiche": self.anagrafiche_salvate_utenze
                    }
                    with open(file, "w", encoding="utf-8") as f:
                        json.dump(data, f, ensure_ascii=False, indent=2)
                    self.show_custom_warning("Esportazione completata", f"Database utenze salvato in:\n{file}")
                except Exception as e:
                    self.show_custom_warning("Errore", f"Errore durante l'esportazione:\n{e}")
        def crea_tabella_consumi(parent, UTENZE_DB):
            try:
                with open(UTENZE_DB, "r", encoding="utf-8") as f:
                    data = json.load(f)
                    letture_salvate = data.get("letture_salvate", {})
            except Exception as e:
                print(f"‚ùå Errore lettura file: {e}")
                return
            utenze = ["Acqua", "Luce", "Gas"]
            win = tk.Toplevel(parent, bg=self.COLOR_TOPLEVEL )
            win.bind("<Escape>", lambda e: win.destroy())
            win.title("Consumi Utenze - Anteprima")
            win.geometry("1150x600")
            win.transient(parent)
            win.grab_set()
            screen_width = win.winfo_screenwidth()
            screen_height = win.winfo_screenheight()
            x_coordinate = (screen_width - 1150) // 2
            y_coordinate = (screen_height - 600) // 2
            win.geometry(f"1150x600+{x_coordinate}+{y_coordinate}")
            frame_principale = ttk.Frame(win)
            frame_principale.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
            canvas = tk.Canvas(frame_principale, bg=self.COLOR_TOPLEVEL)
            scrollbar = ttk.Scrollbar(frame_principale, orient="vertical", command=canvas.yview)
            canvas.configure(yscrollcommand=scrollbar.set)
            scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
            canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
            frame_interno = ttk.Frame(canvas)
            canvas_window = canvas.create_window((0, 0), window=frame_interno, anchor="nw")
            def aggiorna_scrollregion(event):
                canvas.configure(scrollregion=canvas.bbox("all"))
                canvas.itemconfig(canvas_window, width=canvas.winfo_width())
            frame_interno.bind("<Configure>", aggiorna_scrollregion)
            for utenza in utenze:
                frame_tabella = ttk.Frame(frame_interno)
                frame_tabella.pack(fill=tk.BOTH, expand=True, pady=10)
                ttk.Label(
                    frame_tabella,
                    text=f"Consumi {utenza}",
                    font=("Arial", 12, "bold")
                ).pack(pady=5)
                colonne = [
                    "Anno", "Gen", "Feb", "Mar", "Apr", "Mag", "Giu",
                    "Lug", "Ago", "Set", "Ott", "Nov", "Dic", "Totale"
                ]
                tree = ttk.Treeview(
                    frame_tabella,
                    columns=colonne,
                    show="headings",
                    height=4
                )
                for col in colonne:
                    tree.heading(col, text=col)
                    tree.column(col, width=80, anchor="center")
                tree.pack(fill=tk.BOTH, expand=True)
                for anno in sorted(letture_salvate.get(utenza, {}).keys(), reverse=True):
                    row = [anno]
                    tot_consumi = 0.0
                    for mese in range(1, 13):
                        mese_str = f"{mese:02d}/{anno}"
                        consumo = sum(
                            float(r[3])
                            for r in letture_salvate.get(utenza, {}).get(anno, [])
                            if r[0] == mese_str
                        )
                        row.append(consumo)
                        tot_consumi += consumo
                    row.append(tot_consumi)
                    tree.insert("", tk.END, values=row)
            frame_bottoni = tk.Frame(win, bg=self.COLOR_TOPLEVEL )
            frame_bottoni.pack(fill=tk.X, padx=10, pady=10)
            ttk.Button(frame_bottoni, text="üíæ Salva", style="Verde.TButton", command=lambda: salva_dati_letture(letture_salvate)).pack(side=tk.LEFT, padx=10)
            ttk.Button(frame_bottoni, text="‚ùå Chiudi", style="Giallo.TButton", command=win.destroy).pack(side=tk.RIGHT, padx=10)
        def salva_dati_letture(letture_salvate):
            win.focus_force()
            now = datetime.date.today()
            default_filename = f"Letture_anno_Export_{now.day:02d}-{now.month:02d}-{now.year}.txt"
            file_path = filedialog.asksaveasfilename(
                defaultextension=".txt",
                filetypes=[("File txt", "*.txt")],
                initialdir=EXPORT_FILES,
                initialfile=default_filename,
                confirmoverwrite=False,
                title="Salva i dati dei consumi"
               )
            if file_path:
                if os.path.exists(file_path):
                    conferma = self.show_custom_askyesno(
                        "Sovrascrivere file?",
                        f"Il file '{os.path.basename(file_path)}' \nesiste gi√†. Vuoi sovrascriverlo?"
                    )
                    if not conferma:
                        return
            if not file_path:
                return
            mesi = ["Gen", "Feb", "Mar", "Apr", "Mag", "Giu",
            "Lug", "Ago", "Set", "Ott", "Nov", "Dic"]
            try:
                with open(file_path, "w", encoding="utf-8") as f:
                    for utenza, anni in letture_salvate.items():
                        f.write(f"Consumi {utenza}:\n")
                        intestazione = f"{'Anno':>6} " + "".join([f"{mese:>8}" for mese in mesi]) + f"{'Totale':>10}\n"
                        f.write(intestazione)
                        f.write("-" * len(intestazione) + "\n")
                        for anno in sorted(anni.keys(), reverse=True):
                            valori_mensili = {r[0]: float(r[3]) for r in anni[anno]}
                            riga = f"{anno:>6} "
                            totale = 0.0
                            for m in range(1, 13):
                                mese_str = f"{m:02d}/{anno}"
                                consumo = valori_mensili.get(mese_str, 0.0)
                                riga += f"{consumo:8.2f}"
                                totale += consumo
                            riga += f"{totale:10.2f}\n"
                            f.write(riga)
                        f.write("\n")
                self.show_custom_warning("Esportazione", f"Riepilogo esportato correttamente in:\n{file_path}")
            except Exception as e:
                self.show_custom_warning("Errore", f"Errore durante il salvataggio:\n{e}")
        def centra_su_padre(finestra, padre):
            padre.update_idletasks()
            larghezza = finestra.winfo_reqwidth()
            altezza = finestra.winfo_reqheight()
            px = padre.winfo_rootx() + (padre.winfo_width() // 2) - (larghezza // 2)
            py = padre.winfo_rooty() + (padre.winfo_height() // 2) - (altezza // 2)
            finestra.geometry(f"+{px}+{py}")
        def salva_letture_utenza(utenza):
            anno_sel = anno_var.get()
            letture_salvate[utenza][anno_sel] = [
                tuple(self.trees[utenza].item(iid)['values']) for iid in self.trees[utenza].get_children()
            ]
            scrivi_db()
        def salva_anagrafica_utenza(utenza):
            for field, ent in anag_entries[utenza].items():
                if field == "Note":
                    anagrafiche[utenza][field] = ent.get("1.0", "end-1c")
                else:
                    anagrafiche[utenza][field] = ent.get()
            scrivi_db()
        def on_tree_double_click(event, utenza):
            tree = self.trees[utenza]
            item_id = tree.identify_row(event.y)
            if item_id:
                tree.selection_set(item_id)
                tree.focus(item_id)
                apri_modale(utenza)
        def on_tree_right_click(event, utenza):
            tree = self.trees[utenza]
            item_id = tree.identify_row(event.y)
            if not item_id:
                return
            tree.selection_set(item_id)
            tree.focus(item_id)
            apri_modale_solo_totale(utenza)
        def apri_modale_solo_totale(utenza):
            selected = self.trees[utenza].focus()
            if not selected:
                self.show_custom_warning("Errore", "Seleziona un mese dalla tabella")
                return
            item = self.trees[utenza].item(selected)
            mese, prec, att, consumo = item['values']
            try:
                consumo = float(consumo)
            except:
                consumo = 0.0
            modal = tk.Toplevel(win, bg=self.COLOR_TOPLEVEL)
            modal.title(f"Consumo {utenza}")
            modal.geometry("300x140")
            modal.resizable(False, False)
            modal.transient(win)
            centra_su_padre(modal, win)
            modal.after_idle(modal.grab_set)
            def only_numeric_8char(val):
                if len(val) > 8:
                    return False
                if val == "":
                    return True
                if val.count(".") > 1:
                    return False
                return all(c.isdigit() or c == "." for c in val)
            vcmd = modal.register(only_numeric_8char)
            tk.Label(modal, text=f"{utenza} - {mese}", bg=self.COLOR_TOPLEVEL, fg=self.TEXT_COLOR, font=("Arial", 12, "bold")).pack(pady=10)
            tk.Label(modal, text="Consumo:", bg=self.COLOR_TOPLEVEL, fg=self.TEXT_COLOR).pack()
            consumo_var = tk.DoubleVar(value=consumo)
            e_cons = tk.Entry(modal, textvariable=consumo_var, font=("Arial", 10), width=15,
                      validate="key", validatecommand=(vcmd, "%P"))
            e_cons.pack()
            e_cons.focus_set()
            modal.bind("<Return>", lambda event: salva()) 
            modal.bind("<KP_Enter>", lambda event: salva()) 
            def salva():
                val = e_cons.get().strip()
                if not val:
                    self.show_custom_warning("Campo vuoto", "Inserisci il valore del consumo.")
                    return
                try:
                    cons = float(consumo_var.get())
                    if cons < 0:
                        self.show_custom_warning("Errore", "Consumo non pu√≤ essere negativo.")
                        return
                    nuovo_att = float(prec) + cons
                    self.trees[utenza].item(selected, values=(mese, prec, nuovo_att, cons))
                    anno_sel = anno_var.get()
                    righe = [
                        tuple(self.trees[utenza].item(iid)['values'])
                        for iid in self.trees[utenza].get_children()
                    ]
                    letture_salvate[utenza][anno_sel] = righe
                    scrivi_db()
                    modal.destroy()
                except ValueError:
                    self.show_custom_warning("Errore", "Valore non valido.")
            btn_frame = tk.Frame(modal, bg=self.COLOR_TOPLEVEL)
            btn_frame.pack(fill="x", pady=10, padx=10)
            btn_salva = ttk.Button(btn_frame, text="üíæ Salva", command=salva, style="Verde.TButton")
            btn_salva.pack(side=tk.LEFT, padx=(0,10))
            btn_chiudi = ttk.Button(btn_frame, text="‚ùå Chiudi", command=modal.destroy, style="Giallo.TButton")
            btn_chiudi.pack(side=tk.RIGHT, padx=(10,0))
            modal.bind("<Escape>", lambda e: modal.destroy())
        def apri_modale(utenza):
            selected = self.trees[utenza].focus()
            if not selected:
                self.show_custom_warning("Errore", "Seleziona un mese dalla tabella")
                return
            item = self.trees[utenza].item(selected)
            mese, prec, att, _ = item['values']
            items = self.trees[utenza].get_children()
            idx = items.index(selected)
            if idx > 0:
                prev_item = self.trees[utenza].item(items[idx - 1])
                try:
                    prec = float(prev_item['values'][2])
                except:
                    prec = 0.0
            try:
                prec = float(prec)
            except:
                prec = 0.0
            try:
                att = float(att)
            except:
                att = 0.0
            modal = tk.Toplevel(win, bg=self.COLOR_TOPLEVEL)
            modal.title(f"Letture {utenza}")
            modal.geometry("300x180")
            modal.resizable(False, False)
            modal.transient(win)
            centra_su_padre(modal, win)
            modal.after_idle(modal.grab_set)
            modal.bind("<Return>", lambda e: salva())
            modal.bind("<KP_Enter>", lambda e: salva())
            def only_numeric_8char(val):
                if len(val) > 8:
                    return False
                if val == "":
                    return True
                if val.count(".") > 1:
                    return False
                return all(c.isdigit() or c == "." for c in val)
            vcmd = modal.register(only_numeric_8char)
            tk.Label(modal, text=f"{utenza} - {mese}", bg=self.COLOR_TOPLEVEL,fg=self.TEXT_COLOR , font=("Arial", 12, "bold")).pack(pady=10)
            tk.Label(modal, text="Lettura precedente:", bg=self.COLOR_TOPLEVEL,fg=self.TEXT_COLOR).pack()
            prec_var = tk.DoubleVar(value=prec)
            e_prec = tk.Entry(modal, textvariable=prec_var, font=("Arial", 10), width=22,
                      validate="key", validatecommand=(vcmd, "%P"))
            e_prec.pack()
            tk.Label(modal, text="Lettura attuale:", bg=self.COLOR_TOPLEVEL,fg=self.TEXT_COLOR).pack()
            att_var = tk.DoubleVar(value=att)
            e_att = tk.Entry(modal, textvariable=att_var, font=("Arial", 10), width=22,
                     validate="key", validatecommand=(vcmd, "%P"))
            e_att.pack()
            modal.e_prec = e_prec
            modal.e_att = e_att
            modal.prec_var = prec_var
            modal.att_var = att_var
            modal.mese = mese
            modal.utenza = utenza
            def salva():
                try:
                    if not e_prec.get().strip() or not e_att.get().strip():
                        self.show_custom_warning("Campo vuoto", "Compila entrambi i campi prima di salvare.")
                        return
                    p = float(prec_var.get())
                    a = float(att_var.get())
                    if a < p:
                        conferma = tk.Toplevel(modal)
                        conferma.title("Conferif att_var.get() == 0.0 and e_att.get().strip() == "":ma Forzatura")
                        conferma.geometry("350x120")
                        conferma.resizable(False, False)
                        conferma.transient(modal)
                        conferma.grab_set()
                        centra_su_padre(conferma, modal)
                        fnt = ("Arial", 9, "bold")
                        msg = tk.Label(conferma,
                                       text="La lettura attuale √® minore della precedente.\nVuoi forzare l'inserimento?",
                                       font=fnt, fg="red")
                        msg.pack(pady=15)
                        btn_frame = ttk.Frame(conferma)
                        btn_frame.pack()
                        def ok():
                            consumo = round(max(0.0, a - p), 2)
                            self.trees[utenza].item(selected, values=(mese, p, a, consumo))
                            if idx + 1 < len(items):
                                next_item = self.trees[utenza].item(items[idx + 1])
                                next_mese, _, next_att, _ = next_item['values']
                                next_att_f = float(next_att)
                                next_cons = round(next_att_f - a, 2)
                                self.trees[utenza].item(items[idx + 1], values=(next_mese, a, next_att_f, next_cons))
                            conferma.destroy()
                            modal.destroy()
                            salva_letture_utenza(utenza)
                        def annulla():
                            conferma.destroy()
                        ttk.Button(btn_frame, text="Forza", style="Arancio.TButton", width=10, command=ok).pack(side=tk.LEFT, padx=12)
                        ttk.Button(btn_frame, text="Annulla", style="Giallo.TButton", width=10, command=annulla).pack(side=tk.LEFT, padx=12)
                        return
                    consumo = round(a - p, 2)
                    self.trees[utenza].item(selected, values=(mese, p, a, consumo))
                    if idx + 1 < len(items):
                        next_item = self.trees[utenza].item(items[idx + 1])
                        next_mese, _, next_att, _ = next_item['values']
                        next_att_f = float(next_att)
                        next_cons = max(0.0, next_att_f - a)
                        self.trees[utenza].item(items[idx + 1], values=(next_mese, a, next_att_f, next_cons))
                    modal.destroy()
                    salva_letture_utenza(utenza)
                except ValueError:
                    self.show_custom_warning("Errore", "Valori non validi")
            ttk.Button(modal, text="üíæ Salva", command=salva, style="Verde.TButton").pack(side=tk.LEFT, padx=10)
            ttk.Button(modal, text="‚ùå Chiudi", command=modal.destroy, style="Giallo.TButton").pack(side=tk.RIGHT, padx=10)
            modal.bind("<Escape>", lambda e: modal.destroy())
        notebook = ttk.Notebook(main_frame)
        notebook.pack(fill="both", expand=True, padx=10, pady=10)
        for utenza in utenze:
                tab = ttk.Frame(notebook)
                notebook.add(tab, text=f"{'üíß' if utenza=='Acqua' else 'üí°' if utenza=='Luce' else 'üî•'} {utenza}")
                colore_bg = colori[utenza]
                frame = tk.Frame(tab, bg=colore_bg, bd=2, relief="groove")
                frame.pack(fill="both", expand=True, padx=8, pady=8)
                top_btn_fr = tk.Frame(frame, bg=colore_bg)
                top_btn_fr.pack(fill="x", padx=4, pady=(2, 0))
                ttk.Button(top_btn_fr,text="üì• Modifica Letture" , style="Rosso.TButton", command=lambda u=utenza: apri_modale(u)).pack(side=tk.LEFT, padx=5, pady=2)
                ttk.Button(top_btn_fr,text="üü¢ Modifica Consumo", style="Verde.TButton", command=lambda u=utenza: apri_modale_solo_totale(u)).pack(side=tk.LEFT, padx=5, pady=2)
                bg_utenza = colori.get(utenza, "#f0f0f0")  
                tk.Label(
                    top_btn_fr,
                    text="üñ±Ô∏è 2 Click sx: Mod.letture | Click dx: Mod.consumo",
                    font=("Arial", 9, "bold"),
                    fg="black",
                    bg=bg_utenza
                ).pack(side=tk.LEFT, padx=10, pady=2)
                tree = ttk.Treeview(frame, columns=("Mese", "Prec", "Att", "Consumo"), show="headings", height=12)
                for col in ("Mese", "Prec", "Att", "Consumo"):
                        tree.heading(col, text=col)
                        tree.column(col, anchor="center", width=80)
                tree.pack(padx=8, pady=6, fill="both", expand=True)
                anno_sel = anno_var.get()
                if (anno_sel not in letture_salvate[utenza]) or (not letture_salvate[utenza][anno_sel]):
                        letture_salvate[utenza][anno_sel] = [(f"{m:02d}/{anno_sel}", 0.0, 0.0, 0.0) for m in range(1, 13)]
                righe = letture_salvate[utenza][anno_sel]
                righe_norm = []
                for r in righe:
                        if len(r) == 4:
                                mese, prec, att, consumo = r
                                consumo = max(0.0, float(att) - float(prec))
                                righe_norm.append((mese, float(prec), float(att), float(consumo)))
                        else:
                                righe_norm.append(tuple(r))
                letture_salvate[utenza][anno_sel] = righe_norm
                for mese, prec, att, consumo in righe_norm:
                        tree.insert("", "end", values=(mese, float(prec), float(att), float(consumo)))
                self.trees[utenza] = tree
                tree.bind("<Double-1>", lambda event, utenza=utenza: on_tree_double_click(event, utenza))
                tree.bind("<Button-3>", lambda event, utenza=utenza: on_tree_right_click(event, utenza))
                SFONDO_EDITABILE = 'yellow'
                SFONDO_BLOCCATO = 'white'
                anag_frame = tk.LabelFrame(frame, text="Dati Anagrafici", bg=colore_bg)
                anag_frame.pack(fill="x", padx=8, pady=8)
                anag_frame.grid_columnconfigure(3, weight=1)
                anag_frame.grid_columnconfigure(4, weight=0)
                anag_entries[utenza] = {}
                campi = [("Ragione sociale", 40), ("Telefono", 40), ("Email", 40), ("Numero contratto", 40), ("POD", 40)]
                for row, (label, width) in enumerate(campi):
                    tk.Label(anag_frame, text=label+":", bg=colore_bg).grid(row=row, column=0, sticky="e", padx=5, pady=2)
                    ent = tk.Entry(anag_frame, 
                                   width=width, 
                                   bg=SFONDO_EDITABILE, 
                                   readonlybackground=SFONDO_BLOCCATO, 
                                   disabledbackground=SFONDO_BLOCCATO) 
                    ent.grid(row=row, column=1, sticky="w", padx=5, pady=2)
                    ent.insert(0, anagrafiche[utenza][label])
                    ent.config(state="readonly") 
                    anag_entries[utenza][label] = ent
                tk.Label(anag_frame, text="Note:", bg=colore_bg).grid(row=0, column=2, sticky="ne", padx=5, pady=2)
                note_container = tk.Frame(anag_frame, bg=colore_bg)
                note_container.grid(row=0, column=3, rowspan=6, sticky="nsew", padx=5, pady=2)
                note_scrollbar = ttk.Scrollbar(note_container, orient=tk.VERTICAL)
                note_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
                note_txt = tk.Text(
                    note_container, 
                    width=60, 
                    height=8, 
                    wrap="word",
                    bg=SFONDO_BLOCCATO,
                    yscrollcommand=note_scrollbar.set
                )
                note_txt.pack(side=tk.LEFT, fill=tk.BOTH, expand=True) 
                note_scrollbar.config(command=note_txt.yview)
                note_txt.insert("1.0", anagrafiche[utenza]["Note"])
                note_txt.config(state="disabled")
                anag_entries[utenza]["Note"] = note_txt
                btns = ttk.Frame(anag_frame)
                btns.grid(row=0, column=4, rowspan=6, sticky="n", padx=(5,10), pady=2)
                def set_editable(editable, u=utenza):
                    colore_sfondo = SFONDO_EDITABILE if editable else SFONDO_BLOCCATO
                    for k, ent in anag_entries[u].items():
                        if k == "Note":
                            ent.config(state="normal" if editable else "disabled")
                            ent.config(background=colore_sfondo) 
                        else:
                            ent.config(state="normal" if editable else "readonly")
                            ent.config(bg=colore_sfondo)
                def salva_dati(u=utenza):
                    for field, ent in anag_entries[u].items():
                        if field == "Note":
                            anagrafiche[u][field] = ent.get("1.0", "end-1c")
                        else:
                            anagrafiche[u][field] = ent.get()
                    set_editable(False, u)
                    scrivi_db()
                    self.show_custom_warning("Attenzione", f"Dati {u} Salvati correttamente !")
                def modifica_dati(u=utenza):
                    set_editable(True, u)
                btns = tk.Frame(anag_frame, bg='') 
                btns.grid(row=0, column=4, rowspan=6, sticky="n", padx=(5,10), pady=2) 
                ttk.Button(btns,text="üíæ Salva",width=10,command=lambda u=utenza: salva_dati(u), style="Verde.TButton").pack(pady=(0, 5))
                ttk.Button(btns,text="üìÑ Modifica",width=10,command=lambda u=utenza: modifica_dati(u), style="Giallo.TButton").pack()

    # Gestione ed Eliminazione Multipla Transazioni
    def apri_cancella_spese_treeview_unica(self):
        NOMI_MESI_ITALIANO = ["Gennaio", "Febbraio", "Marzo", "Aprile", "Maggio", "Giugno", 
                              "Luglio", "Agosto", "Settembre", "Ottobre", "Novembre", "Dicembre"]
        if not hasattr(self, 'spese') or not isinstance(self.spese, dict):
            self.spese = {} 
        self.filtri_cancellazione = {
            "descrizione": "",
            "categoria": "‚Äî",
            "tipo": "‚Äî",
            "anno": "‚Äî",
            "mese": "‚Äî",
            "da": "",
            "a": "",
            "icona": "‚Äî"
        }
        if not hasattr(self, 'selezionate_iid'):
            self.selezionate_iid = set()
        self.selezionate_iid.clear() 
        def sort_treeview_column(tree, col, reverse, data_type='string'):
            items_to_sort = []
            for k in tree.get_children(''):
                value = tree.set(k, col)
                if value in ("‚Äî", ""): continue 
                items_to_sort.append((value, k))
            def get_sort_key(item):
                value = item[0]
                try:
                    if data_type == 'float':
                        return float(value.replace(' ‚Ç¨', '').replace(',', '.'))
                    elif data_type == 'date':
                        return datetime.datetime.strptime(value, '%d/%m/%Y')
                    else: 
                        return value.lower()
                except Exception:
                    return value
            items_to_sort.sort(key=get_sort_key, reverse=reverse)
            for index, (val, k) in enumerate(items_to_sort):
                tree.move(k, '', index)
            tree.heading(col, command=lambda: sort_treeview_column(tree, col, not reverse, data_type))
        def toggle_selection_treeview(event):
            row_id = self.spese_treeview.identify_row(event.y)
            if not row_id or row_id in ("EMPTY_MSG", "FILTER_MSG"): return
            is_selected = row_id in self.selezionate_iid
            current_tags = list(self.spese_treeview.item(row_id, 'tags'))
            type_tag = [t for t in current_tags if t in ('entrata', 'uscita')] 
            if is_selected:
                self.selezionate_iid.remove(row_id)
                self.spese_treeview.item(row_id, tags=type_tag, text="[ ]") 
            else:
                self.selezionate_iid.add(row_id)
                new_tags = type_tag + ['selezionata']
                self.spese_treeview.item(row_id, tags=new_tags, text="[X]") 
        def esegui_cancellazione_azione(): 
            if not self.selezionate_iid:
                self.show_custom_warning("Attenzione", "Seleziona almeno una spesa da cancellare.")
                return
            num_selezionate = len(self.selezionate_iid)
            testo_messaggio = (
                f"‚ö†Ô∏è CONFERMA CANCELLAZIONE DEFINITIVA\n\n"
                f"Stai per cancellare {num_selezionate} elementi selezionati.\n\n"
                f"ATTENZIONE: Questa azione √® IRREVERSIBILE e i dati non potranno pi√π essere recuperati.\n"
                f"Sei assolutamente sicuro di voler procedere con l'eliminazione?"
            )
            response = self.show_custom_askyesno("Conferma Cancellazione", testo_messaggio)
            if not response: return
            spese_da_mantenere = {}
            for giorno_obj in self.spese.keys():
                giorno_interno = str(giorno_obj)
                spese_mantenute_giorno = []
                for indice, voce in enumerate(self.spese.get(giorno_obj, [])):
                    iid = f"{giorno_interno}_{indice}"
                    if iid not in self.selezionate_iid:
                        spese_mantenute_giorno.append(voce)
                if spese_mantenute_giorno:
                    spese_da_mantenere[giorno_obj] = spese_mantenute_giorno
            self.spese = spese_da_mantenere
            self.selezionate_iid.clear() 
            popola_treeview_spese()
            if hasattr(self, 'refresh_gui'): self.refresh_gui()
            if hasattr(self, 'save_db'): self.save_db()
            self.show_custom_warning("Successo", f"‚úÖ {num_selezionate} spese sono state cancellate.")
        def popola_treeview_spese():
            self.spese_treeview.delete(*self.spese_treeview.get_children())
            if not self.spese:
                self.spese_treeview.insert("", "end", iid="EMPTY_MSG", 
                                           text="", 
                                           values=("‚Äî", "‚ö†Ô∏è Dati spese non trovati o database vuoto.", "", "", ""),
                                           tags=('empty',))
                return
            filtri = self.filtri_cancellazione
            items_inserted = 0
            filtro_testo_globale = filtri.get("descrizione", "").lower()
            filtro_categoria_esatta = filtri.get("categoria")
            filtro_tipo = filtri.get("tipo")
            filtro_anno = filtri.get("anno")
            filtro_mese_nome = filtri.get("mese")
            filtro_mese_numero = ""
            if filtro_mese_nome and filtro_mese_nome != "‚Äî":
                try:
                    mese_index = NOMI_MESI_ITALIANO.index(filtro_mese_nome) + 1
                    filtro_mese_numero = f"{mese_index:02d}"
                except ValueError:
                    pass 
            try:
                giorni_ordinati = sorted(self.spese.keys(), 
                                         key=lambda d: d if isinstance(d, datetime.date) else datetime.datetime.strptime(str(d), '%Y-%m-%d').date(), 
                                         reverse=True) 
            except Exception:
                 giorni_ordinati = sorted(self.spese.keys(), reverse=True)
            for giorno_obj in giorni_ordinati:
                d = None
                giorno_interno = str(giorno_obj)
                giorno_visualizzato = str(giorno_obj)
                try:
                    if isinstance(giorno_obj, datetime.date):
                        d = giorno_obj
                    else:
                        d = datetime.datetime.strptime(str(giorno_obj), '%Y-%m-%d').date()
                    giorno_interno = d.strftime('%Y-%m-%d')
                    giorno_visualizzato = d.strftime('%d/%m/%Y')
                except Exception:
                    pass 
                lista_voci = self.spese.get(giorno_obj, [])
                for indice, voce in enumerate(lista_voci): 
                    try:
                        categoria, descrizione, importo = voce[0], voce[1], voce[2]
                        tipo = voce[3].capitalize() if len(voce) > 3 else "N/A" 
                        filtro_icona = filtri.get("icona")
                        if filtro_icona not in ["", "‚Äî"] and filtro_icona not in descrizione:
                            continue
                        matches = True
                        if filtro_testo_globale:
                            testo_da_cercare = f"{descrizione} {categoria}".lower()
                            if filtro_testo_globale not in testo_da_cercare: 
                                matches = False
                        if matches and filtro_categoria_esatta not in ["", "‚Äî"] and categoria != filtro_categoria_esatta: matches = False
                        if matches and filtro_tipo not in ["", "‚Äî"] and tipo != filtro_tipo: matches = False
                        if matches and filtro_anno not in ["", "‚Äî"] and d and str(d.year) != filtro_anno: matches = False
                        if matches and filtro_mese_numero and d:
                            if d.strftime('%m') != filtro_mese_numero:
                                matches = False
                        try:
                            da = float(filtri.get("da", "") or "0")
                            a = float(filtri.get("a", "") or "999999999")
                            if matches and not (da <= float(importo) <= a): matches = False 
                        except (ValueError, TypeError): pass
                        if matches:
                            importo_formattato = f"{float(importo):.2f} ‚Ç¨"
                            iid = f"{giorno_interno}_{indice}" 
                            is_selected = iid in self.selezionate_iid
                            color_tag = 'entrata' if tipo == 'Entrata' else 'uscita'
                            tags = [color_tag]
                            if is_selected:
                                tags.append('selezionata')
                            checkbox_text = "[X]" if is_selected else "[ ]" 
                            self.spese_treeview.insert(
                                "", "end", iid=iid,
                                text=checkbox_text,
                                values=(giorno_visualizzato, categoria, descrizione, tipo, importo_formattato),
                                tags=tags
                            )
                            items_inserted += 1
                    except Exception:
                        continue
            if items_inserted == 0 and self.spese:
                self.spese_treeview.insert("", "end", iid="FILTER_MSG", 
                                           text="", 
                                           values=("‚Äî", "Nessun risultato.", "", "", ""),
                                           tags=('empty',))
        def aggiorna_stato_filtri():
            attivi = {k: v for k, v in self.filtri_cancellazione.items() if v and v != "‚Äî"}
            if not attivi:
                lbl_filtri_attivi.config(text="Nessun filtro attivo. Attiva un Filtro Avanzato.", fg="gray")
            else:
                testo_formattato = []
                for k, v in attivi.items():
                    if k == 'descrizione':
                        testo_formattato.append(f"Testo Globale: {v}")
                    else:
                        testo_formattato.append(f"{k.capitalize()}: {v}")
                testo = ", ".join(testo_formattato)
                lbl_filtri_attivi.config(text=f"Filtri attivi: {testo}", fg="dodgerblue")
        def apri_filtri_avanzati():
            filtro_win = tk.Toplevel(popup, bg=self.COLOR_TOPLEVEL)
            filtro_win.title("‚öôÔ∏è Filtri Avanzati di Cancellazione")
            larghezza_finestra = 400
            altezza_finestra = 350
            x = popup.winfo_rootx() + (popup.winfo_width() // 2) - (larghezza_finestra // 2)
            y = popup.winfo_rooty() + (popup.winfo_height() // 2) - (altezza_finestra // 2)
            filtro_win.geometry(f"{larghezza_finestra}x{altezza_finestra}+{x}+{y}")
            filtro_win.transient(popup)
            filtro_win.grab_set()
            filtro_win.bind("<Escape>", lambda e: filtro_win.destroy())
            descrizione_var = tk.StringVar(value=self.filtri_cancellazione.get("descrizione", ""))
            categoria_var = tk.StringVar(value=self.filtri_cancellazione.get("categoria", "‚Äî"))
            tipo_var = tk.StringVar(value=self.filtri_cancellazione.get("tipo", "‚Äî"))
            anno_var = tk.StringVar(value=self.filtri_cancellazione.get("anno", "‚Äî"))
            mese_var = tk.StringVar(value=self.filtri_cancellazione.get("mese", "‚Äî"))
            da_var = tk.StringVar(value=self.filtri_cancellazione.get("da", ""))
            a_var = tk.StringVar(value=self.filtri_cancellazione.get("a", ""))
            icona_var = tk.StringVar(value=self.filtri_cancellazione.get("icona", "‚Äî"))
            def crea_riga(testo, var, values=None):
                f = tk.Frame(filtro_win, bg=self.COLOR_TOPLEVEL); f.pack(fill="x", padx=12, pady=5)
                tk.Label(f, text=testo, fg=self.TEXT_COLOR, bg=self.COLOR_TOPLEVEL, width=16, anchor="w").pack(side="left") 
                if values:
                    ttk.Combobox(f, textvariable=var, values=values, style="Border.TCombobox", state="readonly", width=20).pack(side="left")
                else:
                    ttk.Entry(f, textvariable=var, width=22).pack(side="left")
            tutte_cat = ["‚Äî"] + sorted(list(self.categorie_tipi.keys()))
            anni = ["‚Äî"]
            for giorno_obj in self.spese.keys():
                try:
                    d = giorno_obj if isinstance(giorno_obj, datetime.date) else datetime.datetime.strptime(str(giorno_obj), "%Y-%m-%d").date()
                    anni.append(str(d.year))
                except Exception: continue
            anni = sorted(list(set(anni)), reverse=True)
            nomi_mesi_dropdown = ["‚Äî"] + NOMI_MESI_ITALIANO
            crea_riga("Testo Globale:", descrizione_var)
            crea_riga("Categoria:", categoria_var, tutte_cat)
            crea_riga("Tipo voce:", tipo_var, ["‚Äî", "Entrata", "Uscita"]) 
            crea_riga("Anno:", anno_var, anni)
            crea_riga("Mese:", mese_var, nomi_mesi_dropdown)
            crea_riga("Simbolo:", icona_var, ["‚Äî", "üí∞", "üîÑ", "üè¶", "üíé", "üí≥"])
            crea_riga("Importo da (‚Ç¨):", da_var)
            crea_riga("Importo a (‚Ç¨):", a_var)
            def applica():
                self.filtri_cancellazione = {
                    "descrizione": descrizione_var.get(),
                    "categoria": categoria_var.get(),
                    "tipo": tipo_var.get(),
                    "anno": anno_var.get(),
                    "mese": mese_var.get(), 
                    "da": da_var.get(),
                    "a": a_var.get(),
                    "icona": icona_var.get()
                }
                filtro_win.destroy()
                self.selezionate_iid.clear() 
                aggiorna_stato_filtri()
                popola_treeview_spese()
            def cancella_filtri():
                self.filtri_cancellazione = {}
                filtro_win.destroy()
                self.selezionate_iid.clear() 
                aggiorna_stato_filtri()
                popola_treeview_spese()
            f_btn = tk.Frame(filtro_win, bg=self.COLOR_TOPLEVEL); f_btn.pack(pady=10)
            ttk.Button(f_btn, text="‚úÖ Applica Filtri", command=applica, style="Verde.TButton").pack(side="left", padx=10)
            ttk.Button(f_btn, text="üéõ Cancella Filtri", command=cancella_filtri, style="Giallo.TButton").pack(side="right", padx=10)
        def seleziona_tutto_azione():
            all_children = self.spese_treeview.get_children()
            self.selezionate_iid.clear()
            items_to_select = []
            for iid in all_children:
                if iid in ("EMPTY_MSG", "FILTER_MSG", "NO_DATA"):
                    continue
                self.selezionate_iid.add(iid)
                items_to_select.append(iid)
            popola_treeview_spese()
        popup = tk.Toplevel(self.master, bg=self.COLOR_TOPLEVEL)
        popup.title("üóëÔ∏è Cancella Movimenti Multipli")
        larg, alt = 800, 600
        x = self.winfo_x() + (self.winfo_width() // 2) - (larg // 2)
        y = self.winfo_y() + (self.winfo_height() // 2) - (alt // 2)
        popup.geometry(f"{larg}x{alt}+{x}+{y}")
        popup.transient(self.master) 
        tk.Label(popup, text="Seleziona Movimenti da cancellare:", bg=self.COLOR_TOPLEVEL, fg=self.TEXT_COLOR, font=("Arial", 12, "bold")).pack(pady=(10, 5))
        filter_control_frame = tk.Frame(popup, bg=self.COLOR_TOPLEVEL)
        filter_control_frame.pack(fill='x', padx=10, pady=5)
        lbl_filtri_attivi = tk.Label(filter_control_frame, bg=self.COLOR_TOPLEVEL, text="", fg="gray")
        lbl_filtri_attivi.pack(side="left", fill='x', expand=True)
        ttk.Button(
            filter_control_frame,
            text="‚öôÔ∏è Filtri Avanzati",
            command=apri_filtri_avanzati, 
            style='Blu.TButton' 
        ).pack(side="right")
        tree_frame = tk.Frame(popup)
        tree_frame.pack(fill='both', expand=True, padx=10, pady=5) 
        scrollbar = ttk.Scrollbar(tree_frame, orient="vertical")
        scrollbar.pack(side="right", fill="y")
        self.spese_treeview = ttk.Treeview(
            tree_frame,
            columns=("Giorno", "Categoria", "Descrizione", "Tipo", "Importo"), 
            show=("tree", "headings"), 
            yscrollcommand=scrollbar.set,
            height=15
        )
        self.spese_treeview.pack(side="left", fill="both", expand=True) 
        scrollbar.config(command=self.spese_treeview.yview)
        self.spese_treeview.heading("#0", text="Sel.", anchor="center") 
        self.spese_treeview.heading("Giorno", text="Giorno", anchor="center", 
                                    command=lambda: sort_treeview_column(self.spese_treeview, "Giorno", True, data_type='date')) 
        self.spese_treeview.heading("Categoria", text="Categoria", anchor="center", 
                                    command=lambda: sort_treeview_column(self.spese_treeview, "Categoria", False, data_type='string'))
        self.spese_treeview.heading("Descrizione", text="Descrizione", anchor="center", 
                                    command=lambda: sort_treeview_column(self.spese_treeview, "Descrizione", False, data_type='string'))
        self.spese_treeview.heading("Tipo", text="Tipo", anchor="center", 
                                    command=lambda: sort_treeview_column(self.spese_treeview, "Tipo", False, data_type='string'))
        self.spese_treeview.heading("Importo", text="Importo", anchor="center", 
                                    command=lambda: sort_treeview_column(self.spese_treeview, "Importo", False, data_type='float'))
        self.spese_treeview.column("#0", width=40, anchor="center", stretch=False) 
        self.spese_treeview.column("Giorno", width=90, anchor="w", stretch=False)
        self.spese_treeview.column("Categoria", width=150, anchor="w", stretch=False)
        self.spese_treeview.column("Descrizione", width=200, anchor="w", stretch=True)
        self.spese_treeview.column("Tipo", width=60, anchor="center", stretch=False) 
        self.spese_treeview.column("Importo", width=100, anchor="e", stretch=False)
        self.spese_treeview.tag_configure('selezionata', background='#FFEBCC') 
        self.spese_treeview.tag_configure('entrata', foreground='green')
        self.spese_treeview.tag_configure('uscita', foreground='red') 
        self.spese_treeview.tag_configure('empty', foreground='gray', font=('Arial', 10, 'italic')) 
        self.spese_treeview.bind('<Button-1>', toggle_selection_treeview)
        btn_frame = tk.Frame(popup, bg=self.COLOR_TOPLEVEL)
        btn_frame.pack(pady=10) 
        ttk.Button(
            btn_frame,
            text="üóëÔ∏è Cancella Selezionate",
            command=esegui_cancellazione_azione,
            style='Rosso.TButton' 
        ).pack(side="left", padx=5)
        ttk.Button(
            btn_frame, 
            text="‚úÖ Seleziona Tutto", 
            command=seleziona_tutto_azione, 
            style='Verde.TButton'
        ).pack(side="left", padx=5)
        ttk.Button(
            btn_frame,
            text="üîÑ Deseleziona Tutto",
            command=lambda: [self.selezionate_iid.clear(), popola_treeview_spese()], 
            style='Giallo.TButton' 
        ).pack(side="left", padx=5)
        ttk.Button(
            btn_frame,
            text="‚ùå Chiudi",
            command=popup.destroy,
            style='Giallo.TButton' 
        ).pack(side="left", padx=5)
        aggiorna_stato_filtri() 
        popola_treeview_spese()
        sort_treeview_column(self.spese_treeview, "Giorno", True, data_type='date') 
        popup.grab_set()
    
    # Strumento di Ricerca Avanzata, Filtraggio ed Esportazione Transazioni
    def cerca_operazioni(self):
        larghezza, altezza = 900, 600
        x = self.winfo_screenwidth() // 2 - larghezza // 2
        y = self.winfo_screenheight() // 2 - altezza // 2
        finestra = tk.Toplevel(self, bg=self.COLOR_TOPLEVEL)
        finestra.title("Ricerca operazioni")
        finestra.geometry(f"{larghezza}x{altezza}+{x}+{y}")
        finestra.transient(self)
        finestra.bind("<Escape>", lambda e: finestra.destroy())
        frame_superiore = tk.Frame(finestra, bg=self.COLOR_TOPLEVEL )
        frame_superiore.pack(fill="x", pady=10, padx=10)
        tk.Label(frame_superiore, bg=self.COLOR_TOPLEVEL, fg=self.TEXT_COLOR, text="üîé Ricerca generale:").pack(side="left")
        campo_input = ttk.Entry(frame_superiore, width=30)
        campo_input.pack(side="left", padx=8)
        campo_input.focus_set()
        mostra_futuro_var = tk.BooleanVar(value=True)
        ttk.Checkbutton(frame_superiore, text="Includi futuri", variable=mostra_futuro_var).pack(side="left", padx=10)
        frame_risultati = tk.Frame(finestra)
        frame_risultati.pack(fill="both", expand=True, padx=10)
        columns = ("Data", "Categoria", "Descrizione", "Tipo", "Importo")
        tree = ttk.Treeview(frame_risultati, columns=columns, show="headings")
        tree.pack(side="left", fill="both", expand=True)
        tree.bind("<Double-1>", self.cerca_doppio_click)
        def converti_importo(s):
            s = str(s).strip()
            s = s.replace('‚Ç¨', '').strip()
            s = s.replace(',', '')
            if s.count(',') == 1 and s.count('.') != 1:
                s = s.replace(',', '.')
            try:
                return float(s)
            except ValueError:
                return float('-inf')
        def converti_data(s):
            try:
                return datetime.datetime.strptime(str(s), '%d/%m/%Y')
            except ValueError:
                return datetime.datetime.min
        def formatta_italiano(numero):
            s = "{:,.2f}".format(numero).replace('.', '#').replace(',', '.').replace('#', ',')
            return s
        def sort_by_column(tv, col, reverse):
            cols = list(tv["columns"])
            try:
                col_index = cols.index(col)
            except ValueError:
                return
            l = []
            for k in tv.get_children(''):
                item_values = tv.item(k, 'values')
                if item_values and len(item_values) > col_index:
                    if col == "Importo":
                        sort_value = converti_importo(item_values[col_index])
                    elif col == "Data":
                        sort_value = converti_data(item_values[col_index])
                    else:
                        sort_value = item_values[col_index]
                    l.append((sort_value, k))
                else:
                    l.append(('', k))
            l.sort(key=lambda t: t[0], reverse=reverse)
            for index, (val, k) in enumerate(l):
                tv.move(k, '', index)
            tv.heading(col, command=lambda: sort_by_column(tv, col, not reverse))
        for col in columns:
            tree.heading(col, text=col, command=lambda c=col: sort_by_column(tree, c, False))
            if col == "Importo":
                tree.column(col, anchor="e")
            else:
                tree.column(col, anchor="w")
        tree.column("Data", width=90, stretch=False)
        tree.column("Categoria", width=120, stretch=False)
        tree.column("Descrizione", width=300, stretch=True)
        tree.column("Tipo", width=80, stretch=False)
        tree.column("Importo", width=100, stretch=False)
        scroll = ttk.Scrollbar(frame_risultati, orient="vertical", command=tree.yview)
        tree.configure(yscrollcommand=scroll.set)
        scroll.pack(side="right", fill="y")
        tree.tag_configure("entrata_tag", foreground="green")
        tree.tag_configure("uscita_tag", foreground="red")
        tree.tag_configure("neutro_tag", foreground="gray")
        frame_totali = tk.Frame(finestra)
        frame_totali.pack(fill="x", pady=10, padx=10)
        lbl_risultati = tk.Label(frame_totali, text="", anchor="w", font=("Arial", 10))
        lbl_risultati.pack(fill="x")
        lbl_totali = tk.Label(frame_totali, text="", anchor="w", font=("Arial", 10, "bold"))
        lbl_totali.pack(fill="x")
        def esegui_ricerca(event=None):
            parola = campo_input.get().strip().lower()
            filtri = getattr(self, "filtri_avanzati", {})
            if parola:
                filtri = {}
            for item in tree.get_children():
                tree.delete(item)
            risultati = []
            oggi = datetime.date.today()
            mostra_futuro = mostra_futuro_var.get()
            for data_key in sorted(self.spese.keys(), reverse=True):
                try:
                    d = data_key if isinstance(data_key, datetime.date) else datetime.datetime.strptime(data_key, "%d-%m-%Y").date()
                except ValueError:
                    d = datetime.datetime.strptime(data_key, "%Y-%m-%d").date()
                if not mostra_futuro and d > oggi:
                    continue
                for voce in self.spese[data_key]:
                    categoria = str(voce[0]).lower()
                    descrizione = str(voce[1]).lower()
                    importo_voce = voce[2]
                    tipo = str(voce[3]).lower()
                    matches = True
                    if parola:
                        if not any(parola in str(campo).lower() for campo in [categoria, descrizione, tipo, str(importo_voce)]):
                            matches = False
                    elif filtri:
                        if filtri.get("descrizione") and filtri["descrizione"].lower() not in descrizione:
                            matches = False
                        if filtri.get("categoria") not in ["", "‚Äî"] and categoria != filtri["categoria"].lower():
                            matches = False
                        if filtri.get("tipo") not in ["", "‚Äî"] and tipo != filtri["tipo"].lower():
                            matches = False
                        if filtri.get("icona") not in ["", "‚Äî"]:
                            icona = filtri["icona"]
                            if icona not in descrizione:
                                matches = False
                        if filtri.get("anno") not in ["", "‚Äî"] and str(d.year) != filtri["anno"]:
                            matches = False
                        if filtri.get("mese") not in ["", "‚Äî"]:
                            mesi_nomi = ["Gennaio", "Febbraio", "Marzo", "Aprile", "Maggio", "Giugno",
                                         "Luglio", "Agosto", "Settembre", "Ottobre", "Novembre", "Dicembre"]
                            mesi_map = {m: i+1 for i, m in enumerate(mesi_nomi)}
                            if d.month != mesi_map.get(filtri["mese"], 0):
                                matches = False
                        try:
                            da_val = converti_importo(filtri.get("da", "0")) 
                            a_val = converti_importo(filtri.get("a", "999999999"))
                            da = da_val if da_val != float('-inf') else 0.0
                            a = a_val if a_val != float('-inf') else 999999999.0
                            if not (da <= float(importo_voce) <= a):
                                matches = False
                        except (ValueError, TypeError):
                            pass
                    if matches:
                        risultati.append({
                            "data": d.strftime('%d/%m/%Y'),
                            "categoria": voce[0],
                            "descrizione": voce[1],
                            "importo": importo_voce,
                            "tipo": tipo.capitalize()
                        })
            risultati.sort(key=lambda x: datetime.datetime.strptime(x['data'], '%d/%m/%Y'), reverse=True)
            tot_entrate = sum(r['importo'] for r in risultati if r['tipo'] == "Entrata")
            tot_uscite = sum(r['importo'] for r in risultati if r['tipo'] == "Uscita")
            testo_filtri = ""
            if parola:
                testo_filtri = f"Parola chiave: '{parola}'"
            elif filtri:
                testo_filtri = ", ".join([f"{k.capitalize()}: {v}" for k, v in filtri.items() if v not in ["", "‚Äî"]])
            lbl_risultati.config(text=f"üìä Operazioni trovate: {len(risultati)} | Filtri attivi: {testo_filtri or 'Nessuno'}")
            netto = tot_entrate - tot_uscite
            tot_entrate_fmt = formatta_italiano(tot_entrate)
            tot_uscite_fmt = formatta_italiano(tot_uscite)
            netto_fmt = formatta_italiano(netto)
            lbl_totali.config(text=f"‚úÖ Entrate: {tot_entrate_fmt} ‚Ç¨ | ‚ùå Uscite: {tot_uscite_fmt} ‚Ç¨ | üßÆ Saldo: {netto_fmt} ‚Ç¨")
            if not risultati:
                lbl_risultati.config(
                    text=f"üîç Nessuna corrispondenza per la ricerca attuale.", 
                    fg="gray", 
                    bg=self.COLOR_TOPLEVEL
                )
                lbl_totali.config(text="", fg="gray", bg=self.COLOR_TOPLEVEL)
            else:
                lbl_risultati.config(
                    fg=self.TEXT_COLOR,
                    bg=self.COLOR_TOPLEVEL
                )
                lbl_totali.config(
                    fg=self.TEXT_COLOR,     
                    bg=self.COLOR_TOPLEVEL
                )
                for riga in risultati:
                    tipo = riga['tipo'].lower()
                    tag = "entrata_tag" if tipo == "entrata" else "uscita_tag" if tipo == "uscita" else "neutro_tag"
                    tree.insert("", "end", values=(riga['data'], riga['categoria'], riga['descrizione'], riga['tipo'], f"{riga['importo']:,.2f} ‚Ç¨"), tags=(tag,))
            campo_input.bind("<KeyRelease>", esegui_ricerca)
        def resetta_campo():
            campo_input.delete(0, tk.END)
            self.filtri_avanzati = {}
            for item in tree.get_children():
                tree.delete(item)
            lbl_risultati.config(text="üîç Nessuna corrispondenza per la ricerca attuale.", fg="gray")
            lbl_totali.config(text="")
            self.after(100, esegui_ricerca)
        ttk.Button(frame_superiore, text="‚Ü∫", command=resetta_campo, style="Yellow.TButton").pack(side="left", padx=5)
        def apri_filtri_avanzati():
            self.filtri_avanzati = getattr(self, "filtri_avanzati", {})
            parola_chiave = campo_input.get().strip()
            campo_input.delete(0, tk.END)
            if parola_chiave:
                self.filtri_avanzati = {} 
            filtro_win = tk.Toplevel(finestra, bg=self.COLOR_TOPLEVEL)
            filtro_win.title("‚öôÔ∏è Filtri avanzati")
            larghezza_finestra = 400
            altezza_finestra = 350
            x = finestra.winfo_rootx() + (finestra.winfo_width() // 2) - (larghezza_finestra // 2)
            y = finestra.winfo_rooty() + (finestra.winfo_height() // 2) - (altezza_finestra // 2)
            filtro_win.geometry(f"{larghezza_finestra}x{altezza_finestra}+{x}+{y}")
            filtro_win.transient(finestra)
            filtro_win.grab_set()
            filtro_win.bind("<Escape>", lambda e: filtro_win.destroy())
            descrizione_var = tk.StringVar(value=self.filtri_avanzati.get("descrizione", ""))
            categoria_var = tk.StringVar(value=self.filtri_avanzati.get("categoria", "‚Äî"))
            tipo_var = tk.StringVar(value=self.filtri_avanzati.get("tipo", "‚Äî"))
            anno_var = tk.StringVar(value=self.filtri_avanzati.get("anno", "‚Äî"))
            mese_var = tk.StringVar(value=self.filtri_avanzati.get("mese", "‚Äî"))
            da_var = tk.StringVar(value=self.filtri_avanzati.get("da", ""))
            a_var = tk.StringVar(value=self.filtri_avanzati.get("a", ""))
            icona_var = tk.StringVar(value=self.filtri_avanzati.get("icona", "‚Äî"))
            def crea_riga(testo, var, values=None):
                f = tk.Frame(filtro_win, bg=self.COLOR_TOPLEVEL); f.pack(fill="x", padx=12, pady=5)
                tk.Label(f, text=testo, fg=self.TEXT_COLOR, bg=self.COLOR_TOPLEVEL, width=14, anchor="w").pack(side="left")
                if values:
                    ttk.Combobox(f, textvariable=var, values=values, style="Border.TCombobox", state="readonly", width=22).pack(side="left")
                else:
                    ttk.Entry(f, textvariable=var, width=24).pack(side="left")
            tutte_cat = sorted(list(self.categorie_tipi.keys()))
            anni = sorted(set(str(d.year if isinstance(d, datetime.date)else datetime.datetime.strptime(d, "%d-%m-%Y").year) for d in self.spese if self.spese), reverse=True)
            mesi_nomi = ["Gennaio", "Febbraio", "Marzo", "Aprile", "Maggio", "Giugno",
                         "Luglio", "Agosto", "Settembre", "Ottobre", "Novembre", "Dicembre"]           
            crea_riga("Descrizione:", descrizione_var)
            crea_riga("Categoria:", categoria_var, ["‚Äî"] + tutte_cat)
            crea_riga("Tipo voce:", tipo_var, ["‚Äî", "Entrata", "Uscita"])
            crea_riga("Anno:", anno_var, ["‚Äî"] + anni)
            crea_riga("Mese:", mese_var, ["‚Äî"] + mesi_nomi)
            icone_simboli = ["‚Äî", "üí∞", "üîÑ", "üè¶", "üíé", "üí≥"]
            crea_riga("Simbolo:", icona_var, icone_simboli)
            crea_riga("Importo da:", da_var)
            crea_riga("Importo a:", a_var)
            def applica():
                self.filtri_avanzati = {
                    "descrizione": descrizione_var.get(),
                    "categoria": categoria_var.get(),
                    "tipo": tipo_var.get(),
                    "anno": anno_var.get(),
                    "mese": mese_var.get(),
                    "da": da_var.get(),
                    "a": a_var.get(),
                    "icona": icona_var.get()
                }
                filtro_win.destroy()
                esegui_ricerca()
            def cancella():
                self.filtri_avanzati = {}
                filtro_win.destroy()
                esegui_ricerca()
            f_btn = tk.Frame(filtro_win, bg=self.COLOR_TOPLEVEL); f_btn.pack(pady=10)
            ttk.Button(f_btn, text="‚úÖ Applica", command=applica, style="Verde.TButton").pack(side="left", padx=10)
            ttk.Button(f_btn, text="üéõ Cancella filtri", command=cancella, style="Giallo.TButton").pack(side="right", padx=10)
        def esporta_risultato():
            dati_tree = []
            tot_entrate = 0.0
            tot_uscite = 0.0
            for item in tree.get_children():
                values = tree.item(item, "values")
                if values:
                    data, cat, desc, tipo, importo_str = values
                    importo_float = converti_importo(importo_str) 
                    dati_tree.append((data, cat, desc, tipo, importo_float))
                    if tipo == "Entrata":
                        tot_entrate += importo_float
                    elif tipo == "Uscita":
                        tot_uscite += importo_float
            if not dati_tree:
                self.show_custom_warning("Esportazione", "‚ö†Ô∏è Nessun risultato trovato da salvare o stampare.")
                return
            W_DATA, W_CAT, W_DESC, W_TIPO, W_IMP = 10, 20, 28, 8, 15 
            header = f"{'Data':<{W_DATA}} | {'Categoria':<{W_CAT}} | {'Descrizione':<{W_DESC}} | {'Tipo':<{W_TIPO}} | {'Importo (‚Ç¨)':>{W_IMP}}\n"
            separator = f"{'-'*W_DATA}-+-{'-'*W_CAT}-+-{'-'*W_DESC}-+-{'-'*W_TIPO}-+-{'-'*W_IMP}\n"
            testo_filtri_attivi = lbl_risultati.cget("text").split("| Filtri attivi:")[1].strip()
            contenuto_preview = f"--- RISULTATI RICERCA ({datetime.date.today():%d/%m/%Y}) ---\n"
            contenuto_preview += f"Filtri: {testo_filtri_attivi}\n"
            contenuto_preview += f"Operazioni Trovate: {len(dati_tree)}\n\n"
            contenuto_preview += f"--- RIEPILOGO FINANZIARIO ---\n"
            tot_entrate_fmt = formatta_italiano(tot_entrate)
            tot_uscite_fmt = formatta_italiano(tot_uscite)
            netto_fmt = formatta_italiano(tot_entrate - tot_uscite)
            contenuto_preview += f"Entrate Totali: {tot_entrate_fmt} ‚Ç¨\n"
            contenuto_preview += f"Uscite Totali:¬† {tot_uscite_fmt} ‚Ç¨\n"
            contenuto_preview += f"Saldo Netto:¬† ¬† {netto_fmt} ‚Ç¨\n\n"
            contenuto_preview += "--- DETTAGLIO OPERAZIONI ---\n"
            contenuto_preview += header + separator
            for data, cat, desc, tipo, importo_float in dati_tree:
                imp_display = formatta_italiano(importo_float)
                desc_troncata = (desc[:W_DESC-3] + '...') if len(desc) > W_DESC else desc
                cat_troncata = (cat[:W_CAT-3] + '...') if len(cat) > W_CAT else cat
                contenuto_preview += f"{data:<{W_DATA}} | {cat_troncata:<{W_CAT}} | {desc_troncata:<{W_DESC}} | {tipo:<{W_TIPO}} | {imp_display:>{W_IMP}}\n"
            contenuto_preview += "\n" + separator
            def _salva_su_file(content_text, default_name, preview_popup):
                preview_popup.destroy()
                nome_file = f"Risultati_Ricerca_{datetime.date.today():%d_%m_%Y}.txt"
                file = filedialog.asksaveasfilename(
                    defaultextension=".txt", 
                    filetypes=[("File di testo", "*.txt")],
                    initialdir=EXPORT_FILES,
                    initialfile=nome_file,
                    title="Salva risultati ricerca",
                    confirmoverwrite=False,
                    parent=finestra
                )
                if file:
                    if os.path.exists(file):
                        conferma = self.show_custom_askyesno(
                            "Sovrascrivere file?",
                            f"Il file '{os.path.basename(file)}' \nesiste gi√†. Vuoi sovrascriverlo?"
                        )
                        if not conferma:
                            return
                    try:
                        with open(file, "w", encoding="utf-8") as f:
                            f.write(content_text) 
                        self.show_custom_warning("Esportazione completata", f"‚úÖ Risultati salvati:\n{file}")
                    except Exception as e:
                        self.show_custom_warning("Errore", f"‚ùå Salvataggio fallito:\n{e}")
            preview_popup = tk.Toplevel(finestra, bg=self.COLOR_TOPLEVEL)
            preview_popup.title("üìÑ Anteprima Risultati Ricerca")
            WIDTH = 800
            HEIGHT = 500
            screen_width = preview_popup.winfo_screenwidth()
            screen_height = preview_popup.winfo_screenheight()
            x = (screen_width - WIDTH) // 2
            y = (screen_height - HEIGHT) // 2
            preview_popup.geometry(f"{WIDTH}x{HEIGHT}+{x}+{y}")
            preview_popup.transient(finestra)
            preview_popup.grab_set()
            preview_popup.bind('<Escape>', lambda e: preview_popup.destroy())
            text_area = tk.Text(preview_popup, wrap='word', font=('Courier', 10), padx=10, pady=10)
            text_area.insert('1.0', contenuto_preview) 
            text_area.config(state='disabled')
            text_area.pack(fill='both', expand=True, padx=10, pady=10)
            frame_btn = tk.Frame(preview_popup, bg=self.COLOR_TOPLEVEL)
            frame_btn.pack(pady=(0, 10))
            nome_file_default = f"Risultati_Ricerca_{datetime.date.today():%d_%m_%Y}.txt"           
            ttk.Button(
                frame_btn, 
                text="‚ùå Chiudi Anteprima", 
                command=preview_popup.destroy, 
                style='Giallo.TButton'
            ).pack(side='right', padx=5)
            ttk.Button(
                frame_btn, 
                text="üì§ Esporta", 
                style='Verde.TButton',
                command=lambda: _salva_su_file(contenuto_preview, nome_file_default, preview_popup)
            ).pack(side='left', padx=5)
            if hasattr(self, '_stampa_lista_diretta'):
                ttk.Button(
                    frame_btn, 
                    text="üñ®Ô∏è Stampa", 
                    style='Blu.TButton',
                    command=lambda: self._stampa_lista_diretta(
                        contenuto_preview, 
                        self.show_custom_warning
                    )
                ).pack(side='left', padx=5) 
            preview_popup.wait_window(preview_popup)
        frame_bottoni = tk.Frame(finestra, bg=self.COLOR_TOPLEVEL)
        frame_bottoni.pack(pady=(0, 12))
        ttk.Button(frame_bottoni, text="üîç Cerca", command=esegui_ricerca, style="Verde.TButton").pack(side="left", padx=6)
        ttk.Button(frame_bottoni, text="üìÑ Esporta", command=esporta_risultato, style="Arancio.TButton").pack(side="left", padx=6)
        ttk.Button(frame_bottoni, text="‚öôÔ∏è Filtri avanzati", command=apri_filtri_avanzati, style="Blu.TButton").pack(side="left", padx=6)
        ttk.Button(frame_bottoni, text="‚Ü∫ Reset", command=resetta_campo, style="Giallo.TButton").pack(side="left", padx=6)
        ttk.Button(frame_bottoni, text="‚ùå Chiudi", command=finestra.destroy, style="Giallo.TButton").pack(side="left", padx=6)
        self.after(100, esegui_ricerca)
    def cerca_doppio_click(self, event):
        tree = event.widget
        item_id = tree.focus()
        if not item_id:
            return
        vals = tree.item(item_id, "values")
        if not vals or len(vals) < 1:
            return
        data_str = vals[0]  
        try:
            giorno = datetime.datetime.strptime(data_str, "%d/%m/%Y").date()
        except Exception:
            return
        self.set_stats_mode("giorno")
        if hasattr(self, "cal"):
            self.cal.selection_set(giorno)
            self.cal._sel_date = giorno
            self.stats_refdate = giorno
        self.update_stats()
        self.estratto_month_var.set(f"{giorno.month:02d}")
        self.estratto_year_var.set(str(giorno.year))
        self.stats_label.config(text=f"Riepilogo Giornaliero - {giorno.strftime('%d-%m-%Y')}", foreground="purple",
    font=("Arial", 10, "bold"))

    # Popup Rubrica
    def rubrica_app(self):
        if hasattr(self, '_rubrica_window') and self._rubrica_window and self._rubrica_window.winfo_exists():
            self._rubrica_window.lift()
            return
        root = tk.Toplevel(self) 
        self._rubrica_window = root     
        def on_rubrica_close():
            root.destroy()
            self._rubrica_window = None
        root.protocol("WM_DELETE_WINDOW", on_rubrica_close)
        root.bind("<Escape>", lambda e: on_rubrica_close())
        root.title("Rubrica Contatti")
        window_width, window_height = 1100, 600
        screen_width = root.winfo_screenwidth()
        screen_height = root.winfo_screenheight()
        pos_x = (screen_width - window_width) // 2
        pos_y = (screen_height - window_height) // 2
        root.geometry(f"{window_width}x{window_height}+{pos_x}+{pos_y}")
        root.configure(bg=self.COLOR_TOPLEVEL)
        barra_menu_popup = tk.Menu(root, bg=BACKGROUND_DARK, fg=FOREGROUND_LIGHT, activebackground=ACCENT_COLOR, activeforeground='black')
        barra_menu_popup.config(bg=BACKGROUND_DARK, fg=FOREGROUND_LIGHT)
        root.config(menu=barra_menu_popup)
        menu_db = tk.Menu(barra_menu_popup, tearoff=0,bg=MENU_BG, fg=FOREGROUND_LIGHT, activebackground=ACCENT_COLOR, activeforeground='black')
        barra_menu_popup.add_cascade(label="üíæ Database", menu=menu_db)
        menu_db.add_command(label="üì§ Esporta DataBase", command=lambda: esporta_rubrica())
        menu_db.add_command(label="üì• Importa Database", command=lambda: importa_rubrica())
        menu_db.add_separator()
        menu_db.add_command(label="üì• Importa Rubrica vCard", command=lambda: importa_vcf_rubrica())
        menu_db.add_separator()
        menu_db.add_command(label="üì• Reset DataBase", command=lambda: reset_rubrica())
        menu_db.add_separator()
        menu_db.add_command(label="‚ùå Chiudi", command=lambda: on_rubrica_close())
        contatti = []
        def ordina_contatti():
            contatti.sort(key=lambda c: c["nome"].lower())
        def salva_su_json():
            with open(DATI_FILE, "w", encoding="utf-8") as f:
                json.dump(contatti, f, indent=2, ensure_ascii=False)
        def pulisci_campi():
            entry_nome.delete(0, tk.END)
            entry_telefono.delete(0, tk.END)
            entry_email.delete(0, tk.END)
            entry_note.delete("1.0", tk.END)
            tree_contatti.selection_remove(tree_contatti.selection()) 
        def aggiorna_lista():
            for i in tree_contatti.get_children():
                tree_contatti.delete(i)
            if not contatti:
                tree_contatti.insert("", tk.END, text="0", 
                                     values=("Aggiungi il tuo primo contatto!", "", "", ""), 
                                     tags=('empty',))
            else:
                for i, c in enumerate(contatti):
                    tree_contatti.insert("", tk.END, iid=i, 
                                        values=(c["nome"], c["telefono"], c["email"], c["note"]))
        def carica_da_json():
            if os.path.exists(DATI_FILE):
                with open(DATI_FILE, "r", encoding="utf-8") as f:
                    try:
                        dati = json.load(f)
                        contatti.clear()
                        contatti.extend(dati)
                        ordina_contatti()
                        aggiorna_lista()
                    except:
                        self.show_custom_warning("Attenzione", "File rubrica non valido !")
        def seleziona_contatto(event):
            selected_items = tree_contatti.selection()
            if not selected_items:
                return
            iid = selected_items[0]
            if tree_contatti.tag_has('empty', iid):
                pulisci_campi()
                return
            try:
                indice = int(iid)
                c = contatti[indice] 
            except (ValueError, IndexError):
                pulisci_campi()
                return
            entry_nome.delete(0, tk.END)
            entry_nome.insert(0, c["nome"])
            entry_telefono.delete(0, tk.END)
            entry_telefono.insert(0, c["telefono"])
            entry_email.delete(0, tk.END)
            entry_email.insert(0, c["email"])
            entry_note.delete("1.0", tk.END)
            entry_note.insert("1.0", c["note"])
        def aggiungi_contatto():
            nome = entry_nome.get().strip()
            telefono = entry_telefono.get().strip()
            email = entry_email.get().strip()
            note = entry_note.get("1.0", tk.END).strip()
            if len(nome) > 43 or len(telefono) > 43 or len(email) > 43 or len(note) > 100:
                self._show_custom_message("Limite superato", "Hai superato il limite massimo di caratteri:\n\n"
                                     "- Nome: 43\n- Telefono: 43\n- Email: 43\n- Note:100",
                                     "#fff3cd", "#856404")
                return
            if nome:
                contatti.append({"nome": nome, "telefono": telefono, "email": email, "note": note})
                ordina_contatti()
                salva_su_json()
                aggiorna_lista()
                pulisci_campi()
                self.show_custom_warning("Attenzione", "Contatto aggiunto correttamente !")
        def modifica_contatto():
            selected_items = tree_contatti.selection()
            if not selected_items: 
                self.show_custom_warning("Attenzione", "Seleziona un contatto da modificare.")
                return
            iid = selected_items[0]
            if tree_contatti.tag_has('empty', iid):
                 self.show_custom_warning("Attenzione", "Seleziona un contatto valido da modificare.")
                 return
            try:
                i = int(iid)
            except ValueError:
                self.show_custom_warning("Errore", "Selezione non valida per la modifica.")
                return
            contatti[i] = {
                "nome": entry_nome.get().strip(),
                "telefono": entry_telefono.get().strip(),
                "email": entry_email.get().strip(),
                "note": entry_note.get("1.0", tk.END).strip()
            }
            ordina_contatti()
            salva_su_json()
            pulisci_campi() 
            aggiorna_lista()
            self.show_custom_warning("Attenzione", "Contatto modificato correttamente!")
        def cancella_contatto():
            selected_items = tree_contatti.selection()
            if not selected_items: return
            iid = selected_items[0]
            if tree_contatti.tag_has('empty', iid):
                self.show_custom_warning("Attenzione", "Nessun contatto valido selezionato per la cancellazione.")
                return
            try:
                i = int(iid)
            except ValueError:
                return
            contatti.pop(i) 
            salva_su_json()
            pulisci_campi() 
            aggiorna_lista()
            self.show_custom_warning("Attenzione", "Contatto cancellato con successo !")
        def cerca_contatto(event=None):
            query = entry_cerca.get().lower()
            for i in tree_contatti.get_children():
                tree_contatti.delete(i)
            risultati_trovati = False
            if not query:
                aggiorna_lista()
                return
            for i, c in enumerate(contatti):
                if query in c["nome"].lower() or query in c["telefono"].lower() or query in c["email"].lower():
                    tree_contatti.insert("", tk.END, iid=i, 
                                        values=(c["nome"], c["telefono"], c["email"], c["note"]))
                    risultati_trovati = True
            if not risultati_trovati:
                tree_contatti.insert("", tk.END, tags=('empty',), 
                                     values=("Nessun contatto trovato.", "", "", ""))
            pulisci_campi()
        def reset_rubrica():
            conferma = self.show_custom_askyesno(
            )
            if conferma:
                try:
                    if os.path.exists(DATI_FILE):
                        os.remove(DATI_FILE)
                    contatti.clear()
                    aggiorna_lista()
                    self.show_custom_warning("Reset", "Rubrica resettata con successo. Contatti e file dati eliminati.")
                except Exception as e:
                    self.show_custom_warning("Errore", f"Si √® verificato un errore durante il reset del file:\n{e}")
        def _parse_vcard_content_inner(vcard_content):
            contatti_importati = []
            vcard_blocks = re.findall(r"BEGIN:VCARD.*?END:VCARD", vcard_content, re.DOTALL)
            for block in vcard_blocks:
                nome = ""
                all_telefoni = []
                email_principale = ""
                note = [] 
                for line in block.split('\n'):
                    line = line.strip()
                    if not line:
                        continue
                    if line.startswith(' '):
                        if note:
                            note[-1] += line.strip()
                        continue
                    match_prop = re.match(r"([^:]+):(.*)", line, re.IGNORECASE)
                    if not match_prop:
                        continue
                    prop_data = match_prop.group(1).split(';')
                    prop_name = prop_data[0].upper()
                    prop_value = match_prop.group(2).strip()
                    if prop_name == "FN":
                        nome = prop_value                        
                    elif prop_name == "TEL":
                        number = prop_value.replace('-', ' ').strip()
                        if number:
                             all_telefoni.append(number)
                    elif prop_name == "EMAIL":
                        if not email_principale:
                            email_principale = prop_value.strip()
                        else:
                            note.append(prop_value.strip()) 
                    elif prop_name == "ADR":
                        addr_parts = prop_value.split(';')
                        street = addr_parts[2].strip() if len(addr_parts) > 2 and addr_parts[2] else ""
                        city = addr_parts[3].strip() if len(addr_parts) > 3 and addr_parts[3] else ""
                        region = addr_parts[4].strip() if len(addr_parts) > 4 and addr_parts[4] else ""
                        clean_addr = []
                        if street:
                            clean_addr.append(street)
                        if city:
                            clean_addr.append(city)
                        if region and region != city:
                            clean_addr.append(region)
                        if clean_addr:
                            note.append(', '.join(clean_addr))
                    elif prop_name == "ORG":
                        note.append(prop_value.strip())
                    elif prop_name == "NOTE":
                        note.append(prop_value.strip())
                    elif prop_name in ["URL"]:
                        note.append(f"{prop_name}: {prop_value.strip()}")
                telefono_finale = ', '.join(all_telefoni)
                note_finale = "\n".join(note)
                if nome:
                    contatti_importati.append({
                        "nome": nome,
                        "telefono": telefono_finale, 
                        "email": email_principale,
                        "note": note_finale
                    })
            return contatti_importati
        def importa_vcf_rubrica():
            initial_dir = EXP_DB if 'EXP_DB' in globals() else os.getcwd()
            path = filedialog.askopenfilename(
                defaultextension=".vcf",
                filetypes=[("File VCF", "*.vcf")],
                initialdir=initial_dir,
                title="Importa Rubrica da File .vCard",
                parent=root
            )
            if path:
                try:
                    with open(path, "r", encoding="utf-8") as f:
                        vcf_content = f.read()
                    dati_importati = _parse_vcard_content_inner(vcf_content)
                    if dati_importati:
                        conferma = self.show_custom_askyesno(
                            "Importazione vCard",
                            f"Trovati {len(dati_importati)} contatti.\nVuoi SOSTITUIRE la rubrica esistente con i nuovi contatti (S√¨) o UNIRLI (No)?"
                        )
                        if conferma:
                            contatti.clear()
                            contatti.extend(dati_importati)
                            self.show_custom_warning("Importazione vCard", f"Rubrica SOSTITUITA con {len(dati_importati)} contatti.")
                        else:
                            contatti.extend(dati_importati)
                            self.show_custom_warning("Importazione vCard", f"Aggiunti {len(dati_importati)} contatti alla rubrica esistente.")
                        ordina_contatti()
                        salva_su_json()
                        aggiorna_lista()
                    else:
                        self.show_custom_warning("Attenzione", "Il file vCard non contiene contatti validi.")
                except Exception as e:
                    self.show_custom_warning("Errore di Importazione", f"Impossibile leggere o analizzare il file vCard:\n{e}")
        def esporta_rubrica():
            now = datetime.date.today()
            default_dir = EXP_DB 
            default_filename = f"Rubrica_Export_{now.day:02d}-{now.month:02d}-{now.year}.json"
            if not contatti:
                self.show_custom_warning("Attenzione", "Nessun contatto, la rubrica e' vuota !")
                return
            path = filedialog.asksaveasfilename(
                defaultextension=".json",
                filetypes=[("File JSON", "*.json")],
                initialdir=default_dir,
                initialfile=default_filename,
                title="Salva Rubrica .json",
                confirmoverwrite=False,
                parent=root
            )
            if path:
                try:
                    with open(path, "w", encoding="utf-8") as f:
                        json.dump(contatti, f, indent=2, ensure_ascii=False)
                    self.show_custom_warning("Attenzione", f"Rubrica salvata con successo in {path}")
                except Exception as e:
                    self.show_custom_warning("Attenzione", f"Impossibile salvare la rubrica:\n{e}")
        def importa_rubrica():
            path = filedialog.askopenfilename(
                defaultextension=".json",
                filetypes=[("File JSON", "*.json")],
                initialdir=EXP_DB,
                parent=root
            )
            if path:
                try:
                    with open(path, "r", encoding="utf-8") as f:
                        dati_importati = json.load(f)
                        if isinstance(dati_importati, list):
                            contatti.clear()
                            contatti.extend(dati_importati)
                            ordina_contatti()
                            aggiorna_lista()
                            self.show_custom_warning("Importazione riuscita", "Rubrica importata correttamente!")
                        else:
                            self.show_custom_warning("Errore", "Il file selezionato non contiene una rubrica valida (non √® un elenco).")
                except json.JSONDecodeError:
                    self.show_custom_warning("Errore", "Il file non √® un JSON valido.")
                except Exception as e:
                    self.show_custom_warning("Errore", f"Impossibile importare la rubrica:\n{e}")
        def esporta_txt():
            if not contatti:
                self.show_custom_warning("Attenzione", "Nessun Contatto. Rubrica vuota. L'anteprima non pu√≤ essere aperta.")
                return
            contenuto_txt = []
            for c in contatti:
                linea1 = f"Nome: {c['nome']}  Telefono: {c['telefono']}"
                linea2 = f"Email: {c['email']}"
                linea3 = f"Note: {c['note']}"
                contenuto_txt.append(linea1)
                if c['email']:
                    contenuto_txt.append(linea2)
                if c['note']:
                    contenuto_txt.append(linea3)
                contenuto_txt.append("-" * 70)
            contenuto = "\n".join(contenuto_txt).strip()
            if not contenuto:
                self.show_custom_warning("Esporta", "Contenuto rubrica generato vuoto. Nulla da esportare.")
                return
            try:
                preview = tk.Toplevel(root, bg=self.COLOR_TOPLEVEL) 
                preview.title("Preview Esportazione Rubrica")
                larghezza_finestra = 800
                altezza_finestra = 600
                x = root.winfo_rootx() + (root.winfo_width() // 2) - (larghezza_finestra // 2)
                y = root.winfo_rooty() + (root.winfo_height() // 2) - (altezza_finestra // 2)
                preview.geometry(f"{larghezza_finestra}x{altezza_finestra}+{x}+{y}")
                preview.transient(root)
                preview.grab_set()
                preview.focus_set()
                preview.bind("<Escape>", lambda e: preview.destroy())
                text_frame = tk.Frame(preview)
                text_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=(10, 5))
                vsb = ttk.Scrollbar(text_frame, orient="vertical")
                vsb.pack(side=tk.RIGHT, fill=tk.Y)
                tx = tk.Text(text_frame, font=("Courier new", 10), wrap="none", yscrollcommand=vsb.set)
                tx.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
                vsb.config(command=tx.yview)
                tx.insert(tk.END, contenuto)
                tx.config(state="disabled")
                frm = tk.Frame(preview, bg=self.COLOR_TOPLEVEL)
                frm.pack(fill=tk.X, padx=10, pady=8)
                def do_save():
                    now = datetime.date.today()
                    default_filename = f"Rubrica_Export_{now.day:02d}-{now.month:02d}-{now.year}.txt"
                    file = filedialog.asksaveasfilename(
                        defaultextension=".txt",
                        filetypes=[("File txt", "*.txt")],
                        initialdir=EXPORT_FILES,
                        title="Esporta Rubrica",
                        initialfile=default_filename,
                        confirmoverwrite=False,
                        parent=preview)
                    if file:
                        if os.path.exists(file):
                            conferma = self.show_custom_askyesno(
                                "Sovrascrivere file?",
                                f"Il file '{os.path.basename(file)}' \nesiste gi√†. Vuoi sovrascriverlo?"
                            )
                            if not conferma:
                                return  
                        with open(file, "w", encoding="utf-8") as f:
                            f.write(contenuto) 
                            self.show_custom_warning("Esporta", f"Rubrica esportata in {file}")
                        preview.destroy() 
                ttk.Button(frm, text="üíæ Salva", command=do_save, style="Verde.TButton").pack(side=tk.LEFT, padx=6)
                ttk.Button(frm, text="üñ®Ô∏è Stampa", style="Blu.TButton", 
                           command=lambda: self._stampa_lista_diretta(
                               contenuto, self.show_custom_warning)
                           ).pack(side=tk.LEFT, padx=6)
                ttk.Button(frm, text="‚ùå Chiudi", command=preview.destroy, style="Giallo.TButton").pack(side=tk.RIGHT, padx=6)
                preview.lift()
                preview.attributes('-topmost', True)
                preview.after(100, lambda: preview.attributes('-topmost', False))
            except Exception as e:
                self.show_custom_warning("Errore Apertura", f"Errore nell'apertura dell'anteprima: {e}")
        frame_input = ttk.Frame(root) 
        frame_input.pack(padx=10, pady=10, fill=tk.X)
        ttk.Label(frame_input, text="Nome:").grid(row=0, column=0, sticky="e")
        entry_nome = ttk.Entry(frame_input, width=45)
        entry_nome.grid(row=0, column=1, padx=5, pady=2)
        ttk.Label(frame_input, text="Telefono:").grid(row=1, column=0, sticky="e")
        entry_telefono = ttk.Entry(frame_input, width=45)
        entry_telefono.grid(row=1, column=1, padx=5, pady=2)
        ttk.Label(frame_input, text="Email:").grid(row=2, column=0, sticky="e")
        entry_email = ttk.Entry(frame_input, width=45)
        entry_email.grid(row=2, column=1, padx=5, pady=2)
        ttk.Label(frame_input, text="Note:").grid(row=3, column=0, sticky="ne")
        entry_note_frame = ttk.Frame(frame_input, padding=1)
        entry_note_frame.grid(row=3, column=1, padx=5, pady=2, sticky="ew")
        entry_note = tk.Text(
            entry_note_frame, 
            width=45, 
            height=5, 
            relief=tk.FLAT,
            borderwidth=0,
            bg=self.COLOR_WIDGET_BG,
            fg=self.TEXT_COLOR, 
            insertbackground=self.TEXT_COLOR,
            padx=5, pady=5
        )
        entry_note.pack(fill=tk.BOTH, expand=True)
        frame_cerca = ttk.Frame(root) 
        frame_cerca.pack(padx=10, pady=(5, 10), fill=tk.X)
        ttk.Label(frame_cerca, text="        Cerca:    ").pack(side=tk.LEFT)
        entry_cerca = ttk.Entry(frame_cerca, width=30)
        entry_cerca.pack(side=tk.LEFT, padx=5)
        entry_cerca.bind("<Return>", cerca_contatto)
        entry_cerca.bind("<KP_Enter>", cerca_contatto)
        tree_frame = ttk.Frame(root)
        tree_frame.pack(padx=10, pady=10, fill=tk.BOTH, expand=True)
        vsb = ttk.Scrollbar(tree_frame, orient="vertical")
        vsb.pack(side=tk.RIGHT, fill=tk.Y)
        tree_contatti = ttk.Treeview(
            tree_frame, 
            columns=("Nome", "Telefono", "Email", "Note"), 
            show="headings", 
            yscrollcommand=vsb.set
        )
        tree_contatti.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        vsb.config(command=tree_contatti.yview)
        tree_contatti.heading("Nome", text="Nome")
        tree_contatti.heading("Telefono", text="Telefono")
        tree_contatti.heading("Email", text="Email")
        tree_contatti.heading("Note", text="Note")
        tree_contatti.column("Nome", width=180, anchor=tk.W)
        tree_contatti.column("Telefono", width=150, anchor=tk.W)
        tree_contatti.column("Email", width=220, anchor=tk.W)
        tree_contatti.column("Note", width=250, anchor=tk.W)
        tree_contatti.bind("<<TreeviewSelect>>", seleziona_contatto)
        frame_btn = ttk.Frame(root) 
        frame_btn.pack(pady=10)
        ttk.Button(frame_btn, text="üë§ Aggiungi", command=aggiungi_contatto, style="Verde.TButton").pack(side=tk.LEFT, padx=4)
        ttk.Button(frame_btn, text="üîÑ Modifica", command=modifica_contatto, style="Arancio.TButton").pack(side=tk.LEFT, padx=4)
        ttk.Button(frame_btn, text="‚ùå Cancella", command=cancella_contatto, style="Rosso.TButton").pack(side=tk.LEFT, padx=4)
        ttk.Button(frame_btn, text="‚ÑπÔ∏è Esporta/Stampa", command=esporta_txt, style="Verde.TButton").pack(side=tk.LEFT, padx=4)
        ttk.Button(frame_btn, text="‚ùå Chiudi", command=root.destroy, style="Giallo.TButton").pack(side=tk.LEFT, padx=4)
        carica_da_json()        
        root.mainloop()

    # Gestore Popup Calendario Selettore Data
    def mostra_calendario_popup(self, entry_widget, var_data):
        if hasattr(self, "popup_calendario") and self.popup_calendario and self.popup_calendario.winfo_exists():
            self.popup_calendario.destroy()
            self.popup_calendario = None
            self.unbind_all('<Button-1>')
            return
        entry_widget.update_idletasks()
        x_entry = entry_widget.winfo_rootx()
        y_entry = entry_widget.winfo_rooty()
        w_entry = entry_widget.winfo_width()
        h_entry = entry_widget.winfo_height()
        POPUP_WIDTH = 270
        POPUP_HEIGHT = 240
        screen_height = self.winfo_screenheight()
        y_sopra = y_entry - POPUP_HEIGHT
        y_sotto = y_entry + h_entry
        if y_sotto + POPUP_HEIGHT > screen_height and y_sopra > 0:
             final_y = y_sopra
        else:
             final_y = y_sotto
        self.popup_calendario = tk.Toplevel(self)
        self.popup_calendario.withdraw() 
        self.popup_calendario.title("Seleziona Data")
        self.popup_calendario.overrideredirect(True) 
        self.popup_calendario.geometry(f"{POPUP_WIDTH}x{POPUP_HEIGHT}+{x_entry}+{final_y}")
        self.popup_calendario.configure(bg=self.cal_bg)
        cal = Calendar(
            self.popup_calendario,
            selectmode='day',
            locale="it_IT",
            date_pattern="dd-mm-yyyy",
            font=("Arial", 10),
            cursor="hand2",
            background=self.cal_header_bg,
            foreground=self.cal_header_fg,
            headersbackground=self.cal_header_bg,
            headersforeground=self.cal_header_fg,
            normalbackground=self.cal_bg,
            normalforeground=self.cal_fg,
            weekendbackground=self.cal_weekend_bg,
            weekendforeground=self.cal_weekend_fg,
            selectbackground=self.cal_select_bg,
            selectforeground=self.cal_select_fg,
            bordercolor=self.cal_bg
        )
        cal.pack(fill="both", expand=True, padx=1, pady=1)
        oggi = datetime.date.today()
        cal.calevent_create(oggi, "Oggi", "today")
        cal.tag_config("today", background=self.cal_select_bg, foreground=self.cal_select_fg) 
        def chiudi_popup():
            if hasattr(self, 'popup_calendario') and self.popup_calendario:
                try:
                    self.popup_calendario.destroy() 
                except:
                    pass
                self.popup_calendario = None
        def on_date_select(event):
            data_sel = cal.selection_get()
            var_data.set(data_sel.strftime("%d-%m-%Y"))
            chiudi_popup()
        def check_click_outside(event):
            if not self.popup_calendario or not self.popup_calendario.winfo_exists():
                return
            x, y = self.popup_calendario.winfo_pointerxy()
            widget_sotto = self.popup_calendario.winfo_containing(x, y)
            if widget_sotto is None or str(widget_sotto).find(str(self.popup_calendario)) == -1:
                if widget_sotto != entry_widget:
                    chiudi_popup()
        cal.bind("<<CalendarSelected>>", on_date_select)
        self.bind_all('<Button-1>', check_click_outside)
        self.popup_calendario.deiconify()
        cal.focus_set()

    # Anteprima e Stampa Diretta File Testo (.txt)
    def anteprima_e_stampa_txt(self):
        now = datetime.date.today()
        default_dir = EXPORT_FILES
        default_filename = ""
        path = filedialog.askopenfilename(
               filetypes=[("File txt", "*.txt")],
               initialdir=default_dir,
               initialfile=default_filename,
               title="Stampa Testi"
               )
        if not path:
            return

        with open(path, "r", encoding="utf-8") as f:
            contenuto = f.read()
        anteprima = tk.Toplevel(bg=self.COLOR_TOPLEVEL)
        anteprima.withdraw()
        anteprima.title(f"Anteprima stampa: {os.path.basename(path)}")
        anteprima.resizable(False, False)  
        larghezza_finestra = 1300
        altezza_finestra = 600
        def centra_finestra():
            larghezza_schermo = anteprima.winfo_screenwidth()
            altezza_schermo = anteprima.winfo_screenheight()
            x = (larghezza_schermo // 2) - (larghezza_finestra // 2)
            y = (altezza_schermo // 2) - (altezza_finestra // 2)
            anteprima.geometry(f"{larghezza_finestra}x{altezza_finestra}+{x}+{y}")
            anteprima.deiconify()
            anteprima.lift()
            anteprima.focus_force()
        anteprima.after(0, centra_finestra)
        txt = tk.Text(anteprima, wrap="word", font=("Courier new", 10))
        txt.insert("1.0", contenuto)
        txt.config(state="disabled")
        txt.pack(padx=10, pady=10, fill="both", expand=True)
        def stampa():
            try:
                sistema = platform.system()
                if not os.path.exists(path):
                    raise FileNotFoundError("File non trovato per la stampa")
                if sistema == "Windows":
                    import win32print # type: ignore
                    import win32ui    # type: ignore
                    import win32con   # type: ignore
                    printer_name = win32print.GetDefaultPrinter()
                    hprinter = win32print.OpenPrinter(printer_name)
                    properties = win32print.GetPrinter(hprinter, 2)
                    devmode = properties["pDevMode"]
                    devmode.Orientation = 2  # 2 = Landscape
                    win32print.ClosePrinter(hprinter)
                    pdc = win32ui.CreateDC()
                    pdc.CreatePrinterDC(printer_name)
                    pdc.SetMapMode(win32con.MM_TEXT)
                    if hasattr(pdc, "ResetDC"):
                          pdc.ResetDC(devmode)
                    else:
                          print("‚ö†Ô∏è Attenzione: ResetDC non disponibile su questo oggetto DC")                                       
                    HORZRES = pdc.GetDeviceCaps(win32con.HORZRES)  
                    VERTRES = pdc.GetDeviceCaps(win32con.VERTRES)  
                    font = win32ui.CreateFont({
                         "name": "Courier New",     
                         "height": -int(VERTRES / 60),  
                         "width": int(HORZRES / 160),  
                    })
                    pdc.SelectObject(font)
                    pdc.StartDoc("Stampa compatibile")
                    pdc.StartPage()
                    margin_x = 100  # Margine sinistro
                    margin_y = 100  # Margine superiore
                    line_height = int(VERTRES / 70)     #60 righe circa dal fondo def.
                    with open(path, "r", encoding="utf-8") as file:
                        y = margin_y
                        for line in file:
                            pdc.TextOut(margin_x, y, line.rstrip())
                            y += line_height
                            if y + line_height > VERTRES:
                        
                                   pdc.EndPage()
                                   pdc.StartPage()
                                   y = margin_y
                    pdc.EndPage()
                    pdc.EndDoc()
                    pdc.DeleteDC()
                elif sistema in ["Linux", "Darwin"]:
                    subprocess.run([
                        "lp",
                        "-o", "orientation-requested=4",
                        "-o", "fit-to-page",
                        "-o", "cpi=17",
                        "-o", "lpi=8",
                        path
                    ], check=True)
                else:
                    raise OSError(f"Sistema non supportato: {sistema}")
                self.show_custom_warning("Stampa Avviata", f"Inviato alla stampante predefinita ({sistema})")
            except subprocess.CalledProcessError as e:
                self.show_custom_warning("Stampa Errore", f"Errore di stampa: {e}")
            except Exception as ex:
                self.show_custom_warning("Errore imprevisto", str(ex))
        frame_bottoni = tk.Frame(anteprima, bg=self.COLOR_TOPLEVEL)
        frame_bottoni.pack(pady=10, fill="x")
        ttk.Button(frame_bottoni, text="üñ®Ô∏è Stampa", style="Blu.TButton", command=stampa).pack(side="left", padx=20)
        ttk.Button(frame_bottoni, text="‚ùå Chiudi", style="Giallo.TButton", command=anteprima.destroy).pack(side="right", padx=20)

    # Funzione di Utilit√† per la Stampa Diretta Cross-Platform
    def _stampa_lista_diretta(self, testo_da_stampare, show_warning_func):
        temp_file_path = ""
        try:
            with tempfile.NamedTemporaryFile(mode='w', delete=False, encoding="utf-8", suffix=".txt") as tmp_file:
                tmp_file.write(testo_da_stampare)
                temp_file_path = tmp_file.name
            path = temp_file_path
            sistema = platform.system()
            if sistema == "Windows":
                import win32print # type: ignore
                import win32ui    # type: ignore
                import win32con   # type: ignore
                printer_name = win32print.GetDefaultPrinter()
                hprinter = win32print.OpenPrinter(printer_name)
                properties = win32print.GetPrinter(hprinter, 2)
                devmode = properties["pDevMode"]
                devmode.Orientation = 2 # 2 = Landscape
                win32print.ClosePrinter(hprinter)
                pdc = win32ui.CreateDC()
                pdc.CreatePrinterDC(printer_name)
                pdc.SetMapMode(win32con.MM_TEXT)
                if hasattr(pdc, "ResetDC"):
                     pdc.ResetDC(devmode) # Applica le modifiche di orientamento
                HORZRES = pdc.GetDeviceCaps(win32con.HORZRES)
                VERTRES = pdc.GetDeviceCaps(win32con.VERTRES)
                font = win32ui.CreateFont({
                     "name": "Courier New",
                     "height": -int(VERTRES / 70), 
                     "width": int(HORZRES / 160),
                })
                pdc.SelectObject(font)
                pdc.StartDoc(f"Stampa {os.path.basename(path)}")
                pdc.StartPage()
                margin_x = 100
                margin_y = 100
                line_height = int(VERTRES / 70) 
                with open(path, "r", encoding="utf-8") as file:
                    y = margin_y
                    for line in file:
                        try:
                            pdc.TextOut(margin_x, y, line.rstrip())
                        except Exception:
                            pdc.TextOut(margin_x, y, line.encode('ascii', 'ignore').decode('ascii').rstrip())
                        
                        y += line_height
                        
                        if y + line_height > VERTRES:
                            pdc.EndPage()
                            pdc.StartPage()
                            y = margin_y
                pdc.EndPage()
                pdc.EndDoc()
                pdc.DeleteDC()
                show_warning_func("Stampa Avviata", f"Inviato alla stampante predefinita (Windows).")
            elif sistema in ["Linux", "Darwin"]:
                subprocess.run([
                    "lp",
                    "-o", "orientation-requested=4", # Landscape
                    "-o", "fit-to-page",
                    "-o", "cpi=17",
                    "-o", "lpi=8", 
                    path
                ], check=True)
                show_warning_func("Stampa Avviata", f"Inviato alla stampante predefinita ({sistema}).")
            else:
                show_warning_func("Stampa Fallita", f"Sistema operativo '{sistema}' non supportato per la stampa diretta.")
                return
        except subprocess.CalledProcessError as e:
            show_warning_func("Stampa Errore", f"Errore del comando di stampa: {e}.")
        except Exception as ex:
            show_warning_func("Errore imprevisto", f"Impossibile completare la stampa: {str(ex)}")
        finally:
            if temp_file_path and os.path.exists(temp_file_path):
                try:
                    os.remove(temp_file_path)
                except Exception as e:
                    show_warning_func("Attenzione", f"Impossibile cancellare il file temporaneo: {e}")

    # Analisi di Gruppo Personalizzato per Categorie (Report Spese)
    def gruppo_categorie(self):
        popup = tk.Toplevel(self, bg=self.COLOR_TOPLEVEL )
        popup.title("üìÇ Analisi per categorie selezionate")
        popup.geometry("800x650") 
        popup.withdraw() 
        self.update_idletasks()
        main_x = self.winfo_x()
        main_y = self.winfo_y()
        main_width = self.winfo_width()
        main_height = self.winfo_height()
        popup_width = 800
        popup_height = 650
        center_x = main_x + (main_width // 2) - (popup_width // 2)
        center_y = main_y + (main_height // 2) - (popup_height // 2)
        popup.geometry(f"{popup_width}x{popup_height}+{center_x}+{center_y}")
        popup.transient(self)
        popup.update_idletasks()
        popup.deiconify()
        popup.update()  
        main_frame = ttk.Frame(popup, padding=10)
        main_frame.pack(fill="both", expand=True)
        bottom_buttons = ttk.Frame(popup)
        bottom_buttons.pack(fill="x", pady=10)
        today = datetime.date.today()
        mesi = ["Tutti"] + ["Gennaio", "Febbraio", "Marzo", "Aprile", "Maggio", "Giugno",
                        "Luglio", "Agosto", "Settembre", "Ottobre", "Novembre", "Dicembre"]
        mese_var = tk.StringVar(value="Tutti")
        anno_var = tk.StringVar(value=str(today.year))
        mostra_future_var = tk.BooleanVar(value=True)
        top_bar = ttk.Frame(main_frame)
        top_bar.pack(fill="x", pady=(0, 10))
        ttk.Label(top_bar, text="Mese:").pack(side="left", padx=(0, 5))
        ttk.Combobox(top_bar, values=mesi, textvariable=mese_var, style="Border.TCombobox", state="readonly", width=12).pack(side="left")
        anni = sorted({
            d.year if not isinstance(d, str) else datetime.datetime.strptime(d, "%d-%m-%Y").year
            for d in self.spese
        }, reverse=True)
        ttk.Label(top_bar, text="Anno:").pack(side="left", padx=(10, 5))
        ttk.Combobox(top_bar, values=[str(a) for a in anni], textvariable=anno_var, style="Border.TCombobox", state="readonly", width=8).pack(side="left")
        ttk.Button(top_bar,text="‚Ü∫", style="Yellow.TButton", command=lambda: [mese_var.set("Tutti"),anno_var.set(str(today.year))]).pack(side="left", padx=(10, 0))
        ttk.Checkbutton(
            top_bar,
            text="Includi movimenti futuri nei totali",
            variable=mostra_future_var
        ).pack(side="left", padx=(20,0))
        valori_combo = ["‚Äî Nessuna ‚Äî"] + sorted(list(self.categorie_tipi.keys()))
        selettori_box = ttk.LabelFrame(main_frame, text="üéØ Seleziona fino a 10 categorie da analizzare")
        selettori_box.pack(fill="x", pady=(5, 15))
        sx = ttk.Frame(selettori_box)
        dx = ttk.Frame(selettori_box)
        sx.pack(side="left", fill="both", expand=True, padx=(0, 10))
        dx.pack(side="right", fill="both", expand=True)
        combo_vars = []
        for i in range(10):
            var = tk.StringVar(value="‚Äî Nessuna ‚Äî")
            cb = ttk.Combobox(sx if i < 5 else dx, values=valori_combo, textvariable=var, style="Border.TCombobox", state="readonly", width=35, height=15)
            cb.pack(anchor="w", pady=2)
            combo_vars.append(var)
        ttk.Label(main_frame, text="üìä Risultato:", font=("Arial", 10, "bold")).pack(anchor="w")

        text_output = tk.Text(main_frame, height=15, wrap="word", 
                             font=("Courier New", 10),
                             bg=self.COLOR_WIDGET_BG,
                             fg=self.TEXT_COLOR,
                             insertbackground=self.TEXT_COLOR,
                             padx=10, pady=10,
                             borderwidth=1,
                             relief="flat",
                             highlightthickness=1,
                             highlightbackground=self.COLOR_BUTTON_BG)
        scroll = ttk.Scrollbar(main_frame, command=text_output.yview)
        text_output.config(yscrollcommand=scroll.set)
        text_output.pack(side="left", fill="both", expand=True, pady=(5, 10))
        scroll.pack(side="right", fill="y")
        def analizza():
            text_output.delete("1.0", "end")
            try:
                anno = int(anno_var.get())
            except:
                self.show_custom_warning("Errore", "Anno non valido.")
                return
            selezionato = mese_var.get()
            if selezionato not in mesi:
                self.show_custom_warning("Errore", "Mese non valido.")
                return
            scelte = {v.get().strip().title() for v in combo_vars if v.get() != "‚Äî Nessuna ‚Äî"}
            risultato = {}
            oggi = datetime.date.today()
            for d, sp in self.spese.items():
                if isinstance(d, str):
                    d = datetime.datetime.strptime(d, "%d-%m-%Y").date()
                if not mostra_future_var.get() and d > oggi:
                    continue
                if d.year == anno and (selezionato == "Tutti" or d.month == mesi.index(selezionato)):
                    for voce in sp:
                        if len(voce) >= 4:
                            cat = voce[0].strip().title()
                            imp = voce[2]
                            tipo = voce[3]
                            if cat in scelte:
                                if cat not in risultato:
                                    risultato[cat] = {"num": 0, "uscite": 0.0, "entrate": 0.0}
                                risultato[cat]["num"] += 1
                                if tipo == "Uscita":
                                    risultato[cat]["uscite"] += imp
                                elif tipo == "Entrata":
                                    risultato[cat]["entrate"] += imp
            righe = [f"üìÖ Analisi categorie ‚Äì {mese_var.get()} {anno}\n"]
            righe.append(f"{'Categoria':<30} {'Num':>4}   {'Uscite (‚Ç¨)':>12}   {'Entrate (‚Ç¨)':>12}   {'Saldo (‚Ç¨)':>12}")
            righe.append("-" * 80)
            totale = 0.0
            for cat, dati in sorted(risultato.items(), key=lambda x: -(x[1]["entrate"] - x[1]["uscite"])):
                saldo = dati["entrate"] - dati["uscite"]
                righe.append(f"{cat:<30} {dati['num']:>4}   {dati['uscite']:>12.2f}   {dati['entrate']:>12.2f}   {saldo:>12.2f}")
                totale += saldo
            righe.append("-" * 80)
            righe.append(f"üí∞ Totale gruppo categorie (Entrate - Uscite): {totale:.2f} ‚Ç¨")
            text_output.insert("1.0", "\n".join(righe))
        def reset_campi():
            mese_var.set("Tutti")
            anno_var.set(str(today.year))
            mostra_future_var.set(True)
            for var in combo_vars:
                var.set("‚Äî Nessuna ‚Äî")
            text_output.delete("1.0", "end")
        def salva():
            contenuto = text_output.get("1.0", "end").strip()
            if not contenuto:
                self.show_custom_warning("Nessun dato", "Nessun risultato da salvare.")
                return
            now = datetime.date.today()
            nome_file = f"Analisi_Categorie_{now:%d_%m_%Y}.txt"
            file = filedialog.asksaveasfilename(
                defaultextension=".txt",
                filetypes=[("File di testo", "*.txt")],
                initialfile=nome_file,
                initialdir=EXPORT_FILES,
                title="Esporta risultati",
                confirmoverwrite=False,
                parent=popup
            )
            if file:
                if os.path.exists(file):
                    conferma = self.show_custom_askyesno(
                        "Sovrascrivere file?",
                        f"Il file '{os.path.basename(file)}' \nesiste gi√†. Vuoi sovrascriverlo?"
                    )
                    if not conferma:
                        return
                with open(file, "w", encoding="utf-8") as f:
                    f.write(contenuto)
                self.show_custom_warning("Esportazione completata", f"File salvato:\n{file}")
        mostra_future_var.trace_add("write", lambda *a: analizza())
        bottom_buttons = tk.Frame(popup, bg=self.COLOR_TOPLEVEL ) 
        bottom_buttons.pack(fill="x", pady=10)
        ttk.Button(bottom_buttons, text="üì• Analizza", command=analizza, style="Verde.TButton").pack(side="left", padx=10)
        ttk.Button(bottom_buttons, text="üíæ Esporta", command=salva, style="Arancio.TButton").pack(side="left", padx=10)
        ttk.Button(bottom_buttons, text="üü® Reset campi", command=reset_campi, style="Giallo.TButton").pack(side="left", padx=10)
        ttk.Button(bottom_buttons, text="‚ùå Chiudi", command=popup.destroy, style="Giallo.TButton").pack(side="right", padx=10)
        popup.bind("<Escape>", lambda e: popup.destroy())

    # Analisi di Cadenza e Ricorrenza Movimenti per Categoria
    def calcola_mancanti(self):
        if hasattr(self, '_mancanti_popup') and self._mancanti_popup and self._mancanti_popup.winfo_exists():
            self._mancanti_popup.lift()
            return  
        from datetime import datetime, timedelta
        def on_mancanti_close():
            popup.destroy()
            self._mancanti_popup = None
        popup = tk.Toplevel(bg=self.COLOR_TOPLEVEL)
        self._mancanti_popup = popup
        popup.protocol("WM_DELETE_WINDOW", on_mancanti_close)
        popup.bind("<Escape>", lambda e: on_mancanti_close())
        popup.withdraw()
        popup.title("üìã Controllo Categorie Ricorrenti")
        w, h = 950, 600
        x = (popup.winfo_screenwidth() // 2) - (w // 2)
        y = (popup.winfo_screenheight() // 2) - (h // 2)
        popup.geometry(f"{w}x{h}+{x}+{y}")
        popup.resizable(True, True)
        popup.deiconify()
        mesi = ["Gen", "Feb", "Mar", "Apr", "Mag", "Giu",
                "Lug", "Ago", "Set", "Ott", "Nov", "Dic"]
        oggi = datetime.today().date()
        def converti_data(d):
            if isinstance(d, str):
                try:
                    return datetime.strptime(d, "%d-%m-%Y").date()
                except:
                    return None
            elif isinstance(d, datetime):
                return d.date()
            return d
        anni_disponibili = sorted({
            converti_data(d).year for d in self.spese
            if converti_data(d)
        }, reverse=True)
        anno_var = tk.StringVar(value=str(oggi.year))
        top_bar = ttk.Frame(popup, padding=10)
        top_bar.pack(fill="x")
        ttk.Label(top_bar, text="Anno di Analisi:").pack(side="left", padx=6)
        anno_combo = ttk.Combobox(top_bar, textvariable=anno_var,
                                 values=[str(a) for a in anni_disponibili], style="Border.TCombobox", state="readonly", width=6)
        anno_combo.pack(side="left", padx=6)
        anno_combo.bind("<<ComboboxSelected>>", lambda event: analizza())
        ttk.Button(
            top_bar,
            text="‚Ü∫",
            style='Yellow.TButton',
            command=lambda: [
                anno_var.set(str(oggi.year)),
                analizza() 
            ]
        ).pack(side="left", padx=2)
        ttk.Label(top_bar, text="Clicca sull'intestazione per ordinare. ‚úî/‚úñ = Mese con/senza Movimenti.").pack(side="right", padx=6)
        cols = ["Categoria", "Totale (‚Ç¨)", "Media (‚Ç¨)", "Cadenza"] + mesi
        self.tree = ttk.Treeview(popup, columns=cols, show='headings', selectmode='browse')
        self.tree.pack(fill="both", expand=True, padx=10, pady=(0,8))
        for col in cols:
            self.tree.heading(col, 
                              text=col.replace(" (‚Ç¨)", ""), 
                              anchor="center", 
                              command=lambda c=col: self.treeview_sort_column(self.tree, c, False))
            if col == "Categoria":
                width_val = 150
            elif col == "Totale (‚Ç¨)":
                width_val = 75
            elif col == "Media (‚Ç¨)":
                width_val = 75
            elif col == "Cadenza":
                width_val = 100 
            else:
                width_val = 35 
            if col == "Categoria":
                anchor_data = "w"  
            elif col in ("Totale (‚Ç¨)", "Media (‚Ç¨)"):
                anchor_data = "e"     
            else:
                anchor_data = "center"                 
            self.tree.column(col, width=width_val, anchor=anchor_data)
        self.tree.tag_configure("mese_presente", foreground="green", font=("Arial", 8, "bold"))
        self.tree.tag_configure("mese_assente", foreground="red")
        self.tree.tag_configure("cadenza_mensile", background="#E6FFE6", foreground="#004C00")
        self.tree.tag_configure("cadenza_regolare", background="#F0FFF0", foreground="#333333")
        self.tree.tag_configure("cadenza_bimestrale", background="#FFFFE0", foreground="#CC9900")
        self.tree.tag_configure("cadenza_trimestrale", background="#FFF0E0", foreground="#FF6600")
        self.tree.tag_configure("cadenza_irregolare", background="#FFEEEE", foreground="#CC0000")
        self.tree.tag_configure("intestazione", background="#CCCCCC", foreground="black", font=("Arial", 10, "bold"))
        def analizza():
            dati_mensili = {} 
            for i in self.tree.get_children():
                self.tree.delete(i)
            try:
                anno = int(anno_var.get())
            except ValueError:
                self.show_custom_warning("Errore", "Anno non valido.")
                return
            risultati = {}
            importi_categoria = {}
            conteggio_categoria = {}
            for d, sp in self.spese.items():
                dd = converti_data(d)
                if not dd or dd.year != anno:
                    continue
                mese = dd.month
                for voce in sp:
                    if len(voce) < 1 or not voce[0].strip():
                        continue
                    cat = voce[0].strip().title()
                    importo = voce[2] if len(voce) > 2 and isinstance(voce[2], (int, float)) else 0
                    tipo = voce[3].strip().title() if len(voce) > 3 else "Uscita"
                    importi_categoria[cat] = importi_categoria.get(cat, 0) + importo
                    conteggio_categoria[cat] = conteggio_categoria.get(cat, 0) + 1
                    risultati.setdefault(cat, set()).add(mese)
                    dati_mensili.setdefault(cat, {}).setdefault(mese, {"Entrata": 0, "Uscita": 0})
                    if tipo == "Entrata":
                        dati_mensili[cat][mese]["Entrata"] += importo
                    else:
                        dati_mensili[cat][mese]["Uscita"] += importo
            count = 0
            for cat, mesi_presenti in sorted(risultati.items()):
                if len(mesi_presenti) < 2: 
                    continue
                spesa_totale = importi_categoria.get(cat, 0)
                n_elementi = conteggio_categoria.get(cat, 1)
                media_spesa = spesa_totale / n_elementi
                sorted_months = sorted(list(mesi_presenti))
                avg_interval = 0
                if len(sorted_months) > 1:
                    intervals = [(sorted_months[i] - sorted_months[i-1]) for i in range(1, len(sorted_months))]
                    avg_interval = sum(intervals) / len(intervals)
                if len(mesi_presenti) == 12:
                    cadenza = "Mensile"
                    tag_riga = "cadenza_mensile" 
                elif 0.8 <= avg_interval <= 1.2:
                    cadenza = "Mensile Reg."
                    tag_riga = "cadenza_regolare" 
                elif 1.5 <= avg_interval <= 2.5:
                    cadenza = "Bimestrale"
                    tag_riga = "cadenza_bimestrale" 
                elif 2.5 < avg_interval <= 3.5:
                    cadenza = "Trimestrale"
                    tag_riga = "cadenza_trimestrale" 
                else:
                    cadenza = "Irregolare"
                valori_riga = [
                    cat,
                    f"‚Ç¨{spesa_totale:.2f}",
                    f"‚Ç¨{media_spesa:.2f}",
                    cadenza
                ]
                tags = []
                for mese_idx in range(1, 13):
                    tag = "mese_assente"
                    simbolo = "‚úñ"
                    if mese_idx in mesi_presenti:
                        simbolo = "‚úî"
                        tag = "mese_presente"
                        
                    if mese_idx == oggi.month and anno == oggi.year:
                        simbolo = f"[{simbolo}]" 
                    valori_riga.append(simbolo)
                    tags.append(tag)
                self.tree.insert("", "end", iid=cat, values=valori_riga, tags=(tag_riga,))
                count += 1
            if count == 0:
                self.tree.insert("", "end", values=("Nessuna categoria ricorrente trovata.", "", "", ""), tags=("intestazione",))
        def on_tree_select(event):
            selected_item = self.tree.focus()
            if not selected_item:
                return
            valori = self.tree.item(selected_item, 'values')
            categoria_selezionata = valori[0]
            if categoria_selezionata.startswith("Nessuna"):
                return
            anno_selezionato = anno_var.get()
            data_filter = {
                "anno": anno_selezionato,
                "mese": None, 
                "categoria": categoria_selezionata,
                "tipo": None
            }
            title = f"Movimenti Ricorrenti: {categoria_selezionata} ({anno_selezionato})"
            self.mostra_transazioni_popup(data_filter, title)
        self.tree.bind("<Double-1>", on_tree_select)

        legenda_frame = ttk.Frame(popup, padding=(10, 5, 10, 5))
        legenda_frame.pack(fill="x")        
        ttk.Label(legenda_frame, text="Legenda Cadenza: ", font=("Arial", 8, "bold")).pack(side="left", padx=(0, 10))
        voci = [
            ("Mensile", "mensile"),
            ("Regolare", "regolare"),
            ("Bimestrale", "bimestrale"),
            ("Trimestrale", "trimestrale"),
            ("Irregolare", "irregolare")
        ]
        for testo, alias in voci:
            ttk.Label(
                legenda_frame, 
                text=testo, 
                style=f"Legenda.{alias}.TLabel"
            ).pack(side="left", padx=5)
        ttk.Label(legenda_frame, text=" | Simboli Mese: ", font=("Arial", 8, "bold")).pack(side="left", padx=(10, 10))
        ttk.Label(legenda_frame, text="‚úî Presente", foreground="green", font=("Arial", 8, "bold")).pack(side="left", padx=5)
        ttk.Label(legenda_frame, text="‚úñ Assente", foreground="red").pack(side="left", padx=5)
        ttk.Label(legenda_frame, text="[ ] Mese Corrente", foreground="#555555").pack(side="left", padx=5)
        bottom_buttons = tk.Frame(popup, bg=self.COLOR_TOPLEVEL)
        bottom_buttons.pack(pady=8)
        ttk.Button(bottom_buttons, text="‚úñ Chiudi", command=popup.destroy, style="Giallo.TButton").pack(side="right", padx=10)
        popup.bind("<Escape>", lambda e: popup.destroy())
        analizza()

    # Time Machine: Simulazione di Risparmio per Categoria
    def time_machine(self):
        popup = tk.Toplevel()
        popup.title("üï∞Ô∏è Time Machine ‚Äì Simulazione per categoria")
        popup.geometry("880x650")
        popup.withdraw()
        self.update_idletasks()
        main_x = self.winfo_x()
        main_y = self.winfo_y()
        main_width = self.winfo_width()
        main_height = self.winfo_height()
        popup_width = 880
        popup_height = 650
        center_x = main_x + (main_width // 2) - (popup_width // 2)
        center_y = main_y + (main_height // 2) - (popup_height // 2)
        popup.geometry(f"{popup_width}x{popup_height}+{center_x}+{center_y}")
        popup.transient(self)
        popup.update_idletasks()
        popup.deiconify()
        popup.update()
        main = ttk.Frame(popup, padding=10)
        main.pack(fill="both", expand=True)
        anni_disponibili = sorted({datetime.datetime.strptime(str(d), "%d-%m-%Y").year
                                   if isinstance(d, str) else d.year for d in self.spese}, reverse=True)
        anno_var = tk.IntVar(value=datetime.date.today().year)
        mostra_future_var = tk.BooleanVar(value=True)
        top_bar = ttk.Frame(main)
        top_bar.pack(fill="x", pady=(0, 10))
        ttk.Label(top_bar, text="Anno:", font=("Arial", 10)).pack(side="left", padx=(0, 5))
        anno_combo = ttk.Combobox(top_bar, textvariable=anno_var, values=anni_disponibili, style="Border.TCombobox", state="readonly", width=8)
        anno_combo.pack(side="left")
        ttk.Button(
            top_bar,
            text="‚Ü∫",
            style='Yellow.TButton',
            command=lambda: [anno_var.set(datetime.date.today().year)]
        ).pack(side="left", padx=(5, 0))
        ttk.Checkbutton(
            top_bar,
            text="Includi movimenti futuri nei totali",
            variable=mostra_future_var
        ).pack(side="left", padx=(30, 0))
        colonne = ttk.Frame(main)
        colonne.pack(fill="x", padx=5)
        sinistra = ttk.Frame(colonne)
        destra = tk.Frame(colonne, bg=self.COLOR_TOPLEVEL)
        sinistra.pack(side="left", fill="both", expand=True, padx=(0, 40))
        destra.pack(side="right", fill="both", expand=True)
        ttk.Label(sinistra, text="üéØ Selezione manuale", font=("Arial", 10, "bold")).pack(anchor="w", pady=(0, 6))
        destra_label = tk.Label(destra, bg=self.COLOR_TOPLEVEL ,fg=self.TEXT_COLOR, text="üìä Top 10 categorie per risparmio", font=("Arial", 10, "bold"))
        destra_label.pack(anchor="w", pady=(0, 6))
        combo_vars = []
        combo_widgets = []
        for _ in range(10):
            var = tk.StringVar()
            cbx = ttk.Combobox(sinistra, textvariable=var, style="Border.TCombobox", state="readonly", width=30)
            cbx.set("‚Äî Nessuna ‚Äî")
            cbx.pack(pady=2, anchor="w")
            combo_vars.append(var)
            combo_widgets.append(cbx)
        selezioni = {}
        ttk.Separator(main, orient="horizontal").pack(fill="x", pady=14)
        ttk.Label(main, text="üí° Risultato della simulazione:", font=("Arial", 10, "bold")).pack(anchor="w", padx=5)
        text_frame = ttk.Frame(main)
        text_frame.pack(fill="both", expand=True, padx=5, pady=(0, 10))
        text_frame.columnconfigure(0, weight=1)
        text_frame.rowconfigure(0, weight=1)
        scroll_y = ttk.Scrollbar(text_frame, orient=tk.VERTICAL, style="Vertical.TScrollbar")
        scroll_y.grid(row=0, column=1, sticky="ns")
        text_output = tk.Text(
            text_frame, 
            height=10, 
            wrap="word",
            yscrollcommand=scroll_y.set
        )
        text_output.configure(font=("Courier New", 10), bg=self.COLOR_TOPLEVEL, fg=self.TEXT_COLOR)
        text_output.grid(row=0, column=0, sticky="nsew")
        scroll_y.config(command=text_output.yview) 
        def aggiorna_categorie():
            anno = anno_var.get()
            contatori = {}
            oggi = datetime.date.today()
            for d, sp in self.spese.items():
                try:
                    if isinstance(d, str):
                        d_conv = datetime.datetime.strptime(d, "%d-%m-%Y").date()
                    else:
                        d_conv = d
                except:
                    continue
                if not mostra_future_var.get() and d_conv > oggi:
                    continue
                if d_conv.year != anno:
                    continue
                for voce in sp:
                    if len(voce) < 4:
                        continue
                    cat, _, imp, tipo = voce[:4]
                    key = cat.strip().lower()
                    if key not in contatori:
                        contatori[key] = {"count": 0, "uscite": 0.0, "entrate": 0.0}
                    contatori[key]["count"] += 1
                    if tipo == "Uscita":
                        contatori[key]["uscite"] += imp
                    elif tipo == "Entrata":
                        contatori[key]["entrate"] += imp
            for key in contatori:
                contatori[key]["risparmio"] = contatori[key]["uscite"] - contatori[key]["entrate"]
            return contatori
        def aggiorna_interfaccia(*_):
            contatori = aggiorna_categorie()
            tutte_categorie_da_spese = [k.lower() for k in contatori.keys()]
            tutte_categorie_principali = [k.lower() for k in self.categorie_tipi.keys()]
            tutte_categorie = sorted(list(set(tutte_categorie_da_spese) | set(tutte_categorie_principali)))
            valori_combo = ["‚Äî Nessuna ‚Äî"] + tutte_categorie
            for var, cb in zip(combo_vars, combo_widgets):
                cb["values"] = valori_combo
                if var.get().strip().lower() not in tutte_categorie:
                    var.set("‚Äî Nessuna ‚Äî")
            for w in destra.winfo_children():
                if w != destra_label:
                    w.destroy()
            top_cat = sorted(contatori.items(), key=lambda x: -x[1]["risparmio"])[:10]
            selezioni.clear()
            for cat, dati in top_cat:
                var = tk.BooleanVar(value=False)
                selezioni[cat] = (var, dati)
                txt = f"{cat.title()} ‚Äì {dati['count']}√ó, Risparmio: {dati['risparmio']:.2f} ‚Ç¨ (Uscite: {dati['uscite']:.2f} - Entrate: {dati['entrate']:.2f})"
                chk = tk.Checkbutton(
                    destra, 
                    text=txt, 
                    variable=var,
                    bg=self.COLOR_TOPLEVEL, 
                    fg=self.TEXT_COLOR,     
                    selectcolor=self.COLOR_TOPLEVEL,
                    activebackground=self.COLOR_TOPLEVEL,
                    highlightthickness=0 
                )
                chk.pack(anchor="w", pady=2)
        def esegui_simulazione():
            contatori = aggiorna_categorie()
            text_output.delete("1.0", tk.END)
            lines = [f"üï∞Ô∏è Time Machine ‚Äì Anno {anno_var.get()}\n"]
            totale = 0.0
            scelte = set()
            for cat, (var, _) in selezioni.items():
                if var.get():
                    scelte.add(cat)
            for var in combo_vars:
                val = var.get().strip().lower()
                if val and val != "‚Äî nessuna ‚Äî" and val in contatori:
                    scelte.add(val)
            risultati = []
            for cat in scelte:
                dati = contatori.get(cat)
                if dati:
                    risultati.append((cat, dati["count"], dati["uscite"], dati["entrate"], dati["risparmio"]))
            risultati.sort(key=lambda x: -x[4])
            lines.append(f"üí≠ Proiezione del risparmio ottenibile nel {anno_var.get()}, escludendo le categorie selezionate: ‚û§\n")
            lines.append(f"{'Categoria':<25} {'Num':>4}   {'Uscite (‚Ç¨)':>12}   {'Entrate (‚Ç¨)':>12}   {'Risparmio (‚Ç¨)':>14}")
            lines.append("-" * 77)
            for cat, n, usc, ent, risp in risultati:
                lines.append(f"{cat.title():<25} {n:>4}   {usc:>12.2f}   {ent:>12.2f}   {risp:>14.2f}")
                totale += risp
            lines.append("-" * 77)
            lines.append(f"\nüí∞ Risparmio totale teorico: {totale:.2f} ‚Ç¨ (Uscite - Entrate delle categorie selezionate)")
            text_output.insert("1.0", "\n".join(lines))
        def reset_tutto():
            anno_var.set(datetime.date.today().year)
            mostra_future_var.set(True)
            for var in combo_vars:
                var.set("‚Äî Nessuna ‚Äî")
            for var, _ in selezioni.values():
                var.set(False)
            text_output.delete("1.0", tk.END)
            aggiorna_interfaccia()
        def salva_file():
            content = text_output.get("1.0", "end").strip()
            if not content:
                self.show_custom_warning("Nessun dato", "Non c'√® nessuna simulazione da salvare.")
                return
            now = datetime.date.today()
            default_filename = f"Time_Machine_{now.day:02d}_{now.month:02d}_{now.year}.txt"
            file = filedialog.asksaveasfilename(
                defaultextension=".txt",
                filetypes=[("File txt", "*.txt")],
                initialdir=EXPORT_FILES,
                initialfile=default_filename,
                title="Esporta risultato simulazione",
                confirmoverwrite=False,
                parent=popup)
            if file:
                if os.path.exists(file):
                    conferma = self.show_custom_askyesno(
                        "Sovrascrivere file?",
                        f"Il file '{os.path.basename(file)}' \nesiste gi√†. Vuoi sovrascriverlo?"
                    )
                    if not conferma:
                        return
                with open(file, "w", encoding="utf-8") as f:
                    f.write(content)
                self.show_custom_warning("Esportazione completata", f"Simulazione salvata in:\n{file}")
        anno_combo.bind("<<ComboboxSelected>>", lambda e: aggiorna_interfaccia())
        mostra_future_var.trace_add("write", lambda *a: aggiorna_interfaccia())
        aggiorna_interfaccia()
        pulsanti = ttk.Frame(main)
        pulsanti.pack(pady=5)
        ttk.Button(pulsanti, text="üü• Simula Risparmio", command=esegui_simulazione, style="Verde.TButton").pack(side="left", padx=10)
        ttk.Button(pulsanti, text="üíæ Esporta", command=salva_file, style="Arancio.TButton").pack(side="left", padx=10)
        ttk.Button(pulsanti, text="üîÑ Reset campi", command=reset_tutto, style="Giallo.TButton").pack(side="left", padx=10)
        ttk.Button(pulsanti, text="‚úñ Chiudi", command=popup.destroy, style="Giallo.TButton").pack(side="left", padx=10)
        popup.bind("<Escape>", lambda e: popup.destroy())
        
    # Gestore Doppio Click su Movimento Mensile (Navigazione Giornaliera)
    def on_spese_mese_tree_double_click(self, event):
        self.mostra_treeview_statistiche()
        self.after(0, self.imp_entry.focus_set)
        item_id = self.spese_mese_tree.identify_row(event.y)
        if not item_id:
            return
        values = self.spese_mese_tree.item(item_id, "values")
        if not values:
            return
        data_str = str(values[0]).strip()
        try:
            giorno = datetime.datetime.strptime(data_str, "%d-%m-%Y").date()
        except Exception:
            try:
                giorno = datetime.datetime.strptime(data_str, "%d/%m/%Y").date()
            except Exception:
                return
        self.set_stats_mode("giorno")
        if hasattr(self, "cal"):
            self.cal.selection_set(giorno)
            self.cal._sel_date = giorno
        self.update_stats()
        self.stats_label.config(text=f"Riepilogo Giornaliero - {giorno.strftime('%d-%m-%Y')}", foreground="purple",
    font=("Arial", 10, "bold"))

    # Visualizzazione Dettagliata per Categoria (Doppio Click sul Riepilogo)
    def on_stats_table_double_click(self, event):
        MESI_NOME_COMPLETO = {
            1: "Gennaio", 2: "Febbraio", 3: "Marzo", 4: "Aprile", 
            5: "Maggio", 6: "Giugno", 7: "Luglio", 8: "Agosto", 
            9: "Settembre", 10: "Ottobre", 11: "Novembre", 12: "Dicembre"
        }
        mode = self.stats_mode.get()
        item_id = self.stats_table.identify_row(event.y)
        if not item_id:
            return
        values = self.stats_table.item(item_id, "values")
        if not values or len(values) < 1:
            return
        categoria = str(values[0]).strip()
        categoria_selezionata = str(values[1]).strip()
        spese_categoria = []
        if mode == "giorno":
            self.after(500, lambda: self.gestisci_archivi_pdf(categoria_selezionata))
            return 
        if mode == "mese":
            ref = self.stats_refdate
            mese, anno = ref.month, ref.year
            nome_mese = MESI_NOME_COMPLETO.get(mese, f"{mese:02d}")
            for d, sp in self.spese.items():
                if d.month == mese and d.year == anno:
                    for entry in sp:
                        cat, desc, imp, tipo = entry[:4]
                        if cat.strip() == categoria: 
                            spese_categoria.append((d, desc, imp, tipo))
            titolo_periodo = f"{nome_mese} {anno}"
            testo_periodo = f"il mese di {nome_mese} {anno}"
        elif mode == "anno":
            ref = self.stats_refdate
            anno = ref.year
            for d, sp in self.spese.items():
                if d.year == anno:
                    for entry in sp:
                        cat, desc, imp, tipo = entry[:4]
                        if cat.strip() == categoria:
                            spese_categoria.append((d, desc, imp, tipo))
            titolo_periodo = f"{anno}"
            testo_periodo = f"l'anno {anno}"
        elif mode == "totali":
            for d, sp in self.spese.items():
                for entry in sp:
                    cat, desc, imp, tipo = entry[:4]
                    if cat.strip() == categoria:
                        spese_categoria.append((d, desc, imp, tipo))
            titolo_periodo = "Tutte le annualit√†"
            testo_periodo = "tutti gli anni"
        if not spese_categoria:
            self.show_custom_info("Nessuna spesa", f"Nessuna spesa per la categoria '{categoria}' nel periodo selezionato.")
            return
        popup = tk.Toplevel(self, bg=self.COLOR_TOPLEVEL)
        popup.title(f"Dettaglio Movimenti - {categoria} ({titolo_periodo})")
        popup.geometry("650x400")
        popup.withdraw()
        self.update_idletasks()
        main_x = self.winfo_x()
        main_y = self.winfo_y()
        main_width = self.winfo_width()
        main_height = self.winfo_height()
        popup_width = 650
        popup_height = 400
        center_x = main_x + (main_width // 2) - (popup_width // 2)
        center_y = main_y + (main_height // 2) - (popup_height // 2)
        popup.geometry(f"{popup_width}x{popup_height}+{center_x}+{center_y}")
        popup.transient(self)
        popup.update_idletasks()
        popup.deiconify()
        popup.update()
        popup.grab_set()
        label = tk.Label(
            popup,
            text=f"Movimenti Categoria '{categoria}' per {testo_periodo}",
            font=("Arial", 11),
            bg=self.COLOR_TOPLEVEL,
            fg=self.TEXT_COLOR
        )
        label.pack(pady=8)
        tree_frame = ttk.Frame(popup)
        tree_frame.pack(fill="both", expand=True, padx=10, pady=6)
        vsb = ttk.Scrollbar(tree_frame, orient="vertical")
        vsb.pack(side="right", fill="y")
        columns = ("Data", "Descrizione", "Importo", "Tipo")
        tree = ttk.Treeview(
            tree_frame, 
            columns=columns, 
            show="headings", 
            height=10,
            yscrollcommand=vsb.set
        )
        tree.pack(fill="both", expand=True, side="left")
        vsb.config(command=tree.yview)
        def ordina_colonna(treeview, colonna, inverti):
            dati = [(treeview.set(k, colonna), k) for k in treeview.get_children("")]
            try:
                if colonna == "Data":
                    dati.sort(
                        key=lambda t: datetime.datetime.strptime(t[0], "%d-%m-%Y"),
                        reverse=inverti
                    )
                elif colonna == "Importo":
                    dati.sort(
                        key=lambda t: float(t[0].replace(" ‚Ç¨", "").replace(".", "").replace(",", ".")),
                        reverse=inverti
                    )
                else:
                    dati.sort(key=lambda t: t[0].lower(), reverse=inverti)
            except Exception as e:
                print("Errore ordinamento:", e)
            for index, (_, k) in enumerate(dati):
                treeview.move(k, "", index)
            treeview.heading(colonna, command=lambda: ordina_colonna(treeview, colonna, not inverti))
        for col, w in zip(columns, (90, 230, 100, 80)):
            anchor = "w" if col == "Descrizione" else "center"
            tree.heading(col, text=col, command=lambda c=col: ordina_colonna(tree, c, False))
            tree.column(col, width=w, anchor=anchor)
        tot_entrate = tot_uscite = 0.0
        for d, desc, imp, tipo in sorted(spese_categoria, key=lambda x: x[0], reverse=True):
            imp_formattato_it = f"{imp:,.2f}".replace(',', 'X').replace('.', ',').replace('X', '.')
            tag_name = f"row_{d.strftime('%Y%m%d%H%M%S')}_{len(tree.get_children(''))}"
            tree.insert("", "end", values=(d.strftime("%d-%m-%Y"), desc, f"{imp_formattato_it} ‚Ç¨", tipo), tags=(tag_name,))
            if tipo == "Entrata":
                tree.tag_configure(tag_name, foreground="green")
                tot_entrate += imp
            else:
                tree.tag_configure(tag_name, foreground="red")
                tot_uscite += imp
        saldo = tot_entrate - tot_uscite
        lbl = tk.Text(
            popup, 
            bg=self.COLOR_TOPLEVEL, 
            fg=self.TEXT_COLOR, 
            height=1, 
            borderwidth=0, 
            font=("Arial", 10, "bold"), 
            wrap="none", 
            background=popup.cget("background"),
            highlightthickness=0,
            relief="flat"
        )
        lbl.pack(pady=7)
        lbl.tag_config("entrate_color", foreground="green")
        lbl.tag_config("uscite_color", foreground="red")
        lbl.tag_config("saldo_pos_color", foreground="green")
        lbl.tag_config("saldo_neg_color", foreground="red")
        def formatta_italiano(valore):
            return f"{valore:,.2f}".replace(',', 'X').replace('.', ',').replace('X', '.')
        entrate_str_num = formatta_italiano(tot_entrate)
        uscite_str_num = formatta_italiano(tot_uscite)
        saldo_str_num = formatta_italiano(saldo)
        text_full = f"Totale entrate: {entrate_str_num} ‚Ç¨  Totale uscite: {uscite_str_num} ‚Ç¨  Saldo: {saldo_str_num} ‚Ç¨"
        lbl.config(state="normal")
        lbl.insert("end", text_full)
        entrate_start = text_full.find(entrate_str_num)
        entrate_end = entrate_start + len(entrate_str_num)
        lbl.tag_add("entrate_color", f"1.{entrate_start}", f"1.{entrate_end}")
        uscite_start = text_full.find(uscite_str_num, entrate_end)
        uscite_end = uscite_start + len(uscite_str_num)
        lbl.tag_add("uscite_color", f"1.{uscite_start}", f"1.{uscite_end}")
        saldo_start = text_full.find(saldo_str_num, uscite_end)
        saldo_end = saldo_start + len(saldo_str_num)
        if saldo >= 0:
            lbl.tag_add("saldo_pos_color", f"1.{saldo_start}", f"1.{saldo_end}")
        else:
            lbl.tag_add("saldo_neg_color", f"1.{saldo_start}", f"1.{saldo_end}")
        lbl.config(state="disabled")
        tree.bind("<Double-1>", lambda evt: self.goto_day_from_popup(tree, popup))
        ttk.Button(popup, text="‚úñ Chiudi", style="Giallo.TButton", command=popup.destroy).pack(pady=4)

    # Navigazione al Giorno (Da Finestra di Dettaglio)
    def goto_day_from_popup(self, tree, popup):
        if self.stats_view_mode.get() != "tabella":
                self.mostra_treeview_statistiche()
        item_id = tree.focus()
        if not item_id:
                return
        vals = tree.item(item_id, "values")
        if not vals or len(vals) < 1:
                return
        data_str = vals[0]
        try:
                giorno = datetime.datetime.strptime(data_str, "%d-%m-%Y").date()
        except Exception:
                return
        self.set_stats_mode("giorno")
        if hasattr(self, "cal"):
                self.cal.selection_set(giorno)
                self.cal._sel_date = giorno
        self.stats_refdate = giorno
        self.estratto_month_var.set(f"{giorno.month:02d}")
        self.estratto_year_var.set(str(giorno.year))
        self.stats_label.config(text=f"Riepilogo Giornaliero - {giorno.strftime('%d-%m-%Y')}", 
                                foreground="purple", font=("Arial", 10, "bold"))
        def chiudi_e_aggiorna():
            try:
                popup.destroy()
            except Exception:
                pass
            if hasattr(self, 'grafico_analisi_popup') and self.grafico_analisi_popup is not None:
                try:
                    self.grafico_analisi_popup.destroy()
                    self.grafico_analisi_popup = None
                except Exception:
                    pass
            if hasattr(self, 'popup_grafico') and self.popup_grafico and self.popup_grafico.winfo_exists():
                self.popup_grafico.destroy()
                del self.popup_grafico
            self.update_stats() 
            self.after_idle(lambda: self.forza_scroll_e_pulizia_selezione() if hasattr(self, 'forza_scroll_e_pulizia_selezione') else None)
        self.after(50, chiudi_e_aggiorna)
        
    # Gestore Cambio Stato Blocco Data
    def on_blocca_data_changed(self):
        if not self.blocca_data_var.get():
            self.data_spesa_var.set(datetime.date.today().strftime("%d-%m-%Y"))
            
    # Gestore Login Locale
    def gestione_login(self):
        def hash_pw(pw):
                return hashlib.sha256(pw.encode()).hexdigest()
        def salva_hash(pw):
                with open(PW_FILE, "w") as f:
                        json.dump({"hash": hash_pw(pw)}, f)
        def leggi_hash():
                if not os.path.exists(PW_FILE):
                        return None
                with open(PW_FILE) as f:
                        return json.load(f).get("hash")
        login_riuscito = [False]
        args = sys.argv
        def crea_campo_password(parent, etichetta=""):
                if etichetta:
                        tk.Label(parent, text=f"\n{etichetta}:", bg="black", fg="white", font=("Arial", 8, "bold")).pack()
                frame_pw = tk.Frame(parent, bg="black")
                frame_pw.pack()
                visibile = tk.BooleanVar(value=False)
                entry_pw = tk.Entry(frame_pw, show="*", width=22, bg="#333333", fg="white", insertbackground="white")
                entry_pw.pack(side="left", padx=(0, 5))
                def toggle_visibilita():
                        if visibile.get():
                                entry_pw.config(show="*")
                                lbl_occhio.config(text="üëÅ")
                                visibile.set(False)
                        else:
                                entry_pw.config(show="")
                                lbl_occhio.config(text="üîí")
                                visibile.set(True)
                lbl_occhio = tk.Label(
                        frame_pw, text="üëÅ", font=("Arial", 10), bg="black", fg="white", cursor="hand2"
                )
                lbl_occhio.pack(side="left")
                lbl_occhio.bind("<Button-1>", lambda e: toggle_visibilita())
                return entry_pw 
        def cambia_password():
                win = tk.Toplevel(self) 
                win.title("üîÅ Cambia password")
                win.resizable(False, False)
                w_win, h_win = 380, 260
                x_win = self.winfo_screenwidth() // 2 - w_win // 2
                y_win = self.winfo_screenheight() // 2 - h_win // 2
                win.geometry(f"{w_win}x{h_win}+{x_win}+{y_win}")
                win.grab_set()
                win.configure(bg="black")
                win.focus_force()
                mess = tk.Label(win, text="", fg="red", bg="black")
                entry_attuale = crea_campo_password(win, "Vecchia password")
                entry_nuova = crea_campo_password(win, "Nuova password")
                entry_conferma = crea_campo_password(win, "Conferma nuova password")
                entry_attuale.focus()
                mess.pack()
                def conferma_cambio():
                        attuale = entry_attuale.get()
                        nuova = entry_nuova.get()
                        conferma = entry_conferma.get()
                        def reset_campi():
                                entry_attuale.delete(0, tk.END)
                                entry_nuova.delete(0, tk.END)
                                entry_conferma.delete(0, tk.END)
                                entry_attuale.focus()
                        if hash_pw(attuale) != leggi_hash():
                                mess.config(text="‚ùå Password attuale errata.", fg="red")
                                reset_campi()
                                return
                        if not nuova:
                                salva_hash(nuova)
                                mess.config(text="‚úÖ Password disattivata.", fg="lightgreen")
                                win.after(1000, win.destroy)
                                return
                        if nuova != conferma:
                                mess.config(text="‚ùå Le Password non corrispondono.", fg="red")
                                entry_nuova.delete(0, tk.END)
                                entry_conferma.delete(0, tk.END)
                                entry_nuova.focus()
                        else:
                                salva_hash(nuova)
                                mess.config(text="‚úÖ Password aggiornata.", fg="lightgreen")
                                win.after(1000, win.destroy)
                tk.Button(
                        win, text="üíæ Salva", command=conferma_cambio, font=("Arial", 8, "bold"),
                        bg="#4CAF50", fg="white", activebackground="#45A049", relief="raised"
                ).pack(pady=8)
                win.wait_window() 
        def mostra_finestra_login():
            tentativi_falliti = 0
            MAX_TENTATIVI = 3
            login = tk.Toplevel(self)
            login.title(f"üîê Login {NAME}")
            login.resizable(False, False)
            login.configure(bg="black")
            def chiusura():
                self._on_close_lock()
                self.quit()
                self.destroy()
            login.protocol("WM_DELETE_WINDOW", chiusura)
            w, h = 380, 230
            x = self.winfo_screenwidth() // 2 - w // 2
            y = self.winfo_screenheight() // 2 - h // 2
            login.geometry(f"{w}x{h}+{x}+{y}")
            login.deiconify()
            login.lift()
            login.focus_force()
            login.grab_set()
            if os.path.exists(PW_FILE):
                tk.Label(login, text=f"Utente:‚ñ∫ {current_folder} \n\nüîë Inserisci la password: ‚Üµ\n",
                         font=("Arial", 8, "bold"), bg="black", fg="white").pack(pady=(15, 5))
            else:
                tk.Label(login, text=f"üÜï PRIMO ACCESSO \n\n Utente:‚ñ∫ {current_folder} \n\nüîê Crea una nuova password per proteggere i tuoi dati. ‚Üµ\n ", 
                         font=("Arial", 8, "bold"), bg="black", fg="white").pack(pady=(15, 5))
            entry_pw = crea_campo_password(login)
            entry_pw.focus()
            messaggio_errore = tk.Label(login, text="", fg="red", font=("Arial", 8), bg="black")
            messaggio_errore.pack()
            def conferma_login():
                nonlocal tentativi_falliti
                inserita = entry_pw.get()
                salvata = leggi_hash()
                if not salvata:
                    salva_hash(inserita)
                    messaggio_errore.config(text="‚úÖ Password creata con successo.", fg="lightgreen")
                    login_riuscito[0] = True
                    login.after(1500, login.destroy)
                elif hash_pw(inserita) == salvata:
                    login_riuscito[0] = True
                    login.destroy()
                else:
                    tentativi_falliti += 1 
                    entry_pw.delete(0, tk.END)
                    if tentativi_falliti >= MAX_TENTATIVI:
                        messaggio_errore.config(
                            text=f"‚ùå Password errata. Tentativi esauriti ({MAX_TENTATIVI}). Chiusura in corso...", 
                            fg="red"
                        )
                        login.after(2000, chiusura)
                        return
                    tentativi_rimanenti = MAX_TENTATIVI - tentativi_falliti
                    messaggio_errore.config(
                        text=f"‚ùå Password errata. Restano {tentativi_rimanenti} tentativi."
                    )
            tk.Button(
                login, text="Login", command=conferma_login, font=("Arial", 8, "bold"),
                bg="#4CAF50", fg="white", activebackground="#45A049", activeforeground="white", relief="raised"
            ).pack(pady=7)
            entry_pw.bind("<Return>", lambda e: conferma_login())
            entry_pw.bind("<KP_Enter>", lambda e: conferma_login())
            login.bind("<Escape>", lambda e: login.destroy())
            if os.path.exists(PW_FILE):
                tk.Button(
                    login, text="üîÅ Cambia password", command=cambia_password,
                    bg="#2196F3", fg="white", activebackground="#1976D2", activeforeground="white",
                    relief="raised", font=("Arial", 8, "bold"), cursor="hand2"
                ).pack(pady=(2, 8))
            login.wait_window()
        if ("noweb" not in args) and ABILITA_WEBSERVER:
            threading.Thread(target=self.start_web_server, daemon=True).start()
            print("üåê Server web avviato.")
        else:
            print("üõë Server web disattivato.")
        if "auto" in args:
            index = args.index("auto")
            arg_password = args[index + 1] if len(args) > index + 1 else ""
            salvata = leggi_hash()
            if salvata and hash_pw(arg_password) == salvata:
                print("‚úÖ Login automatico riuscito.")
                login_riuscito[0] = True
                self.after(500, self._iconizza_finestra_startup)
                return login_riuscito[0]
            else:
                print("‚ùå Password da argomento non valida. Apro GUI...")
        if ("auto" not in args) and AUTO_ICONIZE_STARTUP:
            salvata = leggi_hash()
            if salvata and hash_pw("") == salvata:
                print("‚úÖ Login bypassato (Password disattivata + Iconizza all'avvio).")
                login_riuscito[0] = True
                self.after(500, self._iconizza_finestra_startup)
                return login_riuscito[0]
        if not login_riuscito[0]:
            mostra_finestra_login()
        return login_riuscito[0]
    
    # Importa da Estratti Bancari
    def apri_finestra_importa(self):
        win = tk.Toplevel(self)
        win.title("Importa Spese")
        larghezza, altezza = 300, 160
        x = (win.winfo_screenwidth() // 2) - (larghezza // 2)
        y = (win.winfo_screenheight() // 2) - (altezza // 2)
        win.geometry(f"{larghezza}x{altezza}+{x}+{y}")
        win.resizable(False, False)
        win.grab_set()
        win.configure(bg="#F9F9D1") 
        tk.Label(win, text="Seleziona la banca:", font=("Arial", 10), bg="#F9F9D1").pack(pady=(10, 4))
        banca_var = tk.StringVar()
        banca_combo = ttk.Combobox(win, textvariable=banca_var, style="Border.TCombobox", state="readonly", values=["-- Nessuna --", "UniCredit", "Intesa", "Fineco", "Altra..."])
        banca_combo.set("-- Nessuna --")  
        banca_combo.pack()
        frame_bottoni = tk.Frame(win, bg="#F9F9D1")
        frame_bottoni.pack(pady=10)
        btn_icc = ttk.Button(frame_bottoni, text="üí≥ ICC", width=10, style="Verde.TButton", command=lambda: [win.destroy(), self.importa_spese_csv_unicredit()])
        btn_ccv = ttk.Button(frame_bottoni, text="üè¶ CCV", width=10, style="Verde.TButton", command=lambda: [win.destroy(), self.importa_spese_cc_csv_unicredit()])
        btn_icc.pack(side="left", padx=8)
        btn_ccv.pack(side="right", padx=8)
        btn_icc.pack_forget()
        btn_ccv.pack_forget()
        messaggio_var = tk.StringVar()
        label_messaggio = tk.Label(win, textvariable=messaggio_var, font=("Arial", 9), bg="#F9F9D1", fg="gray25")
        label_messaggio.pack(pady=(6, 2))
        def mostra_bottoni(event=None):
            banca = banca_var.get()
            if banca == "UniCredit":
                messaggio_var.set("‚úÖ Importazione disponibile per UniCredit:")
                btn_icc.pack(side="left", padx=8)
                btn_ccv.pack(side="right", padx=8)
            else:
                btn_icc.pack_forget()
                btn_ccv.pack_forget()
                messaggio_var.set(f"‚ö†Ô∏è Importazione da {banca} non ancora disponibile.")
        banca_combo.bind("<<ComboboxSelected>>", mostra_bottoni)
    def importa_spese_csv_unicredit(self):
        from datetime import datetime
        path = filedialog.askopenfilename(
            title="Seleziona Estratto CARTA UNICREDIT",
            filetypes=[("File CSV", "*.csv")]
        )
        if not path:
            return
        movimenti = []
        try:
            with open(path, newline="", encoding="utf-8") as f:
                reader = csv.DictReader(f, delimiter=";")
                for row in reader:
                    try:
                        data = datetime.strptime(row["Data Registrazione"], "%d/%m/%Y").date()
                        descrizione = row["Descrizione"].strip()
                        importo = float(row["Importo"].replace(",", "."))
                        movimenti.append({"data": data, "descrizione": descrizione, "importo": importo})
                    except Exception as e:
                        print("Errore riga:", row, "‚Üí", e)
        except Exception as e:
            self.show_custom_warning("Errore apertura CSV", str(e))
            return
        if not movimenti:
            self.show_custom_warning("Importazione", "Nessuna spesa valida trovata.")
            return
        movimenti.sort(key=lambda m: m["data"])
        if not hasattr(self, "memoria_descrizioni_categoria"):
            self.memoria_descrizioni_categoria = {}
        memoria = self.memoria_descrizioni_categoria
        win = tk.Toplevel(self)
        win.resizable(False, False)
        win.title("Importa da Unicredit Credit Card")
        larghezza, altezza = 820, 600
        x = (win.winfo_screenwidth() // 2) - (larghezza // 2)
        y = (win.winfo_screenheight() // 2) - (altezza // 2)
        win.geometry(f"{larghezza}x{altezza}+{x}+{y}")
        win.update_idletasks()
        win.grab_set()
        contenitore = tk.Frame(win)
        contenitore.pack(fill="both", expand=True)
        canvas = tk.Canvas(contenitore, highlightthickness=0)
        scrollbar = ttk.Scrollbar(contenitore, orient="vertical", command=canvas.yview)
        canvas.configure(yscrollcommand=scrollbar.set)
        canvas.pack(side="left", fill="both", expand=True)
        scrollbar.pack(side="right", fill="y")
        area_dati = tk.Frame(canvas)
        canvas.create_window((0, 0), window=area_dati, anchor="nw")
        area_dati.bind("<Configure>", lambda e: canvas.configure(scrollregion=canvas.bbox("all")))
        pannello_aggiungi_cat = tk.Frame(area_dati)
        pannello_aggiungi_cat.pack(anchor="w", pady=(6, 6), padx=4)
        tk.Label(pannello_aggiungi_cat, text="‚ûï Nuova categoria:", foreground="green").pack(side="left", padx=(0, 4))
        var_nuova_cat = tk.StringVar()
        entry_nuova_cat = ttk.Entry(pannello_aggiungi_cat, textvariable=var_nuova_cat, width=20)
        entry_nuova_cat.pack(side="left")
        def aggiungi_categoria_csv():
            nome = var_nuova_cat.get().strip()
            if not nome:
                self.show_custom_warning("Attenzione", "Il nome categoria √® vuoto.")
                return
            if nome in self.categorie:
                self.show_custom_warning("Attenzione", "Categoria gi√† esistente.")
                return
            self.categorie.append(nome)
            self.categorie_tipi[nome] = "Uscita"
            memoria[nome.strip().upper()] = nome
            var_nuova_cat.set("")
            for _, _, combo in righe:
                combo["values"] = self.categorie
            self.aggiorna_combobox_categorie()
            self.show_custom_info("Categoria creata", f"Categoria '{nome}' aggiunta.")
        btn_aggiungi_cat = ttk.Button(
            pannello_aggiungi_cat,
            text="Aggiungi",
            command=aggiungi_categoria_csv,
            style="Verde.TButton"
        )
        btn_aggiungi_cat.pack(side="left", padx=6)
        entry_nuova_cat.bind("<Return>", lambda e: aggiungi_categoria_csv())
        entry_nuova_cat.bind("<KP_Enter>", lambda e: aggiungi_categoria_csv())
        righe = []
        seleziona_tutti_var = tk.BooleanVar(value=True)
        def toggle_tutti():
            for _, var_check, _ in righe:
                var_check.set(seleziona_tutti_var.get())
        tk.Checkbutton(area_dati, text="‚úî Seleziona tutto", variable=seleziona_tutti_var, command=toggle_tutti).pack(anchor="w", pady=(5, 2))
        header = tk.Frame(area_dati)
        header.pack(anchor="w")
        tk.Label(header, text="‚úî", width=2).grid(row=0, column=0)
        tk.Label(header, text="Data", width=10).grid(row=0, column=1)
        tk.Label(header, text="Descrizione", width=40, anchor="w").grid(row=0, column=2)
        tk.Label(header, text="Importo", width=12, anchor="e").grid(row=0, column=3)
        tk.Label(header, text="Categoria", width=20).grid(row=0, column=4)
        for mov in movimenti:
            riga = tk.Frame(area_dati)
            riga.pack(anchor="w", pady=1)
            var = tk.BooleanVar(value=True)
            tk.Checkbutton(riga, variable=var).grid(row=0, column=0)
            tk.Label(riga, text=mov["data"].strftime("%d/%m/%Y"), width=10).grid(row=0, column=1)
            tk.Label(riga, text=mov["descrizione"], width=40, anchor="w").grid(row=0, column=2)
            tk.Label(riga, text=f"{mov['importo']:.2f} ‚Ç¨", width=12, anchor="e").grid(row=0, column=3)
            chiave = mov["descrizione"].strip().upper()
            categoria = memoria.get(chiave, "Generica")
            combo = ttk.Combobox(riga, values=self.categorie, style="Border.TCombobox", state="readonly", width=20)
            combo.set(categoria)
            combo.grid(row=0, column=4, padx=4)
            righe.append((mov, var, combo))
        bottoni = tk.Frame(win)
        bottoni.pack(pady=10)
        def salva():
            count = 0
            duplicati = 0
            for mov, var, combo in righe:
                if var.get():
                    giorno = mov["data"]
                    descr = mov["descrizione"]
                    imp = abs(mov["importo"])
                    tipo = "Entrata" if mov["importo"] >= 0 else "Uscita"
                    cat = combo.get() or "Generica"
                    voce = (cat, descr, imp, tipo)
                    gia_presente = None
                    for voce_esistente in self.spese.get(giorno, []):
                        cat_es, desc_es, imp_es, tipo_es = voce_esistente
                        if (
                            cat_es == cat and
                            tipo_es == tipo and
                            round(imp_es) == round(imp)
                        ):
                            gia_presente = voce_esistente
                            break
                    if gia_presente:
                        if self.conferma_sostituzione_spesa(giorno, cat, imp_es, imp):
                                self.spese[giorno].remove(gia_presente)
                        else:
                                duplicati += 1
                                continue
                    self.spese.setdefault(giorno, []).append(voce)
                    memoria[descr.strip().upper()] = cat
                    count += 1
            self.save_db()
            self.refresh_gui()
            messaggio = f"{count} Movimenti importati/salvati."
            if duplicati > 0:
                messaggio += f"\n‚ö†Ô∏è {duplicati} duplicate/ignorate."
            self.show_custom_warning("Completato", messaggio)
        def chiudi():
            win.destroy()
            self.show_custom_warning("Annullato", "Importazione interrotta.")     
        ttk.Button(bottoni, text="üíæ Salva", style="Verde.TButton", width=12, command=salva).pack(side="left", padx=10)
        ttk.Button(bottoni, text="‚úñ Chiudi", style="Giallo.TButton", width=12, command=chiudi).pack(side="right", padx=10)
    def importa_spese_cc_csv_unicredit(self):
        from datetime import datetime
        path = filedialog.askopenfilename(
            title="Seleziona Estratto Conto UNICREDIT",
            filetypes=[("File CSV", "*.csv")]
        )
        if not path:
            return
        movimenti = []
        try:
            with open(path, newline="", encoding="utf-8") as f:
                reader = csv.DictReader(f, delimiter=";")
                for row in reader:
                    try:
                        data_str = row["Data Registrazione"].strip()
                        try:
                            data = datetime.strptime(data_str, "%d/%m/%Y").date()
                        except ValueError:
                            data = datetime.strptime(data_str, "%d.%m.%Y").date()
                        descrizione = row["Descrizione"].strip()
                        importo_str = row["Importo (EUR)"].strip().replace(".", "").replace(",", ".")
                        importo = float(importo_str)
                        movimenti.append({"data": data, "descrizione": descrizione, "importo": importo})
                    except Exception as e:
                        print("Errore riga:", row, "‚Üí", e)
        except Exception as e:
            self.show_custom_warning("Errore apertura CSV", str(e))
            return
        if not movimenti:
            self.show_custom_warning("Importazione", "Nessuna spesa valida trovata.")
            return
        movimenti.sort(key=lambda m: m["data"])
        if not hasattr(self, "memoria_descrizioni_categoria"):
            self.memoria_descrizioni_categoria = {}
        memoria = self.memoria_descrizioni_categoria
        win = tk.Toplevel(self)
        win.resizable(False, False)
        win.title("Importa da Unicredit C/C")
        larghezza, altezza = 820, 600
        x = (win.winfo_screenwidth() // 2) - (larghezza // 2)
        y = (win.winfo_screenheight() // 2) - (altezza // 2)
        win.geometry(f"{larghezza}x{altezza}+{x}+{y}")
        win.update_idletasks()
        win.grab_set()
        contenitore = tk.Frame(win)
        contenitore.pack(fill="both", expand=True)
        canvas = tk.Canvas(contenitore, highlightthickness=0)
        scrollbar = ttk.Scrollbar(contenitore, orient="vertical", command=canvas.yview)
        canvas.configure(yscrollcommand=scrollbar.set)
        canvas.pack(side="left", fill="both", expand=True)
        scrollbar.pack(side="right", fill="y")
        area_dati = tk.Frame(canvas)
        canvas.create_window((0, 0), window=area_dati, anchor="nw")
        area_dati.bind("<Configure>", lambda e: canvas.configure(scrollregion=canvas.bbox("all")))
        pannello_aggiungi_cat = tk.Frame(area_dati)
        pannello_aggiungi_cat.pack(anchor="w", pady=(6, 6), padx=4)
        tk.Label(pannello_aggiungi_cat, text="‚ûï Nuova categoria:", foreground="green").pack(side="left", padx=(0, 4))
        var_nuova_cat = tk.StringVar()
        entry_nuova_cat = ttk.Entry(pannello_aggiungi_cat, textvariable=var_nuova_cat, width=20)
        entry_nuova_cat.pack(side="left")
        def aggiungi_categoria_csv():
            nome = var_nuova_cat.get().strip()
            if not nome:
                self.show_custom_warning("Attenzione", "Il nome categoria √® vuoto.")
                return
            if nome in self.categorie:
                self.show_custom_warning("Attenzione", "Categoria gi√† esistente.")
                return
            self.categorie.append(nome)
            self.categorie_tipi[nome] = "Uscita"
            memoria[nome.strip().upper()] = nome
            var_nuova_cat.set("")
            for _, _, combo in righe:
                combo["values"] = self.categorie
            self.aggiorna_combobox_categorie()
            self.show_custom_info("Categoria creata", f"Categoria '{nome}' aggiunta.")
        btn_aggiungi_cat = ttk.Button(
            pannello_aggiungi_cat,
            text="Aggiungi",
            command=aggiungi_categoria_csv,
            style="Verde.TButton"
        )
        btn_aggiungi_cat.pack(side="left", padx=6)
        entry_nuova_cat.bind("<Return>", lambda e: aggiungi_categoria_csv())
        entry_nuova_cat.bind("<KP_Enter>", lambda e: aggiungi_categoria_csv())
        righe = []
        seleziona_tutti_var = tk.BooleanVar(value=True)
        def toggle_tutti():
            for _, var_check, _ in righe:
                var_check.set(seleziona_tutti_var.get())
        tk.Checkbutton(area_dati, text="‚úî Seleziona tutto", variable=seleziona_tutti_var, command=toggle_tutti).pack(anchor="w", pady=(5, 2))
        intest = tk.Frame(area_dati)
        intest.pack(anchor="w")
        tk.Label(intest, text="‚úî", width=2).grid(row=0, column=0)
        tk.Label(intest, text="Data", width=10).grid(row=0, column=1)
        tk.Label(intest, text="Descrizione", width=40, anchor="w").grid(row=0, column=2)
        tk.Label(intest, text="Importo", width=12, anchor="e").grid(row=0, column=3)
        tk.Label(intest, text="Categoria", width=20).grid(row=0, column=4)
        for mov in movimenti:
            riga = tk.Frame(area_dati)
            riga.pack(anchor="w", pady=1)
            var = tk.BooleanVar(value=True)
            tk.Checkbutton(riga, variable=var).grid(row=0, column=0)
            tk.Label(riga, text=mov["data"].strftime("%d/%m/%Y"), width=10).grid(row=0, column=1)
            tk.Label(riga, text=mov["descrizione"], width=40, anchor="w").grid(row=0, column=2)
            tk.Label(riga, text=f"{mov['importo']:.2f} ‚Ç¨", width=12, anchor="e").grid(row=0, column=3)
            chiave = mov["descrizione"].strip().upper()
            categoria = memoria.get(chiave, "Generica")
            combo = ttk.Combobox(riga, values=self.categorie, style="Border.TCombobox", state="readonly", width=20)
            combo.set(categoria)
            combo.grid(row=0, column=4, padx=4)
            righe.append((mov, var, combo))
        bottoni = tk.Frame(win)
        bottoni.pack(pady=10)
        def salva():
            count = 0
            duplicati = 0
            for mov, var, combo in righe:
                if var.get():
                    giorno = mov["data"]
                    descr = mov["descrizione"]
                    imp = abs(mov["importo"])
                    tipo = "Entrata" if mov["importo"] >= 0 else "Uscita"
                    cat = combo.get() or "Generica"
                    voce = (cat, descr, imp, tipo)
                    if voce in self.spese.get(giorno, []):
                        duplicati += 1
                        continue
                    self.spese.setdefault(giorno, []).append(voce)
                    memoria[descr.strip().upper()] = cat
                    count += 1
            self.save_db()
            self.refresh_gui()
            try:
                with open("memoria_categorie.json", "w", encoding="utf-8") as f:
                    json.dump(memoria, f, ensure_ascii=False, indent=2)
            except Exception as e:
                print("‚ö†Ô∏è Impossibile salvare memoria categorie:", e)
            messaggio = f"{count} Movimenti importati/salvati."
            if duplicati > 0:
                messaggio += f"\n‚ö†Ô∏è {duplicati} duplicate/ignorate."
            self.show_custom_warning("Completato", messaggio)
        def chiudi():
            win.destroy()
            self.show_custom_warning("Annullato", "Importazione interrotta.")
        ttk.Button(bottoni, text="üíæ Salva", style="Verde.TButton", command=salva).pack(side="left", padx=10)
        ttk.Button(bottoni, text="‚ùå Chiudi", style="Giallo.TButton", command=chiudi).pack(side="right", padx=10)
    def conferma_sostituzione_spesa(self, giorno, categoria, imp_esistente, imp_nuovo):
        popup = tk.Toplevel(self)
        popup.title("Sostituisci spesa?")
        popup.resizable(False, False)
        width, height = 400, 160
        popup.withdraw()
        popup.update_idletasks()
        x = self.winfo_rootx() + (self.winfo_width() // 2) - (width // 2)
        y = self.winfo_rooty() + (self.winfo_height() // 2) - (height // 2)
        popup.geometry(f"{width}x{height}+{x}+{y}")
        popup.configure(bg="#FFFACD")
        popup.deiconify()
        popup.grab_set()
        msg = (
            f"Esiste gi√† una spesa nella categoria ‚Äú{categoria}‚Äù il {giorno.strftime('%d/%m/%Y')} "
            f"da ‚Ç¨{imp_esistente:.2f}.\n\nVuoi sostituirla con la nuova da ‚Ç¨{imp_nuovo:.2f}?"
        )
        label = tk.Label(
            popup,
            text=msg,
            font=("Arial", 10),
            justify="center",
            wraplength=360,
            bg="#FFFACD"
        )
        label.pack(pady=12, padx=16)
        frame = tk.Frame(popup, bg="#FFFACD")
        frame.pack(pady=4)
        result = {"ok": False}
        def conferma():
            result["ok"] = True
            popup.destroy()
        def annulla():
            popup.destroy()
        ttk.Button(frame, text="Sostituisci", style="Verde.TButton", width=12, command=conferma).pack(side="left", padx=10)
        ttk.Button(frame, text="Annulla", style="Giallo.TButton", width=12, command=annulla).pack(side="right", padx=10)
        self.wait_window(popup)
        return result["ok"]

    # Proiezione Annuale e Confronto Spese Storiche
    def calcola_statistiche_annuali(self):
        from datetime import date
        import calendar
        oggi = date.today()
        anno_corr = oggi.year
        anno_prec = anno_corr - 1
        mese_corr = oggi.month
        tot_mese_corr, tot_mese_prec = 0.0, 0.0
        tot_anno_corr_parz, tot_anno_prec_parz = 0.0, 0.0
        tot_anno_prec_totale = 0.0
        for giorno, voci in self.spese.items():
            if giorno.year not in [anno_corr, anno_prec]:
                continue
            for voce in voci:
                if len(voce) < 4 or voce[3] != "Uscita":
                    continue
                importo = voce[2]
                if giorno.year == anno_corr:
                    if giorno <= oggi:
                        tot_anno_corr_parz += importo
                    if giorno.month == mese_corr:
                        tot_mese_corr += importo
                elif giorno.year == anno_prec:
                    tot_anno_prec_totale += importo
                    if giorno.month == mese_corr:
                        tot_mese_prec += importo
                    if (giorno.month, giorno.day) <= (oggi.month, oggi.day):
                        tot_anno_prec_parz += importo
        giorni_tot_anno = 366 if calendar.isleap(anno_corr) else 365
        giorni_passati = (oggi - date(anno_corr, 1, 1)).days + 1
        perc_corr = giorni_passati / giorni_tot_anno
        proiezione_corr = tot_anno_corr_parz / perc_corr if perc_corr else 0.0
        var_mese_pct = (tot_mese_corr - tot_mese_prec) / tot_mese_prec * 100 if tot_mese_prec else 0.0
        differenza = tot_anno_prec_totale - proiezione_corr
        report = f"""
    üìä REPORT PROIEZIONE SPESE ‚Äì {oggi.strftime('%d/%m/%Y')}
    
    ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    üìÖ Mese corrente: {mese_corr:02}/{anno_corr}
    ‚ñ∏ Uscite attuali {anno_corr}      : ‚Ç¨ {tot_mese_corr:>10,.2f}
    ‚ñ∏ Stesso mese {anno_prec}         : ‚Ç¨ {tot_mese_prec:>10,.2f}
    
    ‚ñ∏ Variazione rispetto a {mese_corr:02}/{anno_prec} : {var_mese_pct:+.1f}%
    
    ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    üìÜ Da inizio anno (01/01 ‚Üí oggi)
    ‚ñ∏ Totale uscite {anno_corr}       : ‚Ç¨ {tot_anno_corr_parz:>10,.2f}
    ‚ñ∏ Stesso periodo {anno_prec}      : ‚Ç¨ {tot_anno_prec_parz:>10,.2f}

    ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    üìà Spesa a confronto annuale
    ‚ñ∏ Spesa effettiva {anno_prec}     : ‚Ç¨ {tot_anno_prec_totale:>10,.2f}
    ‚ñ∏ Proiezione {anno_corr}          : ‚Ç¨ {proiezione_corr:>10,.2f}   (basata su {perc_corr:.1%} dell‚Äôanno trascorso)

    ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    """
        if differenza > 0:
            report += f"\nüìâ Risparmio previsto: ‚Ç¨ {differenza:,.2f} se mantieni l‚Äôandamento attuale ‚ú®üí∞‚ú®"
        else:
            report += f"\n‚ö†Ô∏è Spesa stimata superiore di ‚Ç¨ {abs(differenza):,.2f} rispetto al {anno_prec} üìâü™ô"
        self.mostra_report_popup(report.strip())
    def mostra_report_popup(self, testo):
        if not hasattr(self, '_report_popup'):
            self._report_popup = None
        if self._report_popup and self._report_popup.winfo_exists():
            self._report_popup.lift()
            return
        preview = tk.Toplevel(self)
        self._report_popup = preview
        def on_report_close():
            preview.destroy()
            self._report_popup = None
        preview.withdraw()
        preview.title("üìä Report Proiezione Annuale")
        width, height = 860, 530
        self.update_idletasks()
        x = self.winfo_rootx() + (self.winfo_width() - width) // 2
        y = self.winfo_rooty() + (self.winfo_height() - height) // 2
        preview.geometry(f"{width}x{height}+{x}+{y}")
        preview.transient(self)
        preview.configure(bg=self.COLOR_WIDGET_BG )
        preview.deiconify()
        preview.protocol("WM_DELETE_WINDOW", on_report_close)
        preview.bind("<Escape>", lambda e: on_report_close())
        text_area = tk.Text(preview, 
                           font=("Courier new", 10), 
                           bg=self.COLOR_WIDGET_BG , 
                           fg=self.COLOR_TEXT, 
                           insertbackground=self.COLOR_TEXT,
                           wrap="word", 
                           relief="flat",
                           borderwidth=0,
                           highlightthickness=0,
                           padx=20, 
                           pady=20)
        text_area.insert("1.0", testo)
        text_area.config(state="disabled")
        text_area.pack(fill="both", expand=True)
        def save_file():
            try:
                initial_dir = EXPORT_FILES
            except NameError:
                initial_dir = os.path.expanduser("~")
            now = datetime.date.today()
            fname = f"Report_Export_{now.day:02d}-{now.month:02d}-{now.year}.txt"
            file = filedialog.asksaveasfilename(defaultextension=".txt", filetypes=[("File txt", "*.txt")], initialdir=initial_dir, initialfile=fname, title="Salva Report", confirmoverwrite=False, parent=preview)
            if file:
                if os.path.exists(file):
                    if not self.show_custom_askyesno("Sovrascrivere file?", f"Il file '{os.path.basename(file)}' \nesiste gi√†. Sovrascrivere?"):
                        return
                with open(file, "w", encoding="utf-8") as f:
                    f.write(testo)
                on_report_close()
                self.show_custom_warning("Esportazione completata", f"Report esportato in:\n{file}")
        frame_bottoni = tk.Frame(preview, bg=self.COLOR_WIDGET_BG)
        frame_bottoni.pack(fill="x", padx=20, pady=20)
        ttk.Button(frame_bottoni, text="üìÑ Esporta", style="Arancio.TButton", command=save_file).pack(side="left")
        ttk.Button(frame_bottoni, text="‚ùå Chiudi", style="Giallo.TButton", command=on_report_close).pack(side="right")

    # Finestra di Cancellazione Multipla Categorie
    def apri_cancella_multiplo(self):
        popup = tk.Toplevel(self,bg=self.COLOR_TOPLEVEL)
        popup.title("Cancella Categorie")
        popup.resizable(True, True)
        larghezza, altezza = 400, 500
        x = self.winfo_x() + (self.winfo_width() // 2) - (larghezza // 2)
        y = self.winfo_y() + (self.winfo_height() // 2) - (altezza // 2)
        popup.geometry(f"{larghezza}x{altezza}+{x}+{y}")
        popup.grab_set()
        tk.Label(
            popup,
            text="Seleziona le categorie da cancellare:",
            bg=self.COLOR_TOPLEVEL,
            fg=self.TEXT_COLOR,
            font=("Arial", 10, "bold")
        ).pack(pady=(10, 5))
        self.elimina_spese_var = tk.BooleanVar()
        tk.Checkbutton(
            popup,
            text="Elimina anche Movimenti associati",
            variable=self.elimina_spese_var,
            anchor="w",
            bg="yellow",       
            activebackground="gold"  
        ).pack(fill="x", padx=15, pady=(5, 0))
        contenitore = tk.Frame(popup, bg=self.COLOR_TOPLEVEL)
        contenitore.pack(fill="both", expand=True, padx=10, pady=5)
        canvas = tk.Canvas(contenitore, bg=self.COLOR_TOPLEVEL)
        scrollbar = ttk.Scrollbar(contenitore, orient="vertical", command=canvas.yview)
        canvas.configure(yscrollcommand=scrollbar.set)
        scrollbar.pack(side="right", fill="y")
        canvas.pack(side="left", fill="both", expand=True)
        scroll_frame = tk.Frame(canvas, bg=self.COLOR_TOPLEVEL)
        window_id = canvas.create_window((0, 0), window=scroll_frame, anchor="nw")
        def resize_scroll_frame(event):
            canvas.itemconfig(window_id, width=event.width)
        canvas.bind("<Configure>", resize_scroll_frame)
        def aggiorna_scroll(event):
             canvas.configure(scrollregion=canvas.bbox("all"))
        scroll_frame.bind("<Configure>", aggiorna_scroll)
        def aggiorna_scroll(event):
            canvas.configure(scrollregion=canvas.bbox("all"))
        scroll_frame.bind("<Configure>", aggiorna_scroll)
        self.checkbox_vars = {}
        for cat in sorted(set(self.categorie), key=lambda c: c.lower()):
            if cat not in ("Generica", self.CATEGORIA_RIMOSSA):
                var = tk.BooleanVar()
                chk = tk.Checkbutton(
                    scroll_frame,
                    text=cat, 
                    variable=var, 
                    anchor="w",
                    bg=self.COLOR_TOPLEVEL,
                    fg=self.TEXT_COLOR,
                    activebackground=self.COLOR_TOPLEVEL,
                    activeforeground=self.TEXT_COLOR,
                    selectcolor=self.COLOR_TOPLEVEL,
                    highlightthickness=0
                )
                chk.pack(fill="x", padx=5, pady=2)
                self.checkbox_vars[cat] = var
        btn_frame = tk.Frame(popup, bg=self.COLOR_TOPLEVEL)
        btn_frame.pack(pady=10)
        ttk.Button(
            btn_frame,
            text="Elimina Selezionate",
            style="Rosso.TButton",
            command=lambda: self.cancella_categorie_checkbox(popup)
        ).pack(side="left", padx=5)
        ttk.Button(
            btn_frame,
            text="‚ùå Chiudi",
            style="Giallo.TButton",
            command=popup.destroy
        ).pack(side="left", padx=5)
    def cancella_categorie_checkbox(self, popup):
        selezionate = [cat for cat, var in self.checkbox_vars.items() if var.get()]
        if not selezionate:
            self.show_custom_warning("Attenzione", "Seleziona almeno una categoria da cancellare.")
            return
        testo_conferma = f"Sei sicuro di voler cancellare le seguenti categorie?\n\n"
        conferma = self.show_custom_askyesno("Elimina", testo_conferma)
        if not conferma:
            return
        for cat in selezionate:
            if cat in self.categorie:
                self.categorie.remove(cat)
            if cat in self.categorie_tipi:
                del self.categorie_tipi[cat]
            for giorno in list(self.spese.keys()):
                nuove_spese = []
                for voce in self.spese[giorno]:
                    voce_cat = voce[0]
                    if voce_cat == cat:
                         if not self.elimina_spese_var.get():
                             nuove_spese.append((self.CATEGORIA_RIMOSSA,) + voce[1:])
                    else:
                        nuove_spese.append(voce)
                self.spese[giorno] = nuove_spese
        self.show_custom_warning("Rimosse", f"‚úÖ {len(selezionate)} categorie sono state cancellate.")
        popup.destroy()
        self.save_db()
        self.refresh_gui()
        self.aggiorna_combobox_categorie()
    
    # Finestra Aggiunta Categorie Suggerite
    def apri_categorie_suggerite(self):
        CATEGORIE_SUGGERITE = [
            # üè† Casa & Famiglia
            "üè† Casa",
            "üè† Affitto Immobile",
            "üè† Mutuo Immobile",
            "üè° Manutenzione casa",
            "üí° Utenze (Luce)",
            "üî• Utenze (Gas)",
            "üöø Utenze (Acqua)",
            "‚ô®Ô∏è Caldaia",
            "üå∞ Pellet",
            "üóëÔ∏è Tassa Rifiuti",
            "üè† Pulizie domestiche",
            "üõãÔ∏è Arredamento",
            "üêæ Animali domestici",
            "üè† Assicurazione Immobile",
            # üçΩÔ∏è Alimentari & Consumi
            "üçΩÔ∏è Alimentari & Consumi",
            "üõí Spesa supermercato",
            "üçû Spesa Discount",
            "‚òï Colazioni / Caff√® fuori",
            "üçΩÔ∏è Pranzi / Ristoranti",
            "üçï Asporto / Fast food",
            # üöó Veicoli & Trasporti
            "üöó Veicoli & Trasporti",
            "‚õΩ Carburante",
            "üõ†Ô∏è Manutenzione auto",
            "üìÖ Bollo auto",
            "üè• Assicurazione veicoli",
            "üöá Trasporti pubblici",
            "üöï Taxi / Car sharing",
            # üí° Bollette & Abbonamenti
            "üí° Bollette & Abbonamenti",
            "üì± Telefonia / Internet",
            "üì± Telefonia / Cellulari",
            "üíª Streaming (Netflix, Prime...)",
            "üîê Servizi cloud / backup",
            "üéÆ Abbonamenti digitali",
            # ü©∫ Salute & Benessere
            "ü©∫ Salute & Benessere",
            "üíä Farmaci",
            "üë®‚Äç‚öïÔ∏è Visite mediche",
            "üè• Dentista",
            "üßò‚Äç‚ôÇÔ∏è Wellness / Spa",
            "üèãÔ∏è‚Äç‚ôÄÔ∏è Palestra / Fitness",
            # üéì Istruzione & Lavoro
            "üéì Istruzione & Lavoro",
            "üìö Libri / Materiali",
            "üßë‚Äçüè´ Corsi / Formazione",
            "üíª Software",
            "üóÇÔ∏è Utenze professionali / Partita IVA",
            # üéâ Tempo libero & Spese personali
            "üéâ Tempo libero & Spese personali",
            "üéÅ Regali",
            "üé¨ Cinema / Eventi",
            "üéÆ Videogiochi",
            "üéÆ Computer",
            "üß• Abbigliamento",
            "üéÅ Tabacchi",
            "üíá Parrucchiere / Estetica",
            "‚úàÔ∏è Viaggi / Hotel",
            # üí∏ Finanza & Risparmio
            "üí∏ Stipendio",
            "üí∏ Pensione",
            "üí∏ Entrate Extra",
            "üí∏ Finanza & Risparmio",
            "üè¶ Conto corrente",
            "üí≥ Rate / Finanziamenti",
            "üí∞ Commercialista",
            # üì§ Uscite straordinarie
            "üì§ Uscite straordinarie",
            "üè• Emergenze",
            "üõ†Ô∏è Riparazioni impreviste",
            "üì¶ Spese non ricorrenti"
        ]
        TIPO_SUGGERITI = {
            "Casa": "Uscita",
            "Affitto Immobile": "Uscita",
            "Mutuo Immobile": "Uscita",
            "Manutenzione casa": "Uscita",
            "Utenze (Luce)": "Uscita",
            "Utenze (Gas)": "Uscita",
            "Utenze (Acqua)": "Uscita",
            "Caldaia": "Uscita",
            "Pellet": "Uscita",
            "Tassa Rifiuti": "Uscita",
            "Pulizie domestiche": "Uscita",
            "Arredamento": "Uscita",
            "Animali domestici": "Uscita",
            "Assicurazione Immobile": "Uscita",
            "Alimentari & Consumi": "Uscita",
            "Spesa supermercato": "Uscita",
            "Spesa Discount": "Uscita",
            "Colazioni / Caff√® fuori": "Uscita",
            "Pranzi / Ristoranti": "Uscita",
            "Asporto / Fast food": "Uscita",
            "Veicoli & Trasporti": "Uscita",
            "Carburante": "Uscita",
            "Manutenzione auto": "Uscita",
            "Bollo auto": "Uscita",
            "Assicurazione veicoli": "Uscita",
            "Trasporti pubblici": "Uscita",
            "Taxi / Car sharing": "Uscita",
            "Bollette & Abbonamenti": "Uscita",
            "Telefonia / Internet": "Uscita",
            "Telefonia / Cellulari": "Uscita",
            "Streaming (Netflix, Prime...)": "Uscita",
            "Servizi cloud / backup": "Uscita",
            "Abbonamenti digitali": "Uscita",
            "Salute & Benessere": "Uscita",
            "Farmaci": "Uscita",
            "Visite mediche": "Uscita",
            "Dentista": "Uscita",
            "Wellness / Spa": "Uscita",
            "Palestra / Fitness": "Uscita",
            "Istruzione & Lavoro": "Uscita",
            "Libri / Materiali": "Uscita",
            "Corsi / Formazione": "Uscita",
            "Software": "Uscita",
            "Utenze professionali / Partita IVA": "Uscita",
            "Tempo libero & Spese personali": "Uscita",
            "Regali": "Uscita",
            "Cinema / Eventi": "Uscita",
            "Videogiochi": "Uscita",
            "Computer": "Uscita",
            "Abbigliamento": "Uscita",
            "Tabacchi": "Uscita",
            "Parrucchiere / Estetica": "Uscita",
            "Viaggi / Hotel": "Uscita",
            "Stipendio": "Entrata",
            "Pensione": "Entrata",
            "Entrate Extra": "Entrata",
            "Finanza & Risparmio": "Uscita",
            "Conto corrente": "Uscita",
            "Rate / Finanziamenti": "Uscita",
            "Commercialista": "Uscita",
            "Uscite straordinarie": "Uscita",
            "Emergenze": "Uscita",
            "Riparazioni impreviste": "Uscita",
            "Spese non ricorrenti": "Uscita"
        }
        finestra = tk.Toplevel(self, bg=self.COLOR_TOPLEVEL)
        finestra.title("Categorie suggerite")
        finestra.bind("<Escape>", lambda e: finestra.destroy())
        finestra.geometry("500x480") 
        larghezza, altezza = 500, 480
        x = (finestra.winfo_screenwidth() // 2) - (larghezza // 2)
        y = (finestra.winfo_screenheight() // 2) - (altezza // 2)
        finestra.geometry(f"{larghezza}x{altezza}+{x}+{y}")
        finestra.grab_set()
        finestra.focus_force()
        tk.Label(
            finestra,
            text="‚ú® Scegli categorie da aggiungere:", bg=self.COLOR_TOPLEVEL , fg=self.TEXT_COLOR, font=("Arial", 10, "bold")
        ).pack(pady=(10, 5))
        container = tk.Frame(finestra, bg="white")
        container.pack(padx=10, pady=(0, 10), fill="both", expand=True)
        canvas = tk.Canvas(container, bg=self.COLOR_TOPLEVEL, highlightthickness=0)
        scrollbar = ttk.Scrollbar(container, orient="vertical", command=canvas.yview)
        canvas.configure(yscrollcommand=scrollbar.set)
        scrollbar.pack(side="right", fill="y")
        canvas.pack(side="left", fill="both", expand=True)
        scroll_frame = tk.Frame(canvas, bg=self.COLOR_TOPLEVEL)
        canvas_window = canvas.create_window((0, 0), window=scroll_frame, anchor="nw")
        def aggiorna_scroll_region(event):
            canvas.configure(scrollregion=canvas.bbox("all"))
        canvas.bind("<Configure>", lambda event: canvas.itemconfig(canvas_window, width=event.width))
        scroll_frame.bind("<Configure>", aggiorna_scroll_region)
        selezioni = {}
        toggle_var = tk.BooleanVar(value=False)
        def seleziona_tutto():
            stato = toggle_var.get()
            for var in selezioni.values():
                var.set(stato)
        toggle_chk = tk.Checkbutton(
            scroll_frame,
            text="‚úîÔ∏è Seleziona Tutte / Nessuna",
            variable=toggle_var,
            command=seleziona_tutto,
            bg=self.COLOR_TOPLEVEL,
            fg=self.TEXT_COLOR,
            selectcolor=self.COLOR_TOPLEVEL,
            activebackground=self.COLOR_TOPLEVEL,
            highlightthickness=0,
            anchor="w",
            font=("Arial", 9, "bold")
        )
        toggle_chk.pack(anchor="w", pady=(6, 6), padx=4)
        for nome in CATEGORIE_SUGGERITE:
            var = tk.BooleanVar()
            nome_pulito = nome.split(" ", 1)[1] if " " in nome else nome
            tipo = TIPO_SUGGERITI.get(nome_pulito, "Uscita")
            etichetta = f"{nome} [{tipo}]"
            chk = tk.Checkbutton(
                scroll_frame,
                text=etichetta,
                variable=var,
                bg=self.COLOR_TOPLEVEL,
                fg=self.TEXT_COLOR,
                selectcolor=self.COLOR_TOPLEVEL,
                activebackground=self.COLOR_TOPLEVEL,
                highlightthickness=0,
                anchor="w"
            )
            chk.pack(anchor="w", pady=2, padx=4)
            selezioni[nome] = var
        def aggiungi_categorie_scelte():
            nuove = [nome for nome, var in selezioni.items() if var.get()]
            pulite = [nome.split(" ", 1)[1] if " " in nome else nome for nome in nuove]
            if not pulite:
               self.show_custom_warning("Nessuna selezione", "‚ö†Ô∏è Seleziona almeno una categoria da aggiungere.")
               return
            for cat in pulite:
                tipo = TIPO_SUGGERITI.get(cat, "Uscita")
                if cat not in self.categorie:
                    self.categorie.append(cat)
                self.categorie_tipi[cat] = tipo
            self.categorie.sort()
            self.aggiorna_combobox_categorie()
            self.save_db()
            self.show_custom_warning("Aggiunta completata", "‚ö†Ô∏è Categorie aggiunte correttamente..")
            finestra.destroy()
        btn_frame = tk.Frame(finestra, bg=self.COLOR_TOPLEVEL)
        btn_frame.pack(pady=(0, 12))
        ttk.Button(btn_frame, text="‚ûï Aggiungi", style="Verde.TButton", command=aggiungi_categorie_scelte).pack(side="left", padx=8)
        ttk.Button(btn_frame, text="‚ùå Chiudi", style="Giallo.TButton", command=finestra.destroy).pack(side="left", padx=8)

    # Scarica e Apri Manuale Utente (PDF)
    def scarica_manuale(self):
        try:
            response = requests.get(URL_PDF)
            response.raise_for_status()
            temp_path = os.path.join(tempfile.gettempdir(), "manuale_casa_facile.pdf")
            with open(temp_path, "wb") as f:
                f.write(response.content)
            webbrowser.open(f"file://{temp_path}")
        except Exception as e:
            print("Errore nel download del manuale:", e)
            self.show_custom_warning("Attenzione", "‚ùå Download NON completato ! \n\n Sembra ci sia stato un problema. üòï")

   # Scarica e Apri Tabella Consumi (PDF)
    def scarica_tabella(self):
        try:
            response = requests.get(URL_PDF_CONSUMI)
            response.raise_for_status()
            temp_path = os.path.join(tempfile.gettempdir(), "Tabella_Contatori.pdf")
            with open(temp_path, "wb") as f:
                f.write(response.content)
            webbrowser.open(f"file://{temp_path}")
        except Exception as e:
            print("Errore nel download della Tabella Consumi:", e)
            self.show_custom_warning("Attenzione", "‚ùå Download NON completato ! \n\n Sembra ci sia stato un problema. üòï")

    # Apri WebServer nel Browser   
    def apri_webserver(self):
        IP = self.get_ip_locale()
        webbrowser.open(f"http://{IP}:{PORTA}")

    # Recupera Indirizzo IP Locale
    def get_ip_locale(self):
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        try:
            s.connect(("8.8.8.8", 80))
            IP = s.getsockname()[0]
        except Exception:
            IP = "127.0.0.1"
        finally:
            s.close()
        return IP
   
    # Avvio Server Web Locale (Interfaccia HTTP)
    def start_web_server(self):
        server = HTTPServer(('0.0.0.0', PORTA), CasaFacileWebHandler)
        server.app = self  
        print(f"üåê Web server pronto su http://localhost:{PORTA}")
        server.serve_forever()

    # HTML Login
    def html_login(self, path):
        folder = os.path.basename(os.getcwd())
        try:
            query = path.split("?", 1)[1]
            params = parse_qs(query)
            errore = "error" in params
        except:
            errore = False
        messaggio = ""
        if errore:
            messaggio = "<p style='color:red; text-align:center;'>‚ùå Password errata. Riprova.</p>"
        return f"""
        <!DOCTYPE html>
        <html><head><meta charset="utf-8">
        <title>üîê Login</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <style>
          body {{
            font-family: sans-serif;
            background: #f4f4f4;
            padding: 30px;
          }}
          form {{
            max-width: 400px;
            margin: auto;
            background: #fff;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 0 6px rgba(0,0,0,0.1);
          }}
          h2 {{
            text-align: center;
            margin-bottom: 10px;
          }}
          input[type="password"], button {{
            display: block;
            width: 100%;
            padding: 10px;
            margin-top: 10px;
            box-sizing: border-box;
            font-size: 16px;
          }}
          button {{
            background: #0078D4;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
          }}
        </style>
        </head><body>
        <form method="post" action="/check_login">
          <h2>üîê Login {NAME}</h2>
          <h2>Versione v{VERSION} @ 2025</h2>
          <p style="text-align: center; font-size: 14px; color: #555; margin-top: -5px;">{folder}</p>
          {messaggio}
          <input type="password" name="password" placeholder="Password  ‚èé" autofocus>
          <button type="submit">Accedi</button>
        </form>
        </body></html>
        """
    def leggi_hash(self):
        if not os.path.exists(PW_FILE):
            return None
        try:
            with open(PW_FILE, "r", encoding="utf-8") as f:
                return json.load(f).get("hash")
        except:
            return None
    def verifica_password(self, password):
        salvato = self.leggi_hash()
        if salvato is None:
            return False  
        inserito = hashlib.sha256(password.encode()).hexdigest()
        return salvato == inserito

    # Movimenti Mese Web
    def pagina_risultati_avanzati(self, params):
        from datetime import datetime
        from collections import defaultdict 
        categoria = params.get("categoria", [""])[0].strip().lower()
        anno = params.get("anno", [""])[0].strip()
        mese = params.get("mese", [""])[0].strip()
        tipo = params.get("tipo", [""])[0].strip().lower()
        min_importo = float(params.get("min_importo", ["0"])[0] or 0)
        max_importo = float(params.get("max_importo", ["999999"])[0] or 999999)
        query = params.get("q", [""])[0].strip().lower()
        risultati_categorizzati = defaultdict(list)
        for data in sorted(self.spese.keys(), reverse=True):
            if anno and str(data.year) != anno:
                continue
            if mese and f"{data.month:02d}" != mese:
                continue
            for idx_voce, voce in enumerate(self.spese[data]):
                if len(voce) < 4:
                    continue
                cat, descrizione, importo, tipo_voce = voce[:4]
                if categoria and cat.strip().lower() != categoria:
                    continue
                if tipo and tipo_voce.strip().lower() != tipo:
                    continue
                if not (min_importo <= importo <= max_importo):
                    continue
                if query and not (
                    query in descrizione.lower()
                    or query in tipo_voce.lower()
                    or query in cat.lower()
                    or query in str(importo)
                ):
                    continue
                risultati_categorizzati[cat].append(
                    (
                        data.strftime("%d-%m-%Y"),
                        html_escape.escape(descrizione),
                        float(importo),
                        tipo_voce.strip(),
                        idx_voce,
                    )
                )
        entrate_totali = sum(
            v[2]
            for vlist in risultati_categorizzati.values()
            for v in vlist
            if v[3].lower() == "entrata"
        )
        uscite_totali = sum(
            v[2]
            for vlist in risultati_categorizzati.values()
            for v in vlist
            if v[3].lower() != "entrata"
        )
        saldo = entrate_totali - uscite_totali
        colore = "#3c763d" if saldo >= 0 else "#a94442"
        anno_corrente = datetime.now().year
        schede_html = ""
        for idx_cat, (cat, voci) in enumerate(sorted(risultati_categorizzati.items())):
            totale_cat = sum(
                imp if tipo_voce.lower() == "entrata" else -imp
                for _, _, imp, tipo_voce, _ in voci
            )
            voce_html = ""
            for data, descrizione, importo, tipo_voce, idx_voce in voci:
                simbolo = "+" if tipo_voce.lower() == "entrata" else "‚àí"
                colore_tipo = "#007E33" if tipo_voce.lower() == "entrata" else "#D8000C"
                voce_html += f"""
                <li>
                    <form method="get" action="/modifica" style="display:inline;">
                        <input type="hidden" name="data" value="{data}">
                        <input type="hidden" name="idx" value="{idx_voce}">
                        <button type="submit" style="margin-right:4px;" title="Modifica">‚úèÔ∏è</button>
                    </form>
                    <form onsubmit="
                        event.preventDefault();
                        fetch('/cancella', {{
                            method: 'POST',
                            headers: {{ 'Content-Type': 'application/x-www-form-urlencoded' }},
                            body: 'data={data}&idx={idx_voce}'
                        }}).then(function() {{ window.location.reload(); }});
                    " style="display:inline;">
                        <button type="submit" style="margin-right:8px;color:#D8000C;" title="Cancella">‚ùå</button>
                    </form>
                    {data} ‚Ä¢ {descrizione} 
                    <span style='color:#000; font-weight:bold;'>{simbolo}‚Ç¨{importo:.2f}</span>
                    <strong style='color:{colore_tipo};'>[{tipo_voce}]</strong>
                </li>
                """
            simbolo_totale = "‚ûï" if totale_cat >= 0 else "‚ûñ"
            colore_totale = "#007E33" if totale_cat >= 0 else "#D8000C"
            schede_html += f"""
            <div class="categoria-blocco">
                <button class="toggle-btn" onclick="toggleCategoria(this)">
                    <span class="freccia">‚û§</span> <span class="etichetta">{html_escape.escape(cat)}</span>
                </button>

                <div class="riepilogo-riga" style="color:{colore_totale};">
                    {simbolo_totale} Totale: <strong>‚Ç¨{totale_cat:.2f}</strong> ‚Ä¢ Voci: <strong>{len(voci)}</strong>
                </div>
                <div class="categoria-contenuto" style="display:none;">
                    <ul>{voce_html}</ul>
                </div>
            </div>
            """
        html = f"""
        <!DOCTYPE html>
        <html>
        <head>
            <meta charset="utf-8">
            <title>üìä Risultati Avanzati</title>
            <meta name="viewport" content="width=device-width, initial-scale=1">
            <style>
                body {{
                    font-family: 'Segoe UI', sans-serif;
                    background-color: #f4f4f4;
                    padding: 20px;
                    margin: 0;
                }}
                header {{
                    background: #0078D4;
                    color: white;
                    padding: 20px 0;
                    position: relative;
                }}
                .header-title {{
                    text-align: center;
                    font-size: 1.5em;
                }}
                .menu-button {{
                    position: absolute;
                    top: 10px;
                    left: 10px;
                    font-size: 1.6em;
                    background: none;
                    border: none;
                    color: white;
                    cursor: pointer;
                }}
                .dropdown {{
                    position: absolute;
                    top: 45px;
                    left: 10px;
                    background-color: white;
                    box-shadow: 0 4px 8px rgba(0,0,0,0.15);
                    border-radius: 4px;
                    display: none;
                    z-index: 999;
                }}
                .dropdown a {{
                    display: block;
                    padding: 10px 20px;
                    text-decoration: none;
                    color: #0078D4;
                    font-weight: bold;
                }}
                .dropdown a:hover {{
                    background-color: #f0f0f0;
                }}
                h2 {{
                    text-align: center;
                    font-size: 1.5em;
                    color: #333;
                    margin-bottom: 20px;
                }}
                .categoria-blocco {{
                    background: #fff;
                    border-radius: 8px;
                    box-shadow: 0 0 6px rgba(0,0,0,0.1);
                    margin: 20px auto;
                    max-width: 600px;
                    padding: 10px;
                }}
                .toggle-btn {{
                    background: none;
                    border: none;
                    font-size: 1.1em;
                    font-weight: bold;
                    width: 100%;
                    text-align: left;
                    cursor: pointer;
                    padding: 8px 0;
                    color: #0078D4;
                }}
                .categoria-contenuto ul {{
                    list-style: none;
                    padding-left: 0;
                    margin-top: 10px;
                }}
                .categoria-contenuto li {{
                    font-size: 1em;
                    margin: 8px 0;
                }}
                ul.totali {{
                    background: #fff;
                    padding: 16px;
                    border-radius: 8px;
                    box-shadow: 0 0 8px rgba(0,0,0,0.1);
                    max-width: 600px;
                    margin: 0 auto 30px auto;
                    list-style: none;
                }}
                ul.totali li {{
                    font-size: 1.1em;
                    margin: 8px 0;
                }}
                .back {{
                    display: block;
                    text-align: center;
                    font-size: 1em;
                    text-decoration: none;
                    background: #0078D4;
                    color: white;
                    padding: 10px;
                    border-radius: 4px;
                    max-width: 100%;
                    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
                    margin-top: 20px;
                }}
                .back:hover {{
                    background-color: #005ea6;
                }}
                .riepilogo-riga {{
                    font-size: 0.95em;
                    color: #555;
                    margin-top: 6px;
                    margin-bottom: 10px;
                    text-align: left;
                    padding-left: 4px;
                }}
                .pulsanti-finali {{
                    max-width: 600px;
                    margin: 30px auto 0 auto;
                }}
            </style>
            <script>
                function toggleMenu() {{
                    const menu = document.getElementById("extraMenu");
                    menu.style.display = (menu.style.display === "block") ? "none" : "block";
                }}
                document.addEventListener("click", function(event) {{
                    const menu = document.getElementById("extraMenu");
                    const isClickInside = event.target.closest(".menu-button, #extraMenu");
                    if (!isClickInside) {{
                        menu.style.display = "none";
                    }}
                }});
                function toggleCategoria(btn) {{
                    const riepilogo = btn.nextElementSibling;
                    const content = riepilogo.nextElementSibling;
                    const isVisible = content.style.display === "block";
                    content.style.display = isVisible ? "none" : "block";
                    const freccia = btn.querySelector(".freccia");
                    freccia.textContent = isVisible ? "‚û§" : "‚ñº";
                }}
            </script>
        </head>
        <body>
            <header>
                <button class="menu-button" onclick="toggleMenu()">‚ò∞</button>
                <div id="extraMenu" class="dropdown">
                    <a href="/">üè† Torna alla Home</a>
                    <a href="/consultazione_supermercati">üõí Gestione Supermercati</a>
                    <a href="/lista">üìà Elenca/Modifica</a>
                    <a href="/stats">üìä Report Mese</a>
                    <a href="/report_annuo">üìÖ Report Annuale</a>
                    <a href="/menu_esplora">üîç Esplora</a>
                    <a href="/gestione_categorie">‚öôÔ∏è Gestione Categorie</a>
                    <a href="/utenze?anno={anno_corrente}">üíß Utenze</a>
                    <a href="/documenti_pdf_web">üóÑÔ∏è Documenti PDF</a>
                    <a href="/logoff">üîì Logout</a>
                </div>
                <div class="header-title">üîç Risultati</div>
            </header>
            <h2>üìä Totali Esplorazione</h2>
            <ul class="totali">
                <li><strong>Entrate totali:</strong> ‚Ç¨{entrate_totali:.2f}</li>
                <li><strong>Uscite totali:</strong> ‚Ç¨{uscite_totali:.2f}</li>
                <li><strong style="color:{colore};">Saldo:</strong> ‚Ç¨{saldo:.2f}</li>
            </ul>
            <h2>üîé Risultati per Categoria</h2>
            {schede_html if schede_html else "<p style='text-align:center;'>Nessuna voce trovata per questi criteri.</p>"}
            <div class="pulsanti-finali">
                <form method="get" action="/menu_esplora">
                    <input type="submit" value="üîô Torna al Menu Esplora"
                    style="background-color: #0078D4; color: white; border: none;
                    font-size: 1.1em; padding: 12px; border-radius: 6px;
                    cursor: pointer; width: 100%; margin-bottom: 10px;">
                </form>
                <form method="get" action="/">
                    <input type="submit" value="üè† Torna alla Home"
                    style="background-color: #0078D4; color: white; border: none;
                    font-size: 1.1em; padding: 12px; border-radius: 6px;
                    cursor: pointer; width: 100%;">
                </form>
            </div>
        </body>
        </html>
        """
        return html

    # Pagina Principale Web
    def html_form(self):
        categorie_options = "\n".join(
            f"<option value='{c}'>{c}</option>" for c in self.categorie
        )
        today = datetime.date.today().isoformat()
        anno_corrente = datetime.date.today().year
        entrate_mese = 0.0
        uscite_mese = 0.0
        oggi = datetime.date.today()
        for data_spesa, voci in self.spese.items():
            if data_spesa.month == oggi.month and data_spesa.year == oggi.year:
                for voce in voci:
                    categoria, descrizione, importo, tipo = voce[:4]
                    if tipo == "Entrata":
                        entrate_mese += importo
                    else: 
                        uscite_mese += importo
        saldo_mese = entrate_mese - uscite_mese
        saldo_colore = "#3c763d" if saldo_mese >= 0 else "#c43b2e" 
        return f"""
        <!DOCTYPE html>
        <html>
        <head>
            <meta charset="utf-8">
            <title>Casa Facile Web</title>
            <meta name="viewport" content="width=device-width, initial-scale=1">
            <style>
                body {{
                    margin: 0;
                    font-family: 'Segoe UI', sans-serif;
                    background-color: #f4f4f4;
                }}
                header {{
                    background: #0078D4;
                    color: white;
                    padding: 20px 0;
                    position: relative;
                }}
                .header-title {{
                    text-align: center;
                    font-size: 1.5em;
                }}
                .menu-button {{
                    position: absolute;
                    top: 10px;
                    left: 10px;
                    font-size: 1.6em;
                    background: none;
                    border: none;
                    color: white;
                    cursor: pointer;
                }}
                .dropdown {{
                    position: absolute;
                    top: 45px;
                    left: 10px;
                    background-color: white;
                    box-shadow: 0 4px 8px rgba(0,0,0,0.15);
                    border-radius: 4px;
                    display: none;
                    z-index: 999;
                }}
                .dropdown a {{
                    display: block;
                    padding: 10px 20px;
                    text-decoration: none;
                    color: #0078D4;
                    font-weight: bold;
                }}
                .dropdown a:hover {{
                    background-color: #f0f0f0;
                }}
                main {{
                    padding: 20px;
                    max-width: 600px;
                    margin: auto;
                }}
                form {{
                    background: white;
                    padding: 20px;
                    border-radius: 8px;
                    box-shadow: 0 0 10px rgba(0,0,0,0.05);
                }}
                label {{
                    display: block;
                    margin-top: 10px;
                    font-weight: bold;
                }}
                input, select {{
                    width: 100%;
                    padding: 10px;
                    margin-top: 5px;
                    margin-bottom: 15px;
                    border: 1px solid #ccc;
                    border-radius: 4px;
                    box-sizing: border-box;
                }}
                input[type="submit"] {{
                    background-color: #0078D4;
                    color: white;
                    border: none;
                    cursor: pointer;
                    font-size: 1em;
                    border-radius: 6px;
                    padding: 12px;
                }}
                input[type="submit"]:hover {{
                    background-color: #005ea6;
                }}
                .input-errore {{
                    border: 2px solid red;
                }}
                .errore-msg {{
                    color: #a94442;
                    font-size: 0.95em;
                    display: none;
                    margin-top: -10px;
                    margin-bottom: 10px;
                }}
                input.input-errore + .errore-msg {{
                    display: block;
                }}
                .monthly-summary-container {{
                    background-color: #e6f2ff; 
                    border: 1px solid #b3d9ff; 
                    border-radius: 8px;
                    padding: 15px;
                    margin-bottom: 20px;
                    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
                }}
                .monthly-summary-header {{
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                    cursor: pointer;
                    margin-bottom: 10px; 
                }}
                .monthly-summary-header h3 {{
                    margin: 0;
                    color: #005ea6; 
                    font-size: 1.0em; 
                }}
                .arrow {{
                    width: 0;
                    height: 0;
                    border-left: 8px solid transparent;
                    border-right: 8px solid transparent;
                    border-top: 8px solid #005ea6; 
                    transition: transform 0.3s ease; 
                }}
                .arrow.up {{
                    transform: rotate(180deg); 
                }}
                .monthly-summary-content {{
                    max-height: 0; 
                    overflow: hidden;
                    transition: max-height 0.3s ease-out, margin-top 0.3s ease-out;
                }}
                .monthly-summary-content.open {{
                    max-height: 200px; 
                    margin-top: 10px; 
                }}
                .monthly-summary-content p {{
                    margin: 5px 0;
                    font-size: 1.1em;
                    font-weight: bold;
                }}
                .income-value {{
                    color: #3c763d; 
                }}
                .expense-value {{
                    color: #c43b2e; 
                }}
                .balance-value {{
                    color: #0078D4; 
                }}
            </style>
            <script>
                function toggleMenu() {{
                    const menu = document.getElementById("extraMenu");
                    menu.style.display = (menu.style.display === "block") ? "none" : "block";
                }}
                document.addEventListener("click", function(event) {{
                    const menu = document.getElementById("extraMenu");
                    const isClickInside = event.target.closest(".menu-button, #extraMenu");
                    if (!isClickInside) {{
                        menu.style.display = "none";
                    }}
                }});
            </script>
            <script>
              document.addEventListener("DOMContentLoaded", function () {{
                const form = document.getElementById("spesaForm");
                const msg = document.getElementById("successMessage");
                const summaryHeader = document.getElementById("summaryHeader");
                const summaryContent = document.getElementById("summaryContent");
                const arrow = document.getElementById("summaryArrow");
                summaryContent.classList.remove("open");
                arrow.classList.remove("up");
                summaryHeader.style.marginBottom = "0"; 
                summaryHeader.addEventListener("click", function() {{
                    summaryContent.classList.toggle("open");
                    arrow.classList.toggle("up");
                    if (summaryContent.classList.contains("open")) {{
                        summaryHeader.style.marginBottom = "10px";
                    }} else {{
                        summaryHeader.style.marginBottom = "0";
                    }}
                }});
                form.addEventListener("submit", function () {{
                  const categoria = form.categoria.value;
                  const importo = form.importo.value;
                  msg.textContent = `‚úÖ Inserita: ${{categoria}} ‚Ç¨${{importo}}`;
                  msg.style.color = "black";
                  msg.style.display = "block";
                  setTimeout(() => {{
                    msg.style.display = "none";
                  }}, 8000);
                }});
              }});
            </script>
        </head>
        <body>
            <header>
                <button class="menu-button" onclick="toggleMenu()">‚ò∞</button>
                <div id="extraMenu" class="dropdown">
                    <a href="/">üè† Torna alla Home</a>
                    <a href="/consultazione_supermercati">üõí Gestione Supermercati</a>
                    <a href="/lista">üìà Elenca/Modifica</a>
                    <a href="/stats">üìä Report Mese</a>
                    <a href="/report_annuo">üìÖ Report Annuale</a>
                    <a href="/menu_esplora">üîç Esplora</a>
                    <a href="/gestione_categorie">‚öôÔ∏è Gestione Categorie</a>
                    <a href="/utenze?anno={anno_corrente}">üíß Utenze</a>
                    <a href="/documenti_pdf_web">üóÑÔ∏è Documenti PDF</a>
                    <a href="/logoff">üîì Logout</a>
                </div>
                <div class="header-title">üè† Casa Facile Web</div>
            </header>
            <main>
                <div id="successMessage" style="display:none; color:green;">‚úÖ Inserito</div>
                <div class="monthly-summary-container">
                    <div class="monthly-summary-header" id="summaryHeader">
                        <h3>Riepilogo Mese Corrente</h3>
                        <div class="arrow" id="summaryArrow"></div>
                    </div>
                    <div class="monthly-summary-content" id="summaryContent">
                        <p>Entrate: <span class="income-value">‚Ç¨{entrate_mese:.2f}</span></p>
                        <p>Uscite: <span class="expense-value">‚Ç¨{uscite_mese:.2f}</span></p>
                        <p>Saldo: <span class="balance-value" style="color:{saldo_colore};">‚Ç¨{saldo_mese:.2f}</span></p>
                    </div>
                </div>
                <form method="post" action="/" id="spesaForm">
                    <label for="data">Data:</label>
                    <input name="data" type="date" value="{today}">
                    <label for="categoria">Categoria:</label>
                    <select name="categoria">{categorie_options}</select>
                    <label for="descrizione">Descrizione:</label>
                    <input name="descrizione" placeholder="Es: Pizza o bollette">
                    <label for="importo">Importo:</label>
                    <input
                        name="importo"
                        type="number"
                        step="0.01"
                        min="0.01"
                        required
                        placeholder="Es: 12.50"
                        oninvalid="this.classList.add('input-errore')"
                        oninput="this.classList.remove('input-errore')"
                    >
                    <span class="errore-msg">‚ö†Ô∏è Inserisci un importo valido</span>
                    <label for="tipo">Tipo:</label>
                    <select name="tipo">
                        <option value="Uscita">Uscita</option>
                        <option value="Entrata">Entrata</option>
                    </select>
                    <input type="submit" value="‚ûï Aggiungi Voce">
                </form>
            </main>
        </body>
        </html>
        """
    
    # Gestione Documenti Web
    def documenti_pdf_web(self):
        import datetime
        from datetime import datetime as dt
        import base64
        def bytes_to_human(byte_count):
            if byte_count is None: return "N/D"
            byte_count = int(byte_count)
            if byte_count < 1024: return f"{byte_count} B"
            elif byte_count < 1024 ** 2: return f"{byte_count / 1024:.2f} KB"
            else: return f"{byte_count / (1024 ** 2):.2f} MB"
        dati_json = {}
        registry_file_path = os.path.join("db", "documenti_archiviati.json")
        doc_dir = os.path.join("db", "documenti")
        try:
            dati_json = getattr(self, 'archivi_pdf', {})
            if not dati_json and os.path.exists(registry_file_path):
                with open(registry_file_path, "r", encoding="utf-8") as f:
                    dati_json = json.load(f)
        except Exception:
            dati_json = {}
        archivi_dati_strutturati = []
        for nome_file, dettagli in dati_json.items():
            percorso_fisico_check = os.path.join(doc_dir, nome_file)
            if not nome_file or not os.path.exists(percorso_fisico_check):
                 continue
            try:
                data_raw = dettagli.get("data_raw")
                data_obj = dt.strptime(data_raw, "%d%m%Y").date() if data_raw else datetime.date.today()
            except (ValueError, TypeError):
                data_obj = datetime.date.today()
            descrizione_esatta = dettagli.get('descrizione_esatta', 'N/D')
            categoria_esatta = dettagli.get('categoria_esatta', 'Generico')
            importo_raw = dettagli.get('importo_raw')
            if isinstance(importo_raw, (int, float)):
                importo_formattato = f"{importo_raw / 100:.2f} ‚Ç¨"
            else:
                importo_formattato = "N/D"
            dimensione_in_bytes = os.path.getsize(percorso_fisico_check)
            archivi_dati_strutturati.append({
                "nome_file": nome_file,
                "data_caricamento": data_obj,
                "descrizione_esatta": descrizione_esatta,
                "categoria_esatta": categoria_esatta,
                "importo": importo_formattato,
                "dimensione": dimensione_in_bytes
            })
        archivi_list_html = ""
        archivi_ordinati = sorted(archivi_dati_strutturati, key=lambda x: x["data_caricamento"], reverse=True)
        for archivio in archivi_ordinati:
            nome_file = archivio["nome_file"]
            data_str = archivio["data_caricamento"].strftime("%d/%m/%Y")
            descrizione = archivio["descrizione_esatta"]
            categoria = archivio["categoria_esatta"]
            importo = archivio["importo"]
            dimensione_human = bytes_to_human(archivio["dimensione"])
            percorso_fisico = os.path.join(doc_dir, nome_file)
            scarica_link = "#missing"
            if os.path.exists(percorso_fisico):
                try:
                    with open(percorso_fisico, 'rb') as f:
                        pdf_content_base64 = base64.b64encode(f.read()).decode('utf-8')
                    scarica_link = f"data:application/pdf;base64,{pdf_content_base64}"
                except Exception:
                    scarica_link = "#error"
            search_data = f"{data_str} {descrizione} {categoria} {importo} {dimensione_human}"
            archivi_list_html += f"""
            <tr data-search="{search_data.lower()}">
                <td data-label="Data:">
                    <div data-label="Data:">{data_str}</div>
                </td>
                <td data-label="Dettagli">
                    <div data-label="Categoria:">
                        <a href="{scarica_link}" target="_blank" title="Visualizza/Scarica" style="color:#0078D4; text-decoration:none;">
                            <b>{categoria}</b>
                        </a>
                    </div>
                    <div data-label="Descrizione:">{descrizione}</div>
                    <div data-label="Importo:">{importo}</div>
                    <div data-label="Dimensione File:">{dimensione_human}</div>
                </td>
                <td data-label="Azioni" style="white-space:nowrap;">
                    <a href="{scarica_link}" download="{nome_file}" title="Scarica file"¬†
                        style="text-decoration:none; color:#188c07; padding: 0; font-size:1em;">‚¨áÔ∏è</a>
                </td>
            </tr>
            """
        anno_corrente = datetime.date.today().year
        return f"""
        <!DOCTYPE html>
        <html>
        <head>
            <meta charset="utf-8">
            <title>Gestione Documenti PDF</title>
            <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
            <style>
                * {{
                    box-sizing: border-box;
                }}
                body {{ margin: 0; font-family: 'Segoe UI', sans-serif; background-color: #f4f4f4; }}
                header {{ background: #0078D4; color: white; padding: 20px 0; position: relative; }}
                .header-title {{ text-align: center; font-size: 1.5em; }}
                .menu-button {{ position: absolute; left: 15px; top: 50%; transform: translateY(-50%); background: none; border: none; color: white; font-size: 1.5em; cursor: pointer; }}
                .dropdown {{ 
                    display: none; 
                    position: absolute; 
                    top: 100%; 
                    left: 0; 
                    background-color: #005ea6; 
                    max-width: 95vw;
                    box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2); 
                    z-index: 1; 
                    border-radius: 0 0 8px 8px; 
                }}
                .dropdown a {{ color: white; padding: 12px 16px; text-decoration: none; display: block; }}
                .dropdown a:hover {{ background-color: #004a7c; }}
                main {{ padding: 20px; max-width: 800px; margin: auto; }}
                .pdf-list-container {{ background: white; padding: 20px; border-radius: 8px; box-shadow: 0 0 10px rgba(0,0,0,0.05); margin-bottom: 20px; }}
                .pdf-table {{ width: 100%; border-collapse: collapse; }}
                .pdf-table th, .pdf-table td {{ padding: 10px; text-align: left; border-bottom: 1px solid #ddd; }}
                .pdf-table th {{ background-color: #e6f2ff; color: #005ea6; font-size: 0.9em; }}
                .pdf-table tr:hover {{ background-color: #f9f9f9; }}
                .search-container {{
                    padding: 10px 20px 10px;
                    max-width: 800px; 
                    margin: 0 auto;
                }}
                #searchInput {{
                    width: 100%;
                    padding: 10px 15px;
                    border: 1px solid #ccc;
                    border-radius: 5px;
                    box-shadow: inset 0 1px 3px rgba(0,0,0,0.05);
                    font-size: 1em;
                }}
                @media screen and (max-width: 600px) {{
                    body {{
                        overflow-x: hidden;
                    }}
                    main {{
                        padding: 10px;
                        max-width: 100%;
                    }}
                    .search-container {{
                        padding: 10px;
                    }}
                    .pdf-table, .pdf-table tbody, .pdf-table td, .pdf-table th, .pdf-table tr {{
                        display: block;
                        width: 100%;
                    }}
                    .pdf-table thead {{
                        display: none;
                    }}
                    .pdf-table tr {{
                        margin-bottom: 10px;
                        border: 1px solid #ccc;
                        padding: 10px;
                        border-radius: 4px;
                    }}
                    .pdf-table td {{
                        border: none;
                        padding: 0; 
                        position: relative;
                        word-break: break-word;
                        text-align: left; 
                    }}
                    .pdf-table td::before {{
                        content: none !important;
                    }}
                    .pdf-table td div {{
                        padding: 5px 10px; 
                        display: block;
                        color: #000;
                        font-size: 0.9em;
                        position: relative;
                        overflow: hidden; 
                        border-bottom: 1px dashed #eee;
                    }}
                    .pdf-table td div[data-label]::before {{
                        content: attr(data-label);
                        float: left; 
                        width: 45%; 
                        padding-right: 5px;
                        white-space: nowrap;
                        text-align: left;
                        font-weight: bold;
                        color: #0078D4;
                    }}
                    .pdf-table td div {{
                        text-align: right; 
                        color: #666;
                    }}
                    .pdf-table td div[data-label="Categoria:"] {{
                        font-weight: bold;
                        color: #0078D4;
                    }}
                    .pdf-table tr td:last-child {{
                        text-align: center; 
                        padding: 10px 0;
                        margin-top: 10px;
                        border-top: 1px solid #eee;
                        border-bottom: none; 
                    }}
                    .pdf-table tr td:last-child::before {{
                        content: none;
                    }}
                    .pdf-table tr td:first-child div {{
                         border-bottom: 1px solid #ddd;
                    }}
                    .pdf-table tr td:nth-child(2) div:last-child {{
                        border-bottom: none; 
                    }}
                }}
            </style>
            <script>
                function toggleMenu() {{
                    const menu = document.getElementById("extraMenu");
                    menu.style.display = (menu.style.display === "block") ? "none" : "block";
                }}
                document.addEventListener("click", function(event) {{
                    const menu = document.getElementById("extraMenu");
                    const isClickInside = event.target.closest(".menu-button, #extraMenu");
                    if (!isClickInside) {{
                        menu.style.display = "none";
                    }}
                }});
                function searchTable() {{
                    const input = document.getElementById("searchInput");
                    const filter = input.value.toLowerCase();
                    const table = document.getElementById("pdfTableBody");
                    const tr = table.getElementsByTagName("tr");
                    for (let i = 0; i < tr.length; i++) {{
                        const rowData = tr[i].getAttribute("data-search");
                        if (rowData) {{
                            if (rowData.indexOf(filter) > -1) {{
                                tr[i].style.display = "";
                            }} else {{
                                tr[i].style.display = "none";
                            }}
                        }}
                    }}
                }}
            </script>
        </head>
        <body>
            <header>
                <button class="menu-button" onclick="toggleMenu()">‚ò∞</button>
                <div id="extraMenu" class="dropdown">
                    <a href="/">üè† Torna alla Home</a>
                    <a href="/consultazione_supermercati">üõí Gestione Supermercati</a>
                    <a href="/lista">üìà Elenca/Modifica</a>
                    <a href="/stats">üìä Report Mese</a>
                    <a href="/report_annuo">üìÖ Report Annuale</a>
                    <a href="/menu_esplora">üîç Esplora</a>
                    <a href="/gestione_categorie">‚öôÔ∏è Gestione Categorie</a>
                    <a href="/utenze?anno={anno_corrente}">üíß Utenze</a>
                    <a href="/documenti_pdf_web">üóÑÔ∏è Documenti PDF</a>
                    <a href="/logoff">üîì Logout</a>
                </div>
                <div class="header-title">üóÑÔ∏è Documenti PDF</div>
            </header>
            
            <div class="search-container">
                <input type="text" id="searchInput" onkeyup="searchTable()" placeholder="Cerca x Data,Categoria,Descrizione,Importo" title="Digita per cercare">
            </div>

            <main>
                <h2>üìÇ Elenco Archivi</h2>
                <div class="pdf-list-container">
                    <table class="pdf-table">
                        <thead>
                            <tr>
                                <th style="width:15%;">Data</th>
                                <th style="width:75%;">Categoria/Descrizione</th>
                                <th style="width:10%;">Azioni</th>
                            </tr>
                        </thead>
                        <tbody id="pdfTableBody">
                            {archivi_list_html if archivi_list_html else '<tr><td colspan="3" style="text-align:center;">Nessun archivio PDF presente.</td></tr>'}
                        </tbody>
                    </table>
                </div>
            </main>
        </body>
        </html>
        """

    # Visualizza Utenze Web
    def genera_html_utenze(self, percorso_db, anno):
        from datetime import datetime
        utenze = ["Acqua", "Luce", "Gas"]
        if not os.path.exists(percorso_db):
            return """
            <!DOCTYPE html>
            <html>
            <head><title>Errore DB</title><meta charset="utf-8"></head>
            <body style='font-family:Arial; background:#fff; padding:20px;'>
              <h2 style='color:#b00;'>‚ùå Errore database</h2>
              <p style='font-size:3.2em;'>‚ö†Ô∏è Il file <strong>UTENZE_DB</strong> non esiste o √® vuoto.</p>
              <a href='/' style='display:inline-block; margin-top:20px; font-size:3em; text-decoration:none; color:#0078D4;'>üîô Torna alla Home</a>
            </body>
            </html>
            """
        try:
            with open(percorso_db, "r", encoding="utf-8") as f:
                contenuto = f.read().strip()
                if not contenuto:
                    return "<p style='font-size: 3.3em; font-weight: bold; color: #C00;'>‚ö†Ô∏è Il file database √® vuoto.</p>"
                data = json.loads(contenuto)
        except Exception as e:
            return f"<p>‚ùå Errore nel file JSON: {e}</p>"
        letture = data.get("letture_salvate", {})
        anno_corrente = datetime.now().year
        anni_disponibili = [str(anno_corrente - i) for i in range(6)]
        select_html = "<form><label for='anno'>üóìÔ∏è Scegli anno:</label> "
        select_html += "<select id='anno' onchange=\"location.href='/utenze?anno=' + this.value\">"
        for a in anni_disponibili:
            selected = " selected" if a == str(anno) else ""
            select_html += f"<option value='{a}'{selected}>{a}</option>"
        select_html += "</select></form>"
        oggi = datetime.now()
        html = f"""<!DOCTYPE html>
    <html lang="it">
    <head>
      <meta charset="utf-8">
      <title>üíß Utenze ‚Äî {anno}</title>
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <style>
        body {{
          margin: 0;
          font-family: 'Segoe UI', sans-serif;
          background-color: #f4f4f4;
        }}
        header {{
          background: #0078D4;
          color: white;
          padding: 20px 0;
          position: relative;
        }}
        .header-title {{
          text-align: center;
          font-size: 1.5em;
        }}
        .menu-button {{
          position: absolute;
          top: 10px;
          left: 10px;
          font-size: 1.6em;
          background: none;
          border: none;
          color: white;
          cursor: pointer;
        }}
        .dropdown {{
          position: absolute;
          top: 45px;
          left: 10px;
          background-color: white;
          box-shadow: 0 4px 8px rgba(0,0,0,0.15);
          border-radius: 4px;
          display: none;
          z-index: 999;
        }}
        .dropdown a {{
          display: block;
          padding: 10px 20px;
          text-decoration: none;
          color: #0078D4;
          font-weight: bold;
        }}
        .dropdown a:hover {{
          background-color: #f0f0f0;
        }}
        main {{
          padding: 20px;
          max-width: 600px;
          margin: auto;
        }}
        .utenza-title {{
          cursor: pointer;
          padding: 10px;
          background: #0078D4;
          color: white;
          border-radius: 4px;
          margin-top: 20px;
        }}
        .utenza-content {{
          display: none;
          background: white;
          padding: 10px;
          border-radius: 6px;
          box-shadow: 0 0 4px rgba(0,0,0,0.05);
          margin-bottom: 20px;
        }}
        table {{
          width: 100%;
          border-collapse: collapse;
          font-size: 0.9em;
        }}
        th, td {{
          border: 1px solid #ccc;
          padding: 8px;
          text-align: center;
        }}
        th {{
          background: #0078D4;
          color: white;
        }}
        .teardown {{
          background: #f9f9f9;
          margin-top: 10px;
          font-size: 0.9em;
          padding: 8px;
          border-radius: 4px;
        }}
        .back {{
          display: block;
          text-align: center;
          font-size: 1em;
          text-decoration: none;
          background: #0078D4;
          color: white;
          padding: 10px;
          border-radius: 4px;
          box-shadow: 0 2px 5px rgba(0,0,0,0.1);
          margin: 20px auto;
          width: 200px;
        }}
        .back:hover {{
          background-color: #005ea6;
        }}
      </style>
      <script>
        function toggleMenu() {{
          const menu = document.getElementById("extraMenu");
          menu.style.display = (menu.style.display === "block") ? "none" : "block";
        }}
        function toggle(id) {{
          const el = document.getElementById(id);
          el.style.display = (el.style.display === "none") ? "block" : "none";
        }}
        document.addEventListener("click", function(event) {{
          const menu = document.getElementById("extraMenu");
          if (!event.target.closest(".menu-button, #extraMenu")) {{
            menu.style.display = "none";
          }}
        }});
      </script>
    </head>
    <body>
      <header>
        <button class="menu-button" onclick="toggleMenu()">‚ò∞</button>
        <div id="extraMenu" class="dropdown">
          <a href="/">üè† Torna alla Home</a>
          <a href="/consultazione_supermercati">üõí Gestione Supermercati</a>
          <a href="/lista">üìà Elenca/Modifica</a>
          <a href="/stats">üìä Report Mese</a>
          <a href="/report_annuo">üìÖ Report Annuale</a>
          <a href="/menu_esplora">üîç Esplora</a>
          <a href="/gestione_categorie">‚öôÔ∏è Gestione Categorie</a>
          <a href="/utenze?anno={anno_corrente}">üíß Utenze</a>
          <a href="/documenti_pdf_web">üóÑÔ∏è Documenti PDF</a>
          <a href="/logoff">üîì Logout</a>
        </div>
        <div class="header-title">üíß Utenze ‚Äî Anno {anno}</div>
      </header>
      <main>
        {select_html}
    """

        for utenza in utenze:
            righe = letture.get(utenza, {}).get(str(anno), [])
            uid = f"utenza_{utenza.lower()}"
            html += f"<div class='utenza-title' onclick=\"toggle('{uid}')\">‚ñ∂Ô∏è {utenza}</div><div id='{uid}' class='utenza-content'>"
            if righe:
                total = 0.0
                consumi = []
                html += "<table><tr><th>Mese</th><th>Prec</th><th>Att</th><th>Consumo</th></tr>"
                for riga in righe:
                    try:
                        mese, prec, att, cons = riga
                        prec, att, cons = float(prec), float(att), float(cons)
                        total += cons
                        consumi.append(cons)
                        html += f"<tr><td>{mese}</td><td>{prec:.2f}</td><td>{att:.2f}</td><td>{cons:.2f}</td></tr>"
                    except:
                        html += f"<tr><td colspan='4'>‚ö†Ô∏è Errore dati: {riga}</td></tr>"
                media = total / len(consumi) if consumi else 0
                variazioni = [consumi[i] - consumi[i - 1] for i in range(1, len(consumi))]
                ultima = variazioni[-1] if variazioni else 0
                html += "</table>"
                html += f"""
    <div class='teardown'>
    üî¢ Totale: <strong>{total:.2f}</strong><br>
    üìä Media mensile: <strong>{media:.2f}</strong><br>
    üìà Ultima variazione: <strong>{ultima:+.2f}</strong><br>
    üìÖ Mesi registrati: <strong>{len(consumi)}</strong>
    </div>
    """
            else:
                html += "<p><i>Nessun dato disponibile.</i></p>"
            html += "</div>"

        html += f"""
        <a href="/" class="back">üè† Torna alla Home</a>
      </main>
    </body>
    </html>
    """
        return html

    # Lista Spesa Supermarket e Prezzi Promo
    def genera_html_consultazione(self, file_selezionato=None):
        anno_corrente = datetime.datetime.now().year
        def inizializza_db_file(percorso_db, contenuto_iniziale="{}"):
            """Garantisce che la directory e il file DB esistano e siano stati inizializzati."""
            dir_path = os.path.dirname(percorso_db)
            if dir_path and not os.path.exists(dir_path):
                os.makedirs(dir_path) 
            if not os.path.exists(percorso_db):
                try:
                    with open(percorso_db, "w", encoding="utf-8") as f:
                        f.write(contenuto_iniziale)
                    return True
                except Exception as e:
                    print(f"Errore nella creazione automatica di {percorso_db}: {e}")
                    return False
            return True
        def get_file_list_internal():
            directory_esportazione = EXPORT_FILES
            if not os.path.isdir(directory_esportazione):
                try:
                    os.makedirs(directory_esportazione)
                except Exception:
                    pass
                return []
            list_files = os.listdir(directory_esportazione)
            lista_spesa_files = [f for f in list_files if f.startswith("Lista_Spesa_") and f.endswith(".txt")]
            try:
                lista_spesa_files.sort(key=lambda f: os.path.getmtime(os.path.join(directory_esportazione, f)), reverse=True)
            except Exception:
                pass
            return lista_spesa_files
        def leggi_lista_spesa_internal(nome_file):
            directory_esportazione = EXPORT_FILES
            file_path = os.path.join(directory_esportazione, nome_file)
            if not os.path.exists(file_path):
                return []
            try:
                with open(file_path, 'r', encoding='utf-8') as f:
                    content = f.read()
            except Exception as e:
                print(f"Errore lettura file {nome_file}: {e}")
                return []
            return [{"raw_content": content}]
        lista_file_disponibili = get_file_list_internal() 
        file_visualizzato = lista_file_disponibili[0] if lista_file_disponibili else "Nessuna Lista Trovata"
        ultima_spesa_data = []
        if file_visualizzato != "Nessuna Lista Trovata":
            ultima_spesa_data = leggi_lista_spesa_internal(file_visualizzato)
        is_raw_content = ultima_spesa_data and 'raw_content' in ultima_spesa_data[0]
        percorso_db = SUPERMERCATI_DB
        dati_supermercati = {}
        if not inizializza_db_file(percorso_db):
             return f"""<!DOCTYPE html><html><head><title>Errore database</title><meta charset="utf-8"></head><body style='font-family:Arial; background:#fff; padding:20px;'><h2 style='color:#b00;'>‚ùå Errore database</h2><p style='font-size:1.5em;'>‚ö†Ô∏è Impossibile creare il file <strong>{percorso_db}</strong>.</p><a href='/' style='display:inline-block; margin-top:20px; font-size:1.5em; text-decoration:none; color:#0078D4;'>üîô Torna alla Home</a></body></html>"""
        try:
            with open(percorso_db, "r", encoding="utf-8") as f:
                contenuto = f.read().strip()
                dati_supermercati = json.loads(contenuto) if contenuto else {}
        except Exception as e:
            return f"""<!DOCTYPE html><html><head><title>Errore JSON</title><meta charset="utf-8"></head><body style='font-family:Arial; background:#fff; padding:20px;'><h2 style='color:#b00;'>‚ùå Errore JSON</h2><p style='font-size:1.5em;'>Errore lettura database supermercati: {e}</p><a href='/' style='display:inline-block; margin-top:20px; font-size:1.5em; text-decoration:none; color:#0078D4;'>üîô Torna alla Home</a></body></html>"""
        supermercati = sorted(dati_supermercati.keys())
        page_title = "üîç Consultazione Cataloghi e Ultima Spesa"
        header_text = "Gestione Supermarket"
        emoji = ""
        html = f"""<!DOCTYPE html>
        <html lang="it">
        <head>
          <meta charset="utf-8">
          <title>{emoji} {page_title}</title>
          <meta name="viewport" content="width=device-width, initial-scale=1">
          <style>
            body {{ margin: 0; font-family: 'Segoe UI', sans-serif; background-color: #f4f4f4; }}
            header {{ background: #0078D4; color: white; padding: 20px 0; position: relative; }}
            .header-title {{ text-align: center; font-size: 1.5em; }}
            .menu-button {{ position: absolute; top: 10px; left: 10px; font-size: 1.6em; background: none; border: none; color: white; cursor: pointer; }}
            .dropdown {{ position: absolute; top: 45px; left: 10px; background-color: white; box-shadow: 0 4px 8px rgba(0,0,0,0.15); border-radius: 4px; display: none; z-index: 999; }}
            .dropdown a {{ display: block; padding: 10px 20px; text-decoration: none; color: #0078D4; font-weight: bold; }}
            .dropdown a:hover {{ background-color: #f0f0f0; }}
            main {{ padding: 20px; max-width: 800px; margin: auto; }}
            .section-title {{ 
              cursor: pointer; 
              padding: 12px; 
              background: #0078D4; 
              color: white; 
              border-radius: 4px; 
              margin-top: 20px; 
              font-weight: bold; 
              display: flex; 
              justify-content: space-between; 
              align-items: center; 
            }}
            .section-content {{ 
              display: block; 
              background: white; 
              padding: 15px; 
              border-radius: 6px; 
              box-shadow: 0 0 8px rgba(0,0,0,0.1); 
              margin-bottom: 20px; 
            }}
            table {{ 
                width: 100%; 
                border-collapse: collapse; 
                font-size: 0.75em; 
                table-layout: fixed;
            }}
            th, td {{ 
                border: 1px solid #ddd; 
                padding: 4px;
                text-align: left; 
                overflow: hidden; 
                text-overflow: ellipsis;
            }}
            th {{ 
                background: #0078D4; 
                color: white; 
                text-align: center; 
                white-space: normal;
            }}
            .promo {{ color: #d32f2f; font-weight: bold; }}
            .prezzo {{ text-align: right; white-space: nowrap; }}
            .categoria {{ font-style: italic; color: #777; }}
            .back {{ display: block; text-align: center; font-size: 1em; text-decoration: none; background: #0078D4; color: white; padding: 10px; border-radius: 4px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); margin: 20px auto; width: 200px; }}
            .back:hover {{ background-color: #005ea6; }}
            pre {{ 
                white-space: pre-wrap; 
                word-wrap: break-word; 
                background:#fff3e0; 
                padding:15px; 
                border:1px solid #ffcc80; 
                border-left: 5px solid #ff9800; 
                overflow-x: auto; 
                font-size: 0.85em;
            }}
          </style>
          <script>
            function toggleMenu() {{
              const menu = document.getElementById("extraMenu");
              menu.style.display = (menu.style.display === "block") ? "none" : "block";
            }}
            function toggle(id) {{
              const el = document.getElementById(id);
              const icon = document.getElementById('icon_' + id);
              if (el.style.display === "none" || el.style.display === "") {{
                el.style.display = "block";
                icon.textContent = "‚ñº";
              }} else {{
                el.style.display = "none";
                icon.textContent = "‚ñ∂";
              }}
            }}
            document.addEventListener("click", function(event) {{
              const menu = document.getElementById("extraMenu");
              if (!event.target.closest(".menu-button, #extraMenu")) {{
                menu.style.display = "none";
              }}
            }});
          </script>
        </head>
        <body>
          <header>
            <button class="menu-button" onclick="toggleMenu()">‚ò∞</button>
            <div id="extraMenu" class="dropdown">
              <a href="/">üè† Torna alla Home</a>
              <a href="/consultazione_supermercati">üõí Gestione Supermercati</a>
              <a href="/lista">üìà Elenca/Modifica</a>
              <a href="/stats">üìä Report Mese</a>
              <a href="/report_annuo">üìÖ Report Annuale</a>
              <a href="/menu_esplora">üîç Esplora</a>
              <a href="/gestione_categorie">‚öôÔ∏è Gestione Categorie</a>
              <a href="/utenze">üíß Utenze</a>
              <a href="/logoff">üîì Logout</a>
            </div>
            <div class="header-title">{emoji} {header_text}</div>
          </header>
          <main>
        """
        lista_id = "lista_spesa_contenuto"
        html += f"""
        <div class='section-title' style='margin-top: 0;' onclick="toggle('{lista_id}')">
            üìã Contenuto ULTIMA LISTA: {file_visualizzato}
            <span id='icon_{lista_id}'>‚ñ∂</span>
        </div>
        """
        html += f"""
        <div id='{lista_id}' class='section-content' style='display: none;'>
        """
        if is_raw_content:
            raw_text = ultima_spesa_data[0]['raw_content']
            raw_text_safe = raw_text.replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;')
            html += f"""
            <pre>{raw_text_safe}</pre>
            """
        else:
            html += f"""
            <p>‚ùå <strong>Impossibile visualizzare la lista spesa.</strong></p>
            <p>Assicurati che ci sia almeno un file 'Lista_Spesa_....txt' nella cartella 'export'.</p>
            """
        html += "</div>"
        html += f"<div class='section-title' onclick=\"toggle('cataloghi_sezione')\">üõí Consultazione Cataloghi ({len(supermercati)}) <span id='icon_cataloghi_sezione'>‚ñ∂</span></div><div id='cataloghi_sezione' class='section-content' style='display: none;'>"

        if supermercati:
            for superm in supermercati:
                articoli = dati_supermercati.get(superm, [])
                superm_id = f"catalogo_{superm.lower().replace(' ', '_')}"
                html += f"""
                <div class='section-title' style='margin-top:10px;' onclick=\"toggle('{superm_id}')\">
                    {superm} ({len(articoli)} articoli) 
                    <span id='icon_{superm_id}'>‚ñ∂</span>
                </div>
                <div id='{superm_id}' class='section-content' style='padding:0; display: none;'>
                """ 
                if articoli:
                    #articoli_ordinati = sorted(articoli, key=lambda x: (x.get('categoria', ''), x.get('nome', '')))
                    articoli_ordinati = sorted(articoli, key=lambda x: x.get('nome', ''))
                    html += "<table><tr><th>Articolo</th><th>Descrizione</th><th>Categoria</th><th>Prezzo Normale (‚Ç¨)</th><th>Promo Attiva/Valore (‚Ç¨)</th></tr>"
                    for articolo in articoli_ordinati:
                        nome = articolo.get("nome", "N/D")
                        descrizione = articolo.get("descrizione", "N/D")
                        categoria = articolo.get("categoria", "Varie") 
                        prezzo_str = articolo.get("prezzo", "0.0")
                        prezzo_promo_str = articolo.get("prezzo_promo", "0.0")
                        promo_attiva = articolo.get("promo", False) 
                        try:
                            prezzo = float(prezzo_str)
                            prezzo_normale_fmt = f"{prezzo:.2f}"
                        except ValueError:
                            prezzo_normale_fmt = prezzo_str
                        try:
                            prezzo_promo = float(prezzo_promo_str)
                            prezzo_promo_fmt = f"{prezzo_promo:.2f}"
                        except ValueError:
                            prezzo_promo_fmt = prezzo_promo_str
                        prezzo_normale_colonna = prezzo_normale_fmt
                        promo_colonna = 'No'
                        if promo_attiva and prezzo_promo is not None and prezzo_promo > 0:
                            promo_colonna = f"<span class='promo'>{prezzo_promo_fmt}</span>"
                        html += f"""
                        <tr>
                            <td>{nome}</td>
                            <td>{descrizione}</td>
                            <td class='categoria'>{categoria}</td>
                            <td class='prezzo'>{prezzo_normale_colonna}</td>
                            <td class='prezzo'>{promo_colonna}</td>
                        </tr>
                        """
                    html += "</table>"
                else:
                    html += "<p style='padding:15px;'><i>Nessun articolo registrato per questo supermercato.</i></p>"
                html += "</div>"  
        else:
            html += "<p>‚ö†Ô∏è Il database dei cataloghi √® vuoto o non contiene supermercati registrati.</p>"
        html += "</div>" 
        html += f"""
            <a href="/" class="back">üè† Torna alla Home</a>
          </main>
        </body>
        </html>
        """
        return html
    
    # Ricerca Globale Web
    def pagina_menu_esplora(self):
        mesi_it_map = {
            "01": "Gennaio", "02": "Febbraio", "03": "Marzo",
            "04": "Aprile", "05": "Maggio", "06": "Giugno",
            "07": "Luglio", "08": "Agosto", "09": "Settembre",
            "10": "Ottobre", "11": "Novembre", "12": "Dicembre"
        }
        mesi = [f"{m:02d} - {mesi_it_map[f'{m:02d}']}" for m in range(1, 13)]
        categorie = sorted(set(self.categorie))
        anno_corrente = datetime.date.today().year
        anni = [str(anno) for anno in range(anno_corrente, anno_corrente - 6, -1)] 
        html_code = f"""
        <!DOCTYPE html>
        <html lang="it">
        <head>
            <meta charset='utf-8'>
            <title>üîé Esplorazione Avanzata</title>
            <meta name="viewport" content="width=device-width, initial-scale=1">
            <style>
                body {{
                    font-family: 'Segoe UI', sans-serif;
                    background-color: #f4f4f4;
                    padding: 0;
                    margin: 0;
                }}
                header {{
                    background: #0078D4;
                    color: white;
                    padding: 20px 0; 
                    position: relative;
                }}
                .header-title {{
                    text-align: center;
                    font-size: 1.5em;
                }}
                .menu-button {{
                    position: absolute;
                    top: 10px;
                    left: 10px;
                    font-size: 1.6em;
                    background: none;
                    border: none;
                    color: white;
                    cursor: pointer;
                }}
                .dropdown {{
                    position: absolute;
                    top: 45px;
                    left: 10px;
                    background-color: white;
                    box-shadow: 0 4px 8px rgba(0,0,0,0.15);
                    border-radius: 4px;
                    display: none;
                    z-index: 999;
                }}
                .dropdown a {{
                    display: block;
                    padding: 10px 20px;
                    text-decoration: none;
                    color: #0078D4;
                    font-weight: bold;
                }}
                .dropdown a:hover {{
                    background-color: #f0f0f0;
                }}
                main {{
                    padding: 20px;
                    max-width: 600px;
                    margin: auto;
                }}
                form {{
                    background: white;
                    padding: 20px;
                    border-radius: 10px;
                    box-shadow: 0 0 10px rgba(0,0,0,0.08);
                }}
                label {{
                    font-weight: bold;
                    display: block;
                    margin-top: 15px;
                    margin-bottom: 8px;
                    color: #333;
                    font-size: 0.95em;
                }}
                input[type="text"], input[type="number"], select {{
                    width: 100%;
                    padding: 12px; 
                    font-size: 1em;
                    border: 1px solid #ccc;
                    border-radius: 6px; 
                    box-sizing: border-box;
                    background-color: #fff;
                    transition: border-color 0.2s ease, box-shadow 0.2s ease;
                }}
                input[type="text"]:focus, input[type="number"]:focus, select:focus {{
                    outline: none;
                    border-color: #0078D4;
                    box-shadow: 0 0 0 2px rgba(0,120,212,0.2);
                }}
                button[type="submit"] {{
                    margin-top: 30px; 
                    width: 100%;
                    background: #0078D4;
                    color: white;
                    padding: 15px; 
                    font-size: 1.1em;
                    border: none;
                    border-radius: 8px; 
                    cursor: pointer;
                    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
                    transition: background-color 0.2s ease, box-shadow 0.2s ease;
                }}
                button[type="submit"]:hover {{
                    background: #005ea6;
                    box-shadow: 0 4px 10px rgba(0,0,0,0.15);
                }}
                .collapsible-container {{ 
                    margin-top: 25px;
                    border-top: 1px solid #eee; 
                    padding-top: 15px;
                }}
                .collapsible-toggle {{
                    background: none;
                    border: none;
                    font-size: 1.05em; 
                    color: #0078D4;
                    display: flex;
                    align-items: center;
                    gap: 8px; 
                    font-weight: bold;
                    cursor: pointer;
                    width: 100%; 
                    padding: 10px 0; 
                    box-sizing: border-box;
                    text-align: left;
                }}
                .collapsible-toggle:hover {{
                    color: #005ea6;
                }}
                .arrow {{
                    transition: transform 0.3s ease;
                }}
                .collapsible-open .arrow {{
                    transform: rotate(90deg);
                }}
                .collapsible-content {{
                    display: none;
                    margin-top: 10px;
                    padding-top: 10px;
                }}
                .collapsible-open .collapsible-content {{
                    display: block;
                }}
                .back-button {{ 
                    display: block;
                    text-align: center;
                    font-size: 1em;
                    text-decoration: none;
                    background: #0078D4;
                    color: white;
                    padding: 12px;
                    border-radius: 8px;
                    box-shadow: 0 4px 8px rgba(0,0,0,0.1);
                    margin: 20px auto 0 auto; 
                    width: 200px;
                    transition: background-color 0.2s ease, box-shadow 0.2s ease;
                }}
                .back-button:hover {{
                    background-color: #005ea6;
                    box-shadow: 0 6px 12px rgba(0,0,0,0.15);
                }}
                @media (max-width: 600px) {{
                    header {{
                        padding: 20px 0;
                    }}
                    .header-title {{
                        font-size: 1.3em;
                    }}
                    main {{
                        padding: 15px;
                    }}
                    form {{
                        padding: 15px;
                    }}
                    label {{
                        font-size: 0.9em;
                        margin-bottom: 5px;
                    }}
                    input, select, button {{
                        padding: 10px;
                        font-size: 0.95em;
                    }}
                    button[type="submit"] {{
                        margin-top: 25px;
                    }}
                    .back-button {{
                        width: 180px;
                        padding: 10px;
                        font-size: 0.95em;
                    }}
                    .collapsible-toggle {{
                        font-size: 1em;
                    }}
                }}
            </style>
            <script>
                function toggleMenu() {{
                    const menu = document.getElementById("extraMenu");
                    menu.style.display = (menu.style.display === "block") ? "none" : "block";
                }}
                document.addEventListener("click", function(event) {{
                    const menu = document.getElementById("extraMenu");
                    const isClickInside = event.target.closest(".menu-button, #extraMenu");
                    if (!isClickInside) {{
                        menu.style.display = "none";
                    }}
                }});
                function toggleCollapsible(button) {{
                    const container = button.parentNode;
                    container.classList.toggle('collapsible-open');
                }}
            </script>
        </head>
        <body>
            <header>
                <button class="menu-button" onclick="toggleMenu()">‚ò∞</button>
                <div id="extraMenu" class="dropdown">
                    <a href="/">üè† Torna alla Home</a>
                    <a href="/consultazione_supermercati">üõí Gestione Supermercati</a>
                    <a href="/lista">üìà Elenca/Modifica</a>
                    <a href="/stats">üìä Report Mese</a>
                    <a href="/report_annuo">üìÖ Report Annuale</a>
                    <a href="/menu_esplora">üîç Esplora</a>
                    <a href="/gestione_categorie">‚öôÔ∏è Gestione Categorie</a>
                    <a href="/utenze?anno={datetime.date.today().year}">üíß Utenze</a>
                    <a href="/documenti_pdf_web">üóÑÔ∏è Documenti PDF</a>
                    <a href="/logoff">üîì Logout</a>
                </div>
                <div class="header-title">üîé Esplorazione Avanzata</div>
            </header>
            <main>
                <form method='get' action='/cerca_avanzata'>
                    <label for='categoria'>Categoria:</label>
                    <select name='categoria'>
                        <option value=''>-- Qualsiasi --</option>
                        {''.join(f"<option value='{html.escape(str(cat))}'>{html.escape(str(cat))}</option>" for cat in categorie)}
                    </select>
                    <label for='tipo'>Tipo:</label>
                    <select name='tipo'>
                        <option value=''>-- Qualsiasi --</option>
                        <option value='Entrata'>Entrata</option>
                        <option value='Uscita'>Uscita</option>
                    </select>
                    <label for='anno'>Anno:</label>
                    <select name='anno'>
                        <option value=''>-- Tutti --</option>
                        {''.join(f"<option value='{html.escape(a)}'>{html.escape(a)}</option>" for a in anni)}
                    </select>
                    <label for='mese'>Mese:</label>
                    <select name='mese'>
                        <option value=''>-- Tutti --</option>
                        {''.join(f"<option value='{m.split(' - ')[0]}'>{m}</option>" for m in mesi)}
                    </select>
                    <div class="collapsible-container">
                        <button type="button" class="collapsible-toggle" onclick="toggleCollapsible(this)">
                            <span class="arrow">‚ñ∂Ô∏è</span> Filtri aggiuntivi
                        </button>
                        <div class="collapsible-content">
                            <label for='min_importo'>Importo minimo (‚Ç¨):</label>
                            <input type='number' name='min_importo' step='0.01' placeholder='es: 10.50'>
                            <label for='max_importo'>Importo massimo (‚Ç¨):</label>
                            <input type='number' name='max_importo' step='0.01' placeholder='es: 100.00'>
                            <label for='q'>Testo libero (descrizione):</label>
                            <input type='text' name='q' placeholder='es: pane, bolletta, abbonamento'>
                        </div>
                    </div>
                    <button type='submit'>üîç Avvia Esplorazione</button>
                </form>
                <a href="/" class="back-button">üè† Torna alla Home</a>
            </main>
        </body>
        </html>
        """
        return html_code
    
    # Gestione Categorie Web
    def add_categoria_web(self, params):
        nome = params.get("nome_categoria", [""])[0].strip()
        tipo = params.get("tipo_categoria", ["Uscita"])[0]
        if not nome or nome in self.categorie or nome == self.CATEGORIA_RIMOSSA:
            print(f"Errore: Categoria '{nome}' gi√† esistente o non valida.")
            return self.html_gestione_categorie()
        self.categorie.append(nome)
        self.categorie_tipi[nome] = tipo
        self.categorie.sort()
        self.save_db()
        self.refresh_categorie_web()
    def modifica_categoria_web(self, params):
        old_nome = params.get("categoria_selezionata", [""])[0]
        new_nome = params.get("nuovo_nome", [""])[0].strip()
        nuovo_tipo = params.get("nuovo_tipo", ["Uscita"])[0]
        if not old_nome or old_nome == "Generica":
            return
        if new_nome == old_nome:
            self.categorie_tipi[new_nome] = nuovo_tipo
        else:
            if not new_nome or new_nome in self.categorie:
                return 
            idx = self.categorie.index(old_nome)
            self.categorie[idx] = new_nome
            self.categorie_tipi[new_nome] = nuovo_tipo
            self.categorie_tipi.pop(old_nome, None)
            for d in self.spese:
                new_entries = []
                for entry in self.spese[d]:
                    if entry[0] == old_nome:
                        entry = (new_nome,) + entry[1:]
                    new_entries.append(entry)
                self.spese[d] = new_entries
            self.categorie.sort()
        self.save_db()
        self.refresh_categorie_web()
    def cancella_categoria_web(self, params):
        cat_da_cancellare = params.get("categoria_selezionata", [""])[0]
        if not cat_da_cancellare or cat_da_cancellare not in self.categorie or cat_da_cancellare == "Generica":
            return
        self.categorie.remove(cat_da_cancellare)
        self.categorie_tipi.pop(cat_da_cancellare, None)
        for d in self.spese:
            new_entries = []
            for entry in self.spese[d]:
                if entry[0] == cat_da_cancellare:
                    entry = (self.CATEGORIA_RIMOSSA,) + entry[1:]
                new_entries.append(entry)
            self.spese[d] = new_entries
        self.save_db()
        self.refresh_categorie_web()
    def refresh_categorie_web(self):
        self.after(100, self._esegui_aggiornamento_gui)
    def _esegui_aggiornamento_gui(self):
        self.load_db()
        self.aggiorna_combobox_categorie()
        self.carica_voci_treeview() 
        if hasattr(self, 'ricorrenza_popup') and self.ricorrenza_popup.winfo_exists():
            if hasattr(self, 'ric_cat_menu'):
                self.ric_cat_menu['values'] = sorted(self.categorie)
        self.refresh_gui()        
        
    def html_gestione_categorie(self):
        import datetime
        categorie_tipi_js = str(self.categorie_tipi).replace("'", '"')
        categorie_options = "".join(
            f"<option value='{cat}'>{cat}</option>" 
            for cat in sorted(self.categorie, key=lambda x: x.strip().lower())
        )
        anno_corrente = datetime.datetime.now().year
        html = f"""
        <!DOCTYPE html>
        <html>
        <head>
            <meta charset="utf-8">
            <title>Gestione Categorie - Casa Facile Web</title>
            <meta name="viewport" content="width=device-width, initial-scale=1">
            <style>
                body {{
                    margin: 0;
                    font-family: 'Segoe UI', sans-serif;
                    background-color: #f4f4f4;
                }}
                header {{
                    background: #0078D4;
                    color: white;
                    padding: 20px 0;
                    position: relative;
                }}
                .header-title {{
                    text-align: center;
                    font-size: 1.2em;
                }}
                .menu-button {{
                    position: absolute;
                    top: 10px;
                    left: 10px;
                    font-size: 1.6em;
                    background: none;
                    border: none;
                    color: white;
                    cursor: pointer;
                }}
                .dropdown {{
                    position: absolute;
                    top: 45px;
                    left: 10px;
                    background-color: white;
                    box-shadow: 0 4px 8px rgba(0,0,0,0.15);
                    border-radius: 4px;
                    display: none;
                    z-index: 999;
                }}
                .dropdown a {{
                    display: block;
                    padding: 10px 20px;
                    text-decoration: none;
                    color: #0078D4;
                    font-weight: bold;
                }}
                .dropdown a:hover {{
                    background-color: #f0f0f0;
                }}
                main {{
                    padding: 10px;
                    max-width: 400px;
                    margin: auto;
                }}
                .category-box {{
                    background: white;
                    padding: 15px 20px;
                    margin-bottom: 15px;
                    border-radius: 8px;
                    box-shadow: 0 0 8px rgba(0,0,0,0.05);
                }}
                details summary {{
                    cursor: pointer;
                    list-style: none;
                    padding: 5px 0;
                }}
                details summary::-webkit-details-marker {{
                    display: none;
                }}
                details summary:before {{
                    content: '‚ñ∂Ô∏è'; 
                    margin-right: 10px;
                    transition: transform 0.2s;
                }}
                details[open] summary:before {{
                    content: 'üîΩ'; 
                    transform: rotate(90deg);
                }}
                label {{
                    display: block;
                    margin-top: 10px;
                    font-weight: bold;
                    font-size: 0.9em;
                }}
                input[type="text"], select {{
                    width: 100%;
                    padding: 8px;
                    margin-top: 5px;
                    margin-bottom: 12px;
                    border: 1px solid #ccc;
                    border-radius: 4px;
                    box-sizing: border-box;
                    font-size: 0.9em;
                }}
                button[type="submit"] {{
                    background-color: #0078D4;
                    color: white;
                    border: none;
                    cursor: pointer;
                    font-size: 0.9em;
                    border-radius: 6px;
                    padding: 10px;
                    margin-top: 10px;
                    display: inline-block;
                    width: auto;
                }}
                button[type="submit"]:hover {{
                    background-color: #005ea6;
                }}
                .delete-button {{
                    background-color: #c43b2e;
                }}
                .delete-button:hover {{
                    background-color: #9c2e25;
                }}
            </style>
            <script>
                const CategorieTipi = {categorie_tipi_js};

                function toggleMenu() {{
                    const menu = document.getElementById("extraMenu");
                    menu.style.display = (menu.style.display === "block") ? "none" : "block";
                }}
                function aggiornaTipoCategoria() {{
                    const selector = document.getElementById("categoria_modifica");
                    const tipoSelect = document.getElementById("nuovo_tipo");
                    const selectedCat = selector.value;
                    
                    if (selectedCat && CategorieTipi[selectedCat]) {{
                        const tipoCorrente = CategorieTipi[selectedCat];
                        tipoSelect.value = tipoCorrente;
                    }} else {{
                        tipoSelect.value = 'Uscita';
                    }}
                }}
                document.addEventListener("click", function(event) {{
                    const menu = document.getElementById("extraMenu");
                    const isClickInside = event.target.closest(".menu-button, #extraMenu");
                    if (!isClickInside) {{
                        menu.style.display = "none";
                    }}
                }});
                document.addEventListener("DOMContentLoaded", function() {{
                    const categoriaModifica = document.getElementById("categoria_modifica");
                    if (categoriaModifica) {{
                        categoriaModifica.addEventListener("change", aggiornaTipoCategoria);
                        if (categoriaModifica.value) {{ 
                           aggiornaTipoCategoria();
                        }}
                    }}
                }});
            </script>
        </head>
        <body>
            <header>
                <button class="menu-button" onclick="toggleMenu()">‚ò∞</button>
                <div id="extraMenu" class="dropdown">
                    <a href="/">üè† Torna alla Home</a>
                    <a href="/consultazione_supermercati">üõí Gestione Supermercati</a>
                    <a href="/lista">üìà Elenca/Modifica</a>
                    <a href="/stats">üìä Report Mese</a>
                    <a href="/report_annuo">üìÖ Report Annuale</a>
                    <a href="/menu_esplora">üîç Esplora</a>
                    <a href="/gestione_categorie">‚öôÔ∏è Gestione Categorie</a>
                    <a href="/utenze?anno={anno_corrente}">üíß Utenze</a>
                    <a href="/documenti_pdf_web">üóÑÔ∏è Documenti PDF</a>
                    <a href="/logoff">üîì Logout</a>
                </div>
                <div class="header-title">‚öôÔ∏è Gestione Categorie</div>
            </header>
            <main>
                <details class="category-box">
                    <summary style="font-size: 1.1em; font-weight: bold; color: #0078D4;">
                        ‚ûï Aggiungi Categoria
                    </summary>
                    <form action="/salva_categoria" method="POST">
                        <input type="hidden" name="operazione" value="aggiungi">
                        <label for="nome_categoria">Nome:</label>
                        <input type="text" name="nome_categoria" required>
                        <label for="tipo_categoria">Tipo:</label>
                        <select name="tipo_categoria">
                            <option value="Uscita">Uscita</option>
                            <option value="Entrata">Entrata</option>
                        </select>
                        <button type="submit">‚ûï Aggiungi</button>
                    </form>
                </details>
                <details class="category-box">
                    <summary style="font-size: 1.1em; font-weight: bold; color: #0078D4;">
                        ‚öôÔ∏è Modifica Categoria
                    </summary>
                    <form action="/salva_categoria" method="POST">
                        <input type="hidden" name="operazione" value="modifica">
                        <label for="categoria_selezionata">Seleziona:</label>
                        <select 
                            name="categoria_selezionata" 
                            id="categoria_modifica" 
                            required
                        >
                            {categorie_options} 
                        </select>
                        <label for="nuovo_nome">Nuovo Nome:</label>
                        <input type="text" name="nuovo_nome" placeholder="Lascia vuoto per modificare solo il tipo">
                        <label for="nuovo_tipo">Nuovo Tipo:</label>
                        <select name="nuovo_tipo" id="nuovo_tipo">
                            <option value="Uscita">Uscita</option>
                            <option value="Entrata">Entrata</option>
                        </select>
                        <button type="submit">‚öôÔ∏è Modifica</button>
                    </form>
                </details>
                <details class="category-box" style="border: 1px solid #c43b2e;">
                    <summary style="font-size: 1.1em; font-weight: bold; color: #c43b2e;">
                        ‚ùå Cancella Categoria
                    </summary>
                    <form action="/cancella_categoria" method="POST">
                        <label for="categoria_selezionata">Seleziona:</label>
                        <select name="categoria_selezionata" required>
                            {categorie_options}
                        </select>
                        <button type="submit" class="delete-button">‚ùå Cancella</button>
                    </form>
                </details>
                <div style="background-color: #0078D4; text-align: center; margin-top: 20px; padding: 10px; border-radius: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.1);">
                    <a href='/' style='font-size:0.9em; text-decoration:none; color:white; display: block; font-weight: bold;'>
                        üè† Torna alla Home
                    </a>
                </div>
            </main>
        </body>
        </html>
        """
        return html

    # Grafici Web
    def get_dati_entrate_uscite_tutti_gli_anni_json(self):
        totali_annuali = {}
        for giorno, voci in self.spese.items():
            try:
                anno = giorno.year
            except AttributeError:
                continue 
            if anno not in totali_annuali:
                totali_annuali[anno] = {'Entrate': 0.0, 'Uscite': 0.0}
            for voce in voci:
                if len(voce) < 4: continue
                raw_importo = voce[2]
                tipo = voce[3] 
                try:
                    importo_str = str(raw_importo).strip().replace(',', '.')
                    importo = float(importo_str)
                except (TypeError, ValueError):
                    continue 
                if tipo == "Entrata":
                    totali_annuali[anno]['Entrate'] += importo
                elif tipo == "Uscita":
                    totali_annuali[anno]['Uscite'] += importo
        anni_ordinati = sorted(totali_annuali.keys()) 
        data_entrate = [totali_annuali[anno]['Entrate'] for anno in anni_ordinati]
        data_uscite = [totali_annuali[anno]['Uscite'] for anno in anni_ordinati]
        dati_json = {
            "labels": [str(anno) for anno in anni_ordinati],
            "datasets": [
                {
                    "label": "Entrate",
                    "data": data_entrate,
                    "backgroundColor": "rgba(40, 167, 69, 0.7)"
                },
                {
                    "label": "Uscite",
                    "data": data_uscite,
                    "backgroundColor": "rgba(220, 53, 69, 0.7)"
                }
            ]
        }
        return json.dumps(dati_json)

    def pagina_statistiche_annuali_web(self):
        oggi = datetime.date.today()
        anno_corrente = oggi.year
        anno_corrente_int = anno_corrente
        oggi_formattata = oggi.strftime('%d/%m/%Y')
        anno_corrente_format = str(anno_corrente)
        try:
            raw = self.calcola_statistiche_annuali_pura().strip()
            totale_entrate_match = re.search(r"Entrate Totali:.*?([‚Ç¨\s\d.,-]+)", raw, re.DOTALL)
            totale_uscite_match = re.search(r"Uscite Totali:.*?([‚Ç¨\s\d.,-]+)", raw, re.DOTALL)
            totale_entrate = totale_entrate_match.group(1).strip() if totale_entrate_match else None
            totale_uscite = totale_uscite_match.group(1).strip() if totale_uscite_match else None
            report_content = raw
            if totale_entrate:
                report_content = re.sub(r".*Entrate Totali:.*?\n", "", report_content, 1, re.DOTALL) 
            if totale_uscite:
                report_content = re.sub(r".*Uscite Totali:.*?\n", "", report_content, 1, re.DOTALL) 
            report_content = report_content.replace("\n", "<br>")
        except Exception as e:
            report_content = "‚ö† Report Testuale: Dati non disponibili (Controlla calcola_statistiche_annuali_pura)."
            totale_entrate = None
            totale_uscite = None
        report_content = report_content.replace("üîπ Mese corrente", "<strong><span style='color:#c43b2e;'>üóìÔ∏è Mese corrente</span></strong>")
        report_content = report_content.replace("üîπ Da inizio anno", "<strong><span style='color:#d48300;'>üìÜ Da inizio anno</span></strong>")
        report_content = report_content.replace("üîπ Proiezione fine anno", "<strong><span style='color:#0078D4;'>üìä Proiezione fine anno</span></strong>")
        report_content = report_content.replace("‚úÖ Risparmio previsto", "<strong><span style='color:green;'>üí∞ Risparmio previsto</span></strong>")
        report_content = report_content.replace("‚ö†Ô∏è Possibile extra spesa", "<strong><span style='color:red;'>üìâ Possibile extra spesa</span></strong>")
        if totale_entrate is not None or totale_uscite is not None:
            entrate_display = totale_entrate if totale_entrate else "N/D"
            uscite_display = totale_uscite if totale_uscite else "N/D"
            report_summary_html = f"""
<div style="padding: 10px 20px; font-size: 1.1em; font-weight: bold; background: #fff; border-bottom: 2px solid #0078D4;">
    <p style="margin: 0;">üí∏ Riepilogo Totale Anno:</p>
    <p style="margin: 5px 0 0 0;">
        üí∞ Entrate: <span style='color:green;'>{entrate_display}</span> | 
        üìâ Uscite: <span style='color:red;'>{uscite_display}</span>
    </p>
</div>
"""
        else:
            report_summary_html = ""
        fallback_storico = '{"labels": ["N/D"], "datasets": [{"label": "Dati non caricati", "data": [0], "backgroundColor": ["#ccc"]}]}'
        fallback_mensile = '{"labels": ["N/D"], "datasets": [{"label": "Dati non caricati", "data": [0], "backgroundColor": ["#ccc"]}]}'
        fallback_cat = '{"labels": ["N/D"], "datasets": [{"data": [1], "backgroundColor": ["#ccc"], "label": "Dati non caricati"}]}'
        fallback_saldo = '{"labels": ["N/D"], "datasets": [{"label": "Dati non caricati", "data": [0], "borderColor": "#ccc"}]}'
        fallback_cat_storico = '{"labels": ["N/D"], "datasets": [{"data": [1], "backgroundColor": ["#ccc"], "label": "Dati non caricati"}]}'
        fallback_saldo_annuale = '{"labels": ["N/D"], "datasets": [{"label": "Dati non caricati", "data": [0], "borderColor": "#ccc", "backgroundColor": ["#ccc"]}]}'
        try:
            dati_entrate_uscite_storici = self.get_dati_entrate_uscite_tutti_gli_anni_json()
        except Exception:
            dati_entrate_uscite_storici = fallback_storico
        try:
            dati_entrate_uscite_mensili = self.get_dati_entrate_uscite_json()
        except Exception:
            dati_entrate_uscite_mensili = fallback_mensile
        try:
            dati_categorie = self.get_dati_categorie_json()
        except Exception:
            dati_categorie = fallback_cat
        try:
            dati_saldo = self.get_dati_saldo_json()
        except Exception:
            dati_saldo = fallback_saldo
        try:
            dati_categorie_storiche = self.get_dati_categorie_storiche_json()
        except Exception as e:
            dati_categorie_storiche = fallback_cat_storico
        try:
            dati_saldo_annuale = self.get_dati_saldo_annuale_json()
        except Exception:
            dati_saldo_annuale = fallback_saldo_annuale
        try:
            data_storico = json.loads(dati_entrate_uscite_storici)
            totale_eu_storico_str = "Dati Non Trovati"
            if data_storico.get("datasets") and len(data_storico["datasets"]) == 2:
                entrate_storiche = sum(data_storico["datasets"][0].get("data", [0]))
                uscite_storiche = sum(data_storico["datasets"][1].get("data", [0]))
                saldo_storico = entrate_storiche - uscite_storiche
                totale_eu_storico_str = f"Entrate: {entrate_storiche:,.2f} | Uscite: {uscite_storiche:,.2f} | Saldo: {saldo_storico:,.2f}"
        except:
            totale_eu_storico_str = "Errore di calcolo"
        try:
            data_mensile = json.loads(dati_entrate_uscite_mensili)
            totale_eu_mensile_str = "Dati Non Trovati"
            if data_mensile.get("datasets") and len(data_mensile["datasets"]) == 2:
                entrate_mensili = sum(data_mensile["datasets"][0].get("data", [0]))
                uscite_mensili = sum(data_mensile["datasets"][1].get("data", [0]))
                saldo_mensile = entrate_mensili - uscite_mensili
                totale_eu_mensile_str = f"Entrate: {entrate_mensili:,.2f} | Uscite: {uscite_mensili:,.2f} | Saldo: {saldo_mensile:,.2f}"
        except:
            totale_eu_mensile_str = "Errore di calcolo"
        try:
            data_saldo = json.loads(dati_saldo)
            saldo_finale_str = "Dati Non Trovati"
            if data_saldo.get("datasets") and data_saldo["datasets"][0].get("data"):
                saldo_finale = data_saldo["datasets"][0]["data"][-1]
                saldo_finale_str = f"Saldo Finale: {saldo_finale:,.2f}"
        except:
            saldo_finale_str = "Errore di calcolo"
        try:
            data_saldo_annuale = json.loads(dati_saldo_annuale)
            totale_saldo_annuale_str = "Dati Non Trovati"
            if data_saldo_annuale.get("datasets") and data_saldo_annuale["datasets"][0].get("data"):
                somma_saldi = sum(data_saldo_annuale["datasets"][0]["data"])
                totale_saldo_annuale_str = f"Saldo Cumulativo: {somma_saldi:,.2f}"
        except:
            totale_saldo_annuale_str = "Errore di calcolo"
        html_template = f"""
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>üìä Report Annuale ‚Äî {oggi_formattata}</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <style>
        body {{
            margin: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f4f4f4;
            font-size: 0.9em;
        }}
        header {{ background: #0078D4; color: white; padding: 20px 0; position: relative; }}
        .header-title {{ text-align: center; font-size: 1.5em; }}
        .menu-button {{ position: absolute; top: 10px; left: 10px; font-size: 1.6em; background: none; border: none; color: white; cursor: pointer; }}
        .dropdown {{ position: absolute; top: 45px; left: 10px; background-size: 100%; background-color: white; box-shadow: 0 4px 8px rgba(0,0,0,0.15); border-radius: 4px; display: none; z-index: 999; }}
        .dropdown a {{ display: block; padding: 10px 20px; text-decoration: none; color: #0078D4; font-weight: bold; }}
        .dropdown a:hover {{ background-color: #f0f0f0; }}
        main {{ padding: 20px; max-width: 600px; margin: auto; }}
        .report-box {{ background: white; padding: 20px; border-radius: 8px; box-shadow: 0 0 8px rgba(0,0,0,0.1); white-space: pre-wrap; word-break: break-word; font-size: 1em; line-height: 1.5em; font-weight: bold; }}
        .back {{ display: block; text-align: center; font-size: 1em; text-decoration: none; background: #0078D4; color: white; padding: 10px; border-radius: 4px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); margin: 20px auto; width: 200px; }}
        .back:hover {{ background-color: #005ea6; }}
        .accordion-header {{ background: #e0e0e0; color: #333; padding: 15px; border-radius: 6px; cursor: pointer; margin-top: 20px; display: flex; justify-content: space-between; align-items: center; font-size: 1.1em; font-weight: bold; }}
        .accordion-header:hover {{ background: #d0d0d0; }}
        .arrow {{ transition: transform 0.3s ease; font-size: 1.2em; }}
        .accordion-header.active .arrow {{ transform: rotate(90deg); }}
        .accordion-content {{
            padding: 0 15px;
            border: 1px solid #ddd;
            border-top: none;
            border-radius: 0 0 8px 8px;
            background: white;
        }}
        .tab-pane {{ padding-top: 15px; display: none; }}
        .tab-pane.active {{ display: block; }}
        .tab-container {{ 
            display: flex; 
            flex-wrap: wrap;
            border-bottom: 2px solid #0078D4; 
            justify-content: center;
            padding: 0;
        }}
        .tab-button {{ 
            padding: 8px 10px;
            cursor: pointer; 
            font-weight: bold; 
            color: #555; 
            border: none; 
            background: #f0f0f0; 
            border-radius: 5px 5px 0 0; 
            margin-right: 2px; 
            margin-bottom: 5px;
            font-size: 0.9em;
        }}
        .tab-button.active {{ background: #0078D4; color: white; }}
        .chart-container {{
            position: relative;
            width: 100%;
            margin: auto;
        }}
        .bar-chart-container {{
            min-height: 500px; 
            height: 50vh; 
            max-height: 600px;
        }}
        #tabCategorie .chart-container,
        #tabStoricoCat .chart-container {{
            height: 650px; 
            max-height: 90vh; 
            display: flex; 
            flex-direction: column;
            padding-top: 0px;
        }}
        .chart-container canvas {{
            max-width: 95%; 
            height: auto !important; 
            display: block;
            margin: 0 auto;
            flex-grow: 1;
        }}
    </style>
    <script>
        const currentYear = {anno_corrente_int};
        const chartInstances = {{}}; 
        window.CATEGORIE_DATA = null;
        window.CATEGORIE_STORICHE_DATA = null;
        window.DATA_SALDO_ANNUALE = JSON.parse('{dati_saldo_annuale}');
        
        const TOTALI = {{
            STORICO_EU: "{totale_eu_storico_str}",
            MENSILE_EU: "{totale_eu_mensile_str}",
            SALDO: "{saldo_finale_str}",
            SALDO_ANNUALE: "{totale_saldo_annuale_str}"
        }};

        function createChart(id, type, data, options) {{
            if (chartInstances[id] && typeof chartInstances[id].destroy === 'function') {{
                chartInstances[id].destroy(); 
            }}
            const ctx = document.getElementById(id);
            if (ctx) {{
                chartInstances[id] = new Chart(ctx, {{ type, data, options }});
                return true;
            }}
            return false;
        }}
        function drawCharts() {{
            const dataCategorie = JSON.parse('{dati_categorie}');
            if (dataCategorie && dataCategorie.labels && dataCategorie.datasets && dataCategorie.datasets.length > 0) {{
                const combinedData = dataCategorie.labels.map((label, index) => ({{
                    label: label,
                    data: dataCategorie.datasets[0].data[index],
                    backgroundColor: dataCategorie.datasets[0].backgroundColor[index]
                }}));
                combinedData.sort((a, b) => a.label.localeCompare(b.label));
                dataCategorie.labels = combinedData.map(item => item.label);
                dataCategorie.datasets[0].data = combinedData.map(item => item.data);
                dataCategorie.datasets[0].backgroundColor = combinedData.map(item => item.backgroundColor);
                dataCategorie.total = combinedData.reduce((sum, item) => sum + item.data, 0);
            }}
            window.CATEGORIE_DATA = dataCategorie; 
            const dataCategorieStoriche = JSON.parse('{dati_categorie_storiche}');
            if (dataCategorieStoriche && dataCategorieStoriche.labels && dataCategorieStoriche.datasets && dataCategorieStoriche.datasets.length > 0) {{
                const combinedData = dataCategorieStoriche.labels.map((label, index) => ({{
                    label: label,
                    data: dataCategorieStoriche.datasets[0].data[index],
                    backgroundColor: dataCategorieStoriche.datasets[0].backgroundColor[index]
                }}));
                dataCategorieStoriche.total = combinedData.reduce((sum, item) => sum + item.data, 0);
            }}
            window.CATEGORIE_STORICHE_DATA = dataCategorieStoriche;
        }}
        function toggleMenu() {{
            const menu = document.getElementById("extraMenu");
            menu.style.display = (menu.style.display === "block") ? "none" : "block";
        }}
        
        document.addEventListener("click", function(event) {{
            const menu = document.getElementById("extraMenu");
            if (!event.target.closest(".menu-button, #extraMenu")) {{
                menu.style.display = "none";
            }}
        }});
        function toggleAccordion(header) {{
            header.classList.toggle("active");
            const content = header.nextElementSibling;
            const isOpening = content.style.display === "none" || content.style.display === "";
            content.style.display = isOpening ? "block" : "none";
            if (isOpening) {{
                const activeTabButton = document.querySelector('.tab-button.active');
                if (activeTabButton) {{
                    const tabName = activeTabButton.getAttribute('onclick').match(/'([^']+)'/)[1];
                    drawSpecificChart(tabName);
                }}
            }}
        }}
        function openTab(tabName, button) {{
            document.querySelectorAll(".tab-pane").forEach(el => el.classList.remove("active"));
            document.querySelectorAll(".tab-button").forEach(el => el.classList.remove("active"));
            document.getElementById(tabName).classList.add("active");
            button.classList.add("active");
            drawSpecificChart(tabName);
        }}
        function drawSpecificChart(tabName) {{
            const dataEntrateUsciteStorici = JSON.parse('{dati_entrate_uscite_storici}');
            const dataEntrateUsciteMensili = JSON.parse('{dati_entrate_uscite_mensili}');
            const dataSaldo = JSON.parse('{dati_saldo}');
            const dataCategorie = window.CATEGORIE_DATA;
            const dataCategorieStoriche = window.CATEGORIE_STORICHE_DATA;
            const dataSaldoAnnuale = window.DATA_SALDO_ANNUALE;
            let success = false;
            const formatCurrency = (amount) => amount.toLocaleString('it-IT', {{ style: 'currency', currency: 'EUR' }});
            const barOptions = {{
                responsive: true,
                maintainAspectRatio: false,
                plugins: {{
                    title: {{ display: true }}
                }},
                barPercentage: 0.9,      
                categoryPercentage: 0.9  
            }};
            const pieOptions = {{
                responsive: true,
                maintainAspectRatio: false,
                plugins: {{
                    title: {{ display: true }}, 
                    legend: {{ 
                        display: true, 
                        position: 'bottom', 
                        align: 'start', 
                        labels: {{ usePointStyle: false, boxWidth: 20, padding: 5 }},
                        onClick: (e, legendItem, legend) => {{
                            const chart = legend.chart;
                            chart.toggleDataVisibility(legendItem.index);
                            const meta = chart.getDatasetMeta(0);
                            let newTotal = 0;
                            meta.data.forEach((element, index) => {{
                                if (chart.getDataVisibility(index)) {{ 
                                    newTotal += chart.data.datasets[0].data[index];
                                }}
                            }});
                            const newTitleText = 'Totale: ' + formatCurrency(newTotal);
                            let mainTitle = chart.options.plugins.title.text[0];
                            chart.options.plugins.title.text = [mainTitle, newTitleText];
                            chart.update(); 
                        }} 
                    }}
                }}
            }};
            switch(tabName) {{
                case 'tabStoricoEU':
                    success = createChart('entrateUsciteStoricheChart', 'bar', dataEntrateUsciteStorici, {{ 
                        ...barOptions, 
                        plugins: {{ ...barOptions.plugins, title: {{ display: true, text: ['Entrate e Uscite Storiche per Anno', 'Totali: ' + TOTALI.STORICO_EU] }} }} 
                    }});
                    break;
                case 'tabMensileEU':
                    success = createChart('entrateUsciteMensiliChart', 'bar', dataEntrateUsciteMensili, {{ 
                        ...barOptions, 
                        plugins: {{ ...barOptions.plugins, title: {{ display: true, text: ['Entrate e Uscite Mensili (' + currentYear + ')', 'Totali: ' + TOTALI.MENSILE_EU] }} }} 
                    }});
                    break;
                case 'tabCategorie':
                    const totalCat = dataCategorie.total !== undefined ? formatCurrency(dataCategorie.total) : 'N/D';
                    success = createChart('categorieChart', 'doughnut', dataCategorie, {{ 
                        ...pieOptions, 
                        plugins: {{ ...pieOptions.plugins, title: {{ display: true, text: ['Spese per Categoria (Anno Corrente)', 'Totale: ' + totalCat] }} }} 
                    }});
                    break;
                case 'tabStoricoCat':
                    const totalStoricoCat = dataCategorieStoriche.total !== undefined ? formatCurrency(dataCategorieStoriche.total) : 'N/D';
                    success = createChart('storicoCategorieChart', 'doughnut', dataCategorieStoriche, {{ 
                        ...pieOptions, 
                        plugins: {{ ...pieOptions.plugins, title: {{ display: true, text: ['Spese Storiche per Categoria (Tutti gli anni)', 'Totale: ' + totalStoricoCat] }} }} 
                    }});
                    break;
                case 'tabSaldo':
                    success = createChart('saldoChart', 'line', dataSaldo, {{ 
                        responsive: true, 
                        maintainAspectRatio: false, 
                        plugins: {{ title: {{ display: true, text: ['Saldo Progressivo Mensile', TOTALI.SALDO] }} }} 
                    }});
                    break;
                case 'tabSaldoAnnuale':
                    success = createChart('saldoAnnualeChart', 'bar', dataSaldoAnnuale, {{ 
                        ...barOptions, 
                        scales: {{ y: {{ beginAtZero: false }} }},
                        plugins: {{ ...barOptions.plugins, title: {{ display: true, text: ['Saldo Netto Annuale per Anno', TOTALI.SALDO_ANNUALE] }} }} 
                    }});
                    break;
            }}
            if (success) {{
                chartInstances[tabName] = true; 
            }}
        }}

        document.addEventListener("DOMContentLoaded", () => {{
            drawCharts();
            const firstTabButton = document.querySelector('.tab-container .tab-button');
            if(firstTabButton) {{
                const tabName = firstTabButton.getAttribute('onclick').match(/'([^']+)'/)[1];
                openTab(tabName, firstTabButton);
            }}
            const accordionContent = document.getElementById("accordionContent");
            accordionContent.style.display = "none";
        }});
    </script>
</head>
<body>
    <header>
        <button class="menu-button" onclick="toggleMenu()">‚ò∞</button>
        <div id="extraMenu" class="dropdown">
            <a href="/">üè† Torna alla Home</a>
            <a href="/consultazione_supermercati">üõí Gestione Supermercati</a>
            <a href="/lista">üìà Elenca/Modifica</a>
            <a href="/stats">üìä Report Mese</a>
            <a href="/report_annuo">üìÖ Report Annuale</a>
            <a href="/menu_esplora">üîç Esplora</a>
            <a href="/gestione_categorie">‚öôÔ∏è Gestione Categorie</a>
            <a href="/utenze?anno={anno_corrente_format}">üíß Utenze</a>
            <a href="/documenti_pdf_web">üóÑÔ∏è Documenti PDF</a>
            <a href="/logoff">üîì Logout</a>
        </div>
        <div class="header-title">üìä Report del {oggi_formattata}</div>
    </header>
    {report_summary_html}
    <main>
        <div class="report-box">{report_content}</div>
        <div class="accordion-header" onclick="toggleAccordion(this)">
            Visualizza Grafici Dettaglio üìä
            <span class="arrow">‚ñ∂</span>
        </div>
        <div id="accordionContent" class="accordion-content">
            <div class="tab-content-wrapper">
                <div class="tab-container">
                    <button class="tab-button" onclick="openTab('tabStoricoEU', this)">Storico</button>
                    <button class="tab-button" onclick="openTab('tabMensileEU', this)">Mensile</button>
                    <button class="tab-button" onclick="openTab('tabSaldo', this)">Saldo Mese</button>
                    <button class="tab-button" onclick="openTab('tabSaldoAnnuale', this)">Saldo Annuale</button> <button class="tab-button" onclick="openTab('tabCategorie', this)">Uscite</button>
                    <button class="tab-button" onclick="openTab('tabStoricoCat', this)">Uscite Storiche</button>
                </div>
                <div class="tab-content">
                    <div id="tabStoricoEU" class="tab-pane">
                        <div class="chart-container bar-chart-container">
                            <canvas id="entrateUsciteStoricheChart"></canvas>
                        </div>
                    </div>
                    <div id="tabMensileEU" class="tab-pane">
                        <div class="chart-container bar-chart-container">
                            <canvas id="entrateUsciteMensiliChart"></canvas>
                        </div>
                    </div>
                    <div id="tabCategorie" class="tab-pane">
                        <div class="chart-container">
                            <canvas id="categorieChart"></canvas>
                        </div>
                    </div>
                    <div id="tabStoricoCat" class="tab-pane">
                        <div class="chart-container">
                            <canvas id="storicoCategorieChart"></canvas>
                        </div>
                    </div>
                    <div id="tabSaldo" class="tab-pane">
                        <div class="chart-container bar-chart-container">
                            <canvas id="saldoChart"></canvas>
                        </div>
                    </div>
                    <div id="tabSaldoAnnuale" class="tab-pane"> 
                        <div class="chart-container bar-chart-container">
                            <canvas id="saldoAnnualeChart"></canvas>
                        </div>
                    </div>
                    
                </div>
            </div>
        </div>
        <a href="/" class="back">üè† Torna alla Home</a>
    </main>
</body>
</html>
"""
        return html_template

    def get_dati_saldo_annuale_json(self):
        saldo_per_anno = {} 
        for d, voci in self.spese.items():
            anno = d.year
            if anno not in saldo_per_anno:
                saldo_per_anno[anno] = 0.0
            for voce in voci:
                importo = float(voce[2]) 
                tipo = voce[3].strip().lower()
                if tipo == "entrata":
                    saldo_per_anno[anno] += importo
                elif tipo == "uscita":
                    saldo_per_anno[anno] -= importo
        anni_ordinati = sorted(saldo_per_anno.keys())
        dati_json = {
            "labels": [str(anno) for anno in anni_ordinati],
            "datasets": [{
                "label": "Saldo Netto Annuale",
                "data": [saldo_per_anno[anno] for anno in anni_ordinati],
                "backgroundColor": ["#228B22" if saldo_per_anno[anno] >= 0 else "#c43b2e" for anno in anni_ordinati]
            }]
        }
        return json.dumps(dati_json)

    def get_dati_categorie_storiche_json(self):
        spese_per_categoria = {}
        for giorno, voci in self.spese.items():
                for voce in voci:
                        if len(voce) >= 4 and voce[3] == "Uscita":
                                categoria, _, importo, _ = voce[:4]
                                spese_per_categoria[categoria] = spese_per_categoria.get(categoria, 0.0) + importo
        if not spese_per_categoria:
                return '{"labels": ["N/D"], "datasets": [{"data": [1], "backgroundColor": ["#ccc"], "label": "Dati non disponibili"}]}'
        sorted_categorie = sorted(spese_per_categoria.keys())
        labels = sorted_categorie
        data = [spese_per_categoria[cat] for cat in sorted_categorie]
        colori_predefiniti = [
                "#3e95cd", "#8e5ea2", "#3cba9f", "#e8c3b9", "#c45850",
                "#ff6384", "#36a2eb", "#ffce56", "#4bc0c0", "#9966ff",
                "#ff9f40", "#ff6384", "#63b5ff", "#c9cbcf", "#e7e9ed"
        ]
        background_colors = [colori_predefiniti[i % len(colori_predefiniti)] for i in range(len(labels))]
        chart_data = {
                "labels": labels,
                "datasets": [{
                        "data": data,
                        "backgroundColor": background_colors,
                        "label": "Spese Storiche"
                }]
        }
        return json.dumps(chart_data)

    # Saldo fine anno
    def calcola_statistiche_annuali_pura(self):
        from datetime import date
        oggi = date.today()
        anno_corr = oggi.year
        anno_prec = anno_corr - 1
        mese_corr = oggi.month
        tot_mese_corr = tot_mese_prec = 0.0
        tot_anno_corr = tot_anno_prec = 0.0
        stima_anno_prec = 0.0
        for giorno, voci in self.spese.items():
            for voce in voci:
                if len(voce) < 4:
                    continue
                categoria, descrizione, importo, tipo = voce[:4]
                if tipo != "Uscita":
                    continue
                if giorno.year == anno_corr and giorno.month == mese_corr:
                    tot_mese_corr += importo
                if giorno.year == anno_prec and giorno.month == mese_corr:
                    tot_mese_prec += importo
                if giorno.year == anno_corr and giorno <= oggi:
                    tot_anno_corr += importo
                if giorno.year == anno_prec and giorno <= oggi.replace(year=anno_prec):
                    tot_anno_prec += importo
                if giorno.year == anno_prec:
                    stima_anno_prec += importo
        giorni_passati = (oggi - date(anno_corr, 1, 1)).days + 1
        giorni_totali = 365
        perc_anno = giorni_passati / giorni_totali
        stima_anno_corr = tot_anno_corr / perc_anno if perc_anno else tot_anno_corr
        variazione_mese_pct = (
            (tot_mese_corr - tot_mese_prec) / tot_mese_prec * 100
            if tot_mese_prec else 0.0
        )
        differenza = stima_anno_prec - stima_anno_corr
        report = f"""üìä Bilancio dinamico Previsionale
        
 Analisi delle spese attuali e stima
 fino a fine {anno_corr}
  üîπ Mese corrente ({mese_corr:02}/{anno_corr})
  ‚Ä¢ Spese {anno_corr}:  ‚Ç¨ {tot_mese_corr:,.2f}
  ‚Ä¢ Spese {anno_prec}:  ‚Ç¨ {tot_mese_prec:,.2f}
  ‚Ä¢ Variazione mensile: {variazione_mese_pct:+.1f}%
 üîπ Da inizio anno (01/01 ‚Üí oggi)
  ‚Ä¢ Totale {anno_corr}:  ‚Ç¨ {tot_anno_corr:,.2f}
  ‚Ä¢ Totale {anno_prec}:  ‚Ç¨ {tot_anno_prec:,.2f}
 üîπ Proiezione fine anno
  ‚Ä¢ Spesa stimata {anno_corr}: ‚Ç¨ {stima_anno_corr:,.2f}  
  ‚Ä¢ (‚è≥ {perc_anno:.1%} dell‚Äôanno trascorso)
  ‚Ä¢ Spesa effettiva {anno_prec}: ‚Ç¨ {stima_anno_prec:,.2f}
    """
        if differenza > 0:
            report += f"\n‚úÖ Risparmio previsto: ‚Ç¨ {differenza:,.2f} \n   se mantieni questo ritmo üí∞"
        else:
            report += f"\n‚ö†Ô∏è Possibile extra spesa: ‚Ç¨ {abs(differenza):,.2f}\n   rispetto al {anno_prec} ü™ô"
        return report.strip()

    def stats_mensili_html(self):
        mesi_it = {
            "January": "gennaio", "February": "febbraio", "March": "marzo",
            "April": "aprile", "May": "aprile", "June": "giugno",
            "July": "luglio", "August": "agosto", "September": "settembre",
            "October": "ottobre", "November": "novembre", "December": "dicembre"
        }
        oggi = datetime.date.today()
        mese_en = oggi.strftime('%B')
        mese_it_corrente = mesi_it.get(mese_en, mese_en)
        titolo_mese = f"{mese_it_corrente.capitalize()} {oggi.year}"
        entrate = 0.0
        uscite = 0.0
        entrate_categorie = {}
        uscite_categorie = {}
        raw_entrate_dettaglio = {}
        raw_uscite_dettaglio = {}
        entrate_count = {}
        uscite_count = {}
        for d, voci in self.spese.items():
            if d.month == oggi.month and d.year == oggi.year:
                for voce in voci:
                    categoria, descrizione, importo, tipo = voce[:4]
                    if tipo == "Entrata":
                        entrate += importo
                        entrate_categorie[categoria] = entrate_categorie.get(categoria, 0.0) + importo
                        raw_entrate_dettaglio.setdefault(categoria, []).append((d, descrizione, importo))
                        entrate_count[categoria] = entrate_count.get(categoria, 0) + 1 
                    else:
                        uscite += importo
                        uscite_categorie[categoria] = uscite_categorie.get(categoria, 0.0) + importo
                        raw_uscite_dettaglio.setdefault(categoria, []).append((d, descrizione, importo))
                        uscite_count[categoria] = uscite_count.get(categoria, 0) + 1 
        saldo = entrate - uscite
        saldo_colore = "#3c763d" if saldo >= 0 else "#c43b2e" 

        def genera_html_categorie(categorie_totals, raw_dettaglio, prefix, counts_dict):
            html_content = ""
            if not categorie_totals:
                return f"<p class='no-data-msg'>Nessuna {prefix} per categoria da mostrare.</p>"
            html_content += "<ul class='category-list'>"
            for cat, totale in sorted(categorie_totals.items()):
                voci_dettaglio = raw_dettaglio.get(cat, [])
                
                dettagli_id = f"{prefix}_{''.join(filter(str.isalnum, cat))}"
                
                arrow_button_html = ''
                if voci_dettaglio:
                    arrow_button_html = f"""
                        <button type="button" class="category-arrow-button" onclick="toggleVisibility('{dettagli_id}', this)" aria-expanded="false" aria-controls="{dettagli_id}">
                            <span class="category-arrow">‚ñ∂Ô∏è</span>
                        </button>
                    """

                color_class = "detail-income" if prefix == "entrate" else "detail-expense"
                dettaglio_items_html = ''.join(
                    f'<li class="detail-item"><span class="detail-text">{data.strftime("%d-%m-%Y")}{" ‚Äî " + desc if desc else ""}</span><span class="detail-amount {color_class}">‚Ç¨{imp:.2f}</span></li>'
                    for data, desc, imp, *_ in voci_dettaglio
                )
                if not dettaglio_items_html:
                    dettaglio_items_html = '<li>Nessun dettaglio disponibile.</li>'
                num_operations = counts_dict.get(cat, 0)
                category_name_html = f'<strong class="category-name">{cat} ({num_operations}):</strong>'
                html_content += f"""
                <li class="category-item">
                    <div class="category-summary">
                        {arrow_button_html}
                        {category_name_html}
                        <span class="category-total">‚Ç¨{totale:.2f}</span>
                    </div>
                    <ul id="{dettagli_id}" class="hidden category-details">
                        {dettaglio_items_html}
                    </ul>
                </li>
                """
            html_content += "</ul>"
            return html_content
        categorie_uscite_html = genera_html_categorie(uscite_categorie, raw_uscite_dettaglio, "uscite", uscite_count)
        categorie_entrate_html = genera_html_categorie(entrate_categorie, raw_entrate_dettaglio, "entrate", entrate_count)
        return f"""
        <!DOCTYPE html>
        <html>
        <head>
            <meta charset="utf-8">
            <title>üìä Report Mese ‚Äî {titolo_mese}</title>
            <meta name="viewport" content="width=device-width, initial-scale=1">
            <style>
                body {{
                    font-family: 'Segoe UI', sans-serif;
                    background-color: #f4f4f4;
                    margin: 0;
                    padding: 0;
                    box-sizing: border-box;
                }}
                header {{
                    background: #0078D4;
                    color: white;
                    padding: 20px 0;
                    position: relative;
                }}
                .header-title {{
                    text-align: center;
                    font-size: 1.5em;
                }}
                .menu-button {{
                    position: absolute;
                    top: 10px;
                    left: 10px;
                    font-size: 1.6em;
                    background: none;
                    border: none;
                    color: white;
                    cursor: pointer;
                }}
                .dropdown {{
                    position: absolute;
                    top: 45px;
                    left: 10px;
                    background-color: white;
                    box-shadow: 0 4px 8px rgba(0,0,0,0.15);
                    border-radius: 4px;
                    display: none;
                    z-index: 999;
                }}
                .dropdown a {{
                    display: block;
                    padding: 10px 20px;
                    text-decoration: none;
                    color: #0078D4;
                    font-weight: bold;
                }}
                .dropdown a:hover {{
                    background-color: #f0f0f0;
                }}
                main {{
                    padding: 15px;
                    max-width: 600px;
                    margin: auto;
                }}
                h2 {{
                    color: #333;
                    text-align: center;
                    font-size: 1.4em;
                    margin-bottom: 15px;
                    padding: 10px 0;
                    background-color: #e9e9e9;
                    border-radius: 6px;
                    box-shadow: 0 1px 3px rgba(0,0,0,0.08);
                }}
                .main-stats {{
                    list-style-type: none;
                    padding: 15px;
                    background: #fff;
                    border-radius: 8px;
                    box-shadow: 0 0 8px rgba(0,0,0,0.1);
                    max-width: 100%;
                    margin-bottom: 15px;
                    box-sizing: border-box;
                }}
                .main-stats li {{
                    font-size: 1.1em;
                    margin: 8px 0;
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                }}
                .main-stats li strong {{
                    flex-shrink: 0;
                }}
                .main-stats li span {{
                    text-align: right;
                    flex-grow: 1;
                }}
                .income-color {{
                    color: #3c763d;
                }}
                .expense-color {{
                    color: #c43b2e;
                }}
                .detail-income {{
                    color: #3c763d;
                }}
                .detail-expense {{
                    color: #c43b2e;
                }}

                .category-list {{
                    list-style-type: none;
                    padding: 0;
                    margin: 0;
                }}
                .category-item {{
                    font-size: 1em;
                    margin: 8px 0;
                    display: flex;
                    flex-direction: column;
                    background-color: #fcfcfc;
                    padding: 10px;
                    border-radius: 6px;
                    border: 1px solid #eee;
                    box-shadow: 0 1px 3px rgba(0,0,0,0.05);
                }}
                .category-summary {{
                    display: flex;
                    align-items: center;
                    justify-content: space-between;
                    width: 100%;
                }}
                .category-name {{
                    flex-grow: 1;
                }}
                .category-total {{
                    text-align: right;
                    font-weight: bold;
                    flex-shrink: 0;
                    margin-left: 10px;
                }}
                .category-arrow-button {{
                    background: none;
                    border: none;
                    font-size: 1em;
                    cursor: pointer;
                    padding: 0;
                    margin-right: 5px;
                    -webkit-appearance: none;
                    -moz-appearance: none;
                    appearance: none;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                }}
                .category-arrow-button:hover {{
                    opacity: 0.8;
                }}
                .category-arrow {{
                    transition: transform 0.3s ease;
                    font-size: 0.8em;
                }}
                .category-arrow.rotated {{
                    transform: rotate(90deg);
                }}
                ul.category-details {{
                    list-style-type: none;
                    background: #f0f0f0;
                    padding: 10px 15px;
                    border-radius: 4px;
                    margin-top: 8px;
                    margin-left: 0;
                    font-size: 0.9em;
                    width: 100%;
                    box-sizing: border-box;
                }}
                ul.category-details .detail-item {{
                    display: flex;
                    justify-content: space-between;
                    align-items: baseline;
                    margin: 5px 0;
                    padding-left: 10px;
                    position: relative;
                    flex-wrap: wrap; 
                }}
                ul.category-details .detail-item::before {{
                    content: '‚Ä¢';
                    position: absolute;
                    left: 0;
                    color: #0078D4;
                }}
                .detail-text {{
                    flex-grow: 1;
                    flex-shrink: 1;
                    min-width: 0;
                    padding-right: 5px;
                }}
                .detail-amount {{
                    text-align: right;
                    font-weight: bold;
                    flex-shrink: 0;
                    margin-left: auto;
                }}
                .section-toggle-button {{
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                    width: 100%;
                    padding: 12px;
                    background-color: #0078D4;
                    color: white;
                    border: none;
                    border-radius: 6px;
                    font-size: 1.05em;
                    font-weight: bold;
                    cursor: pointer;
                    margin-top: 20px;
                    margin-bottom: 10px;
                    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
                    text-align: left;
                    box-sizing: border-box;
                    -webkit-appearance: none;
                    -moz-appearance: none;
                    appearance: none;
                }}
                .section-toggle-button:hover {{
                    background-color: #005ea6;
                }}
                .arrow {{
                    transition: transform 0.3s ease;
                    font-size: 0.9em;
                }}
                .arrow.rotated {{
                    transform: rotate(90deg);
                }}
                .hidden {{
                    display: none;
                }}
                .collapsible-content {{
                    display: none;
                    width: 100%;
                    box-sizing: border-box;
                    padding-bottom: 5px;
                }}
                .collapsible-content.active {{
                    display: block;
                }}
                .back {{
                    display: block;
                    text-align: center;
                    font-size: 1em;
                    text-decoration: none;
                    background: #0078D4;
                    color: white;
                    padding: 12px;
                    border-radius: 8px;
                    box-shadow: 0 4px 8px rgba(0,0,0,0.1);
                    margin: 30px auto 20px auto;
                    width: 200px;
                }}
                .back:hover {{
                    background-color: #005ea6;
                }}
                .no-data-msg {{
                    text-align: center;
                    color: #555;
                    font-style: italic;
                    margin-top: 10px;
                    padding: 10px;
                    border: 1px dashed #ccc;
                    border-radius: 5px;
                    background-color: #f9f9f9;
                }}
                @media (max-width: 600px) {{
                    .header-title {{
                        font-size: 1.3em;
                    }}
                    main {{
                        padding: 10px;
                    }}
                    h2 {{
                        font-size: 1.2em;
                        padding: 8px 0;
                    }}
                    .main-stats li {{
                        font-size: 1em;
                    }}
                    .category-item {{
                        padding: 8px;
                    }}
                    .category-summary {{
                        flex-wrap: wrap;
                    }}
                    .category-name {{
                        white-space: normal;
                        overflow: visible;
                        text-overflow: clip;
                    }}
                    .category-total {{
                        width: auto;
                        text-align: right;
                    }}
                    .category-arrow-button {{
                        margin-right: 0;
                    }}
                    ul.category-details {{
                        padding: 8px 10px;
                        font-size: 0.85em;
                    }}
                    ul.category-details .detail-item {{
                        display: flex;
                        flex-wrap: wrap;
                        justify-content: space-between;
                        align-items: baseline;
                    }}
                    .detail-text {{
                        flex-grow: 1;
                        flex-shrink: 1;
                        min-width: 0;
                        padding-right: 5px;
                    }}
                    .detail-amount {{
                        flex-shrink: 0;
                        margin-left: auto;
                        text-align: right;
                    }}

                    ul.category-details li {{
                        padding-left: 15px;
                    }}
                    .section-toggle-button {{
                        font-size: 1em;
                        padding: 10px;
                    }}
                    .back {{
                        width: 180px;
                        padding: 10px;
                    }}
                }}
            </style>
            <script>
                function toggleMenu() {{
                    const menu = document.getElementById("extraMenu");
                    menu.style.display = (menu.style.display === "block") ? "none" : "block";
                }}
                document.addEventListener("click", function(event) {{
                    const menu = document.getElementById("extraMenu");
                    const isClickInside = event.target.closest(".menu-button, #extraMenu");
                    if (!isClickInside) {{
                        menu.style.display = "none";
                    }}
                }});
                function toggleVisibility(contentId, buttonElement) {{
                    const content = document.getElementById(contentId);
                    const arrow = buttonElement.querySelector('.category-arrow') || buttonElement.querySelector('.arrow');
                    let isExpanded = false;
                    if (content.classList.contains('collapsible-content')) {{
                        isExpanded = content.classList.contains('active');
                    }} else {{
                        isExpanded = !content.classList.contains('hidden');
                    }}
                    if (isExpanded) {{
                        if (content.classList.contains('collapsible-content')) {{
                            content.classList.remove('active');
                        }} else {{
                            content.classList.add('hidden');
                        }}
                        if (arrow) arrow.classList.remove('rotated');
                        buttonElement.setAttribute('aria-expanded', 'false');
                    }} else {{
                        if (content.classList.contains('collapsible-content')) {{
                            content.classList.add('active');
                        }} else {{
                            content.classList.remove('hidden');
                        }}
                        if (arrow) arrow.classList.add('rotated');
                        buttonElement.setAttribute('aria-expanded', 'true');
                    }}
                }}
            </script>
        </head>
        <body>
            <header>
                <button class="menu-button" onclick="toggleMenu()">‚ò∞</button>
                <div id="extraMenu" class="dropdown">
                    <a href="/">üè† Torna alla Home</a>
                    <a href="/consultazione_supermercati">üõí Gestione Supermercati</a>
                    <a href="/lista">üìà Elenca/Modifica</a>
                    <a href="/stats">üìä Report Mese</a>
                    <a href="/report_annuo">üìÖ Report Annuale</a>
                    <a href="/menu_esplora">üîç Esplora</a>
                    <a href="/gestione_categorie">‚öôÔ∏è Gestione Categorie</a>
                    <a href="/utenze?anno={datetime.date.today().year}">üíß Utenze</a>
                    <a href="/documenti_pdf_web">üóÑÔ∏è Documenti PDF</a>
                    <a href="/logoff">üîì Logout</a>
                </div>
                <div class="header-title">üìä Report del Mese</div>
            </header>
            <main>
                <h2>üìä Statistiche di {titolo_mese}</h2>
                <ul class="main-stats">
                    <li><strong>Entrate Totali:</strong> <span class="income-color">‚Ç¨{entrate:.2f}</span></li>
                    <li><strong>Uscite Totali:</strong> <span class="expense-color">‚Ç¨{uscite:.2f}</span></li>
                    <li><strong style="color:{saldo_colore};">Saldo:</strong> <span style="color:{saldo_colore};">‚Ç¨{saldo:.2f}</span></li>
                </ul>
                <button type="button" class="section-toggle-button" onclick="toggleVisibility('usciteCategorieContent', this)" aria-expanded="false" aria-controls="usciteCategorieContent">
                    <span>üßÆ Uscite per Categoria</span>
                    <span class="arrow">‚ñ∂Ô∏è</span>
                </button>
                <div id="usciteCategorieContent" class="collapsible-content">
                    {categorie_uscite_html}
                </div>
                <button type="button" class="section-toggle-button" onclick="toggleVisibility('entrateCategorieContent', this)" aria-expanded="false" aria-controls="entrateCategorieContent">
                    <span>üì• Entrate per Categoria</span>
                    <span class="arrow">‚ñ∂Ô∏è</span>
                </button>
                <div id="entrateCategorieContent" class="collapsible-content">
                    {categorie_entrate_html}
                </div>
                <a href="/" class="back">üè† Torna alla Home</a>
            </main>
        </body>
        </html>
        """

    def html_lista_spese_mensili(self):
        mesi_it = {
            "January": "gennaio", "February": "febbraio", "March": "marzo",
            "April": "aprile", "May": "maggio", "June": "giugno",
            "July": "luglio", "August": "agosto", "September": "settembre",
            "October": "ottobre", "November": "novembre", "December": "dicembre"
        }
        oggi = datetime.date.today()
        mese_en = oggi.strftime('%B')
        mese_it_corrente = mesi_it.get(mese_en, mese_en)
        titolo_mese = f"{mese_it_corrente.capitalize()} {oggi.year}"
        current_month_expenses = []
        for d, voci in self.spese.items():
            if d.month == oggi.month and d.year == oggi.year:
                for idx, voce in enumerate(voci):
                    current_month_expenses.append((d, idx, voce))
        current_month_expenses.sort(key=lambda x: x[0], reverse=True)
        if not current_month_expenses:
            schede_html = "<p class='no-data-msg'>Nessuna spesa registrata per questo mese.</p>"
        else:
            schede_html = ""
            for d, idx, voce in current_month_expenses:
                categoria, descrizione, importo, tipo = voce[:4]
                data_str = d.strftime('%d-%m-%Y')
                details_id = f"details_{d.strftime('%Y%m%d')}_{idx}"
                colore_importo = "#228B22" if tipo.strip().lower() == "entrata" else "#c43b2e"
                segno = "+" if tipo.strip().lower() == "entrata" else "-"
                schede_html += f"""
                <div class="expense-item">
                    <div class="expense-summary" onclick="toggleVisibility('{details_id}', this)">
                        <span class="arrow">‚ñ∂Ô∏è</span>
                        <span class="date">{data_str}</span>
                        <span class="cat">{categoria}</span>
                        <span class="amount" style="color:{colore_importo};">{segno}‚Ç¨{importo:.2f}</span>
                    </div>
                    <div id="{details_id}" class="collapsible-content expense-actions">
                        <div class="row-detail">
                            <span class="label">Tipo:</span>
                            <span>{tipo}</span>
                        </div>
                        <div class="row-detail">
                            <span class="label">Descrizione:</span>
                            <span>{descrizione}</span>
                        </div>
                        <div class="row-detail actions">
                            <form method="get" action="/modifica">
                                <input type="hidden" name="data" value="{data_str}">
                                <input type="hidden" name="idx" value="{idx}">
                                <button type="submit" class="details-button">‚úèÔ∏è Modifica</button>
                            </form>
                            <form onsubmit="
                                event.preventDefault();
                                fetch('/cancella', {{
                                    method: 'POST',
                                    headers: {{ 'Content-Type': 'application/x-www-form-urlencoded' }},
                                    body: 'data={data_str}&idx={idx}'
                                }}).then(function() {{
                                    window.location.href='/lista';
                                }});
                            ">
                                <button type="submit" class="details-button danger">‚ùå Cancella</button>
                            </form>
                        </div>
                    </div>
                </div>
                """
        return f"""
        <!DOCTYPE html>
        <html>
        <head>
            <meta charset="utf-8">
            <title>üìà Spese ‚Äî {titolo_mese}</title>
            <meta name="viewport" content="width=device-width, initial-scale=1">
            <style>
                body {{
                    font-family: 'Segoe UI', sans-serif;
                    background-color: #f4f4f4;
                    margin: 0;
                    padding: 0;
                }}
                header {{
                    background: #0078D4;
                    color: white;
                    padding: 20px 0;
                    position: relative;
                }}
                .header-title {{
                    text-align: center;
                    font-size: 1.5em;
                }}
                .menu-button {{
                    position: absolute;
                    top: 10px;
                    left: 10px;
                    font-size: 1.6em;
                    background: none;
                    border: none;
                    color: white;
                    cursor: pointer;
                }}
                .dropdown {{
                    position: absolute;
                    top: 45px;
                    left: 10px;
                    background-color: white;
                    box-shadow: 0 4px 8px rgba(0,0,0,0.15);
                    border-radius: 4px;
                    display: none;
                    z-index: 999;
                }}
                .dropdown a {{
                    display: block;
                    padding: 10px 20px;
                    text-decoration: none;
                    color: #0078D4;
                    font-weight: bold;
                }}
                .dropdown a:hover {{
                    background-color: #f0f0f0;
                }}
                main {{
                    padding: 15px;
                    max-width: 700px;
                    margin: auto;
                }}
                h2 {{
                    color: #333;
                    text-align: center;
                    font-size: 1.4em;
                    margin-bottom: 15px;
                    padding: 10px 0;
                    background-color: #e9e9e9;
                    border-radius: 6px;
                    box-shadow: 0 1px 3px rgba(0,0,0,0.08);
                }}
                .expense-item {{
                    background: #fff;
                    border-radius: 8px;
                    box-shadow: 0 0 8px rgba(0,0,0,0.1);
                    margin-bottom: 13px;
                    overflow: hidden;
                    transition: box-shadow 0.2s;
                    padding-bottom: 0;
                }}
                .expense-summary {{
                    display: flex;
                    flex-direction: row;
                    align-items: center;
                    width: 100%;
                    cursor: pointer;
                    padding: 13px 12px 8px 0px;
                    background: #f9f9f9;
                    position: relative;
                    transition: background 0.2s;
                    border-bottom: 1px solid #e5e5e5;
                    gap: 10px;
                }}
                .expense-summary:hover {{
                    background: #edf7fd;
                }}
                .arrow {{
                    flex-shrink: 0;
                    width: 22px;
                    height: 22px;
                    display: inline-block;
                    vertical-align: middle;
                    transition: transform 0.3s ease;
                    font-size: 1em;
                    margin-right: 5px;
                }}
                .date {{
                    color: #888;
                    font-size: 1.04em;
                    white-space: nowrap;
                    flex-shrink: 0;
                    margin-right: 12px;
                }}
                .cat {{
                    font-weight: bold;
                    color: #0078D4;
                    font-size: 1.09em;
                    white-space: nowrap;
                    overflow: hidden;
                    text-overflow: ellipsis;
                    flex: 1 1 0;
                    min-width: 0;
                    margin-right: 12px;
                    max-width: 170px;
                }}
                .amount {{
                    font-weight: bold;
                    font-size: 1.09em;
                    white-space: nowrap;
                    flex-shrink: 0;
                    margin-left: auto;
                    text-align: right;
                    min-width: 100px;
                }}
                .expense-summary[aria-expanded="true"] .arrow,
                .expense-summary .arrow.rotated {{
                    transform: rotate(90deg);
                }}
                .collapsible-content {{
                    display: none;
                    width: 100%;
                    box-sizing: border-box;
                    background: #f0f0f0;
                    padding: 10px 15px;
                    border-top: 1px solid #e0e0e0;
                    animation: fadeIn 0.4s;
                }}
                .collapsible-content.active {{
                    display: flex;
                    flex-direction: column;
                    gap: 8px;
                }}
                .row-detail {{
                    display: flex;
                    gap: 7px;
                    align-items: center;
                    font-size: 1em;
                    margin-bottom: 3px;
                }}
                .row-detail .label {{
                    font-weight: 600;
                    color: #0078D4;
                    min-width: 90px;
                }}
                .actions {{
                    gap: 12px;
                    margin-top: 7px;
                }}
                .details-button {{
                    font-size: 0.96em;
                    background: none;
                    border: 1px solid #0078D4;
                    color: #0078D4;
                    cursor: pointer;
                    padding: 6px 12px;
                    border-radius: 5px;
                    margin-right: 10px;
                    margin-bottom: 0;
                    white-space: nowrap;
                    transition: background 0.2s, color 0.2s;
                }}
                .details-button:hover {{
                    background: #0078D4;
                    color: white;
                }}
                .details-button.danger {{
                    border-color: #c43b2e;
                    color: #c43b2e;
                }}
                .details-button.danger:hover {{
                    background: #c43b2e;
                    color: white;
                }}
                .no-data-msg {{
                    text-align: center;
                    color: #555;
                    font-style: italic;
                    margin-top: 10px;
                    padding: 10px;
                    border: 1px dashed #ccc;
                    border-radius: 5px;
                    background-color: #f9f9f9;
                }}
                .back {{
                    display: block;
                    text-align: center;
                    font-size: 1em;
                    text-decoration: none;
                    background: #0078D4;
                    color: white;
                    padding: 12px;
                    border-radius: 8px;
                    box-shadow: 0 4px 8px rgba(0,0,0,0.1);
                    margin: 30px auto 20px auto;
                    width: 200px;
                }}
                .back:hover {{
                    background-color: #005ea6;
                }}
                @media (max-width: 700px) {{
                    main {{
                        max-width: 97vw;
                    }}
                    .cat {{
                        font-size: 1em;
                        max-width: 110px;
                    }}
                    .amount {{
                        min-width: 90px;
                    }}
                }}
                @media (max-width: 600px) {{
                    .header-title {{
                        font-size: 1.2em;
                    }}
                    main {{
                        padding: 5px;
                    }}
                    h2 {{
                        font-size: 1em;
                        padding: 6px 0;
                    }}
                    .expense-summary {{
                        gap: 7px;
                        padding: 11px 8px 6px 0px;
                    }}
                    .cat {{
                        font-size: 1em;
                        max-width: 130px;
                    }}
                    .amount {{
                        font-size: 0.98em;
                        min-width: 76px;
                    }}
                    .arrow {{
                        margin-right: 3px;
                    }}
                    .collapsible-content {{
                        gap: 8px;
                        padding: 8px 7px;
                    }}
                    .back {{
                        width: 95%;
                    }}
                }}
                @keyframes fadeIn {{
                    from {{ opacity: 0; }}
                    to {{ opacity: 1; }}
                }}
            </style>
            <script>
                function toggleMenu() {{
                    const menu = document.getElementById("extraMenu");
                    menu.style.display = (menu.style.display === "block") ? "none" : "block";
                }}
                document.addEventListener("click", function(event) {{
                    const menu = document.getElementById("extraMenu");
                    const isClickInside = event.target.closest(".menu-button, #extraMenu");
                    if (!isClickInside) {{
                        menu.style.display = "none";
                    }}
                }});
                function toggleVisibility(contentId, summaryElem) {{
                    var content = document.getElementById(contentId);
                    var arrow = summaryElem.querySelector('.arrow');
                    var expanded = content.classList.contains('active');
                    if (expanded) {{
                        content.classList.remove('active');
                        arrow.classList.remove('rotated');
                        summaryElem.setAttribute('aria-expanded', 'false');
                    }} else {{
                        content.classList.add('active');
                        arrow.classList.add('rotated');
                        summaryElem.setAttribute('aria-expanded', 'true');
                    }}
                }}
            </script>
        </head>
        <body>
            <header>
                <button class="menu-button" onclick="toggleMenu()">‚ò∞</button>
                <div id="extraMenu" class="dropdown">
                    <a href="/">üè† Torna alla Home</a>
                    <a href="/consultazione_supermercati">üõí Gestione Supermercati</a>
                    <a href="/lista">üìà Elenca/Modifica</a>
                    <a href="/stats">üìä Report Mese</a>
                    <a href="/report_annuo">üìÖ Report Annuale</a>
                    <a href="/menu_esplora">üîç Esplora</a>
                    <a href="/gestione_categorie">‚öôÔ∏è Gestione Categorie</a>
                    <a href="/utenze?anno={datetime.date.today().year}">üíß Utenze</a>
                    <a href="/documenti_pdf_web">üóÑÔ∏è Documenti PDF</a>
                    <a href="/logoff">üîì Logout</a>
                </div>
                <div class="header-title">üìà Movimenti di {titolo_mese}</div>
            </header>
            <main>
                <h2>üìà Elenco Movimenti di {titolo_mese}</h2>
                {schede_html}
                <a href="/" class="back">üè† Torna alla Home</a>
            </main>
        </body>
        </html>
        """

    def modifica_voce_form(self, params):
        from datetime import datetime
        data = params.get("data", [""])[0]
        idx = int(params.get("idx", ["0"])[0])
        d_obj = datetime.strptime(data, "%d-%m-%Y").date()
        voce = self.spese[d_obj][idx]
        categoria_corrente, descrizione, importo, tipo = voce[:4]

        categorie_options = "\n".join(
            f"<option value='{c}' {'selected' if c == categoria_corrente else ''}>{c}</option>"
            for c in sorted(self.categorie)
        )
        return f"""
        <html><head><meta charset="utf-8"><title>Modifica</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <style>
            body {{
                font-family: Segoe UI, sans-serif;
                padding: 20px;
                background: #f4f4f4;
                margin: 0;
            }}
            .container {{
                max-width: 500px;
                margin: auto;
                background: white;
                padding: 20px;
                border-radius: 8px;
                box-shadow: 0 0 8px rgba(0,0,0,0.1);
            }}
            label {{
                display: block;
                margin: 12px 0 4px;
                font-weight: bold;
            }}
            input, select {{
                width: 100%;
                padding: 8px;
                font-size: 1em;
                margin-bottom: 12px;
                box-sizing: border-box;
            }}
            button {{
                background: #0078D4;
                color: white;
                border: none;
                padding: 10px;
                font-size: 1em;
                border-radius: 6px;
                width: 100%;
            }}
            a {{
                display: block;
                margin-top: 20px;
                text-align: center;
                text-decoration: none;
                color: #0078D4;
            }}
        </style>
        </head>
        <body>
            <div class="container">
                <h2 style="text-align:center;">‚úèÔ∏è Modifica voce del {data}</h2>
                <form method="post" action="/salva_modifica">
                    <input type="hidden" name="data" value="{data}">
                    <input type="hidden" name="idx" value="{idx}">
                    <label for="categoria">Categoria</label>
                    <select name="categoria" required>
                        {categorie_options}
                    </select>
                    <label for="descrizione">Descrizione</label>
                    <input name="descrizione" value="{descrizione}">
                    <label for="importo">Importo (‚Ç¨)</label>
                    <input name="importo" type="number" step="0.01" min="0.01" value="{importo}" required>
                    <label for="tipo">Tipo</label>
                    <select name="tipo">
                        <option value="Entrata" {"selected" if tipo == "Entrata" else ""}>Entrata</option>
                        <option value="Uscita" {"selected" if tipo != "Entrata" else ""}>Uscita</option>
                    </select>
                    <button type="submit">üíæ Salva</button>
                </form>
                <a href="/lista" style="background:#0078D4;color:#fff;padding:10px;border-radius:6px;text-align:center;display:block;text-decoration:none;">üîô Torna alla lista</a>
            </div>
        </body></html>
        """

    def salva_modifica_voce(self, params):
        from datetime import datetime
        data = params.get("data", [""])[0]
        idx = int(params.get("idx", ["0"])[0])
        cat = params.get("categoria", [""])[0]
        descr = params.get("descrizione", [""])[0]
        imp = float(params.get("importo", ["0"])[0])
        tipo = params.get("tipo", ["Uscita"])[0]
        d_obj = datetime.strptime(data, "%d-%m-%Y").date()
        originale = self.spese[d_obj][idx]  
        nuova_voce = [cat, descr, imp, tipo]
        if len(originale) > 4:
            nuova_voce.append(originale[4])
        self.spese[d_obj][idx] = nuova_voce
        self.save_db()
        self.carica_db_web()
        self.refresh_gui() 
    def cancella_voce_web(self, data_str, idx):
        try:
            d_obj = datetime.datetime.strptime(data_str, "%d-%m-%Y").date()
        except Exception as e:
            print(f"‚ùå Data non valida: {data_str} ‚Üí {e}")
            return
        if d_obj not in self.spese or idx >= len(self.spese[d_obj]):
            print(f"‚ùå Voce non trovata per cancellazione")
            return
        voce_eliminata = self.spese[d_obj].pop(idx)
        print(f"üóëÔ∏è Voce eliminata:", voce_eliminata)
        self.save_db()
        self.carica_db_web()
        self.refresh_gui()
    def aggiungi_voce_web(self, voce):
        try:
            with open(DB_FILE, "r", encoding="utf-8") as f:
                dati = json.load(f)
        except Exception:
            dati = {"spese": []}
        try:
            d_obj = datetime.datetime.strptime(voce["date"], "%Y-%m-%d").date()
            data_str = d_obj.strftime("%d-%m-%Y")
            voce["date"] = data_str  
        except Exception as e:
            print(f"‚ùå Data non valida: {voce['date']} ‚Üí {e}")
            return
        for giorno in dati["spese"]:
            if giorno["date"] == data_str:
                giorno["entries"].append(voce)
                break
        else:
            dati["spese"].append({
                "date": data_str,
                "entries": [voce]
            })
        with open(DB_FILE, "w", encoding="utf-8") as f:
            json.dump(dati, f, indent=2, ensure_ascii=False)
        self.carica_db_web()
        self.refresh_gui()
 
    def carica_db_web(self):
        try:
            with open(DB_FILE, "r", encoding="utf-8") as f:
                dati = json.load(f)
        except Exception as e:
            print(f"‚ùå Errore lettura DB: {e}")
            return
        self.spese = {}
        for giorno in dati.get("spese", []):
            try:
                d = datetime.datetime.strptime(giorno["date"], "%d-%m-%Y").date()
                entries = []
                for e in giorno["entries"]:
                    voce = (
                        e.get("categoria", ""),
                        e.get("descrizione", ""),
                        float(e.get("importo", 0.0)),
                        e.get("tipo", "Uscita"),
                        *([e["id_ricorrenza"]] if "id_ricorrenza" in e else [])
                    )
                    entries.append(voce)
                self.spese[d] = entries
            except Exception as ex:
                print(f"‚ö†Ô∏è Errore parsing giorno {giorno.get('date')}: {ex}")

    def get_dati_entrate_uscite_json(self):
        oggi = datetime.date.today()
        anno_corrente = oggi.year
        entrate_mensili = [0.0] * 12
        uscite_mensili = [0.0] * 12
        for data, entries in self.spese.items():
            if data.year == anno_corrente:
                mese_indice = data.month - 1  
                for entry in entries:
                    categoria = entry[0]
                    importo = entry[2]
                    tipo = self.categorie_tipi.get(categoria, 'Uscita') 
                    if tipo == 'Entrata':
                        entrate_mensili[mese_indice] += importo
                    else: 
                        uscite_mensili[mese_indice] += importo
        mesi = ['Gen', 'Feb', 'Mar', 'Apr', 'Mag', 'Giu', 'Lug', 'Ago', 'Set', 'Ott', 'Nov', 'Dic']
        
        dati = {
            'labels': mesi,
            'datasets': [
                {'label': 'Entrate (‚Ç¨)', 'data': entrate_mensili, 'borderColor': 'rgba(75, 192, 192, 1)', 'backgroundColor': 'rgba(75, 192, 192, 0.5)'},
                {'label': 'Uscite (‚Ç¨)', 'data': uscite_mensili, 'borderColor': 'rgba(255, 99, 132, 1)', 'backgroundColor': 'rgba(255, 99, 132, 0.5)'}
            ]
        }
        return json.dumps(dati)

    def get_dati_saldo_json(self):
        oggi = datetime.date.today()
        anno_corrente = oggi.year
        saldo_mensile_netto = [0.0] * 12
        for data, entries in self.spese.items():
            if data.year == anno_corrente:
                mese_indice = data.month - 1
                for entry in entries:
                    categoria = entry[0]
                    importo = entry[2]
                    tipo = self.categorie_tipi.get(categoria, 'Uscita')
                    
                    if tipo == 'Entrata':
                        saldo_mensile_netto[mese_indice] += importo
                    else:
                        saldo_mensile_netto[mese_indice] -= importo
        saldo_progressivo = []
        saldo_accumulato = 0.0
        for saldo_netto in saldo_mensile_netto:
            saldo_accumulato += saldo_netto
            saldo_progressivo.append(round(saldo_accumulato, 2))
        mesi = ['Gen', 'Feb', 'Mar', 'Apr', 'Mag', 'Giu', 'Lug', 'Ago', 'Set', 'Ott', 'Nov', 'Dic']
        dati = {
            'labels': mesi,
            'datasets': [{
                'label': 'Saldo Progressivo (‚Ç¨)',
                'data': saldo_progressivo,
                'fill': False,
                'borderColor': 'rgb(75, 192, 192)',
                'tension': 0.1
            }]
        }
        return json.dumps(dati)

    def get_dati_categorie_json(self):
        oggi = datetime.date.today()
        anno_corrente = oggi.year
        spese_per_categoria = {}
        for data, entries in self.spese.items():
            if data.year == anno_corrente:
                for entry in entries:
                    categoria = entry[0]
                    importo = entry[2]
                    tipo = self.categorie_tipi.get(categoria, 'Uscita')
                    if tipo == 'Uscita':
                        spese_per_categoria[categoria] = spese_per_categoria.get(categoria, 0.0) + importo
        labels = list(spese_per_categoria.keys())
        spese = [round(v, 2) for v in spese_per_categoria.values()]
        colori = ['#' + ''.join([random.choice('0123456789ABCDEF') for j in range(6)]) for i in range(len(labels))]
        dati = {
            'labels': labels,
            'datasets': [{
                'data': spese,
                'backgroundColor': colori,
                'hoverOffset': 4
            }]
        }
        return json.dumps(dati)

    def refresh_gui(self):
        self.update_stats()
        #self.aggiorna_combobox_categorie()
        self.update_totalizzatore_anno_corrente()
        self.update_totalizzatore_mese_corrente()
        self.update_spese_mese_corrente()
        self.colora_giorni_spese()

    def aggiorna_gui_da_db(self):
        self.spese = {}
        for giorno in self.db.get("spese", []):
            try:
                d = datetime.datetime.strptime(giorno["date"], "%d-%m-%Y").date()
                entries = []
                for e in giorno["entries"]:
                    voce = (
                        e.get("categoria", ""),
                        e.get("descrizione", ""),
                        float(e.get("importo", 0.0)),
                        e.get("tipo", "Uscita")
                    )
                    if "id_ricorrenza" in e:
                        voce += (e["id_ricorrenza"],)
                    entries.append(voce)
                self.spese[d] = entries
            except Exception as ex:
                print(f"‚ö†Ô∏è Errore parsing giorno: {giorno.get('date')} ‚Üí {ex}")
                
    # Salva DB Web
    def save_db_web(self, db=None):
        if db is None:
            db = self.db
        try:
            with open(DB_FILE, "w", encoding="utf-8") as f:
                json.dump(db, f, indent=2, ensure_ascii=False)
            print("üíæ Database salvato correttamente.")
            self.aggiorna_gui_da_db()        
        except Exception as e:
            print("‚ùå Errore salvataggio DB:", e)

    # Gestione Spesa Intelligente
    def spesa_supermercato(self):
        self.risultati_finali = []
        try:
            from tkcalendar import DateEntry
        except ImportError:
            DateEntry = None
            if not hasattr(self, '_tkcalendar_warned'):
                print("AVVISO: Libreria 'tkcalendar' non trovata. La data dovr√† essere inserita manualmente (gg-mm-aaaa).")
                self._tkcalendar_warned = True
        DEFAULT_SUPERMERCATI = ["Coop", "Dpiu", "Esselunga", "Eurospin", "Lidl", "Maurys"]
        SUPERMERCATI = []
        lista_spesa_data = defaultdict(lambda: {})
        campi_input_refs = {}
        dati_supermercati = {}
        ricerca_vars_crud = {}
        ricerca_var_confronto = tk.StringVar()
        supermercato_selezionato_var = tk.StringVar()
        filtro_supermercato_confronto_var = tk.StringVar(value="Tutti i supermercati")
        if not hasattr(self, 'risultati_tv_ref'):
            self.risultati_tv_ref = None
        if hasattr(self, '_popup_spesa_active') and self._popup_spesa_active.winfo_exists():
            self._popup_spesa_active.lift()
            return
        def _carica_dati_interno():
            nonlocal SUPERMERCATI, dati_supermercati
            if not os.path.exists(DB_DIR):
                os.makedirs(DB_DIR, exist_ok=True)
            try:
                if not os.path.exists(SUPERMERCATI_DB) or os.stat(SUPERMERCATI_DB).st_size == 0:
                    dati = {s: [] for s in DEFAULT_SUPERMERCATI}
                    SUPERMERCATI = DEFAULT_SUPERMERCATI
                    dati_supermercati = dati
                    _salva_dati_interno(dati)
                    return
                else:
                    with open(SUPERMERCATI_DB, 'r', encoding='utf-8') as f:
                        dati = json.load(f)
                        loaded_supermercati = [k for k, v in dati.items() if isinstance(v, list)]
                        loaded_supermercati.sort()
                        SUPERMERCATI = loaded_supermercati if loaded_supermercati else DEFAULT_SUPERMERCATI
                        dati_supermercati = {s: dati.get(s, []) for s in SUPERMERCATI}
            except (FileNotFoundError, json.JSONDecodeError):
                SUPERMERCATI = DEFAULT_SUPERMERCATI
                dati_supermercati = {s: [] for s in DEFAULT_SUPERMERCATI}
        def _salva_dati_interno(dati_da_salvare):
            try:
                with open(SUPERMERCATI_DB, 'w', encoding='utf-8') as f:
                    dati_filtrati = {}
                    for s in SUPERMERCATI:
                        if s in dati_da_salvare and dati_da_salvare[s]:
                            lista_articoli = dati_da_salvare[s].copy()
                            lista_articoli.sort(key=lambda x: x.get('nome', '').strip().lower()) 
                            dati_filtrati[s] = lista_articoli
                        elif s in dati_da_salvare:
                            dati_filtrati[s] = []
                    json.dump(dati_filtrati, f, indent=4, ensure_ascii=False)
            except Exception as e:
                print(f"Errore durante il salvataggio: {e}")
        def _svuota_campi(refs):
            prima_categoria_default = "Affettati"
            if CATEGORIE_PREDEFINITE and isinstance(CATEGORIE_PREDEFINITE, list):
                prima_categoria_default = CATEGORIE_PREDEFINITE[0]
            refs['nome'].set("")
            refs['descrizione'].set("")
            refs['categoria'].set(prima_categoria_default)
            refs['prezzo'].set("")
            refs['promo_attiva'].set(False)
            refs['prezzo_promo'].set("")
            refs['quantita'].set("")
            refs['data_scadenza'].set("")
            refs['data_inserimento_prezzo'].set("")
            refs['data_inizio_promo'].set("")
        def _controlla_scadenza_promo():
            def _parse_data_per_confronto(data_str):
                if not data_str:
                    return None
                for fmt in ['%d-%m-%Y']:
                    try:
                        return datetime.datetime.strptime(data_str, fmt).date() 
                    except ValueError:
                        continue
                return None
            nonlocal dati_supermercati
            oggi = datetime.datetime.now().date()
            articoli_modificati = False
            for supermercato, articoli in dati_supermercati.items():
                for articolo in articoli:
                    if articolo.get("promo", False) and articolo.get("data_scadenza"):
                        data_scad_str = articolo["data_scadenza"].strip()
                        data_scadenza = _parse_data_per_confronto(data_scad_str)
                        if data_scadenza is None:
                            continue 
                        if data_scadenza <= oggi:
                            articolo["promo"] = False
                            articolo["prezzo_promo"] = ""
                            articolo["data_scadenza"] = ""
                            articolo["data_inizio_promo"] = ""
                            articoli_modificati = True
            if articoli_modificati:
                _salva_dati_interno(dati_supermercati)
                if hasattr(self, 'risultati_tv_ref') and self.risultati_tv_ref:
                    _aggiorna_lista_spesa_intelligente(self.risultati_tv_ref)
                if hasattr(self, 'show_custom_warning'):
                    self.show_custom_warning("Aggiornamento Automatico", "Sono state disattivate alcune promozioni scadute.")
        def _sort_treeview(treeview, col, reverse):
            def convert_value(val):
                if isinstance(val, str):
                    val_clean = val.replace('‚Ç¨', '').replace(',', '.').strip()
                    try:
                        return float(val_clean)
                    except (ValueError, TypeError):
                        return str(val).lower()
                try:
                    return float(val)
                except:
                    return str(val).lower()
            is_hierarchical = treeview.cget('show') == 'tree headings' and col != '#0' and treeview.master.winfo_name() == 'frame_tv_lista'
            if is_hierarchical:
                for parent in treeview.get_children(''):
                    if treeview.tag_has('grand_total', parent): continue
                    children = treeview.get_children(parent)
                    data = [(treeview.set(child, col), child) for child in children if treeview.item(child, 'tags') != ('supermarket',)]
                    data.sort(key=lambda item: convert_value(item[0]), reverse=reverse)
                    for index, (val, child) in enumerate(data):
                        treeview.move(child, parent, index)
            else:
                data = [(treeview.set(child, col), child) for child in treeview.get_children('')]
                data.sort(key=lambda item: convert_value(item[0]), reverse=reverse)
                for index, (val, child) in enumerate(data):
                    treeview.move(child, '', index)
            treeview.heading(col, command=lambda _col=col, t=treeview: _sort_treeview(t, _col, not reverse))
        def _carica_treeview(treeview, supermercato, articoli_filtrati=None):
            from datetime import datetime
            def determina_tag_promo(data_inizio_str, data_scadenza_str, is_promo_flag):
                if not is_promo_flag:
                    return ()
                FORMATO_DATA = '%d-%m-%Y' 
                oggi = datetime.now().date()
                data_inizio = None
                data_scadenza = None
                try:
                    if data_inizio_str:
                        data_inizio = datetime.strptime(data_inizio_str, FORMATO_DATA).date()
                    if data_scadenza_str:
                        data_scadenza = datetime.strptime(data_scadenza_str, FORMATO_DATA).date()
                except (ValueError, TypeError):
                    pass 
                if not data_inizio or not data_scadenza:
                    return ('promo_in_arrivo',) 
                if data_inizio <= oggi <= data_scadenza:
                    return ('promo_attiva',)
                elif oggi < data_inizio:
                    return ('promo_in_arrivo',)
                else:
                    return () 
            treeview.delete(*treeview.get_children())
            articoli_da_mostrare = articoli_filtrati if articoli_filtrati is not None else dati_supermercati.get(supermercato, [])
            articoli_da_mostrare.sort(key=lambda x: x.get('nome', '').lower())
            for i, articolo in enumerate(articoli_da_mostrare):
                promo_attiva_str = "Si" if articolo.get('promo', False) else "No"
                prezzo_promo_raw = articolo.get('prezzo_promo')
                prezzo_promo_val = f"{float(prezzo_promo_raw):.2f}" if prezzo_promo_raw and str(prezzo_promo_raw).replace('.', '', 1).isdigit() else ""
                prezzo_normale_raw = articolo.get('prezzo')
                prezzo_normale_val = f"{float(prezzo_normale_raw):.2f}" if prezzo_normale_raw and str(prezzo_normale_raw).replace('.', '', 1).isdigit() else ""
                data_inizio = articolo.get('data_inizio_promo', '')
                data_scadenza = articolo.get('data_scadenza', '')
                is_promo = articolo.get('promo', False)
                tags_da_applicare = determina_tag_promo(data_inizio, data_scadenza, is_promo) 
                valori_tupla = (
                    articolo.get('nome', ''),
                    articolo.get('descrizione', ''),
                    articolo.get('categoria', ''),
                    prezzo_normale_val,
                    articolo.get('data_inserimento_prezzo', ''),
                    promo_attiva_str,
                    prezzo_promo_val,
                    articolo.get('quantita', ''),
                    articolo.get('data_inizio_promo', ''),
                    articolo.get('data_scadenza', '')
                )
                treeview.insert('', 'end', 
                                        iid=f"item_{supermercato}_{i}", 
                                        values=valori_tupla,
                                        tags=tags_da_applicare 
                                       )
        def calcola_prezzo_minimo_globale(nome_articolo_cercato):
            minimo = float('inf')
            supermercato_migliore = None
            for nome_superm, articoli in dati_supermercati.items():
                for articolo in articoli:
                    if articolo.get('nome', '').lower() == nome_articolo_cercato.lower():
                        try:
                            prezzo_str = articolo.get('prezzo', '9999.0')
                            prezzo = float(prezzo_str.replace(',', '.'))
                        except (ValueError, TypeError):
                            continue
                        if prezzo < minimo:
                            minimo = prezzo
                            supermercato_migliore = nome_superm
            return minimo, supermercato_migliore
        def trova_dettagli_affare_migliore(nome_articolo, superm_migliore, prezzo_minimo):
            articoli_superm = dati_supermercati.get(superm_migliore, [])
            for articolo in articoli_superm:
                nome = articolo.get('nome', '').lower()
                qta_catalogo = articolo.get('qta_catalogo', '1PZ')
                prezzo_str = articolo.get('prezzo', '9999.0')
                try:
                    prezzo = float(prezzo_str.replace(',', '.'))
                except (ValueError, TypeError):
                    continue
                if nome == nome_articolo.lower() and prezzo == prezzo_minimo:
                    return {
                        'supermercato': superm_migliore,
                        'prezzo_un': prezzo,
                        'qta_catalogo': qta_catalogo 
                    }
            raise ValueError(f"Dettagli completi dell'affare non trovati per {nome_articolo}.")
        def _cerca_articoli_crud(supermercato, treeview, ricerca_var):
            testo_ricerca = ricerca_var.get().lower().strip()
            if not treeview: return
            
            if not testo_ricerca:
                self.risultati_finali = dati_supermercati.get(supermercato, []).copy()
                _carica_treeview(treeview, supermercato, articoli_filtrati=None)
                return
            articoli_filtrati = []
            for articolo in dati_supermercati.get(supermercato, []):
                nome = articolo.get("nome", "").lower()
                categoria = articolo.get("categoria", "").lower()
                descrizione = articolo.get("descrizione", "").lower()
                
                if testo_ricerca in nome or testo_ricerca in categoria or testo_ricerca in descrizione:
                    articoli_filtrati.append(articolo)
            self.risultati_finali = articoli_filtrati 
            _carica_treeview(treeview, supermercato, articoli_filtrati=articoli_filtrati)
        def _funzione_crud(azione, supermercato, treeview, frame_input):
            if supermercato not in campi_input_refs:
                self.show_custom_warning("Selezione", "Seleziona un supermercato prima di procedere."); return
            if not treeview: return
            refs = campi_input_refs.get(supermercato)
            if not refs:
                refs = campi_input_refs.get('combo_gestione_super')
            if not refs: return
            data_ins_prezzo_ref = refs.get('data_inserimento_prezzo', tk.StringVar())
            data_inizio_promo_ref = refs.get('data_inizio_promo', tk.StringVar())
            LIMITI_CARATTERI = {
                'nome': 27,
                'descrizione': 35,
                'categoria': 24,
                'quantita': 18,
                'prezzo': 7,
                'prezzo_promo': 7
            }
            def _valida_lunghezza_campi_locale(refs):
                errori = []
                prezzo = refs['prezzo'].get().strip().replace(',', '.')
                prezzo_promo = refs['prezzo_promo'].get().strip().replace(',', '.')
                data_scadenza = refs['data_scadenza'].get().strip()
                data_ins_prezzo = data_ins_prezzo_ref.get().strip()
                data_inizio_promo = data_inizio_promo_ref.get().strip()
                promo_attiva = refs['promo_attiva'].get()
                if promo_attiva:
                    if not prezzo_promo:
                        errori.append("- Hai attivato la promozione: il 'PREZZO PROMO' √® obbligatorio.")
                    if not data_inizio_promo:
                        errori.append("- Hai attivato la promozione: la 'DATA INIZIO PROMO' √® obbligatoria.")
                    if not data_scadenza:
                        errori.append("- Hai attivato la promozione: la 'DATA SCADENZA PROMO' √® obbligatoria.")
                for key, max_len in LIMITI_CARATTERI.items():
                    if key in refs:
                        current_value = refs[key].get().strip()
                        if len(current_value) > max_len:
                            errori.append(
                                f"- Il campo '{key.upper()}' ha {len(current_value)} caratteri, "
                                f"ma il limite massimo √® {max_len}. Per favore accorcia."
                            )
                campi_prezzo = {
                    'prezzo': prezzo,
                    'prezzo_promo': prezzo_promo
                }
                for key, value in campi_prezzo.items():
                    if value:
                        try:
                            float(value)
                        except ValueError:
                            errore_visuale = value.replace('.', ',')
                            errori.append(f"- Il campo '{key.upper()}' ('{errore_visuale}') deve essere un valore numerico valido (es. 10.50 o 10,50).")
                campi_data_check = {
                    'DATA SCADENZA': data_scadenza,
                    'DATA INSERIMENTO PREZZO': data_ins_prezzo,
                    'DATA INIZIO PROMO': data_inizio_promo
                }
                formati_validi = ['%d-%m-%Y']
                date_oggetti = {}
                for key_name, date_value in campi_data_check.items():
                    if date_value:
                        data_valida = False
                        data_obj = None
                        for formato in formati_validi:
                            try:
                                data_obj = datetime.datetime.strptime(date_value, formato)
                                data_valida = True; break
                            except ValueError: continue
                            
                        if data_valida:
                            date_oggetti[key_name] = data_obj
                        else:
                            errori.append(f"- Il campo '{key_name}' ('{date_value}') non √® nel formato richiesto (GG-MM-AAAA).")
                if (promo_attiva and 'DATA INIZIO PROMO' in date_oggetti and 'DATA SCADENZA' in date_oggetti):
                    data_inizio = date_oggetti['DATA INIZIO PROMO']
                    data_fine = date_oggetti['DATA SCADENZA']
                    if data_inizio >= data_fine:
                        errori.append("- Errore Logico: La 'DATA INIZIO PROMO' deve essere precedente (minore) alla 'DATA SCADENZA PROMO'.")
                nome = refs['nome'].get().strip()
                descrizione = refs['descrizione'].get().strip()
                categoria = refs['categoria'].get().strip()
                quantita = refs['quantita'].get().strip()
                return errori, nome, descrizione, categoria, quantita, prezzo, prezzo_promo, data_ins_prezzo, data_inizio_promo
            selezione = treeview.selection()
            azione_eseguita = False
            ricerca_var_locale = ricerca_vars_crud.get(supermercato, tk.StringVar())
            if azione == 'inserisci':
                errori, nome, descrizione, categoria, quantita, prezzo, prezzo_promo, data_ins_prezzo, data_inizio_promo = _valida_lunghezza_campi_locale(refs)
                data_ins_prezzo = data_ins_prezzo.strip()
                if errori:
                    errore_messaggio = "Impossibile inserire. Si sono verificati i seguenti errori:\n" + "\n".join(errori)
                    self.show_custom_warning("Errore di Validazione", errore_messaggio); return
                promo_attiva = refs['promo_attiva'].get()
                data_scadenza = refs['data_scadenza'].get().strip()
                data_corrente = datetime.datetime.now().strftime("%d-%m-%Y")
                if not data_ins_prezzo:
                    data_ins_prezzo = data_corrente
                    refs['data_inserimento_prezzo'].set(data_corrente)
                if not nome or not prezzo: self.show_custom_warning("Errore di Input", "Nome e Prezzo sono obbligatori."); return
                nuovo_articolo = {
                    "nome": nome, "descrizione": descrizione, "categoria": categoria,
                    "prezzo": prezzo,
                    "promo": promo_attiva,
                    "prezzo_promo": prezzo_promo,
                    "supermercato": supermercato,
                    "quantita": quantita,
                    "data_scadenza": data_scadenza,
                    "data_inserimento_prezzo": data_ins_prezzo,
                    "data_inizio_promo": data_inizio_promo
                }
                dati_supermercati[supermercato].append(nuovo_articolo)
                dati_supermercati[supermercato].sort(key=lambda x: x.get('nome', '').lower())
                _svuota_campi(refs); _salva_dati_interno(dati_supermercati)
                _cerca_articoli_crud(supermercato, treeview, ricerca_var_locale)
                azione_eseguita = True
            elif azione == 'cancella':
                if not selezione: self.show_custom_warning("Selezione", "Selezionare un articolo da cancellare."); return
                if self.show_custom_askyesno("Conferma Cancellazione", "Sei sicuro di voler cancellare l'articolo selezionato?"):
                    iid_da_cancellare = selezione[0]
                    try: idx_cancellare = int(iid_da_cancellare.split('_')[-1])
                    except ValueError: self.show_custom_warning("Errore", "Impossibile identificare l'articolo da cancellare."); return
                    if 0 <= idx_cancellare < len(dati_supermercati[supermercato]):
                        dati_supermercati[supermercato].pop(idx_cancellare)
                        dati_supermercati[supermercato].sort(key=lambda x: x.get('nome', '').lower())
                        _svuota_campi(refs);
                        _salva_dati_interno(dati_supermercati)
                        _cerca_articoli_crud(supermercato, treeview, ricerca_var_locale)
                        azione_eseguita = True
            elif azione == 'modifica':
                if not selezione:
                    self.show_custom_warning("Selezione", "Per modificare, seleziona un articolo dalla lista."); return
                iid_selezionato = selezione[0]; valori_selezionati = treeview.item(iid_selezionato, 'values')
                if len(valori_selezionati) < 10:
                    self.show_custom_warning("Errore Dati", f"Articolo incompleto. Trovati {len(valori_selezionati)} campi, attesi 10."); return
                refs['nome'].set(valori_selezionati[0])
                refs['descrizione'].set(valori_selezionati[1])
                refs['categoria'].set(valori_selezionati[2])
                prezzo_normale_pulito = valori_selezionati[3].replace('‚Ç¨', '').strip()
                refs['prezzo'].set(prezzo_normale_pulito)
                data_ins_prezzo_ref.set(valori_selezionati[4])
                promo_attiva = (valori_selezionati[5] == "Si" or valori_selezionati[5] == "S√¨")
                refs['promo_attiva'].set(promo_attiva)
                prezzo_promo_pulito = valori_selezionati[6].replace('‚Ç¨', '').strip()
                refs['prezzo_promo'].set(prezzo_promo_pulito)
                refs['quantita'].set(valori_selezionati[7])
                refs['data_scadenza'].set(valori_selezionati[9])
                data_inizio_promo_ref.set(valori_selezionati[8])
                setattr(self, 'modifica_iid', iid_selezionato)
            elif azione == 'salva':
                modifica_iid_ref = getattr(self, 'modifica_iid', None) 
                if not selezione or not modifica_iid_ref or modifica_iid_ref not in selezione:
                    self.show_custom_warning("Selezione/Stato", "Nessun articolo selezionato o lo stato di modifica non √® attivo.\nSeleziona un articolo e premi 'Modifica', poi 'Salva'."); return
                errori, nome, descrizione, categoria, quantita, prezzo, prezzo_promo, data_ins_prezzo, data_inizio_promo = _valida_lunghezza_campi_locale(refs)
                if errori:
                    errore_messaggio = "Impossibile salvare. Si sono verificati i seguenti errori:\n" + "\n".join(errori)
                    self.show_custom_warning("Errore di Validazione", errore_messaggio); return
                promo_attiva = refs['promo_attiva'].get()
                data_corrente = datetime.datetime.now().strftime("%d-%m-%Y")
                if not data_ins_prezzo:
                    data_ins_prezzo = data_corrente
                    refs['data_inserimento_prezzo'].set(data_corrente)
                if not promo_attiva:
                    data_inizio_promo = ""
                    refs['data_inizio_promo'].set("")
                    data_scadenza = ""
                    refs['data_scadenza'].set("")
                    prezzo_promo = ""
                    refs['prezzo_promo'].set("")
                data_scadenza = refs['data_scadenza'].get().strip()
                if not nome or not prezzo: self.show_custom_warning("Errore di Input", "Nome e Prezzo sono obbligatori per il salvataggio."); return
                iid_da_salvare = selezione[0]
                try: idx_da_salvare = int(iid_da_salvare.split('_')[-1])
                except ValueError: self.show_custom_warning("Errore", "Impossibile identificare l'articolo da salvare."); return
                if 0 <= idx_da_salvare < len(dati_supermercati[supermercato]):
                    dati_supermercati[supermercato][idx_da_salvare] = {
                        "nome": nome, "descrizione": descrizione, "categoria": categoria,
                        "prezzo": prezzo,
                        "promo": promo_attiva,
                        "prezzo_promo": prezzo_promo,
                        "supermercato": supermercato,
                        "quantita": quantita,
                        "data_scadenza": data_scadenza,
                        "data_inserimento_prezzo": data_ins_prezzo,
                        "data_inizio_promo": data_inizio_promo
                    }
                    dati_supermercati[supermercato].sort(key=lambda x: x.get('nome', '').lower())
                    _salva_dati_interno(dati_supermercati); _svuota_campi(refs);
                    delattr(self, 'modifica_iid')
                    _cerca_articoli_crud(supermercato, treeview, ricerca_var_locale)
                    azione_eseguita = True
            if azione_eseguita and self.risultati_tv_ref:
                _aggiorna_lista_spesa_intelligente(self.risultati_tv_ref)
        def _svuota_supermercato(supermercato, treeview):
            if not supermercato or supermercato == "Seleziona Supermercato":
                self.show_custom_warning("Selezione", "Seleziona un supermercato prima di svuotare."); return
            if self.show_custom_askyesno("Azzeramento Dati", f"‚ö†Ô∏è Sei sicuro di voler cancellare TUTTI gli articoli\n dal supermercato '{supermercato}'?"):
                dati_supermercati[supermercato] = []
                _salva_dati_interno(dati_supermercati)
                _carica_treeview(treeview, supermercato)
                if self.risultati_tv_ref:
                    _aggiorna_lista_spesa_intelligente(self.risultati_tv_ref)
                self.show_custom_warning("Successo", f"Database del supermercato '{supermercato}' azzerato.")
        def _cerca_articoli(testo_ricerca, tv_risultati):
            def _parse_data_per_confronto(data_str):
                if not data_str:
                    return None
                for fmt in ['%d-%m-%Y']:
                    try:
                        return datetime.datetime.strptime(data_str, fmt).date()
                    except ValueError:
                        continue
                return None
            if not tv_risultati: return
            tv_risultati.delete(*tv_risultati.get_children())
            testo_ricerca = testo_ricerca.lower().strip()
            articoli_da_mostrare = []
            filtro_superm_selezionato = filtro_supermercato_confronto_var.get()
            if filtro_superm_selezionato == "Tutti i supermercati" or filtro_superm_selezionato == "Seleziona Supermercato":
                supermercati_da_cercare = dati_supermercati.keys()
                cerca_il_piu_conveniente = True
            else:
                supermercati_da_cercare = [filtro_superm_selezionato]
                cerca_il_piu_conveniente = False
            oggi = datetime.date.today()
            for supermercato in supermercati_da_cercare:
                if supermercato not in dati_supermercati: continue
                articoli = dati_supermercati[supermercato]
                for articolo in articoli:
                    nome = articolo.get("nome", "").strip()
                    categoria = articolo.get("categoria", "").strip()
                    descrizione = articolo.get("descrizione", "").strip()
                    if testo_ricerca and not (testo_ricerca in nome.lower() or testo_ricerca in categoria.lower() or testo_ricerca in descrizione.lower()):
                        continue
                    prezzo_base_str = articolo.get("prezzo", "")
                    prezzo_promo_str = articolo.get("prezzo_promo", "")
                    prezzo_effettivo = prezzo_base_str
                    promozione_valida = False
                    promozione_futura = False
                    status_promo = ""
                    if articolo.get("promo", False) and prezzo_promo_str:
                        data_inizio = _parse_data_per_confronto(articolo.get("data_inizio_promo"))
                        data_fine = _parse_data_per_confronto(articolo.get("data_scadenza"))
                        if data_inizio:
                            if oggi < data_inizio:
                                status_promo = "Promo dal " + articolo.get('data_inizio_promo')
                                promozione_futura = True
                            elif oggi >= data_inizio:
                                if not data_fine or oggi <= data_fine:
                                    promozione_valida = True
                                    status_promo = "Promo Attiva"
                                    prezzo_effettivo = prezzo_promo_str
                                else:
                                    status_promo = "Promo scaduta"
                    if not prezzo_effettivo: continue
                    try:
                        prezzo_float = float(str(prezzo_effettivo).replace(',', '.'))
                        prezzo_base_float = float(str(prezzo_base_str).replace(',', '.')) if prezzo_base_str else None
                        prezzo_base_finale = f"{prezzo_base_float:.2f}" if prezzo_base_float else ""
                        prezzo_finale_formattato = f"{prezzo_float:.2f}"
                        articoli_da_mostrare.append({
                            "nome": nome,
                            "quantita": articolo.get("quantita", ""),
                            "supermercato": supermercato,
                            "descrizione": descrizione,
                            "categoria": categoria,
                            "prezzo_float": prezzo_float,
                            "prezzo_formattato": prezzo_finale_formattato,
                            "dettagli": status_promo,
                            "is_promo_valida": promozione_valida,
                            "is_promo_futura": promozione_futura,
                            "prezzo_base_str": prezzo_base_finale,
                            "data_inizio_promo_str": articolo.get("data_inizio_promo", ""),
                            "data_scadenza_str": articolo.get("data_scadenza", ""),
                        })
                    except (ValueError, TypeError):
                        continue
            articoli_raggruppati_per_nome = defaultdict(list)
            for offerta in articoli_da_mostrare:
                chiave = (offerta['nome'].lower(), offerta['quantita'].lower())
                articoli_raggruppati_per_nome[chiave].append(offerta)
            tutti_gli_articoli_ordinati = sorted(articoli_da_mostrare, key=lambda x: x['nome'].strip().lower())
            articoli_inseriti_set = set()
            for offerta in tutti_gli_articoli_ordinati:
                chiave_comparazione = (offerta['nome'].lower(), offerta['quantita'].lower())
                iid_val = f"{offerta['nome']}|{offerta['quantita']}|{offerta['supermercato']}|{offerta['prezzo_float']}"
                if iid_val in articoli_inseriti_set: continue
                articoli_inseriti_set.add(iid_val)
                indicatore = ""
                is_strictly_cheaper = False
                if cerca_il_piu_conveniente:
                    prezzi_simili = [o['prezzo_float'] for o in articoli_raggruppati_per_nome.get(chiave_comparazione, [])]
                    min_price = min(prezzi_simili) if prezzi_simili else float('inf')
                    is_min_price = (offerta['prezzo_float'] == min_price)
                    count_min_price = sum(1 for p in prezzi_simili if p == min_price)
                    is_strictly_cheaper = (is_min_price and count_min_price < len(prezzi_simili))
                promo_icona = ""
                if offerta.get("is_promo_valida", False):
                    promo_icona = "Promoüî•" 
                elif offerta.get("is_promo_futura", False):
                    promo_icona = "Promoüî•"
                elif offerta['dettagli'] and 'scaduta' in offerta['dettagli'].lower():
                    promo_icona = "Promo‚è≥"
                miglior_prezzo_icona = ""
                if cerca_il_piu_conveniente and is_strictly_cheaper:
                    miglior_prezzo_icona = "Top‚≠ê"
                indicatore_testo = []
                if promo_icona:
                    indicatore_testo.append(promo_icona)
                if miglior_prezzo_icona:
                    indicatore_testo.append(miglior_prezzo_icona)
                if offerta['dettagli'] and 'attiva' not in offerta['dettagli'].lower():
                    indicatore_testo.append(offerta['dettagli'])
                indicatore = " ".join(indicatore_testo).strip()
                tags_list = []
                if offerta.get("is_promo_valida", False):
                    tags_list.append('promo_rossa')
                elif offerta.get("is_promo_futura", False):
                    tags_list.append('promo_gialla')
                if cerca_il_piu_conveniente and is_strictly_cheaper and not tags_list:
                    tags_list.append('piu_conveniente')
                tags_da_applicare = tuple(tags_list)
                values_to_insert = (
                    offerta["nome"],
                    offerta["quantita"],
                    offerta["supermercato"],
                    offerta["descrizione"],
                    offerta["categoria"],
                    f'{offerta["prezzo_formattato"]}',
                    indicatore,
                    offerta["data_inizio_promo_str"],
                    offerta["data_scadenza_str"],
                    f'{offerta["prezzo_base_str"]}'
                )
                tv_risultati.insert(
                    parent='', index='end', iid=iid_val,
                    values=values_to_insert, 
                    tags=tags_da_applicare
                )
            self.risultati_finali = tutti_gli_articoli_ordinati
        def _ricarica_lista_spesa(tv_lista):
            tv_lista.delete(*tv_lista.get_children())
            totale_generale = 0.0
            gruppi_supermercati = defaultdict(lambda: [])
            for chiave, dati in lista_spesa_data.items():
                gruppi_supermercati[dati['supermercato']].append(dati)
            for superm in sorted(gruppi_supermercati.keys()):
                articoli = gruppi_supermercati[superm]
                articoli.sort(key=lambda x: x['nome'])
                totale_super = 0.0
                iid_super = f"group_{superm}"
                tv_lista.insert('', 'end', iid=iid_super, text=f"üõí {superm}", tags=('supermarket',))
                for dati in articoli:
                    totale_articolo = dati['qta_int'] * dati['prezzo_un']
                    totale_super += totale_articolo
                    chiave_lista = f"{dati['nome']}|{superm}"
                    iid_articolo = f"item_{chiave_lista}"
                    tv_lista.insert(
                        iid_super, 'end', iid=iid_articolo, text=dati['nome'],
                        values=(dati['qta_catalogo'], dati['qta_int'], f"{dati['prezzo_un']:.2f}",
                                f"{totale_articolo:.2f}", dati['supermercato'])
                    )
                tv_lista.item(iid_super, values=("", "", "TOTALE PARZIALE:", f"{totale_super:.2f}", ""), tags=('supermarket',))
                totale_generale += totale_super
            tv_lista.insert('', 'end', text="TOTALE GENERALE SPESA:", values=("", "", "", f"{totale_generale:.2f}", ""), tags=('grand_total',))
            tv_lista.tag_configure('grand_total', font=('Arial', 10, 'bold'), background='#E0F7FA')
            tv_lista.tag_configure('supermarket', font=('Arial', 10, 'bold'), foreground='dodgerblue')
        def _aggiungi_a_lista_spesa(event, tv_lista, tv_risultati_ref):
            def mostra_avviso_conferma(title, message):
                root_window = tv_risultati_ref.winfo_toplevel()
                for child in root_window.winfo_children():
                    if isinstance(child, tk.Toplevel):
                        child.destroy()
                TIMEOUT_MS = 10000
                risultato = {"value": 'ANNULLA'}
                dialog = tk.Toplevel(tv_risultati_ref.winfo_toplevel(), bg="orange")
                dialog.withdraw()
                dialog.title(title)
                dialog.resizable(False, False)
                dialog.attributes("-topmost", True)
                dialog.update_idletasks()
                w, h = 480, 160
                x = dialog.winfo_screenwidth() // 2 - w // 2
                y = dialog.winfo_screenheight() // 2 - h // 2
                dialog.geometry(f"{w}x{h}+{x}+{y}")
                dialog.deiconify()
                text_label = tk.Text(
                    dialog, 
                    font=("Arial", 10), 
                    height=5, 
                    width=55, 
                    padx=16, 
                    pady=12, 
                    bg="orange", 
                    relief="flat",
                    borderwidth=0,
                    highlightthickness=0
                )
                text_label.insert(tk.END, message)
                start_index = "1.0"
                while True:
                    start_bold = text_label.search('**', start_index, stopindex=tk.END)
                    if not start_bold: break
                    end_bold = text_label.search('**', f"{start_bold}+2c", stopindex=tk.END)
                    if not end_bold: break
                    text_label.tag_add("bold", f"{start_bold}+2c", end_bold)
                    text_label.delete(start_bold, f"{start_bold}+2c")
                    text_label.delete(end_bold, f"{end_bold}-2c")
                    start_index = end_bold
                text_label.tag_config("bold", font=("Arial", 10, "bold"))
                text_label.config(state=tk.DISABLED)
                text_label.pack()
                btns = tk.Frame(dialog, bg="orange")
                btns.pack(pady=(0,10))
                def aggiungi_selezionato():
                    risultato["value"] = 'SELEZIONATO'
                    dialog.destroy()
                def aggiungi_migliore():
                    risultato["value"] = 'MIGLIORE'
                    dialog.destroy()
                def annulla():
                    risultato["value"] = 'ANNULLA'
                    dialog.destroy()
                dialog.bind('<Escape>', lambda e: annulla())
                b1 = ttk.Button(btns, text="Aggiungi Selezionato", style="Rosso.TButton", command=aggiungi_selezionato)
                b2 = ttk.Button(btns, text="Aggiungi Affare Migliore", style="Verde.TButton", command=aggiungi_migliore)
                b3 = ttk.Button(btns, text="Annulla", style="Giallo.TButton", command=annulla)
                b1.grid(row=0, column=0, padx=8)
                b2.grid(row=0, column=1, padx=8)
                b3.grid(row=0, column=2, padx=8)
                dialog.focus_set()
                dialog.grab_set()
                if TIMEOUT_MS > 0:
                    dialog.after(TIMEOUT_MS, annulla)
                dialog.wait_window()
                return risultato["value"]
            selezione = tv_risultati_ref.selection()
            if not selezione: return
            iid_selezionato = selezione[0]
            try:
                nome, qta_catalogo_base, superm_base, prezzo_str_base = iid_selezionato.split('|')
                prezzo_float_base = float(prezzo_str_base)
                nome = nome.strip()
            except ValueError:
                return
            prezzo_minimo, superm_migliore = calcola_prezzo_minimo_globale(nome)
            azione_richiesta = 'SELEZIONATO'
            if prezzo_minimo < prezzo_float_base and superm_migliore != superm_base:
                titolo_custom = "üö® CONVIENE ALTROVE! üö®"
                messaggio_custom = (
                    f"L'articolo '{nome.upper()}' costa {prezzo_float_base:.2f} da {superm_base}.\n\n"
                    f"Trovato a {prezzo_minimo:.2f} presso {superm_migliore}."
                    f"\n\nQuale articolo vuoi aggiungere alla lista?"
                )
                azione_richiesta = mostra_avviso_conferma(titolo_custom, messaggio_custom)
            if azione_richiesta == 'ANNULLA':
                return
            superm_finale = superm_base
            prezzo_float_finale = prezzo_float_base
            qta_catalogo_finale = qta_catalogo_base
            if azione_richiesta == 'MIGLIORE':
                try:
                    dettagli_migliore = trova_dettagli_affare_migliore(nome, superm_migliore, prezzo_minimo)
                    superm_finale = dettagli_migliore['supermercato']
                    prezzo_float_finale = dettagli_migliore['prezzo_un']
                    qta_catalogo_finale = dettagli_migliore['qta_catalogo']
                except Exception as e:
                    errore_dialog = tk.Toplevel(tv_risultati_ref.winfo_toplevel(), bg="yellow")
                    errore_dialog.title("Errore Dati Critico")
                    tk.Label(errore_dialog, text=f"ERRORE: Impossibile recuperare i dettagli dell'affare migliore.\n{e}", fg="red", bg="yellow").pack(padx=15, pady=10)
                    ttk.Button(errore_dialog, text="OK", command=errore_dialog.destroy).pack(pady=5)
                    errore_dialog.grab_set()
                    return
            chiave_lista = f"{nome}|{superm_finale}"
            quantita_precedente = lista_spesa_data.get(chiave_lista, {}).get('qta_int', 0)
            nuova_quantita_int = quantita_precedente + 1
            if quantita_precedente > 0:
                azione_testo = "Aggiornato"
            else:
                azione_testo = "Aggiunto"
            lista_spesa_data[chiave_lista] = {
                'nome': nome,
                'qta_catalogo': qta_catalogo_finale,
                'qta_int': nuova_quantita_int,
                'prezzo_un': prezzo_float_finale,
                'supermercato': superm_finale
            }
            messaggio_notifica = (
                f"‚úÖ Articolo {azione_testo} in lista!\n"
                f"'{nome}' ({superm_finale})\n"
                f"Quantit√† Totale: {nuova_quantita_int} pezzi"
            )
            show_temporary_notification(tv_risultati_ref.winfo_toplevel(),
                "Conferma Lista",
                messaggio_notifica)
            _ricarica_lista_spesa(tv_lista)
        def show_temporary_notification(parent, title, message, duration_ms=3000):
            popup_note = tk.Toplevel(parent)
            popup_note.title(title)
            popup_note.overrideredirect(True) 
            popup_note.attributes("-topmost", True)
            popup_note.config(bg="orange")
            popup_note.withdraw() 
            parent.update_idletasks()
            width = 300
            height = 80
            parent_width = parent.winfo_width()
            parent_height = parent.winfo_height()
            parent_x = parent.winfo_x()
            parent_y = parent.winfo_y()
            x = parent_x + (parent_width // 2) - (width // 2)
            y = parent_y + (parent_height // 2) - (height // 2)
            popup_note.geometry(f"{width}x{height}+{x}+{y}")
            label = tk.Label(popup_note, text=message, font=("Arial", 10, "bold"), 
                            justify="center", padx=10, pady=10, bg="orange", fg="black")
            label.pack(expand=True, fill='both')
            popup_note.deiconify() 
            popup_note.after(duration_ms, popup_note.destroy)
        def _rimuovi_articolo_da_lista(tv_lista):
            selezione = tv_lista.selection()
            if not selezione: 
                show_temporary_notification(
                    tv_lista.winfo_toplevel(), 
                    "Attenzione", 
                    "‚ö†Ô∏è Seleziona articolo o gruppo da rimuovere.",
                    duration_ms=1500
                )
                return
            iid_selezionato = selezione[0]
            if iid_selezionato.startswith('item_'):
                try: 
                    chiave_lista = iid_selezionato.split('item_')[1]
                except IndexError: 
                    return
                if chiave_lista in lista_spesa_data:
                    dettagli_articolo = lista_spesa_data[chiave_lista]
                    nome_articolo = dettagli_articolo['nome']
                    superm_articolo = dettagli_articolo['supermercato']
                    qta_articolo = dettagli_articolo['qta_int']
                    del lista_spesa_data[chiave_lista]
                    _ricarica_lista_spesa(tv_lista)
                    messaggio_notifica = (
                        f"üóëÔ∏è Articolo Rimosso dalla lista.\n"
                        f"'{nome_articolo}' ({superm_articolo})\n"
                        f"Quantit√†: {qta_articolo} pezzi"
                    )
                    show_temporary_notification(tv_lista.winfo_toplevel(), 
                                                "Conferma Rimozione", 
                                                messaggio_notifica,
                                                duration_ms=2500)
            elif iid_selezionato.startswith('group_'):
                if self.show_custom_askyesno("Conferma", "Sei sicuro di voler rimuovere tutti gli articoli\n di questo supermercato dalla lista?"):
                    superm = iid_selezionato.split('group_')[1]
                    chiavi_da_rimuovere = [k for k, v in lista_spesa_data.items() if v['supermercato'] == superm]
                    if chiavi_da_rimuovere:
                        for chiave in chiavi_da_rimuovere: 
                            del lista_spesa_data[chiave]
                        _ricarica_lista_spesa(tv_lista)
                        messaggio_notifica = f"üóëÔ∏è Gruppo Rimosso dalla lista.\nSupermercato: {superm}"
                        show_temporary_notification(tv_lista.winfo_toplevel(), 
                                                    "Conferma Rimozione", 
                                                    messaggio_notifica,
                                                    duration_ms=2500)
        def _svuota_lista_spesa(tv_lista):
            if not lista_spesa_data:
                show_temporary_notification(
                    tv_lista.winfo_toplevel(), 
                    "Attenzione", 
                    "‚ö†Ô∏è La lista della spesa √® gi√† vuota.",
                    duration_ms=2000
                )
                return
            if self.show_custom_askyesno("Conferma", "Sei sicuro di voler rimuovere TUTTI gli articoli\n dalla lista spesa?"):
                tv_lista.delete(*tv_lista.get_children())
                lista_spesa_data.clear()
                _ricarica_lista_spesa(tv_lista)
                show_temporary_notification(
                tv_lista.winfo_toplevel(), 
                "Lista Svuotata", 
                "üóëÔ∏è La lista della spesa √® stata svuotata.",
                duration_ms=2000,
            )
        def _on_edit_quantity(event, tv_lista):
            region = tv_lista.identify("region", event.x, event.y)
            col = tv_lista.identify_column(event.x)
            
            if region == "cell" and col == "#2":
                row_id = tv_lista.identify_row(event.y)
                if not row_id.startswith('item_'): return
                try: chiave_lista = row_id.split('item_')[1]
                except: return
                if chiave_lista not in lista_spesa_data: return
                current_value = tv_lista.item(row_id)['values'][1]
                entry_editor = ttk.Entry(tv_lista, width=10)
                entry_editor.insert(0, str(current_value))
                x, y, width, height = tv_lista.bbox(row_id, col)
                entry_editor.place(x=x, y=y, width=width, height=height)
                entry_editor.focus_set()
                def on_entry_confirm(e):
                    try:
                        new_qta = int(entry_editor.get().strip())
                        if new_qta > 0:
                            lista_spesa_data[chiave_lista]['qta_int'] = new_qta
                            _ricarica_lista_spesa(tv_lista)
                        elif new_qta == 0:
                            del lista_spesa_data[chiave_lista]
                            _ricarica_lista_spesa(tv_lista)
                    except ValueError:
                        self.show_custom_warning("Errore", "La quantit√† deve essere un numero intero valido.")
                    finally:
                        entry_editor.destroy()
                entry_editor.bind('<Return>', on_entry_confirm)
                entry_editor.bind('<FocusOut>', on_entry_confirm)
        def _genera_testo_esportazione():
            import datetime
            data_esportazione = datetime.datetime.now().strftime("%d/%m/%Y")
            WIDTH_NOME = 45
            WIDTH_QTA = 4
            WIDTH_PREZZO_BLOCCO = 30
            testo = f"CHECK-OUT: Spesa Ottimizzata ({data_esportazione})\n\n"
            totale_generale = 0.0
            gruppi_supermercati = defaultdict(lambda: [])
            for chiave, dati in lista_spesa_data.items(): gruppi_supermercati[dati['supermercato']].append(dati)
            for superm in sorted(gruppi_supermercati.keys()):
                articoli = gruppi_supermercati[superm]
                articoli.sort(key=lambda x: x['nome'])
                testo += f"[{superm.upper()}]\n"
                totale_super = 0.0
                for dati in articoli:
                    totale_articolo = dati['qta_int'] * dati['prezzo_un']
                    totale_super += totale_articolo
                    linea = "[ ] "
                    nome_completo = f"{dati['nome']} ({dati['qta_catalogo']})"
                    linea += f"{nome_completo:<{WIDTH_NOME}}"
                    qta_comprare = f"x {dati['qta_int']} pz"
                    linea += f"{qta_comprare:<{WIDTH_QTA + 4}}"
                    prezzo_blocco = f"({dati['prezzo_un']:.2f}) - Tot: {totale_articolo:.2f}"
                    linea += f"{prezzo_blocco:>{WIDTH_PREZZO_BLOCCO}}\n"
                    testo += linea
                testo += f"  TOTALE PARZIALE {superm}: {totale_super:.2f}\n\n"
                totale_generale += totale_super
            testo += f"\n"
            testo += f"TOTALE GENERALE STIMATO: {totale_generale:.2f}\n"
            return testo
        def _mostra_anteprima_esportazione():
            anteprima_text = _genera_testo_esportazione()
            preview_popup = tk.Toplevel(popup, bg=self.COLOR_TOPLEVEL)
            preview_popup.title("Anteprima Esportazione Lista Spesa")
            preview_popup.geometry("1050x600")
            screen_width = preview_popup.winfo_screenwidth()
            screen_height = preview_popup.winfo_screenheight()
            x = (screen_width - 1050) // 2
            y = (screen_height - 600) // 2
            preview_popup.geometry(f"1050x600+{x}+{y}")
            preview_popup.after(10, lambda: preview_popup.focus_force())
            preview_popup.bind('<Escape>', lambda e: preview_popup.destroy())
            text_area = tk.Text(preview_popup, wrap='word', font=('Courier', 10), padx=10, pady=10)
            text_area.insert('1.0', anteprima_text)
            text_area.config(state='disabled')
            text_area.pack(fill='both', expand=True, padx=10, pady=10)
            frame_btn = tk.Frame(preview_popup, bg=self.COLOR_TOPLEVEL); frame_btn.pack(pady=(0, 10))
            ttk.Button(frame_btn, text="Chiudi", command=preview_popup.destroy, style='Giallo.TButton').pack(side='right', padx=5)
            ttk.Button(frame_btn, text="Esporta", style='Verde.TButton',
                        command=lambda: _esporta_su_file(anteprima_text, preview_popup)).pack(side='left', padx=5)
            ttk.Button(frame_btn, text="üñ®Ô∏è Stampa", style='Blu.TButton', command=lambda: self._stampa_lista_diretta(anteprima_text, self.show_custom_warning)).pack(side='left', padx=5)
        def _esporta_su_file(content_text, preview_popup):
            preview_popup.destroy()
            now = datetime.date.today()
            default_filename = f"Lista_Spesa_{now.day:02d}_{now.month:02d}_{now.year}.txt"
            f = filedialog.asksaveasfilename(
                defaultextension=".txt", filetypes=[("File txt", "*.txt")], title="Salva la Lista Spesa su File",
                initialdir=EXPORT_FILES, confirmoverwrite=False, initialfile=default_filename, parent=popup
            )
            if f:
                try:
                    with open(f, 'w', encoding='utf-8') as file_handle: file_handle.write(content_text)
                    self.show_custom_warning("Successo", f"‚úÖ Lista spesa salvata con successo in:\n{f}")
                except Exception as e:
                    self.show_custom_warning("Errore", f"‚ùå Impossibile salvare il file:\n{e}")
            
        def _aggiorna_lista_spesa_intelligente(tv_risultati):
            if tv_risultati:
                _cerca_articoli(ricerca_var_confronto.get(), tv_risultati)
                if hasattr(self, 'risultati_finali') and self.risultati_finali:
                    self.risultati_finali.sort(key=lambda x: x.get('nome', '').strip().lower())
        def _on_supermercato_change(event, combo, treeview_crud, frame_input, ricerca_var):
            selected_superm = combo.get()
            refs_combo = campi_input_refs.get('combo_gestione_super')
            if selected_superm == "Seleziona Supermercato":
                treeview_crud.delete(*treeview_crud.get_children())
                _svuota_campi(refs_combo) 
                return
            if selected_superm not in campi_input_refs:
                refs = {
                    'nome': tk.StringVar(), 'descrizione': tk.StringVar(), 'categoria': tk.StringVar(),
                    'prezzo': tk.StringVar(), 'promo_attiva': tk.BooleanVar(), 'prezzo_promo': tk.StringVar(),
                    'quantita': tk.StringVar(), 'data_scadenza': tk.StringVar(),
                    'data_inserimento_prezzo': tk.StringVar(),
                    'data_inizio_promo': tk.StringVar()
                }
                campi_input_refs[selected_superm] = refs
            refs_superm = campi_input_refs[selected_superm]
            for key in refs_superm:
                refs_combo[key].set(refs_superm[key].get())
                refs_superm[key] = refs_combo[key] 
            if CATEGORIE_PREDEFINITE:
                if not refs_combo['categoria'].get().strip():
                     refs_combo['categoria'].set(CATEGORIE_PREDEFINITE[0])
            if selected_superm not in ricerca_vars_crud:
                ricerca_vars_crud[selected_superm] = tk.StringVar()
            ricerca_var.set(ricerca_vars_crud[selected_superm].get())
            _cerca_articoli_crud(selected_superm, treeview_crud, ricerca_vars_crud[selected_superm])
        def _esegui_rinomina_supermercato(combo, treeview_crud, ricerca_var):
            nonlocal SUPERMERCATI, dati_supermercati, campi_input_refs
            old_superm = combo.get()
            if old_superm == "Seleziona Supermercato" or not old_superm:
                self.show_custom_warning("Modifica Supermercato", "Seleziona prima un supermercato da rinominare.")
                return
            rinomina_popup = tk.Toplevel(popup, bg=self.COLOR_TOPLEVEL)
            rinomina_popup.title(f"Rinomina {old_superm}")
            rinomina_popup.transient(popup)
            rinomina_popup.grab_set()
            ttk.Label(rinomina_popup, text="Nuovo nome:", style="Popup.TLabel").pack(padx=10, pady=(10, 0))
            new_name_var = tk.StringVar(value=old_superm)
            entry = ttk.Entry(rinomina_popup, textvariable=new_name_var, width=30)
            entry.pack(padx=10, pady=5)
            entry.focus_set()
            def on_confirm(e=None):
                nonlocal SUPERMERCATI
                new_superm = new_name_var.get().strip()
                if not new_superm or new_superm == old_superm:
                    rinomina_popup.destroy(); return                
                if new_superm in dati_supermercati:
                    self.show_custom_warning("Errore", f"Il supermercato '{new_superm}' esiste gi√†."); return
                if old_superm in dati_supermercati:
                    articoli = dati_supermercati.pop(old_superm)
                    dati_supermercati[new_superm] = articoli
                    for articolo in dati_supermercati[new_superm]: 
                        articolo['supermercato'] = new_superm                    
                    try: 
                        index = SUPERMERCATI.index(old_superm)
                        SUPERMERCATI[index] = new_superm
                    except ValueError: pass
                    if old_superm in campi_input_refs: campi_input_refs[new_superm] = campi_input_refs.pop(old_superm)
                    if old_superm in ricerca_vars_crud: ricerca_vars_crud[new_superm] = ricerca_vars_crud.pop(old_superm)
                    combo['values'] = tuple(["Seleziona Supermercato"] + sorted(SUPERMERCATI))
                    combo.set(new_superm)
                    rinomina_popup.destroy()
                    _carica_treeview(treeview_crud, new_superm)
                    _salva_dati_interno(dati_supermercati)
                    if self.risultati_tv_ref: _aggiorna_lista_spesa_intelligente(self.risultati_tv_ref)
                    self.show_custom_warning("Successo", f"Supermercato rinominato in '{new_superm}'.")
            btn_frame = ttk.Frame(rinomina_popup, style="Popup.TFrame")
            btn_frame.pack(pady=(10, 10))
            ttk.Button(btn_frame, text="Annulla", command=rinomina_popup.destroy, style='Giallo.TButton').pack(side='left', padx=5)
            ttk.Button(btn_frame, text="Salva", command=on_confirm, style='Verde.TButton').pack(side='left', padx=5)
            entry.bind("<Return>", on_confirm)
            rinomina_popup.update_idletasks()
            w, h = rinomina_popup.winfo_reqwidth(), rinomina_popup.winfo_reqheight()
            x = popup.winfo_rootx() + (popup.winfo_width() // 2) - (w // 2)
            y = popup.winfo_rooty() + (popup.winfo_height() // 2) - (h // 2)
            rinomina_popup.geometry(f'+{x}+{y}')

        def import_supermercati_db():
            popup.lift() 
            popup.focus_force() 
            SUPERMERCATI_DB = os.path.join(DB_DIR, "supermercati.json")
            file = filedialog.askopenfilename(
                parent=popup,
                title="Importa Database Supermercati",
                defaultextension=".json",
                initialdir=EXP_DB,
                filetypes=[("File JSON", "*.json"), ("Tutti i file", "*.*")]
            )
            if file:
                if not self.show_custom_askyesno("Conferma Ripristino", "\nSovrascrivere il database attuale dei supermercati?\n"):
                    return
                try:
                    with open(file, "r", encoding="utf-8") as fsrc:
                        dati_importati = json.load(fsrc) 
                    with open(SUPERMERCATI_DB, "w", encoding="utf-8") as fdst:
                        json.dump(dati_importati, fdst, indent=4, ensure_ascii=False) 
                    _carica_dati_interno()
                    _controlla_scadenza_promo()
                    if popup.winfo_exists():
                        popup.destroy()
                        self.deiconify()
                        self.after(0, self.imp_entry.focus_set)
                        self.spesa_supermercato()
                    self.show_custom_warning("Importazione completata", f"\nDatabase Supermercati ripristinato da:\n\n {file}\n")
                except json.JSONDecodeError:
                    self.show_custom_warning("Errore", f"Errore di lettura JSON. Il file selezionato non √® un file di database valido.")
                except Exception as e:
                    self.show_custom_warning("Errore", f"Errore durante il ripristino: {e}")
        def export_supermercati_db():
            popup.lift() 
            popup.focus_force() 
            SUPERMERCATI_DB = os.path.join(DB_DIR, "supermercati.json")
            now = datetime.date.today()
            default_dir = EXP_DB
            default_filename = f"Export_Supermercati_{now.day:02d}-{now.month:02d}-{now.year}.json"
            file = filedialog.asksaveasfilename(
                parent=popup,
                title="Esporta Database Supermercati",
                defaultextension=".json",
                initialdir=default_dir,
                initialfile=default_filename,
                confirmoverwrite=False,
                filetypes=[("File JSON", "*.json"), ("Tutti i file", "*.*")]
            )
            if file:
                try:
                    with open(SUPERMERCATI_DB, "r", encoding="utf-8") as fsrc:
                        dbdata = fsrc.read()
                    with open(file, "w", encoding="utf-8") as fdst:
                        fdst.write(dbdata)
                    self.show_custom_warning("Esportazione completata", f"Database Supermercati esportato in {file}")
                except FileNotFoundError:
                    self.show_custom_warning("Errore", "Impossibile trovare il database sorgente dei supermercati.")
                except Exception as e:
                    self.show_custom_warning("Errore", f"Errore durante l'esportazione: {e}")

        def info_popup():
            popup = tk.Toplevel(frame_gestione, width=550) 
            popup.title("Informazioni sull'Importazione")
            popup.withdraw() 
            popup.transient(frame_gestione)
            messaggio = (
                "Questo programma gestisce i prezzi dei supermercati. üìä\n\n"
                
                "Non √® indispensabile inserire tutti i prezzi a mano. \nIl database "
                "prevede l'importazione tramite scontrini digitali.\n\n"
            )
            frame_contenuto = ttk.Frame(popup, padding="2")
            frame_contenuto.pack(expand=True, fill='both')
            ttk.Label(
                frame_contenuto, 
                text=messaggio, 
                wraplength=400,
                justify='left'
            ).pack(pady=10)
            ttk.Button(frame_contenuto, text="OK", command=popup.destroy, style="Giallo.TButton").pack(pady=10)
            frame_gestione.update_idletasks()
            popup.update_idletasks() 
            width = popup.winfo_width()
            height = popup.winfo_height()
            MIN_W = 450 
            MIN_H = 200
            if width < MIN_W or height < MIN_H:
                 width = max(width, MIN_W)
                 height = max(height, MIN_H)
            parent_x = frame_gestione.winfo_rootx() 
            parent_y = frame_gestione.winfo_rooty()
            parent_width = frame_gestione.winfo_width()
            parent_height = frame_gestione.winfo_height()
            x = parent_x + (parent_width // 2) - (width // 2)
            y = parent_y + (parent_height // 2) - (height // 2)
            popup.geometry(f'{width}x{height}+{x}+{y}') 
            popup.deiconify() 
            popup.grab_set() 
            popup.bind("<Escape>", lambda e: popup.destroy())
            
        _carica_dati_interno()
        _controlla_scadenza_promo()
        popup = tk.Toplevel(self.master, bg=self.COLOR_TOPLEVEL)
        barra_menu_popup = tk.Menu(popup, bg=BACKGROUND_DARK, fg=FOREGROUND_LIGHT, activebackground=ACCENT_COLOR, activeforeground='black')
        barra_menu_popup.config(bg=BACKGROUND_DARK, fg=FOREGROUND_LIGHT)
        popup.config(menu=barra_menu_popup) 
        menu_db = tk.Menu(barra_menu_popup, tearoff=0,bg=MENU_BG, fg=FOREGROUND_LIGHT, activebackground=ACCENT_COLOR, activeforeground='black')
        barra_menu_popup.add_cascade(label="üíæ Database", menu=menu_db)       
        menu_db.add_command(label="üì§ Esporta Supermercati", command=export_supermercati_db)
        menu_db.add_command(label="üì• Importa Supermercati", command=import_supermercati_db)
        menu_db.add_separator()
        menu_db.add_command(label="‚¨áÔ∏è Controlla Aggiornamento Editor Scontrini", command=self.check_supermarket_update_manuale)
        menu_db.add_command(label="‚¨áÔ∏è Forza Aggiornamento Editor Scontrini", command=self._scarica_editor_esterno)
        menu_db.add_command(label="‚¨áÔ∏è Rimuovi Completamente Editor Scontrini", command=self._rimuovi_editor_esterno)
        menu_db.add_separator()
        menu_db.add_command(label="‚ùå Chiudi (ESC)", command=lambda: (self.deiconify(), self.after(0, self.imp_entry.focus_set), popup.destroy()))
        self._popup_spesa_active = popup
        popup.title("Gestione e Confronto Spesa")
        popup.geometry("1200x630")
        screen_width = popup.winfo_screenwidth()
        screen_height = popup.winfo_screenheight()
        x = (screen_width - 1200) // 2
        y = (screen_height - 630) // 2
        popup.geometry(f"1200x630+{x}+{y}")
        popup.after(10, lambda: popup.focus_force())
        popup.bind("<Escape>", lambda e: (self.deiconify(), self.after(0, self.imp_entry.focus_set), popup.destroy()))
        self.withdraw()
        self.after(1000, self.check_supermarket_update)
        def on_popup_close():
            _salva_dati_interno(dati_supermercati)
            try:
                self.popup_calendario.destroy() 
            except:
                pass
            self.popup_calendario = None
            popup.destroy()
            self.deiconify()
            self.after(0, self.imp_entry.focus_set)
        popup.protocol("WM_DELETE_WINDOW", on_popup_close)
        notebook = ttk.Notebook(popup)
        notebook.pack(expand=True, fill='both', padx=10, pady=10)
        frame_lista = ttk.Frame(notebook, padding="10", name='frame_lista')
        notebook.add(frame_lista, text="Lista Spesa Intelligente")
        frame_lista.grid_rowconfigure(1, weight=1)
        frame_lista.grid_rowconfigure(3, weight=2)
        frame_lista.grid_columnconfigure(0, weight=1)
        frame_ricerca_input = ttk.Frame(frame_lista)
        frame_ricerca_input.grid(row=0, column=0, sticky='ew', pady=5)
        frame_ricerca_input.grid_columnconfigure(3, weight=1) 
        ttk.Label(frame_ricerca_input, text="Filtra Supermercato:").grid(row=0, column=0, padx=(5,0), sticky='w')
        combo_filtro_confronto = ttk.Combobox(
            frame_ricerca_input,
            textvariable=filtro_supermercato_confronto_var,
            values=tuple(["Tutti i supermercati"] + sorted(SUPERMERCATI)),
            style="Border.TCombobox",
            state='readonly',
            width=30
        )
        combo_filtro_confronto.grid(row=0, column=1, padx=5, sticky='w')
        ttk.Label(frame_ricerca_input, text="Cerca Articolo (Testo):").grid(row=0, column=2, padx=(15, 0), sticky='w')
        entry_ricerca = ttk.Entry(frame_ricerca_input, textvariable=ricerca_var_confronto)
        entry_ricerca.grid(row=0, column=3, padx=5, sticky='ew')
        ttk.Button(frame_ricerca_input, text="‚Ü∫",
                   style='Yellow.TButton', 
                   command=lambda: (ricerca_var_confronto.set(""), _aggiorna_lista_spesa_intelligente(risultati_tv)), 
                   width=2
                   ).grid(row=0, column=4, padx=(5, 5), sticky='w')
        ttk.Button(frame_ricerca_input, text="Cerca/Aggiorna Confronto", style='Verde.TButton',
                   command=lambda: _aggiorna_lista_spesa_intelligente(risultati_tv)).grid(row=0, column=5, padx=(10, 5), sticky='e')
        ttk.Button(frame_ricerca_input, text="?", style='Yellow.TButton', width=2,
           command=lambda: self.mostra_help_supermercati()).grid(row=0, column=6, padx=(5, 5), sticky='w')
        combo_filtro_confronto.bind('<<ComboboxSelected>>', lambda e: _aggiorna_lista_spesa_intelligente(risultati_tv))
        cols_risultati = ("Nome Articolo", "Qt√† Catalogo", "Supermercato", "Descrizione", "Categoria", "Prezzo", "Confronto",
    "Data Inizio Promo", "Data Scadenza Promo", "Prezzo Intero")
        frame_tv_risultati = ttk.Frame(frame_lista)
        frame_tv_risultati.grid(row=1, column=0, sticky='nsew', pady=5)
        risultati_tv = ttk.Treeview(frame_tv_risultati, columns=cols_risultati, show='headings')
        self.risultati_tv_ref = risultati_tv
        risultati_tv.tag_configure('promo_rossa', foreground='red')
        risultati_tv.tag_configure('piu_conveniente', foreground='green')
        risultati_tv.tag_configure('promo_gialla', foreground='orange')
        vbar_res = ttk.Scrollbar(frame_tv_risultati, orient="vertical", command=risultati_tv.yview)
        hbar_res = ttk.Scrollbar(frame_tv_risultati, orient="horizontal", command=risultati_tv.xview)
        risultati_tv.configure(yscrollcommand=vbar_res.set, xscrollcommand=hbar_res.set)
        vbar_res.pack(side="right", fill="y")
        hbar_res.pack(side="bottom", fill="x")
        risultati_tv.pack(side="left", fill='both', expand=True)
        risultati_tv.heading("Nome Articolo", text="Articolo"); 
        risultati_tv.heading("Qt√† Catalogo", text="Qt√† Cat."); 
        risultati_tv.heading("Supermercato", text="Supermercato"); 
        risultati_tv.heading("Prezzo", text="Prezzo")
        risultati_tv.heading("Confronto", text="Confronto")
        risultati_tv.heading("Descrizione", text="Descrizione")
        risultati_tv.heading("Categoria", text="Categoria")
        risultati_tv.column("Descrizione", width=150, stretch=True)
        risultati_tv.column("Categoria", width=130, stretch=False)
        risultati_tv.column("Qt√† Catalogo", width=60, anchor='center', stretch=True)
        risultati_tv.column("Prezzo", width=70, anchor='e', stretch=False)
        risultati_tv.column("Confronto", width=80, anchor='center')
        risultati_tv.column("Nome Articolo", width=140, anchor='w', stretch=True)
        risultati_tv.column("Supermercato", width=100, anchor='w', stretch=False)
        risultati_tv.column("Prezzo Intero", width=70, anchor='e', stretch=False)
        risultati_tv.column("Data Inizio Promo", width=80, anchor='center', stretch=False)
        risultati_tv.column("Data Scadenza Promo", width=80, anchor='center', stretch=False)
        for col in cols_risultati:
            text_to_show = {
                "Nome Articolo": "Articolo", 
                "Qt√† Catalogo": "Qt√† Cat.", 
                "Supermercato": "Supermercato",
                "Descrizione": "Descrizione",
                "Categoria": "Categoria",
                "Prezzo": "Prezzo",
                "Confronto": "Confronto",
                "Prezzo Intero": "Prezzo üî•", 
                "Data Inizio Promo": "Inizio", 
                "Data Scadenza Promo": "Scadenza"
            }.get(col, col)
            risultati_tv.heading(col, text=text_to_show, command=lambda _col=col, t=risultati_tv: _sort_treeview(t, _col, False))
        ttk.Label(frame_lista, text="La Tua Lista Spesa Ottimizzata (Doppio Click su Qt√† per Modificare) Promoüî• Attiva (ROSSO) / Futura (ARANCIO) | Top‚≠ê Miglior Prezzo Assoluto (VERDE)", font=('Arial', 10, 'bold')
        ).grid(row=2, column=0, sticky='ew', pady=(10, 5))
        cols_lista_spesa = ("Qt√† Catalogo", "Qt√† da Comprare", "Prezzo Un. (‚Ç¨)", "Totale (‚Ç¨)", "Supermercato")
        frame_tv_lista = ttk.Frame(frame_lista, name='frame_tv_lista')
        frame_tv_lista.grid(row=3, column=0, sticky='nsew')
        tv_lista_spesa = ttk.Treeview(frame_tv_lista, columns=cols_lista_spesa, show='tree headings')
        vbar_list = ttk.Scrollbar(frame_tv_lista, orient="vertical", command=tv_lista_spesa.yview)
        hbar_list = ttk.Scrollbar(frame_tv_lista, orient="horizontal", command=tv_lista_spesa.xview)
        tv_lista_spesa.configure(yscrollcommand=vbar_list.set, xscrollcommand=hbar_list.set)
        vbar_list.pack(side="right", fill="y")
        hbar_list.pack(side="bottom", fill="x")
        tv_lista_spesa.pack(side="left", fill='both', expand=True)
        tv_lista_spesa.heading("#0", text="Articolo/Gruppo")
        heading_map = {
            "Qt√† Catalogo": "Qt√† Cat.",
            "Qt√† da Comprare": "Qt√† Ordine",
            "Prezzo Un. (‚Ç¨)": "Prezzo Un. (‚Ç¨)",
            "Totale (‚Ç¨)": "Totale (‚Ç¨)",      
            "Supermercato": "Supermercato"
        }
        for col in cols_lista_spesa: 
            tv_lista_spesa.heading(col, text=heading_map.get(col, col))
        tv_lista_spesa.column("#0", width=180, anchor='w', stretch=True)
        tv_lista_spesa.column("Qt√† Catalogo", width=80, anchor='center', stretch=False)
        tv_lista_spesa.column("Qt√† da Comprare", width=120, anchor='center', stretch=False)
        tv_lista_spesa.column("Prezzo Un. (‚Ç¨)", width=140, anchor='e', stretch=False)
        tv_lista_spesa.column("Totale (‚Ç¨)", width=100, anchor='e', stretch=False)
        tv_lista_spesa.column("Supermercato", width=120, anchor='center')
        for col in cols_lista_spesa:
            tv_lista_spesa.heading(col, command=lambda _col=col, t=tv_lista_spesa: _sort_treeview(t, _col, False))
        risultati_tv.bind('<Double-1>', lambda e, tv_list=tv_lista_spesa, tv_res=risultati_tv: _aggiungi_a_lista_spesa(e, tv_list, tv_res))
        entry_ricerca.bind('<KeyRelease>', lambda e, tv=risultati_tv: _cerca_articoli(ricerca_var_confronto.get(), tv))
        tv_lista_spesa.bind('<Button-1>', lambda e, tv=tv_lista_spesa: _on_edit_quantity(e, tv))
        frame_pulsanti_lista = ttk.Frame(frame_lista)
        frame_pulsanti_lista.grid(row=4, column=0, sticky='ew', pady=5)
        ttk.Button(frame_pulsanti_lista, text="‚ùå Rimuovi Selezionato", style='Rosso.TButton',
                   command=lambda tv=tv_lista_spesa: _rimuovi_articolo_da_lista(tv)).pack(side='left', padx=5)
        ttk.Button(frame_pulsanti_lista, text="üóëÔ∏è Svuota Lista", style='Rosso.TButton',
                   command=lambda tv=tv_lista_spesa: _svuota_lista_spesa(tv)).pack(side='left', padx=5)
        ttk.Button(frame_pulsanti_lista, text="üö™ Chiudi", style='Giallo.TButton',
                   command=lambda: on_popup_close()).pack(side='right', padx=5)
        ttk.Button(frame_pulsanti_lista, text="üñ®Ô∏è Esporta Lista", style='Verde.TButton',
                   command=_mostra_anteprima_esportazione).pack(side='right', padx=5)
        frame_gestione = ttk.Frame(notebook, padding="10")
        notebook.add(frame_gestione, text="Gestione Supermercati")
        frame_gestione.grid_columnconfigure(0, weight=1)
        frame_gestione.grid_rowconfigure(3, weight=1)
        self.label_conteggio_db = ttk.Label(
            frame_gestione, 
            text="üõí", 
            font=('Arial', 12, 'bold'), 
            foreground='#3f51b5'
        )
        self.label_conteggio_db.bind("<Button-1>", lambda event: info_popup())
        self.label_conteggio_db.grid(row=0, column=1, sticky='e', padx=5, pady=5)
        frame_selezione = ttk.Frame(frame_gestione)
        frame_selezione.grid(row=0, column=0, sticky='ew', pady=(0, 10))
        ttk.Label(frame_selezione, text="Seleziona Supermercato da Gestire:").pack(side='left', padx=5)
        combo_supermercato = ttk.Combobox(frame_selezione, textvariable=supermercato_selezionato_var,
                                          values=tuple(["Seleziona Supermercato"] + sorted(SUPERMERCATI)),
                                          style="Border.TCombobox",
                                          state='readonly', width=30, name='combo_gestione_super')
        combo_supermercato.pack(side='left', padx=5)
        supermercato_selezionato_var.set("Seleziona Supermercato")
        ttk.Button(frame_selezione, text="‚úèÔ∏è Rinomina Selezionato", style='Giallo.TButton',
                   command=lambda c=combo_supermercato, t=None, r=None: _esegui_rinomina_supermercato(c, tree_super_crud, ricerca_vars_crud.get(supermercato_selezionato_var.get(), tk.StringVar()))).pack(side='left', padx=15)
        if 'combo_gestione_super' not in campi_input_refs:
            campi_input_refs['combo_gestione_super'] = {
                'nome': tk.StringVar(), 'descrizione': tk.StringVar(), 'categoria': tk.StringVar(),
                'prezzo': tk.StringVar(), 'promo_attiva': tk.BooleanVar(), 'prezzo_promo': tk.StringVar(),
                'quantita': tk.StringVar(), 'data_scadenza': tk.StringVar(),
                'data_inserimento_prezzo': tk.StringVar(),
                'data_inizio_promo': tk.StringVar()
            }
        refs_crud = campi_input_refs['combo_gestione_super']
        frame_input = ttk.Frame(frame_gestione)
        frame_input.grid(row=1, column=0, sticky='nw', pady=5)
        ttk.Label(frame_input, text="Nome Articolo:").grid(row=0, column=0, padx=5, pady=2, sticky='w')
        ttk.Entry(frame_input, textvariable=refs_crud['nome'], width=30).grid(row=0, column=1, padx=5, pady=2, sticky='w')
        ttk.Label(frame_input, text="Categoria:").grid(row=0, column=2, padx=5, pady=2, sticky='w')
        combo_categoria = ttk.Combobox(
            frame_input, 
            textvariable=refs_crud['categoria'],
            values=CATEGORIE_PREDEFINITE,
            state='readonly',
            style="Border.TCombobox",
            width=15
        )
        combo_categoria.grid(row=0, column=3, padx=5, pady=2, sticky='w') 
        if CATEGORIE_PREDEFINITE:
            combo_categoria.set(CATEGORIE_PREDEFINITE[0])
        ttk.Label(frame_input, text="Descrizione:").grid(row=1, column=0, padx=5, pady=2, sticky='w')
        ttk.Entry(frame_input, textvariable=refs_crud['descrizione'], width=30).grid(row=1, column=1, padx=5, pady=2, sticky='w')
        ttk.Label(frame_input, text="Quantit√† (es: 500g):").grid(row=1, column=2, padx=5, pady=2, sticky='w')
        ttk.Entry(frame_input, textvariable=refs_crud['quantita'], width=15).grid(row=1, column=3, padx=5, pady=2, sticky='w')
        ttk.Label(frame_input, text="Prezzo Normale (‚Ç¨):").grid(row=2, column=0, padx=5, pady=2, sticky='w')
        ttk.Entry(frame_input, textvariable=refs_crud['prezzo'], width=15).grid(row=2, column=1, padx=5, pady=2, sticky='w')
        ttk.Label(frame_input, text="Prezzo Promo (‚Ç¨):").grid(row=2, column=2, padx=5, pady=2, sticky='w')
        ttk.Entry(frame_input, textvariable=refs_crud['prezzo_promo'], width=15).grid(row=2, column=3, padx=5, pady=2, sticky='w')
        ttk.Checkbutton(frame_input, text="Articolo in Promozione", variable=refs_crud['promo_attiva']).grid(row=3, column=0, padx=5, pady=5, sticky='w')
        ttk.Label(frame_input, text="Data Inizio Promo:").grid(row=3, column=2, padx=5, pady=2, sticky='w')
        frame_data_inizio_promo = ttk.Frame(frame_input)
        frame_data_inizio_promo.grid(row=3, column=3, padx=5, pady=2, sticky='w')
        entry_data_inizio_promo = ttk.Entry(frame_data_inizio_promo, textvariable=refs_crud['data_inizio_promo'], width=15)
        entry_data_inizio_promo.grid(row=0, column=0, sticky='w')
        ttk.Button(
            frame_data_inizio_promo,
            text="üóìÔ∏è",
            style='Giallo.TButton',
            width=3,
            command=lambda e=entry_data_inizio_promo: self.mostra_calendario_popup(e, refs_crud['data_inizio_promo'])
        ).grid(row=0, column=1, sticky='w', padx=(5, 0))
        ttk.Label(frame_input, text="Data Inserimento Prezzo:").grid(row=4, column=0, padx=5, pady=2, sticky='w')
        frame_data_ins = ttk.Frame(frame_input)
        frame_data_ins.grid(row=4, column=1, padx=5, pady=2, sticky='w')
        entry_data_ins = ttk.Entry(frame_data_ins, textvariable=refs_crud['data_inserimento_prezzo'], width=15)
        entry_data_ins.grid(row=0, column=0, sticky='w')
        ttk.Button(
            frame_data_ins,
            text="üóìÔ∏è",
            style='Giallo.TButton',
            width=3,
            command=lambda e=entry_data_ins: self.mostra_calendario_popup(e, refs_crud['data_inserimento_prezzo'])
        ).grid(row=0, column=1, sticky='w', padx=(5, 0))
        ttk.Label(frame_input, text="Data Scadenza:").grid(row=4, column=2, padx=5, pady=2, sticky='w')
        frame_data_input = ttk.Frame(frame_input)
        frame_data_input.grid(row=4, column=3, padx=5, pady=2, sticky='w')
        entry_data_scadenza = ttk.Entry(frame_data_input, textvariable=refs_crud['data_scadenza'], width=15)
        entry_data_scadenza.grid(row=0, column=0, sticky='w')
        ttk.Button(
            frame_data_input, 
            text="üóìÔ∏è", 
            style='Giallo.TButton',
            width=3, 
            command=lambda e=entry_data_scadenza: self.mostra_calendario_popup(e, refs_crud['data_scadenza'])
        ).grid(row=0, column=1, sticky='w', padx=(5, 0))
        frame_ricerca_crud = ttk.Frame(frame_gestione)
        frame_ricerca_crud.grid(row=2, column=0, sticky='ew', pady=(0, 5))        
        frame_ricerca_crud = ttk.Frame(frame_gestione)
        frame_ricerca_crud.grid(row=2, column=0, sticky='ew', pady=(0, 5))
        ttk.Label(frame_ricerca_crud, text="Cerca Articolo (Testo):").pack(side='left', padx=5)
        ricerca_var_crud_attuale = tk.StringVar()
        entry_ricerca_crud = ttk.Entry(frame_ricerca_crud, textvariable=ricerca_var_crud_attuale, width=40)
        entry_ricerca_crud.pack(side='left', padx=5, fill='x', expand=True)
        def update_crud_search_var(e=None):
            current_superm = supermercato_selezionato_var.get()
            if current_superm != "Seleziona Supermercato":
                _cerca_articoli_crud(current_superm, tree_super_crud, ricerca_var_crud_attuale)
        def reset_ricerca_crud():
            ricerca_var_crud_attuale.set("") 
            update_crud_search_var()
        ttk.Button(frame_ricerca_crud, 
                   text="‚Ü∫",
                   style='Yellow.TButton', 
                   command=reset_ricerca_crud,
                   width=2
                  ).pack(side='left', padx=5)
        ttk.Button(frame_ricerca_crud, text="Cerca", style='Blu.TButton', command=update_crud_search_var).pack(side='left', padx=10)
        entry_ricerca_crud.bind('<KeyRelease>', update_crud_search_var)
        cols_super = ("Nome", "Descrizione", "Categoria", "Prezzo", "Data Ins.", "Promo", "P. Promo", "Quantit√†", "Inizio Promo", "Scadenza")
        frame_tv_crud = ttk.Frame(frame_gestione)
        frame_tv_crud.grid(row=3, column=0, sticky='nsew', pady=(5, 0))
        tree_super_crud = ttk.Treeview(frame_tv_crud, columns=cols_super, show='headings')
        tree_super_crud.tag_configure('promo_attiva', foreground='red')
        tree_super_crud.tag_configure('promo_in_arrivo', foreground='orange')
        vbar_tv = ttk.Scrollbar(frame_tv_crud, orient="vertical", command=tree_super_crud.yview)
        hbar_tv = ttk.Scrollbar(frame_tv_crud, orient="horizontal", command=tree_super_crud.xview)
        tree_super_crud.configure(yscrollcommand=vbar_tv.set, xscrollcommand=hbar_tv.set)
        vbar_tv.pack(side="right", fill="y")
        hbar_tv.pack(side="bottom", fill="x")
        tree_super_crud.pack(side="left", fill='both', expand=True)
        for col in cols_super:
            text_to_show = col.replace("P. Promo", "Promo ‚Ç¨").replace("Data Ins.", "Data Inserita").replace("Inizio Promo", "Inizio Promo").replace("Scadenza", "Scadenza")
            tree_super_crud.heading(col, text=text_to_show, command=lambda _col=col, t=tree_super_crud: _sort_treeview(t, _col, False))
        tree_super_crud.column("Promo", width=50, anchor='center', stretch=False)
        tree_super_crud.column("P. Promo", width=70, anchor='e', stretch=False)
        tree_super_crud.column("Quantit√†", width=80, anchor='center', stretch=False)
        tree_super_crud.column("Prezzo", width=70, anchor='e', stretch=False)
        tree_super_crud.column("Inizio Promo", width=90, anchor='center', stretch=False)
        tree_super_crud.column("Scadenza", width=90, anchor='center', stretch=False)
        tree_super_crud.column("Nome", width=120, anchor='w')
        tree_super_crud.column("Descrizione", width=120, anchor='w')
        tree_super_crud.column("Categoria", width=90, anchor='w')
        tree_super_crud.column("Data Ins.", width=90, anchor='center', stretch=False)
        frame_pulsanti_crud = ttk.Frame(frame_gestione)
        frame_pulsanti_crud.grid(row=4, column=0, sticky='ew', pady=5)
        supermercato_destinazione_var = tk.StringVar() 
        ttk.Label(frame_pulsanti_crud, text="Sposta Articolo").pack(side='left', padx=(20, 5))
        combo_super_sposta = ttk.Combobox(
            frame_pulsanti_crud,
            textvariable=supermercato_destinazione_var,
            values=tuple(sorted(SUPERMERCATI)),
            style="Border.TCombobox",
            state='readonly',
            width=20
        )
        combo_super_sposta.pack(side='left', padx=5)
        ttk.Button(frame_pulsanti_crud, text="‚û°Ô∏è Sposta", style='Giallo.TButton',
                   command=lambda tv=tree_super_crud, combo=combo_super_sposta: _sposta_articolo_tra_super(tv, combo)).pack(side='left', padx=10)
        def _sposta_articolo_tra_super(treeview_crud, combo_superm_dest):
            selected_item_iid = treeview_crud.focus()
            if not selected_item_iid:
                self.show_custom_warning("Articolo Mancante", "Seleziona un articolo nella tabella da spostare.")
                return
            super_destinazione = combo_superm_dest.get()
            super_corrente = supermercato_selezionato_var.get()
            if not super_destinazione: 
                self.show_custom_warning("Destinazione Mancante", "Seleziona un supermercato di destinazione valido.")
                return
            if super_destinazione == super_corrente:
                self.show_custom_warning("Spostamento Inutile", "L'articolo √® gi√† nel supermercato selezionato come destinazione.")
                return
            if not dati_supermercati.get(super_corrente):
                self.show_custom_warning("Errore Dati", "Supermercato di origine non trovato.")
                return
            try:
                iid_parts = selected_item_iid.split('_')
                if len(iid_parts) == 3 and iid_parts[0] == 'item':
                    idx_da_rimuovere = int(iid_parts[2])
                else:
                    item_values = treeview_crud.item(selected_item_iid, 'values')
                    if not item_values:
                        self.show_custom_warning("Errore Dati", "Articolo non trovato nei dati del supermercato corrente.")
                        return
                    nome_articolo = item_values[0]
                    articoli_correnti = dati_supermercati[super_corrente]
                    idx_da_rimuovere = next(i for i, a in enumerate(articoli_correnti) if a.get('nome') == nome_articolo)
                articolo_spostato = dati_supermercati[super_corrente].pop(idx_da_rimuovere)
            except StopIteration:
                self.show_custom_warning("Errore Dati", "Articolo non trovato nei dati del supermercato corrente.")
                return
            except Exception as e:
                self.show_custom_warning("Errore Estrazione", f"Errore durante l'estrazione o rimozione dell'articolo: {e}")
                return
            if super_destinazione not in dati_supermercati:
                 dati_supermercati[super_destinazione] = []
            dati_supermercati[super_destinazione].append(articolo_spostato)
            supermercato_destinazione_var.set("")
            self.show_custom_warning("Spostamento Riuscito", f"L'articolo √® stato spostato con successo da '{super_corrente}' a '{super_destinazione}'.")
            ricerca_var_attuale = ricerca_vars_crud.get(super_corrente, tk.StringVar())
            _cerca_articoli_crud(super_corrente, treeview_crud, ricerca_var_attuale)
            if hasattr(self, 'risultati_tv_ref') and self.risultati_tv_ref:
                _aggiorna_lista_spesa_intelligente(self.risultati_tv_ref)
            _salva_dati_interno(dati_supermercati)
        def _genera_testo_esportazione_supermercato(supermercato):
            import datetime
            WIDTH_NOME = 29          
            WIDTH_DESC = 20          
            WIDTH_CAT = 20
            WIDTH_QTA = 10           
            WIDTH_PREZZO_N = 8
            WIDTH_PREZZO_P = 8
            WIDTH_PROMO = 5          
            WIDTH_INIZIO_PROMO = 10  
            WIDTH_SCAD = 10          
            WIDTH_DATA_INS = 10      
            EXTRA_SPACE = "  "
            data_esportazione = datetime.datetime.now().strftime("%d/%m/%Y %H:%M:%S")
            testo = f"=== CATALOGO SUPERMERCATO: {supermercato.upper()} ({data_esportazione}) ===\n"
            articoli = dati_supermercati.get(supermercato, [])
            if not articoli:
                testo += "\nNessun articolo registrato per questo supermercato."
                return testo
            articoli.sort(key=lambda x: x.get('nome', ''))
            intestazione = (
                f"{'Nome':<{WIDTH_NOME}} {'Descrizione':<{WIDTH_DESC}} {'Cat.':<{WIDTH_CAT}} " 
                f"{'Qt√†':<{WIDTH_QTA}} {'P.N.':>{WIDTH_PREZZO_N}} {'P.P.':>{WIDTH_PREZZO_P}} " 
                f"{'Pr.':<{WIDTH_PROMO}} "                               
                f"{'Iniz.Pr.':<{WIDTH_INIZIO_PROMO}}{EXTRA_SPACE}"  
                f"{'Scad.':<{WIDTH_SCAD}}{EXTRA_SPACE}"             
                f"{'Ins.':<{WIDTH_DATA_INS}}"                            
            )
            separatore = "-" * len(intestazione)
            testo += "\n" + separatore + "\n"
            testo += intestazione + "\n"
            testo += separatore + "\n"
            articoli_incompleti_count = 0
            articoli_esportati_count = 0
            for articolo in articoli:
                nome = articolo.get("nome", "")
                categoria = articolo.get("categoria", "")
                prezzo = str(articolo.get("prezzo", ""))
                mancanze = []
                if not nome: mancanze.append("Nome")
                if not categoria: mancanze.append("Cat")
                if not (prezzo and prezzo.replace('.', '', 1).isdigit()): mancanze.append("Prezzo")
                if mancanze:
                    articoli_incompleti_count += 1
                    continue 
                articoli_esportati_count += 1
                descrizione = articolo.get("descrizione", "")
                quantita = articolo.get("quantita", "")
                promo = "SI" if articolo.get("promo") else "NO"
                prezzo_promo = str(articolo.get("prezzo_promo", ""))
                data_scadenza = articolo.get("data_scadenza", "")
                data_inizio_promo = articolo.get("data_inizio_promo", "")
                data_inserimento = articolo.get("data_inserimento_prezzo", "") 
                prezzo_fmt = f"{float(prezzo):.2f}"
                promo_fmt = f"{float(prezzo_promo):.2f}" if prezzo_promo and prezzo_promo.replace('.', '', 1).isdigit() else ""
                linea = (
                    f"{nome[:WIDTH_NOME-1]:<{WIDTH_NOME}} "
                    f"{descrizione[:WIDTH_DESC-1]:<{WIDTH_DESC}} "
                    f"{categoria[:WIDTH_CAT-1]:<{WIDTH_CAT}} "
                    f"{quantita[:WIDTH_QTA-1]:<{WIDTH_QTA}} "
                    f"{prezzo_fmt:>{WIDTH_PREZZO_N}} " 
                    f"{promo_fmt:>{WIDTH_PREZZO_P}} " 
                    f"{promo:<{WIDTH_PROMO}} "                             
                    f"{data_inizio_promo:<{WIDTH_INIZIO_PROMO}}{EXTRA_SPACE}" 
                    f"{data_scadenza:<{WIDTH_SCAD}}{EXTRA_SPACE}"             
                    f"{data_inserimento:<{WIDTH_DATA_INS}}\n"              
                )
                testo += linea
            testo += separatore + "\n"
            total_articoli = len(articoli)
            testo += f"\n=== RIEPILOGO DATI ===\n"
            testo += f"Totale Articoli: {total_articoli}\n"
            testo += f"Articoli Esportati: {articoli_esportati_count}\n"
            testo += f"Articoli Ignorati: {articoli_incompleti_count}\n"
            testo += "=" * len(intestazione) + "\n"
            return testo
        def _mostra_anteprima_esportazione_supermercato(supermercato):
            if supermercato == "Seleziona Supermercato" or not supermercato:
                self.show_custom_warning("Selezione", "Seleziona un supermercato da esportare."); return
            anteprima_text = _genera_testo_esportazione_supermercato(supermercato)
            def _esporta_su_file_super(content_text, default_name, preview_popup):
                preview_popup.destroy()
                f = filedialog.asksaveasfilename(
                    defaultextension=".txt",
                    filetypes=[("File txt", "*.txt")],
                    title=f"Salva Catalogo {supermercato} su File",
                    initialdir=EXPORT_FILES,
                    confirmoverwrite=False,
                    initialfile=default_name,
                    parent=popup
                )
                if f:
                    try:
                        with open(f, 'w', encoding='utf-8') as file_handle: file_handle.write(content_text)
                        self.show_custom_warning("Successo", f"‚úÖ Catalogo salvato con successo in:\n{f}")
                    except Exception as e:
                        self.show_custom_warning("Errore", f"‚ùå Impossibile salvare il file:\n{e}")
            preview_popup = tk.Toplevel(popup, bg=self.COLOR_TOPLEVEL)
            preview_popup.title(f"Anteprima Esportazione Catalogo: {supermercato}")
            WIDTH = 1200
            HEIGHT = 600
            screen_width = preview_popup.winfo_screenwidth()
            screen_height = preview_popup.winfo_screenheight()
            x = (screen_width - WIDTH) // 2
            y = (screen_height - HEIGHT) // 2
            preview_popup.geometry(f"{WIDTH}x{HEIGHT}+{x}+{y}")
            preview_popup.after(10, lambda: preview_popup.focus_force())
            preview_popup.bind('<Escape>', lambda e: preview_popup.destroy())
            text_area = tk.Text(preview_popup, wrap='word', font=('Courier', 10), padx=10, pady=10)
            text_area.insert('1.0', anteprima_text)
            text_area.config(state='disabled')
            text_area.pack(fill='both', expand=True, padx=10, pady=10)
            frame_btn = tk.Frame(preview_popup, bg=self.COLOR_TOPLEVEL); frame_btn.pack(pady=(0, 10))
            ttk.Button(frame_btn, text="‚ùå Chiudi", command=preview_popup.destroy, style='Giallo.TButton').pack(side='right', padx=5)
            now = datetime.date.today()
            default_filename = f"Catalogo_{supermercato}_{now.day:02d}_{now.month:02d}_{now.year}.txt"
            ttk.Button(frame_btn, text="üì§ Esporta", style='Verde.TButton',
                         command=lambda: _esporta_su_file_super(anteprima_text, default_filename, preview_popup)
            ).pack(side='left', padx=5)
            ttk.Button(
                frame_btn, 
                text="üñ®Ô∏è Stampa", 
                style='Blu.TButton',
                command=lambda: self._stampa_lista_diretta(
                anteprima_text, 
                self.show_custom_warning
                )
            ).pack(side='left', padx=5)
        def crud_wrapper(azione, tree, frame_input):
            superm = supermercato_selezionato_var.get()
            if superm == "Seleziona Supermercato":
                self.show_custom_warning("Selezione", "Seleziona un supermercato prima di eseguire l'azione."); return
            _funzione_crud(azione, superm, tree, frame_input)
        ttk.Button(frame_pulsanti_crud, text="‚ûï Inserisci", style='Blu.TButton',
                   command=lambda a='inserisci', t=tree_super_crud, f=frame_input: crud_wrapper(a, t, f)).pack(side='left', padx=5)
        ttk.Button(frame_pulsanti_crud, text="‚úèÔ∏è Modifica", style='Blu.TButton',
                   command=lambda a='modifica', t=tree_super_crud, f=frame_input: crud_wrapper(a, t, f)).pack(side='left', padx=5)
        ttk.Button(frame_pulsanti_crud, text="üíæ Salva Modifiche", style='Blu.TButton',
                   command=lambda a='salva', t=tree_super_crud, f=frame_input: crud_wrapper(a, t, f)).pack(side='left', padx=5)
        ttk.Button(frame_pulsanti_crud, text="‚ùå Cancella", style='Rosso.TButton',
                   command=lambda a='cancella', t=tree_super_crud, f=frame_input: crud_wrapper(a, t, f)).pack(side='left', padx=5)
        ttk.Button(frame_pulsanti_crud, text="üí£ AZZERA Dati", style='Rosso.TButton',
                   command=lambda s=supermercato_selezionato_var, t=tree_super_crud: _svuota_supermercato(s.get(), t)).pack(side='right', padx=15)
        ttk.Button(frame_pulsanti_crud, text="üñ®Ô∏è Esporta Catalogo", style='Verde.TButton',
                   command=lambda s=supermercato_selezionato_var: _mostra_anteprima_esportazione_supermercato(s.get())).pack(side='right', padx=5)
        combo_supermercato.bind('<<ComboboxSelected>>', 
                                lambda e, c=combo_supermercato, t=tree_super_crud, f=frame_input, r=ricerca_var_crud_attuale: _on_supermercato_change(e, c, t, f, r))
        ttk.Button(frame_pulsanti_crud, text="üõí Importa Scontrini", 
                   command=self._avvia_editor_esterno, 
                   style='Blu.TButton').pack(side='left', padx=5)
        _cerca_articoli("", risultati_tv)
        _ricarica_lista_spesa(tv_lista_spesa)
        popup.wait_visibility()
    def mostra_help_supermercati(self):
        if not hasattr(self, '_popup_spesa_active') or not self._popup_spesa_active.winfo_exists():
            return 
        parent_window = self._popup_spesa_active
        help_text_lista = """
Obiettivo: Creare una lista spesa ottimizzata, trovando il prezzo migliore per ogni articolo tra tutti i cataloghi registrati.

# A. Sezione Confronto (Tabella Superiore)
1.  Filtro e Ricerca: Utilizza la casella di ricerca e il filtro supermercato per visualizzare solo gli articoli desiderati nel catalogo complessivo.
2.  La Colonna 'Confronto' (Il Cuore Smart):
    * Questa colonna esegue il confronto prezzi in tempo reale.
    * Se l'articolo costa meno altrove, la colonna ti mostra il costo minimo pi√π basso trovato e in quale supermercato, evidenziando l'opportunit√† di risparmio.
    * La tua scelta finale √® sempre basata sulla riga che selezioni.
    
3.  Aggiunta Articoli e Accumulo Quantit√† (Doppio Click):
    * Doppio click su una riga nella tabella superiore per aggiungere l'articolo alla lista spesa ottimizzata (tabella inferiore).
    * Cruciale: Se l'articolo √® gi√† presente nella lista inferiore, un ulteriore doppio click su di esso non aggiunge una nuova riga,\n      ma incrementa automaticamente la quantit√† da comprare di 1 unit√†.

# B. Sezione Lista Spesa Ottimizzata (Tabella Inferiore)
1.  Ottimizzazione Prezzo/Supermercato: La lista spesa finale suggerisce gli acquisti. La colonna 'Supermercato' indica dove\n
      √® consigliato comprare l'articolo per ottenere il prezzo finale pi√π basso.
2.  Modifica Quantit√†: Fai doppio click sulla cella della colonna 'Qt√† da Comprare' per modificare manualmente il numero esatto di unit√†.
3.  Gestione: Usa i pulsanti Rimuovi Selezionato, Svuota Lista e Esporta Lista per finalizzare e salvare la tua lista spesa ottimizzata.
"""
        help_text_gestione = """
Obiettivo: Mantenere aggiornati i cataloghi (prezzi, promozioni, descrizioni) di ciascun supermercato per garantire un confronto accurato.

# A. Operazioni Base (CRUD)
1.  Selezione Catalogo: Seleziona un supermercato dal ComboBox 'Seleziona Supermercato da Gestire'. La tabella sottostante si popoler√† con i suoi articoli.
2.  ‚ûï Inserisci: Compila tutti i campi di input (Nome Articolo, Categoria, Prezzo, ecc.) e aggiungi un nuovo articolo al catalogo selezionato.
3.   Modifica (Carica): Seleziona un articolo nella tabella e premi 'Modifica' per caricare i suoi dati nei campi di input per l'editing.
4.   Salva Modifiche (Aggiorna): Dopo aver modificato i dati negli input, premi 'Salva Modifiche' per aggiornare l'articolo precedentemente selezionato.
5.  ‚ùå Cancella: Seleziona un articolo e premi 'Cancella' per rimuoverlo dal catalogo.

# B. Funzionalit√† Aggiuntive
*  Sposta Articolo: Sposta l'articolo selezionato dal catalogo corrente a un altro supermercato, specificato nel ComboBox di destinazione.
*  Rinomina Selezionato: Permette di cambiare il nome del supermercato selezionato.
*  AZZERA Dati: Attenzione! Cancella TUTTI gli articoli del supermercato selezionato.
*  Esporta Catalogo: Salva l'intero catalogo del supermercato selezionato in un file di testo per backup o consultazione esterna.
*  Importa Scontrini: Strumento per l'importazione e modifica rapida di dati dagli scontrini per popolare il catalogo.

# C. Funzionalit√† Menu'
*  Importa Supermercati: Carica un archivio contenente l'intero database. ATTENZIONE: Sovrascrive TUTTI i dati esistenti.
*  Esporta Supermercati: Crea un archivio con l'intero database dei cataloghi per un backup completo .
"""
        testo_stampa_completo = (
            "========================================================\n"
            "         GUIDA COMPLETA: LISTA SPESA E CATALOGO\n"
            "========================================================\n\n"
            
            "--- SEZIONE 1: LISTA SPESA INTELLIGENTE ---\n"
            "Obiettivo: Creare una lista spesa ottimizzata, trovando il prezzo migliore per ogni articolo tra tutti i cataloghi registrati.\n\n"
            
            "A. Sezione Confronto (Tabella Superiore)\n"
            "1. Filtro e Ricerca: Utilizza la casella di ricerca e il filtro supermercato per visualizzare solo gli articoli desiderati.\n"
            "2. La Colonna 'Confronto' (Il Cuore Smart): Mostra il costo minimo pi√π basso trovato e il supermercato pi√π conveniente.\n"
            "3. Aggiunta Articoli e Accumulo Quantit√† (Doppio Click): Doppio click aggiunge l'articolo; se √® gi√† presente, incrementa la quantit√† di 1 unit√†.\n\n"
            
            "B. Sezione Lista Spesa Ottimizzata (Tabella Inferiore)\n"
            "1. Ottimizzazione Prezzo/Supermercato: La lista suggerisce dove comprare l'articolo per il prezzo pi√π basso.\n"
            "2. Modifica Quantit√†: Doppio click sulla cella 'Qt√† da Comprare' per modificare manualmente.\n"
            "3. Gestione: Usa i pulsanti Rimuovi Selezionato, Svuota Lista e Esporta Lista.\n\n"
            
            "--- SEZIONE 2: GESTIONE SUPERMERCATI ---\n"
            "Obiettivo: Mantenere aggiornati i cataloghi per garantire un confronto accurato.\n\n"
            
            "A. Operazioni Base (CRUD)\n"
            "1. Selezione Catalogo: Scegli il supermercato dal ComboBox per popolare la tabella.\n"
            "2. Inserisci: Compila i campi e aggiungi un nuovo articolo.\n"
            "3. Modifica (Carica): Seleziona un articolo e premi 'Modifica' per caricare i dati.\n"
            "4. Salva Modifiche (Aggiorna): Aggiorna l'articolo con i nuovi dati negli input.\n"
            "5. Cancella: Rimuove l'articolo dal catalogo.\n\n"
            
            "B. Funzionalit√† Aggiuntive\n"
            "* Sposta Articolo: Sposta l'articolo selezionato a un altro supermercato.\n"
            "* Rinomina Selezionato: Cambia il nome del supermercato.\n"
            "* AZZERA Dati: ATTENZIONE! Cancella TUTTI gli articoli del supermercato selezionato.\n"
            "* Esporta Catalogo: Salva l'intero catalogo in un file di testo.\n"
            "* Importa Scontrini: Strumento per l'importazione e modifica rapida di dati dagli scontrini.\n\n"
            
            "C. Funzionalit√† Menu\n"
            "* Importa Supermercati: Carica un archivio contenente l'intero database. ATTENZIONE: Sovrascrive TUTTI i dati esistenti.\n"
            "* Esporta Supermercati: Crea un archivio con l'intero database dei cataloghi per un backup completo."
        )
        def _crea_text_area(parent_frame, content):
            text_container = ttk.Frame(parent_frame)
            text_container.pack(fill='both', expand=True)
            text_area = tk.Text(text_container, wrap='word', font=('Arial', 10), 
                                padx=10, pady=10, background='#f0f0f0', borderwidth=0)
            text_area.insert('1.0', content)
            text_area.config(state='disabled') 
            scrollbar = ttk.Scrollbar(text_container, command=text_area.yview)
            text_area.config(yscrollcommand=scrollbar.set)
            scrollbar.pack(side='right', fill='y')
            text_area.pack(side='left', fill='both', expand=True)
        help_popup = tk.Toplevel(parent_window, bg=self.COLOR_TOPLEVEL) 
        help_popup.title("Guida Completa: Catalogo e Lista Spesa Intelligente")
        WIDTH = 1200
        HEIGHT = 630
        screen_width = help_popup.winfo_screenwidth()
        screen_height = help_popup.winfo_screenheight()
        x = (screen_width - WIDTH) // 2
        y = (screen_height - HEIGHT) // 2
        help_popup.geometry(f"{WIDTH}x{HEIGHT}+{x}+{y}")
        help_popup.transient(parent_window)
        help_popup.bind("<Escape>", lambda e: help_popup.destroy())
        help_popup.grab_set()
        help_popup.protocol("WM_DELETE_WINDOW", help_popup.destroy)
        help_popup.after(10, lambda: help_popup.focus_force())
        main_frame = ttk.Frame(help_popup, padding="15")
        main_frame.pack(fill='both', expand=True)
        ttk.Label(main_frame, text="Guida all'Utilizzo delle Schede", 
                  font=('Arial', 14, 'bold')).pack(pady=(0, 15))
        notebook_help = ttk.Notebook(main_frame)
        notebook_help.pack(expand=True, fill='both')
        frame_help_lista = ttk.Frame(notebook_help, padding="10")
        notebook_help.add(frame_help_lista, text="Lista Spesa Intelligente")
        _crea_text_area(frame_help_lista, help_text_lista)
        frame_help_gestione = ttk.Frame(notebook_help, padding="10")
        notebook_help.add(frame_help_gestione, text="Gestione Supermercati (CRUD)")
        _crea_text_area(frame_help_gestione, help_text_gestione)
        btn_frame = ttk.Frame(help_popup, padding=(15, 0))
        btn_frame.pack(fill='x', padx=15, pady=(5, 15))
        ttk.Button(
            btn_frame, 
            text="üñ®Ô∏è Stampa Guida", 
            command=lambda: self._stampa_lista_diretta(
                testo_stampa_completo, 
                self.show_custom_warning
            ), 
            style='Blu.TButton'
        ).pack(side=tk.LEFT, padx=10, pady=5)
        ttk.Button(
            btn_frame, 
            text="Ho Capito (OK)", 
            command=help_popup.destroy, 
            style='Giallo.TButton'
        ).pack(side=tk.RIGHT, padx=10, pady=5)
        help_popup.wait_window(help_popup)

    # Generatore QR Code / Link Promemoria Google Calendar
    def launch_qr_svg_generator(self, initial_category="", initial_amount="", initial_date="", initial_description="", initial_type=""):
        from datetime import datetime, timedelta
        from urllib.parse import quote
        import segno
        root_widget = self
        categories_list = getattr(self, 'categorie', [])
        CATEGORIES = [""] + categories_list
        TYPE_OPTIONS = ["Promemoria", "uscita", "entrata"]
        def create_google_calendar_url(category, description, amount, date_obj, transaction_type):
            description = description.strip()
            display_category = category if category else ""
            event_date = date_obj.date() if isinstance(date_obj, datetime) else date_obj
            start_date_fmt = event_date.strftime("%Y%m%d")
            end_date_fmt = (event_date + timedelta(days=1)).strftime("%Y%m%d")
            title = f"PROMEMORIA: {display_category}"
            details = (f"Descrizione: {description}\n"
                       f"Importo: {amount} ‚Ç¨\n"
                       f"Categoria: {display_category}\n"
                       f"Tipo: {transaction_type.upper()}")
            encoded_title = quote(title)
            encoded_details = quote(details)
            base_url = "https://www.google.com/calendar/event?action=TEMPLATE"
            dates_part = f"&dates={start_date_fmt}/{end_date_fmt}"
            title_part = f"&text={encoded_title}"
            details_part = f"&details={encoded_details}"
            return f"{base_url}{dates_part}{title_part}{details_part}"
        def show_unified_qr_generator(root_widget):
            qr_popup = tk.Toplevel(root_widget)
            qr_popup.title("Generatore Promemoria QRCODE Google Calendar")
            qr_popup.transient(root_widget)
            qr_popup.withdraw()
            W, H = 550, 500
            qr_popup.resizable(False, False)
            qr_popup.geometry(f'{W}x{H}')
            qr_popup.minsize(width=W, height=H)
            qr_popup.update_idletasks()
            screen_width = qr_popup.winfo_screenwidth()
            screen_height = qr_popup.winfo_screenheight()
            x = (screen_width // 2) - (W // 2)
            y = (screen_height // 2) - (H // 2)
            qr_popup.geometry(f'{W}x{H}+{x}+{y}')
            qr_popup.deiconify()
            save_path_tracker = None
            def close_and_cleanup():
                try:
                    self.popup_calendario.destroy() 
                except:
                    pass
                self.popup_calendario = None
                qr_popup.destroy()
                if save_path_tracker and os.path.exists(save_path_tracker):
                    os.remove(save_path_tracker)
            def open_agenda_url():
                webbrowser.open("https://calendar.google.com/calendar/u/0/r/agenda")
            qr_popup.protocol("WM_DELETE_WINDOW", close_and_cleanup)
            qr_popup.bind('<Escape>', lambda e: close_and_cleanup())
            main_frame = ttk.Frame(qr_popup, padding="15")
            main_frame.pack(fill="both", expand=True)
            qr_cat_var = tk.StringVar(qr_popup, value=initial_category or CATEGORIES[0]) 
            qr_type_var = tk.StringVar(qr_popup, value=initial_type if initial_type in TYPE_OPTIONS else TYPE_OPTIONS[0])
            qr_amount_var = tk.StringVar(qr_popup, value=initial_amount) 
            bg_box = self.COLOR_WIDGET_BG
            fg_text = self.TEXT_COLOR
            cursor_color = self.TEXT_COLOR 
            border_color = self.COLOR_HIGHLIGHT
            desc_text_widget = tk.Text(
                main_frame, 
                height=3, 
                width=30, 
                wrap="word",
                bg=bg_box,
                fg=fg_text,
                insertbackground=cursor_color,
                font=("Arial", 10),
                relief="flat",
                highlightthickness=1,
                highlightbackground=border_color
            )
            if initial_description:
                desc_text_widget.insert(tk.END, initial_description)
            date_to_use = initial_date
            if not date_to_use:
                date_to_use = datetime.now().strftime("%d-%m-%Y")
            qr_date_var = tk.StringVar(main_frame, value=date_to_use)
            date_entry_widget_frame = ttk.Frame(main_frame) 
            date_entry_input = ttk.Entry(
                date_entry_widget_frame,
                textvariable=qr_date_var,
                width=24
            )
            date_entry_input.pack(side=tk.LEFT, fill=tk.X, expand=True)
            calendar_button = ttk.Button(
                date_entry_widget_frame,
                text="üóìÔ∏è",
                width=3,
                style="Yellow.TButton",
                command=lambda: self.mostra_calendario_popup(date_entry_input, qr_date_var) 
            )
            calendar_button.pack(side=tk.RIGHT, padx=(2, 0))
            def validate_importo(P):
                if P == "":
                    return True
                try:
                    float(P)
                    if P.count('.') <= 1:
                        return True
                    else:
                        return False
                except ValueError:
                    return False
            vcmd = main_frame.register(validate_importo)
            qr_amount_entry = ttk.Entry(
                main_frame, 
                textvariable=qr_amount_var, 
                width=30,
                validate='key',
                validatecommand=(vcmd, '%P')
            )
            cat_combobox = ttk.Combobox(main_frame, textvariable=qr_cat_var, values=CATEGORIES, width=30, style='Border.TCombobox')
            def reset_fields():
                qr_cat_var.set(CATEGORIES[0])
                qr_type_var.set(TYPE_OPTIONS[0])
                qr_amount_var.set("")
                qr_date_var.set(datetime.now().strftime("%d-%m-%Y"))
                desc_text_widget.delete('1.0', tk.END)
                url_display_label.grid_remove()
                url_text.grid_remove()
                browser_button.grid_remove()
                link_button.grid_remove()
                browser_message.grid_remove()
                browser_message.config(text="")
                generate_button.config(text="Genera QR Code/Link")
            def generate_qr_and_show_result():
                nonlocal save_path_tracker
                browser_message.config(text="", foreground="blue")
                description = desc_text_widget.get("1.0", tk.END).strip()
                date_str = qr_date_var.get()
                try:
                    date_obj = datetime.strptime(date_str, "%d-%m-%Y") 
                except ValueError:
                    browser_message.config(text="Errore: Data non valida (formato gg-mm-aaaa).", foreground="red")
                    browser_message.grid()
                    return
                url = create_google_calendar_url(qr_cat_var.get(), description, qr_amount_var.get().replace(',', '.'), date_obj, qr_type_var.get())
                try:
                    if save_path_tracker and os.path.exists(save_path_tracker):
                        os.remove(save_path_tracker)
                    temp_file = tempfile.NamedTemporaryFile(suffix='.svg', delete=False)
                    temp_file.close()
                    save_path = temp_file.name
                    save_path_tracker = save_path
                except Exception as e:
                    browser_message.config(text=f"ERRORE TEMPFILE: {e}", foreground="red")
                    browser_message.grid()
                    return
                try:
                    qrcode = segno.make(url)
                    qrcode.save(save_path, scale=8, dark="#333", light="white")
                    browser_button.grid() 
                    
                except Exception as e:
                    error_msg = f"ERRORE: Generazione QR fallita. {e}"
                    browser_message.config(text=error_msg, foreground="red")
                    browser_message.grid()
                url_text.delete('1.0', tk.END)
                url_text.insert(tk.END, url)
                root_widget.clipboard_clear()
                root_widget.clipboard_append(url)
                browser_message.config(text="Link copiato negli appunti!", foreground="green")
                url_display_label.grid()
                url_text.grid()
                link_button.grid()
                browser_message.grid()
                def open_svg_in_browser():
                    try:
                        full_path = 'file://' + os.path.realpath(save_path_tracker)
                        webbrowser.open(full_path)
                        browser_message.config(text="QR Code temporaneo aperto nel browser!", foreground="dodgerblue")
                    except Exception:
                        browser_message.config(text="ERRORE: Impossibile aprire il browser.", foreground="red")
                def open_link_in_browser():
                    try:
                        webbrowser.open(url)
                        browser_message.config(text="Link promemoria aperto nel browser!", foreground="dodgerblue")
                    except Exception:
                        browser_message.config(text="ERRORE: Impossibile aprire il link.", foreground="red")
                browser_button.config(command=open_svg_in_browser)
                link_button.config(command=open_link_in_browser)
                generate_button.config(
                    text="Rigenera QR Code/Link",
                    command=generate_qr_and_show_result
                )
                def open_svg_in_browser():
                    if not segno: return
                    try:
                        full_path = 'file://' + os.path.realpath(save_path_tracker)
                        webbrowser.open(full_path)
                        browser_message.config(text="QR Code temporaneo aperto nel browser!", foreground="dodgerblue")
                    except Exception:
                        browser_message.config(text="ERRORE: Impossibile aprire il browser.", foreground="red")
                def open_link_in_browser():
                    try:
                        webbrowser.open(url)
                        browser_message.config(text="Link promemoria aperto nel browser!", foreground="dodgerblue")
                    except Exception:
                        browser_message.config(text="ERRORE: Impossibile aprire il link.", foreground="red")
                browser_button.config(command=open_svg_in_browser)
                link_button.config(command=open_link_in_browser)
                generate_button.config(
                    text="Rigenera QR Code/Link",
                    command=generate_qr_and_show_result
                )
            fields = [
                ("Categoria:", cat_combobox),
                ("Data:", date_entry_widget_frame),
                ("Descrizione (Note):", desc_text_widget),
                ("Tipo:", ttk.Combobox(main_frame, textvariable=qr_type_var, values=TYPE_OPTIONS, state="readonly", width=30, style='Border.TCombobox')),
                ("Importo:", qr_amount_entry) 
            ]
            current_row = 0
            for label_text, widget in fields:
                sticky_val = "nw" if isinstance(widget, tk.Text) else "w"
                ttk.Label(main_frame, text=label_text).grid(row=current_row, column=0, sticky=sticky_val, pady=5, padx=5)
                if isinstance(widget, tk.Text):
                    rowspan = 3 
                    widget.grid(row=current_row, column=1, sticky="ew", pady=5, padx=5, rowspan=rowspan)
                    current_row += rowspan 
                else:
                    widget.grid(row=current_row, column=1, sticky="ew", pady=5, padx=5)
                    current_row += 1 
            sep_row = current_row
            ttk.Separator(main_frame, orient='horizontal').grid(row=sep_row, columnspan=2, sticky="ew", pady=10)
            control_row_1 = sep_row + 1
            generate_button = ttk.Button(main_frame, text="Genera QR Code/Link", command=generate_qr_and_show_result, style="Blu.TButton")
            generate_button.grid(row=control_row_1, column=0, sticky="ew", pady=5, padx=(0, 5))
            close_button = ttk.Button(
                main_frame,
                text="‚ùå Chiudi",
                command=close_and_cleanup,
                style='Giallo.TButton'
            )
            close_button.grid(row=control_row_1, column=1, sticky="ew", pady=5, padx=(5, 0))
            control_row_2 = control_row_1 + 1 
            reset_button = ttk.Button(main_frame, text="üîÑ Reset Campi", command=reset_fields, style="Rosso.TButton")
            reset_button.grid(row=control_row_2, column=0, sticky="ew", pady=5, padx=(0, 5))
            agenda_button = ttk.Button(main_frame, text="üóìÔ∏è Vai ad Agenda Calendar", command=open_agenda_url, style="Blu.TButton")
            agenda_button.grid(row=control_row_2, column=1, sticky="ew", pady=5, padx=(5, 0))
            output_row_start = control_row_2 + 1 
            url_display_label = ttk.Label(main_frame, text="LINK GENERATO:", font=('Arial', 10, 'bold'))
            url_text = tk.Text(
                main_frame, 
                height=3, 
                width=50, 
                wrap="word", 
                bg=bg_box, 
                fg=fg_text,
                insertbackground=cursor_color,
                font=("Courier new", 9),
                relief="flat",
                highlightthickness=1,
                highlightbackground=border_color
            )
            browser_button = ttk.Button(main_frame, text="Mostra QR Code nel Browser", style="Blu.TButton")
            link_button = ttk.Button(main_frame, text="Apri Link Promemoria", style="Arancio.TButton")
            browser_message = ttk.Label(main_frame, text="", foreground="blue")
            url_display_label.grid(row=output_row_start, columnspan=2, sticky="w", pady=(10, 5))
            url_display_label.grid_remove()
            url_text.grid(row=output_row_start + 1, columnspan=2, sticky="ew")
            url_text.grid_remove()
            browser_button.grid(row=output_row_start + 2, column=0, sticky="ew", pady=10, padx=(0, 5))
            browser_button.grid_remove()
            link_button.grid(row=output_row_start + 2, column=1, sticky="ew", pady=10, padx=(5, 0))
            link_button.grid_remove()
            browser_message.grid(row=output_row_start + 3, columnspan=2, pady=5)
            browser_message.grid_remove()
            main_frame.grid_columnconfigure(0, weight=1)
            main_frame.grid_columnconfigure(1, weight=1)
        show_unified_qr_generator(root_widget)

    # Gestione Archivi PDF Documentali
    def gestisci_archivi_pdf(self, categoria_iniziale=None):
        from datetime import datetime
        categorie_vuote = [] 
        if not hasattr(self, 'filtri_avanzati'):
             self.filtri_avanzati = {} 
        if categoria_iniziale and categoria_iniziale.strip() not in ("", "Generica", "‚Äî"):
             self.filtri_avanzati['categoria'] = categoria_iniziale
        elif 'categoria' in self.filtri_avanzati and not categoria_iniziale:
             del self.filtri_avanzati['categoria']
        if not hasattr(self, '_ignore_trace'):
             self._ignore_trace = False
        def crea_directory_documenti():
             if not os.path.exists(DB_DIR): os.makedirs(DB_DIR)
             if not os.path.exists(DOC_DIR): os.makedirs(DOC_DIR)
        def load_document_registry():
             crea_directory_documenti()
             if os.path.exists(REGISTRY_FILE):
                 with open(REGISTRY_FILE, 'r', encoding='utf-8') as f:
                     try:
                         content = f.read()
                         if not content: return {}
                         f.seek(0)
                         return json.load(f)
                     except json.JSONDecodeError:
                         self.show_custom_warning("Attenzione", "Il file di registro √® corrotto. Creazione di un nuovo registro.")
                         return {}
             return {}
        def save_document_registry(registry):
             crea_directory_documenti()
             with open(REGISTRY_FILE, 'w', encoding='utf-8') as f:
                 json.dump(registry, f, indent=4, ensure_ascii=False)
        def sanitizza_stringa(s, max_len=None):
             s_sanitizzata = s.strip().replace(' ', '_')
             s_sanitizzata = re.sub(r'[^\w\.-]', '', s_sanitizzata) 
             if max_len and len(s_sanitizzata) > max_len: return s_sanitizzata[:max_len]
             return s_sanitizzata.upper()
        def trace_importo(name, index, mode):
            current_value = importo_var.get()
            if self._ignore_trace: return
            self._ignore_trace = True
            pulito = re.sub(r'[^\d]', '', current_value) 
            formattato = formatta_importo_pulito(pulito)
            if formattato != current_value:
                importo_var.set(formattato)
            self._ignore_trace = False
        def validate_importo(P):
             if P == "": return True
             if not re.match(r'^[\d,\.]*$', P): return False
             cifre = re.sub(r'[^\d]', '', P)
             if len(cifre) > 7: return False
             return True
        vcmd_importo = self.register(validate_importo) 
        def trace_importo(name, index, mode):
             current_value = importo_var.get()
             if self._ignore_trace: return
             self._ignore_trace = True
             pulito = re.sub(r'[^\d]', '', current_value)
             formattato = formatta_importo_pulito(pulito)
             if formattato != current_value:
                 importo_var.set(formattato)
             self._ignore_trace = False
        def formatta_importo_pulito(importo_str):
             if not importo_str.isdigit(): return "0,00"
             padded_str = importo_str.zfill(2)
             interi = padded_str[:-2]
             decimali = padded_str[-2:]
             interi_formattati = f"{int(interi):,}".replace(",", ".")
             return f"{interi_formattati},{decimali}"
        def parse_importo_pulito(importo_str_visibile):
             if not importo_str_visibile: return None
             s = importo_str_visibile.replace(' ‚Ç¨', '').replace('.', '').replace(',', '.')
             try: return float(s.strip())
             except ValueError: return None
        def open_pdf(event, treeview):
             try:
                 selected_item = treeview.selection()[0]
                 values = treeview.item(selected_item, 'values')
                 file_name = values[5] 
                 if not file_name or file_name == "N/D":
                     self.show_custom_warning("Attenzione", "Il nome del file non √® disponibile per l'apertura.")
                     return
                 file_path = os.path.join(DOC_DIR, file_name)
                 if os.path.exists(file_path):
                     webbrowser.open(file_path)
                 else:
                     self.show_custom_warning("File Non Trovato", f"Il file:\n{file_name}\nnon esiste pi√π nel percorso:\n{DOC_DIR}")
                     if self.show_custom_askyesno("Registro Corrotto", "Vuoi rimuovere questa voce dal registro?"):
                         self.show_custom_info("Rimuovi Manualmente", "Rimuovi la voce con il tasto 'Cancella Documento' per pulire il registro.")
             except IndexError:
                 self.show_custom_warning("Selezione", "Seleziona un documento da aprire con doppio click.")
             except Exception as e:
                 self.show_custom_warning("Errore Apertura", f"Impossibile aprire il file: {e}")
        def get_document_components(filename, registry):
             DEFAULT_CATEGORY = "Generica"
             if filename in registry:
                 doc_data = registry[filename]
                 categoria = doc_data.get('categoria_esatta', DEFAULT_CATEGORY)
                 descrizione = doc_data.get('descrizione_esatta', 'N/D')
                 tipo = doc_data.get('tipo_esatto', 'N/D')
                 data_ggmmaaaa = doc_data.get('data_raw', '00000000')
                 try: data_formattata = datetime.strptime(data_ggmmaaaa, "%d%m%Y").strftime("%d-%m-%Y")
                 except ValueError: data_formattata = "N/D"
                 importo_raw = str(doc_data.get('importo_raw', 0))
                 importo_formattato = formatta_importo_pulito(importo_raw)
                 return (data_formattata, categoria, descrizione, importo_formattato, tipo, data_ggmmaaaa, importo_raw, True)
             return "N/D", "N/D", filename, "N/D", "N/D", "00000000", "0", False
        def treeview_sort_column(treeview, col, reverse):
             l = [(treeview.set(k, col), k) for k in treeview.get_children('')]
             if col == 'importo':
                 def sort_key_importo(item):
                     s = item[0].replace(' ‚Ç¨', '').replace('.', '').replace(',', '.')
                     try: return float(s.strip())
                     except ValueError: return -999999999
                 l.sort(key=sort_key_importo, reverse=reverse)
             elif col == 'data':
                 def sort_key_date(item):
                     date_str = item[0]
                     try: return datetime.strptime(date_str, "%d-%m-%Y")
                     except ValueError: return datetime.min
                 l.sort(key=sort_key_date, reverse=reverse)
             else:
                 l.sort(reverse=reverse)
             for index, (val, k) in enumerate(l):
                 treeview.move(k, '', index)
             treeview.heading(col, command=lambda c=col: treeview_sort_column(treeview, col, not reverse))
        def load_documents(treeview, filtri_attuali=None):
                for item in treeview.get_children(): treeview.delete(item)
                crea_directory_documenti()
                registry = load_document_registry()
                documenti_su_disco = [f for f in os.listdir(DOC_DIR) if f.endswith('.pdf')]
                items_caricati = []
                totale_filtrato = 0.0
                filtri_attuali = filtri_attuali or {}
                parola_chiave_lower = filtri_attuali.get('parola_chiave', '').lower().strip()
                data_da_obj = None; data_a_obj = None
                if filtri_attuali:
                        try: 
                                if filtri_attuali.get('data_da'): data_da_obj = datetime.strptime(filtri_attuali['data_da'], "%d-%m-%Y").date()
                                if filtri_attuali.get('data_a'): data_a_obj = datetime.strptime(filtri_attuali['data_a'], "%d-%m-%Y").date()
                        except ValueError: pass
                importo_da_float = parse_importo_pulito(filtri_attuali.get('importo_da', ''))
                importo_a_float = parse_importo_pulito(filtri_attuali.get('importo_a', ''))
                def sort_key(doc_file):
                        data_raw = registry.get(doc_file, {}).get('data_raw')
                        if data_raw and len(data_raw) == 8 and data_raw.isdigit():
                                giorno = data_raw[0:2]
                                mese = data_raw[2:4]
                                anno = data_raw[4:8]
                                return anno + mese + giorno
                        return '00000000'
                for doc_file in sorted(documenti_su_disco, key=sort_key, reverse=True):
                        data, categoria, descrizione, importo_formattato, tipo, data_raw, importo_raw, is_new_logic = get_document_components(doc_file, registry)
                        importo_visualizzato = f"{importo_formattato} ‚Ç¨" if importo_formattato != "N/D" else "N/D"
                        search_string = f"{data} {categoria} {descrizione} {tipo} {importo_formattato} {doc_file}".lower()
                        match = True
                        if parola_chiave_lower and parola_chiave_lower not in search_string: match = False
                        if filtri_attuali and match:
                                filtro_categoria_attuale = filtri_attuali.get("categoria")
                                if filtro_categoria_attuale and filtro_categoria_attuale != "‚Äî":
                                        if filtro_categoria_attuale != categoria: 
                                                match = False
                                if filtri_attuali.get("descrizione") and filtri_attuali["descrizione"].lower() not in descrizione.lower(): match = False
                                if filtri_attuali.get("tipo") and filtri_attuali["tipo"] != "‚Äî" and filtri_attuali["tipo"] != tipo: match = False
                                if data_raw != "00000000":
                                        try:
                                                doc_date_obj = datetime.strptime(data_raw, "%d%m%Y").date()
                                                if data_da_obj and doc_date_obj < data_da_obj: match = False
                                                if data_a_obj and doc_date_obj > data_a_obj: match = False
                                        except ValueError: pass 
                                if importo_raw.isdigit():
                                        doc_importo_float = float(importo_raw) / 100 
                                        if importo_da_float is not None and doc_importo_float < importo_da_float: match = False
                                        if importo_a_float is not None and doc_importo_float > importo_a_float: match = False
                        if match:
                                if tipo == "Uscita":
                                        tag_colore = 'uscita_tag'
                                elif tipo == "Entrata":
                                        tag_colore = 'entrata_tag'
                                else:
                                        tag_colore = ''
                                treeview.insert(
                                        "", 
                                        "end", 
                                        values=(data, categoria, descrizione, importo_visualizzato, tipo, doc_file),
                                        tags=(tag_colore,)
                                )
                                items_caricati.append(doc_file)
                                if importo_formattato != "N/D":
                                        importo_float_str = importo_formattato.replace('.', '').replace(',', '.')
                                        try: totale_filtrato += float(importo_float_str)
                                        except ValueError: pass
                num_risultati = len(items_caricati)
                lbl_conteggio_doc.config(text=f"Documenti visualizzati: {num_risultati}")
                totale_in_centesimi = int(round(totale_filtrato * 100))
                totale_formattato = formatta_importo_pulito(str(totale_in_centesimi))
                lbl_totali.config(text=f"Totale Filtrato: {totale_formattato} ‚Ç¨", fg="blue")
                if num_risultati == 0: 
                        lbl_risultati.config(text="‚ùå Nessuna corrispondenza per i filtri attuali.", fg="red")
                elif parola_chiave_lower or filtri_attuali: 
                        lbl_risultati.config(text=f"üîç Trovati {num_risultati} documenti filtrati.", fg="black")
                else: 
                        lbl_risultati.config(text=f"üìã Totale documenti archiviati: {num_risultati}.", fg="gray")
                if num_risultati == 0: lbl_risultati.config(text="‚ùå Nessuna corrispondenza per i filtri attuali.", fg="red")
                elif parola_chiave_lower or filtri_attuali: lbl_risultati.config(text=f"üîç Trovati {num_risultati} documenti.", fg="black")
                else: lbl_risultati.config(text=f"üìã Totale documenti archiviati: {num_risultati}.", fg="gray")
                totale_in_centesimi = int(round(totale_filtrato * 100))
                totale_formattato = formatta_importo_pulito(str(totale_in_centesimi))
                lbl_totali.config(text=f"Totale Filtrato: {totale_formattato} ‚Ç¨", fg="blue")
        def inserisci_documento_e_copia():
                data_str = data_var.get()
                categoria_esatta = combo_categoria.get()
                descrizione_esatta = entry_descrizione.get().strip()
                tipo_esatto = combo_tipo.get()
                importo_visualizzato_per_file = importo_var.get()
                try:
                        data_obj = datetime.strptime(data_str, "%d-%m-%Y")
                        data_ggmmaaaa = data_obj.strftime("%d%m%Y")
                except ValueError:
                        self.show_custom_warning("Attenzione", "Formato Data non valido. Usa DD-MM-YYYY.")
                        return
                try:
                        importo_str = importo_visualizzato_per_file.replace(",", ".").strip()
                        importo_decimal = Decimal(importo_str)
                        importo_pulito_per_file_raw = str(int(importo_decimal * 100))
                except (InvalidOperation, ValueError):
                        self.show_custom_warning("Attenzione", "Importo non valido. Inserisci un numero (es. 1, 1.25, 12.50).")
                        return
                if int(importo_pulito_per_file_raw) < 100:
                        self.show_custom_warning("Attenzione", "Importi inferiori a 1,00 ‚Ç¨ non sono ammessi.")
                        return
                if int(importo_pulito_per_file_raw) > 100000000:
                        self.show_custom_warning("Attenzione", "Importi superiori a 1.000.000 ‚Ç¨ non sono ammessi.")
                        return
                if not descrizione_esatta or descrizione_esatta.isdigit() or len(descrizione_esatta) < 3:
                        descrizione_esatta = f"{descrizione_esatta or 'Senza_Descrizione'}"
                campi_obbligatori = {
                        "Data": data_ggmmaaaa,
                        "Categoria": categoria_esatta,
                        "Descrizione": descrizione_esatta,
                        "Importo": importo_pulito_per_file_raw,
                        "Tipo": tipo_esatto
                }
                if any(not v for v in campi_obbligatori.values()):
                        self.show_custom_warning("Attenzione", "Tutti i campi sono obbligatori per l'archiviazione.")
                        return
                san_cat = sanitizza_stringa(categoria_esatta, max_len=20)
                san_desc = sanitizza_stringa(descrizione_esatta, max_len=30)
                san_tipo = sanitizza_stringa(tipo_esatto, max_len=10)
                file_name_format = f"{data_ggmmaaaa}_{san_desc}_{san_tipo}_{san_cat}_{importo_pulito_per_file_raw}.pdf"
                initial_pdf_path = filedialog.askopenfilename(
                        title="Seleziona il file PDF da archiviare",
                        defaultextension=".pdf",
                        filetypes=[("Documenti PDF", "*.pdf *.PDF"),("Tutti i file", "*.*")]
                )
                if not initial_pdf_path:
                        self.show_custom_info("Annullato", "Nessun file PDF selezionato. Archiviazione annullata.")
                        return
                final_path = os.path.join(DOC_DIR, file_name_format)
                messaggio_preliminare = ""
                try:
                        if os.path.exists(final_path):
                                messaggio_preliminare = f"ATTENZIONE: Il file '{file_name_format}' √® stato sovrascritto!\n\n"
                        shutil.copy2(initial_pdf_path, final_path)
                        registry = load_document_registry()
                        registry[file_name_format] = {
                                "data_raw": data_ggmmaaaa,
                                "categoria_esatta": categoria_esatta,
                                "descrizione_esatta": descrizione_esatta,
                                "importo_raw": int(importo_pulito_per_file_raw),
                                "tipo_esatto": tipo_esatto,
                                "timestamp": datetime.now().isoformat()
                        }
                        save_document_registry(registry)
                        importo_formattato = formatta_importo_pulito(importo_pulito_per_file_raw)
                        importo_visualizzato = f"{importo_formattato} ‚Ç¨"
                        tag_colore = 'entrata_tag' if tipo_esatto == "Entrata" else ('uscita_tag' if tipo_esatto == "Uscita" else '')
                        new_item = tree.insert(
                                "",
                                "end",
                                values=(data_str, categoria_esatta, descrizione_esatta, importo_visualizzato, tipo_esatto, file_name_format),
                                tags=(tag_colore,)
                        )
                        try:
                                treeview_sort_column(tree, 'data', reverse=True)
                        except Exception:
                                pass
                        try:
                                tree.selection_set(new_item)
                                tree.focus(new_item)
                                tree.see(new_item)
                        except Exception:
                                pass
                        messaggio_finale = f"{messaggio_preliminare}Documento archiviato come:\n{file_name_format}"
                        self.show_custom_info("Successo", messaggio_finale)
                        pdf_window.after(100, filtra_documenti)
                        def ripristina_campi():
                                data_var.set(datetime.now().strftime("%d-%m-%Y"))
                                entry_descrizione.delete(0, tk.END)
                                importo_var.set("")
                                combo_categoria.set("Generica")
                                pdf_window.update_idletasks()
                        pdf_window.after(50, ripristina_campi)
                except Exception as e:
                        self.show_custom_warning("Errore Archiviazione", f"Errore critico durante la copia/registro: {e}")
        def cancella_documento():
            def esegui_refresh_ritardato():
                load_documents(tree, self.filtri_avanzati) 
                pdf_window.update_idletasks()
            selected_items = tree.selection()
            if not selected_items:
                self.show_custom_warning("Selezione", "Seleziona una o pi√π voci da cancellare.")
                return
            try:
                num_selezionati = len(selected_items)
                if num_selezionati == 1:
                    item_values = tree.item(selected_items[0], 'values')
                    descrizione_visualizzata = item_values[2]
                    categoria_visualizzata = item_values[1]
                    messaggio_cancellazione = (
                        "Eliminare questo documento?\n\n"
                        f"Descrizione: {descrizione_visualizzata}\n"
                        f"Categoria: {categoria_visualizzata}\n"
                        "Questa azione √® permanente!"
                    )
                else:
                    messaggio_cancellazione = (
                        f"Eliminare {num_selezionati} documenti selezionati?\n\n"
                        "ATTENZIONE: Azione permanente e irrecuperabile!"
                    )
                if self.show_custom_askyesno("Conferma Cancellazione", messaggio_cancellazione):
                    registry = load_document_registry()
                    count_cancellati = 0
                    for selected_item in selected_items:
                        data_visualizzata, categoria_visualizzata, descrizione_visualizzata, importo_visualizzato, tipo_visualizzato, file_name = tree.item(selected_item, 'values')
                        file_path = os.path.join(DOC_DIR, file_name)
                        if os.path.exists(file_path):
                            os.remove(file_path)
                        if file_name in registry:
                            del registry[file_name]
                            count_cancellati += 1
                        tree.delete(selected_item)
                    save_document_registry(registry)
                    self.show_custom_info("Cancellato", f"{count_cancellati} documenti eliminati con successo.")
                    pdf_window.after(100, filtra_documenti)
                    pdf_window.after(10, esegui_refresh_ritardato) 
            except IndexError:
                pass
            except Exception as e:
                self.show_custom_warning("Errore", f"Impossibile completare la cancellazione. Errore: {e}")
        def esporta_documenti_selezionati():
            selected_items = tree.selection()
            if not selected_items:
                self.show_custom_warning("Attenzione", "Seleziona almeno un documento da esportare.")
                return
            target_dir = filedialog.askdirectory(
                initialdir=EXPORT_FILES,
                title="Seleziona la cartella di destinazione per l'esportazione",
            )
            if not target_dir:
                return
            esportati_count = 0
            errori_count = 0
            for item_id in selected_items:
                try:
                    values = tree.item(item_id, 'values')
                    data = values[0]       
                    categoria = values[1]  
                    descrizione = values[2] 
                    original_file_name = values[5]
                    if not original_file_name or original_file_name == "N/D":
                        errori_count += 1
                        continue
                    original_path = os.path.join(DOC_DIR, original_file_name)
                    if not os.path.exists(original_path):
                        self.show_custom_warning("File Mancante", f"Il file sorgente '{original_file_name}' non √® stato trovato.")
                        errori_count += 1
                        continue
                    categoria_safe = categoria.replace(" ", "_").replace("/", "_")
                    descrizione_safe = descrizione.replace(" ", "_").replace("/", "_").replace(".", "")
                    data_safe = data.replace("-", "_")
                    if descrizione_safe and descrizione_safe != "N/D":
                         new_file_name = f"{categoria_safe}_{descrizione_safe}_{data_safe}.pdf"
                    else:
                         new_file_name = f"{categoria_safe}_{data_safe}.pdf"
                    target_path = os.path.join(target_dir, new_file_name)
                    shutil.copy2(original_path, target_path)
                    esportati_count += 1
                except Exception as e:
                    print(f"Errore durante l'esportazione del file '{item_id}': {e}") 
                    errori_count += 1
                    continue
            if esportati_count > 0:
                messaggio = f"Esportazione completata! Sono stati copiati {esportati_count} documenti nella cartella:\n{target_dir}"
                if errori_count > 0:
                    messaggio += f"\nAttenzione: {errori_count} documenti non sono stati esportati a causa di errori."
                self.show_custom_info("Esportazione Multipla Riuscita", messaggio)
                try:
                    os.startfile(target_dir)
                except Exception:
                    pass
            elif errori_count > 0:
                 self.show_custom_warning("Esportazione Fallita", f"Nessun documento √® stato esportato. {errori_count} errori riscontrati.")
        def apri_filtri_avanzati():
            root = pdf_window
            filtro_win = tk.Toplevel(root, bg=self.COLOR_TOPLEVEL)
            filtro_win.title("‚öôÔ∏è Filtri Avanzati")
            larghezza_finestra = 500
            altezza_finestra = 380
            x = root.winfo_rootx() + (root.winfo_width() // 2) - (larghezza_finestra // 2)
            y = root.winfo_rooty() + (root.winfo_height() // 2) - (altezza_finestra // 2)
            filtro_win.geometry(f"{larghezza_finestra}x{altezza_finestra}+{x}+{y}")
            filtro_win.protocol("WM_DELETE_WINDOW", lambda: (
                (self.popup_calendario.destroy(), setattr(self, 'popup_calendario', None)) 
                if hasattr(self, 'popup_calendario') and self.popup_calendario and self.popup_calendario.winfo_exists() 
                else None,
                filtro_win.destroy()
            ))
            filtro_win.bind("<Escape>", lambda e: filtro_win.destroy())
            filtro_win.transient(root)
            descrizione_initial = self.filtri_avanzati.get("descrizione", campo_input.get().strip() if 'campo_input' in locals() else '')
            descrizione_var = tk.StringVar(value=descrizione_initial)
            categoria_var = tk.StringVar(value=self.filtri_avanzati.get("categoria", "‚Äî"))
            tipo_var = tk.StringVar(value=self.filtri_avanzati.get("tipo", "‚Äî"))
            data_da_var = tk.StringVar(value=self.filtri_avanzati.get("data_da", ""))
            data_a_var = tk.StringVar(value=self.filtri_avanzati.get("data_a", ""))
            importo_da_var = tk.StringVar(value=self.filtri_avanzati.get("importo_da", ""))
            importo_a_var = tk.StringVar(value=self.filtri_avanzati.get("importo_a", ""))
            valori_categoria = ["‚Äî"] + (getattr(self, 'categorie', []))
            valori_tipo = ["‚Äî", "Entrata", "Uscita"]
            def applica_filtri():
                nuovi_filtri = {}; 
                if descrizione_var.get().strip():
                    nuovi_filtri["descrizione"] = descrizione_var.get().strip()
                    if 'campo_input' in locals(): campo_input.delete(0, tk.END) 
                if categoria_var.get() and categoria_var.get() != "‚Äî": nuovi_filtri["categoria"] = categoria_var.get()
                if tipo_var.get() and tipo_var.get() != "‚Äî": nuovi_filtri["tipo"] = tipo_var.get()
                try:
                    data_da_str = data_da_var.get().strip()
                    data_a_str = data_a_var.get().strip()
                    if data_da_str: 
                        datetime.strptime(data_da_str, "%d-%m-%Y")
                        nuovi_filtri["data_da"] = data_da_str
                    if data_a_str: 
                        datetime.strptime(data_a_str, "%d-%m-%Y")
                        nuovi_filtri["data_a"] = data_a_str
                except ValueError: 
                    self.show_custom_warning("Errore", "Formato Data non valido (DD-MM-YYYY).")
                    return 
                if parse_importo_pulito(importo_da_var.get()) is not None: nuovi_filtri["importo_da"] = importo_da_var.get()
                if parse_importo_pulito(importo_a_var.get()) is not None: nuovi_filtri["importo_a"] = importo_a_var.get()
                self.filtri_avanzati = nuovi_filtri
                filtro_win.destroy()
                load_documents(tree, self.filtri_avanzati) 
                self.show_custom_info("Filtri Applicati", "Filtri avanzati applicati con successo.")
            def chiudi_filtri(): filtro_win.destroy()
            frame_filtri = ttk.Frame(filtro_win, padding="10"); frame_filtri.pack(fill='both', expand=True)
            ttk.Label(frame_filtri, text="Descrizione (nel nome file):").grid(row=0, column=0, padx=5, pady=5, sticky="w")
            ttk.Entry(frame_filtri, textvariable=descrizione_var, width=30).grid(row=0, column=1, columnspan=2, padx=5, pady=5, sticky="ew")
            ttk.Label(frame_filtri, text="Categoria Esatta:").grid(row=1, column=0, padx=5, pady=5, sticky="w")
            combo_cat_filtro = ttk.Combobox(frame_filtri, textvariable=categoria_var, values=valori_categoria, style="Border.TCombobox", state='readonly', width=27)
            combo_cat_filtro.grid(row=1, column=1, columnspan=2, padx=5, pady=5, sticky="ew")
            ttk.Label(frame_filtri, text="Tipo (Entrata/Uscita):").grid(row=2, column=0, padx=5, pady=5, sticky="w")
            ttk.Combobox(frame_filtri, textvariable=tipo_var, values=valori_tipo, style="Border.TCombobox", state='readonly', width=27).grid(row=2, column=1, columnspan=2, padx=5, pady=5, sticky="ew")
            ttk.Separator(frame_filtri, orient='horizontal').grid(row=3, column=0, columnspan=3, sticky='ew', pady=10)
            ttk.Label(frame_filtri, text="Intervallo Data DA:").grid(row=4, column=0, padx=5, pady=5, sticky="w")
            entry_data_da = ttk.Entry(frame_filtri, textvariable=data_da_var, width=12)
            entry_data_da.grid(row=4, column=1, padx=(0, 2), pady=5, sticky="ew")
            ttk.Button(frame_filtri, text="üóìÔ∏è", style='Giallo.TButton', 
                       command=lambda: self.mostra_calendario_popup(entry_data_da, data_da_var), width=3).grid(row=4, column=2, padx=(0, 0), pady=5, sticky="w")
            ttk.Label(frame_filtri, text="Intervallo Data A:").grid(row=5, column=0, padx=5, pady=5, sticky="w")
            entry_data_a = ttk.Entry(frame_filtri, textvariable=data_a_var, width=12)
            entry_data_a.grid(row=5, column=1, padx=(0, 2), pady=5, sticky="ew")
            ttk.Button(frame_filtri, text="üóìÔ∏è", style='Giallo.TButton', 
                       command=lambda: self.mostra_calendario_popup(entry_data_a, data_a_var), width=3).grid(row=5, column=2, padx=(0, 0), pady=5, sticky="w")
            ttk.Label(frame_filtri, text="Importo DA (‚Ç¨):").grid(row=6, column=0, padx=5, pady=5, sticky="w")
            entry_importo_da = ttk.Entry(frame_filtri, textvariable=importo_da_var, width=15); entry_importo_da.grid(row=6, column=1, padx=5, pady=5, sticky="ew")
            ttk.Label(frame_filtri, text="Importo A (‚Ç¨):").grid(row=7, column=0, padx=5, pady=5, sticky="w")
            entry_importo_a = ttk.Entry(frame_filtri, textvariable=importo_a_var, width=15); entry_importo_a.grid(row=7, column=1, padx=5, pady=5, sticky="ew")
            frame_btns = tk.Frame(filtro_win, bg=self.COLOR_TOPLEVEL); frame_btns.pack(pady=10)
            ttk.Button(frame_btns, text="Applica Filtri", style='Blu.TButton', command=applica_filtri).pack(side='left', padx=10)
            ttk.Button(frame_btns, text="Annulla", style='Giallo.TButton', command=chiudi_filtri).pack(side='left', padx=10)
            filtro_win.wait_window()
        def stampa_documenti_selezionati():
            selected_items = tree.selection()
            if not selected_items:
                self.show_custom_warning("Attenzione", "Seleziona almeno un documento da stampare.")
                return
            stampati_count = 0
            errori_count = 0
            current_os = platform.system()
            for item_id in selected_items:
                try:
                    values = tree.item(item_id, 'values')
                    original_file_name = values[5] 
                    if not original_file_name or original_file_name == "N/D":
                        errori_count += 1
                        continue
                    original_path = os.path.join(DOC_DIR, original_file_name) 
                    if not os.path.exists(original_path):
                        self.show_custom_warning("File Mancante", f"Il file sorgente '{original_file_name}' non √® stato trovato.")
                        errori_count += 1
                        continue
                    if current_os == "Windows":
                        os.startfile(original_path, 'print')
                    elif current_os in ["Linux", "Darwin"]:
                        subprocess.Popen(['lp', original_path])
                    else:
                        self.show_custom_warning("OS Non Supportato", f"La stampa diretta di documenti non √® supportata su {current_os}.")
                        errori_count += 1
                        continue
                    stampati_count += 1
                except Exception as e:
                    print(f"Errore durante la preparazione alla stampa del file '{original_file_name}': {e}")
                    self.show_custom_warning("Errore Stampa", f"Impossibile avviare la stampa per '{original_file_name}'. Dettagli: {e}")
                    errori_count += 1
                    continue
            if stampati_count > 0:
                messaggio = f"Comando di stampa inviato per {stampati_count} documento/i."
                if errori_count > 0:
                    messaggio += f"\nAttenzione: {errori_count} documenti non sono stati elaborati per la stampa."
                self.show_custom_info("Stampa Avviata", messaggio)
            elif errori_count > 0:
                self.show_custom_warning("Stampa Fallita", f"Nessun documento √® stato stampato. {errori_count} errori riscontrati.")
        def chiudi_finestra():
             if hasattr(self, 'popup_calendario') and self.popup_calendario and self.popup_calendario.winfo_exists():
                 self.popup_calendario.destroy()
             self.filtri_avanzati = {}
             self.pdf_window.destroy()
        def filtra_documenti(event=None):
             filtri = self.filtri_avanzati.copy(); filtri['parola_chiave'] = campo_input.get().strip()
             load_documents(tree, filtri)
        def resetta_campo():
             campo_input.delete(0, tk.END); self.filtri_avanzati = {}
             load_documents(tree, {})
        crea_directory_documenti()
        if hasattr(self, 'pdf_window') and self.pdf_window.winfo_exists(): self.pdf_window.lift(); return
        pdf_window = tk.Toplevel(self, bg=self.COLOR_TOPLEVEL)
        barra_menu_popup = tk.Menu(pdf_window, bg=BACKGROUND_DARK, fg=FOREGROUND_LIGHT, activebackground=ACCENT_COLOR, activeforeground='black') 
        barra_menu_popup.config(bg=BACKGROUND_DARK, fg=FOREGROUND_LIGHT)
        pdf_window.config(menu=barra_menu_popup)
        menu_archivio = tk.Menu(barra_menu_popup, tearoff=0,bg=MENU_BG, fg=FOREGROUND_LIGHT, activebackground=ACCENT_COLOR, activeforeground='black')
        barra_menu_popup.add_cascade(label="üìÇ Archivio", menu=menu_archivio)
        menu_archivio.add_command(label="‚ùå Esporta documenti", command=self.esegui_export_documenti_pdf)
        menu_archivio.add_command(label="‚ùå Importa documenti", command=self.esegui_import_documenti_pdf)
        menu_archivio.add_separator()
        menu_archivio.add_command(label="‚ùå Chiudi (ESC)", command=chiudi_finestra)
        self.pdf_window = pdf_window
        pdf_window.title("üìÇ Archivio Documenti PDF")
        pdf_window.withdraw()
        larghezza_finestra = 1200
        altezza_finestra = 600
        larghezza_schermo = self.winfo_screenwidth()
        altezza_schermo = self.winfo_screenheight()
        x = (larghezza_schermo // 2) - (larghezza_finestra // 2)
        y = (altezza_schermo // 2) - (altezza_finestra // 2)
        pdf_window.geometry(f"{larghezza_finestra}x{altezza_finestra}+{x}+{y}")
        pdf_window.minsize(width=800, height=500)
        pdf_window.transient(self)
        pdf_window.deiconify()
        pdf_window.protocol("WM_DELETE_WINDOW", chiudi_finestra)
        pdf_window.bind('<Escape>', lambda e: chiudi_finestra())
        frame_input = ttk.Frame(pdf_window, padding="10") 
        frame_input.pack(fill='x', padx=10, pady=(10, 5))
        data_var = tk.StringVar(value=datetime.now().strftime("%d-%m-%Y")) 
        importo_var = tk.StringVar()
        importo_var.trace_add("write", trace_importo)
        ttk.Label(frame_input, text="Data:").grid(row=0, column=0, padx=5, pady=5, sticky="w")
        sub_frame_data = ttk.Frame(frame_input)
        sub_frame_data.grid(row=0, column=1, padx=0, pady=5, sticky="w")
        entry_data = ttk.Entry(sub_frame_data, textvariable=data_var, width=12)
        entry_data.pack(side="left", padx=0)
        ttk.Button(sub_frame_data, text="üóìÔ∏è", style="Giallo.TButton", command=lambda: self.mostra_calendario_popup(entry_data, data_var), width=2).pack(side="left", padx=0)
        ttk.Label(frame_input, text="Categoria:").grid(row=0, column=3, padx=5, pady=5, sticky="w")
        combo_categoria = ttk.Combobox(frame_input, values=(getattr(self, 'categorie', categorie_vuote)), width=35, style="Border.TCombobox", state='readonly') 
        combo_categoria.set(categoria_iniziale if categoria_iniziale and categoria_iniziale.strip() not in ("", "Generica", "‚Äî") else "Generica") 
        combo_categoria.grid(row=0, column=4, padx=5, pady=5, sticky="w")
        ttk.Label(frame_input, text="Descrizione:").grid(row=0, column=5, padx=5, pady=5, sticky="w")
        entry_descrizione = ttk.Entry(frame_input, width=35)
        entry_descrizione.grid(row=0, column=6, padx=5, pady=5, sticky="w")
        ttk.Label(frame_input, text="Importo:").grid(row=1, column=0, padx=5, pady=5, sticky="w")
        entry_importo = ttk.Entry(frame_input, width=15, textvariable=importo_var, validate='key', validatecommand=(vcmd_importo, '%P')) 
        entry_importo.grid(row=1, column=1, padx=5, pady=5, sticky="w")
        tipi_movimento = ["Entrata", "Uscita"] 
        ttk.Label(frame_input, text="Tipo:").grid(row=1, column=3, padx=5, pady=5, sticky="w")
        combo_tipo = ttk.Combobox(frame_input, values=tipi_movimento, width=15, style="Border.TCombobox", state='readonly')
        combo_tipo.set("Uscita")
        combo_tipo.grid(row=1, column=4, padx=5, pady=5, sticky="w")
        frame_ricerca = ttk.Frame(pdf_window, padding="10 0 10 5") 
        frame_ricerca.pack(fill='x', padx=10)
        lbl_cerca = ttk.Label(frame_ricerca, text="Ricerca Documenti:", font=('Arial', 10, 'bold'))
        lbl_cerca.pack(side="left", padx=(0, 5))
        campo_input = ttk.Entry(frame_ricerca, width=60)
        campo_input.pack(side="left", padx=(0, 5), fill='x', expand=True)
        campo_input.bind('<KeyRelease>', filtra_documenti)
        lbl_conteggio_doc = ttk.Label(frame_ricerca, text="Documenti visualizzati: 0", foreground="#0066cc", font=('Arial', 10, 'bold'))
        lbl_conteggio_doc.pack(side="left", padx=(10, 5))
        lbl_risultati = ttk.Label(frame_ricerca, text="", foreground="gray")
        lbl_risultati.pack(side="left")
        lbl_totali = ttk.Label(frame_ricerca, text="")
        lbl_totali.pack(side="left", padx=10)
        ttk.Button(frame_ricerca, text="?", command=lambda: self.mostra_help_pdf(), width=2, style="Yellow.TButton").pack(side="right", padx=(1, 5))
        ttk.Button(frame_ricerca, text="‚öôÔ∏è Filtri Avanzati", command=apri_filtri_avanzati, style="Blu.TButton").pack(side="right", padx=5)
        ttk.Button(frame_ricerca, text="‚Ü∫ ", command=resetta_campo, style="Yellow.TButton").pack(side="right")
        frame_treeview_container = ttk.Frame(pdf_window)
        frame_treeview_container.pack(fill='both', expand=True, padx=10, pady=5)
        cols = ("data", "categoria", "descrizione", "importo", "tipo", "nome_completo")
        vsb = ttk.Scrollbar(frame_treeview_container, orient="vertical")
        tree = ttk.Treeview(frame_treeview_container, columns=cols, show='headings', selectmode='extended', yscrollcommand=vsb.set)
        vsb.config(command=tree.yview)
        vsb.pack(side='right', fill='y') 
        tree.pack(side='left', fill='both', expand=True) 
        col_widths = {'data': 100, 'categoria': 150, 'descrizione': 300, 'importo': 100, 'tipo': 70, 'nome_completo': 0}
        col_anchors = {'data': 'center', 'categoria': 'w', 'descrizione': 'w', 'importo': 'e', 'tipo': 'center', 'nome_completo': 'w'}
        for col in cols: 
            tree.heading(col, text=col.capitalize(), command=lambda c=col: treeview_sort_column(tree, c, False))
            tree.column(col, width=col_widths.get(col, 100), anchor=col_anchors.get(col, 'w'))
        tree.column("nome_completo", width=0, stretch=tk.NO) 
        tree.tag_configure('uscita_tag', foreground='red')
        tree.tag_configure('entrata_tag', foreground='green') 
        tree.bind('<Double-1>', lambda e: open_pdf(e, tree))
        tree.bind('<Delete>', lambda e: cancella_documento())
        tree.bind('<Button-3>', lambda event: esporta_documenti_selezionati())
        frame_bottom_buttons = ttk.Frame(pdf_window, padding="10") 
        frame_bottom_buttons.pack(fill='x', padx=10, pady=(5, 10))
        ttk.Button(frame_bottom_buttons, text="üì• Archivia PDF", style='Verde.TButton', command=inserisci_documento_e_copia).pack(side='left', padx=10)
        ttk.Button(frame_bottom_buttons, text="üóëÔ∏è Cancella Documenti", style='Rosso.TButton', command=cancella_documento).pack(side='left', padx=10)
        ttk.Button(frame_bottom_buttons, text="üñ®Ô∏è Stampa Selezionati", style='Blu.TButton', command=stampa_documenti_selezionati).pack(side='left', padx=10)
        ttk.Button(frame_bottom_buttons, text="‚ùå Chiudi", command=chiudi_finestra, style='Giallo.TButton').pack(side='right', padx=10)
        filtra_documenti() 
        self.wait_window(pdf_window)
    def mostra_help_pdf(self):
        if hasattr(self, '_filter_help_popup') and self._filter_help_popup.winfo_exists():
            self._filter_help_popup.destroy()
        popup_aiuto = tk.Toplevel(self, bg=self.COLOR_TOPLEVEL)
        popup_aiuto.title("Guida: Archivio Documenti PDF")
        popup_width = 950
        popup_height = 500
        screen_width = self.winfo_screenwidth()
        screen_height = self.winfo_screenheight()
        center_x = int((screen_width / 2) - (popup_width / 2))
        center_y = int((screen_height / 2) - (popup_height / 2))
        popup_aiuto.geometry(f"{popup_width}x{popup_height}+{center_x}+{center_y}")
        popup_aiuto.resizable(False, False)
        popup_aiuto.transient(self)
        popup_aiuto.grab_set() 
        self._filter_help_popup = popup_aiuto
        main_frame = ttk.Frame(popup_aiuto, padding="15")
        main_frame.pack(fill="both", expand=True)
        content_frame = tk.Frame(main_frame)
        content_frame.pack(fill="both", expand=True)
        def ottieni_contenuto_testo():
            testo = ""

            testo += "=================================================\n"
            testo += "          HELP: ARCHIVIO DOCUMENTI PDF\n"
            testo += "=================================================\n"

            testo += "\nArchiviazione Nuovi Documenti:\n"
            testo += "---------------------------------------\n"
            testo += "‚Ä¢ Campi di Archiviazione: I campi nel pannello superiore sono obbligatori e vengono usati per creare il nome univoco del file e per registrare i metadati nel registro locale.\n\n"
            testo += "‚Ä¢ Archivia PDF (Bottone Verde): Apre il selettore file. Il PDF selezionato viene copiato nella directory locale (db/doc). Attenzione: se il nome file generato esiste gi√†, il file viene sovrascritto.\n"

            testo += "\nNavigazione e Interazione (Treeview Documenti):\n"
            testo += "---------------------------------------------------------\n"
            testo += "‚Ä¢ Apertura Documento (Doppio Clic): Doppio clic su una riga per aprire il file PDF associato.\n"
            testo += "‚Ä¢ Ordinamento: Clicca sull'intestazione di qualsiasi colonna (Data, Importo, Categoria, ecc.) per ordinare i dati.\n"
            testo += "‚Ä¢ Esportazione Selezionata (Tasto Destro): Seleziona righe, clicca Tasto Destro per esportare i file in una cartella esterna.\n"
            testo += "  > Utilizza CTRL + Click per selezionare righe sparse, o SHIFT + Click per selezionare un intervallo continuo.\n"
            testo += "‚Ä¢ Scroll e Navigazione: Utilizza la Rotella del Mouse per scorrere verticalmente in qualsiasi Treeview o area.\n"
            testo += "‚Ä¢ Cancellazione (Canc/Bottone): Seleziona una riga e premi CANC (o usa il bottone 'Cancella Documento') per eliminare file e registro.\n"

            testo += "\nRicerca e Filtraggio:\n"
            testo += "----------------------------\n"

            testo += "‚Ä¢ Ricerca Veloce: Digita una parola chiave; la ricerca √® effettuata su nome file, data, categoria, descrizione e tipo.\n"
            testo += "‚Ä¢ Filtri Avanzati (Bottone Filtro): Filtra documenti per Intervallo di Data, Intervallo di Importo, Categoria Esatta e Tipo (Entrata/Uscita).\n"
 
            testo += "\nOperazioni di Sistema (Menu Archivio):\n"
            testo += "--------------------------------------------------\n"

            testo += "‚Ä¢ Esporta documenti: Crea un archivio ZIP contenente tutti i PDF e il file di registro (.json) per il backup.\n"
            testo += "‚Ä¢ Importa documenti: Carica un archivio ZIP esportato. Attenzione: questa operazione √® distruttiva e sovrascrive tutti i documenti e il registro esistenti.\n"
            
            return testo.strip()
        tk.Label(
            content_frame, 
            text="Archiviazione Nuovi Documenti:", 
            font=("Arial", 11, "bold"), 
            anchor='w'
        ).pack(pady=(5, 5), fill='x')
        tk.Label(
            content_frame,
            text="‚Ä¢ Campi di Archiviazione: I campi nel pannello superiore sono obbligatori e vengono usati per creare il nome univoco del file\n¬† ¬† ¬† e per registrare i metadati nel registro locale.\n\n"
                 "‚Ä¢ Archivia PDF (Bottone Verde): Apre il selettore file. Il PDF selezionato viene copiato nella directory locale (`db/doc`).\n¬† ¬† ¬† Attenzione: se il nome file generato esiste gi√†, il file viene sovrascritto.",
            font=("Arial", 9),
            justify=tk.LEFT,
            anchor='w',
            wraplength=900 
        ).pack(fill='x', padx=5, pady=(0, 5))
        tk.Label(
            content_frame, 
            text="Navigazione e Interazione (Treeview Documenti):", 
            font=("Arial", 11, "bold"), 
            anchor='w'
        ).pack(pady=(10, 5), fill='x')
        tk.Label(
            content_frame,
            text="‚Ä¢ Apertura Documento (Doppio Clic): Doppio clic su una riga per aprire il file PDF associato.\n"
                 "‚Ä¢ Ordinamento: Clicca sull'intestazione di qualsiasi colonna (Data, Importo, Categoria, ecc.) per ordinare i dati.\n"
                 "‚Ä¢ Esportazione Selezionata (Tasto Destro): Seleziona righe, clicca Tasto Destro per esportare i file in una cartella esterna.\n"
                 "¬† > Utilizza CTRL + Click per selezionare righe sparse (selezione mista), o SHIFT + Click per selezionare un intervallo continuo di righe.\n" 
                 "‚Ä¢ Scroll e Navigazione: Utilizza la Rotella del Mouse per scorrere verticalmente in qualsiasi Treeview o area.\n"
                 "‚Ä¢ Cancellazione (Canc/Bottone): Seleziona una riga e premi CANC (o usa il bottone 'üóëÔ∏è Cancella Documento') per eliminare file e registro.",
            font=("Arial", 9),
            justify=tk.LEFT,
            anchor='w',
            wraplength=900
        ).pack(fill='x', padx=5, pady=(0, 5))
        tk.Label(
            content_frame, 
            text="Ricerca e Filtraggio:", 
            font=("Arial", 11, "bold"), 
            anchor='w'
        ).pack(pady=(10, 5), fill='x')
        tk.Label(
            content_frame,
            text="‚Ä¢ Ricerca Veloce: Digita una parola chiave; la ricerca √® effettuata su nome file, data, categoria, descrizione e tipo.\n"
                 "‚Ä¢ Filtri Avanzati (Bottone ‚öôÔ∏è): Filtra documenti per Intervallo di Data, Intervallo di Importo, Categoria Esatta e Tipo (Entrata/Uscita).",
            font=("Arial", 9),
            justify=tk.LEFT,
            anchor='w',
            wraplength=900
        ).pack(fill='x', padx=5, pady=(0, 5))
        tk.Label(
            content_frame, 
            text="Operazioni di Sistema (Menu üìÇ Archivio):", 
            font=("Arial", 11, "bold"), 
            anchor='w'
        ).pack(pady=(10, 5), fill='x')
        tk.Label(
            content_frame,
            text="‚Ä¢ Esporta documenti: Crea un archivio ZIP contenente tutti i PDF e il file di registro (`.json`) per il backup.\n"
                 "‚Ä¢ Importa documenti: Carica un archivio ZIP esportato. Attenzione: questa operazione √® distruttiva e sovrascrive tutti i documenti e il registro esistenti.",
            font=("Arial", 9),
            justify=tk.LEFT,
            anchor='w',
            wraplength=900
        ).pack(fill='x', padx=5, pady=(0, 5))
        bottom_frame = ttk.Frame(popup_aiuto)
        bottom_frame.pack(side=tk.BOTTOM, fill=tk.X, pady=(0, 10), padx=15)
        ttk.Button(
            bottom_frame,
            text="üñ®Ô∏è Stampa Guida",
            command=lambda: self._stampa_lista_diretta(
                ottieni_contenuto_testo(),
                self.show_custom_warning
            ),
            style="Blu.TButton"
        ).pack(side=tk.LEFT, pady=5, padx=10)
        ttk.Button(
            bottom_frame, 
            text="Ho Capito (OK)", 
            command=popup_aiuto.destroy,
            style="Giallo.TButton" 
        ).pack(side=tk.RIGHT, pady=5, padx=10)
        popup_aiuto.bind("<Escape>", lambda e: popup_aiuto.destroy())
    def esegui_export_documenti_pdf(self):
        from datetime import datetime
        backup_formato = "zip"
        current_folder = os.path.basename(DOC_DIR)
        percorso_archivio = ""
        cartella_temp_path = None
        if not os.path.exists(DOC_DIR):
            self.show_custom_warning("Attenzione", f"La cartella sorgente '{DOC_DIR}' non esiste. Backup annullato.")
            return ""
        try:
            timestamp = datetime.now().strftime("%Y%m%d")
            default_name = f"Archivio_PDF_backup_{timestamp}"
            percorso_completo_output = filedialog.asksaveasfilename(
                title="Scegli dove salvare l'archivio ZIP dei Documenti PDF",
                initialdir=os.path.expanduser('~'),
                initialfile=default_name,
                confirmoverwrite=False,
                defaultextension=f".{backup_formato}",
                filetypes=[(f"Archivi {backup_formato.upper()}", f"*.{backup_formato}")]
            )
            if not percorso_completo_output:
                return ""
            self.update_idletasks()
            self.update() 
            percorso_output_senza_ext, _ = os.path.splitext(percorso_completo_output)
            cartella_temp_path = tempfile.mkdtemp()
            cartella_dati_nel_temp_path = os.path.join(cartella_temp_path, current_folder)
            PATTERNS_DA_IGNORARE = ('*.lock', '*-journal', '*.db-wal', '*.tmp', '__pycache__')
            shutil.copytree(
                DOC_DIR,
                cartella_dati_nel_temp_path,
                ignore=shutil.ignore_patterns(*PATTERNS_DA_IGNORARE),
                dirs_exist_ok=True
            )
            if os.path.exists(REGISTRY_FILE):
                destinazione_registro = os.path.join(cartella_temp_path, os.path.basename(REGISTRY_FILE))
                shutil.copy2(REGISTRY_FILE, destinazione_registro)
            percorso_archivio = shutil.make_archive(
                base_name=percorso_output_senza_ext,
                format=backup_formato,
                root_dir=cartella_temp_path,
                base_dir=''
            )
            self.show_custom_warning("Salvataggio", f"Estrazione Archivio PDF completato.\n\nFile salvato in: {percorso_archivio}")
        except Exception as e:
            self.show_custom_warning("Errore Backup", f"Errore durante la creazione del backup dei PDF: {e}")
        finally:
            if cartella_temp_path and os.path.exists(cartella_temp_path):
                shutil.rmtree(cartella_temp_path, ignore_errors=True)
        return percorso_archivio
    def esegui_import_documenti_pdf(self):
        current_folder_name = os.path.basename(DOC_DIR)
        registry_file_name = os.path.basename(REGISTRY_FILE)
        backup_file_path = filedialog.askopenfilename(
            title="Seleziona l'archivio ZIP da importare",
            defaultextension=".zip",
            filetypes=[("Archivi ZIP", "*.zip")]
        )
        if not backup_file_path:
            return
        cartella_temp_path = None
        try:
            cartella_temp_path = tempfile.mkdtemp()
            try:
                with zipfile.ZipFile(backup_file_path, 'r') as zip_ref:
                    zip_ref.extractall(cartella_temp_path)
            except zipfile.BadZipFile:
                self.show_custom_warning("Errore Importazione", "Il file selezionato non √® un archivio ZIP valido.")
                return
            temp_pdf_dir = os.path.join(cartella_temp_path, current_folder_name)
            temp_registry_file = os.path.join(cartella_temp_path, registry_file_name)
            if not os.path.isdir(temp_pdf_dir):
                 self.show_custom_warning("Errore Importazione", f"Archivio non valido. Manca la cartella '{current_folder_name}' al suo interno.")
                 return
            registry_present = os.path.exists(temp_registry_file)
            messaggio_conferma = (
                "ATTENZIONE: Stai per importare un backup.\n\n"
                "Sei sicuro di voler procedere con la\nSOVRASCRITTURA?"
            )
            response = self.show_custom_askyesno("Conferma Importazione e Sovrascrittura", messaggio_conferma)
            if not response:
                return   
            if os.path.exists(DOC_DIR):
                shutil.rmtree(DOC_DIR)
            shutil.copytree(temp_pdf_dir, DOC_DIR)
            if registry_present:
                if not os.path.exists(DB_DIR): os.makedirs(DB_DIR) 
                shutil.copy2(temp_registry_file, REGISTRY_FILE)
            if hasattr(self, 'pdf_window') and self.pdf_window.winfo_exists():
                self.pdf_window.destroy()
                self.after(50, lambda: self.gestisci_archivi_pdf(self.filtri_avanzati.get('categoria')))
                self.show_custom_info("Importazione Riuscita", "Archivio documenti importato con successo.\nIl registro e i file PDF sono stati aggiornati.")
        except Exception as e:
            self.show_custom_warning("Errore Importazione", f"Si √® verificato un errore critico durante l'importazione: {e}")
        finally:
            if cartella_temp_path and os.path.exists(cartella_temp_path):
                shutil.rmtree(cartella_temp_path, ignore_errors=True)

    # Aggiornamenti Github Supermarket.pyw
    def check_supermarket_update(self):
        from datetime import timedelta
        nome_file_locale = NOME_EDITOR_LOCALE
        try:
            url_parts = GITHUB_SUPERMARKET.split('/')
            REPO_OWNER = url_parts[3] 
            REPO_NAME = url_parts[4]
            titolo_popup = "üîÑ Aggiornamento Disponibile"
        except IndexError:
            print("‚ö†Ô∏è Errore nel parsing dell'URL GITHUB_SUPERMARKET.")
            return
        except NameError:
            print("‚ö†Ô∏è Errore: Costanti GITHUB_SUPERMARKET o NOME_EDITOR_LOCALE non definite.")
            return
        try:
            api_url = f"https://api.github.com/repos/{REPO_OWNER}/{REPO_NAME}/commits"
            params = {"path": nome_file_locale, "per_page": 1} 
            response = requests.get(api_url, params=params, timeout=5)
            response.raise_for_status()
            commits = response.json()
            if not commits: return
            commit_date = commits[0]["commit"]["committer"]["date"]
            remote_time = datetime.datetime.strptime(commit_date, "%Y-%m-%dT%H:%M:%SZ").replace(microsecond=0)
            changelog_text = ""
            for commit in commits:
                date_str = commit["commit"]["committer"]["date"]
                commit_dt = datetime.datetime.strptime(date_str, "%Y-%m-%dT%H:%M:%SZ")
                message = commit["commit"]["message"].strip()
                message = message.replace('\r', '') 
                lines = message.split('\n')
                subject = lines[0] 
                body_lines = lines[1:] 
                start_index = 0
                while start_index < len(body_lines):
                    current_line = body_lines[start_index].strip()
                    if not current_line or current_line == subject.strip():
                        start_index += 1
                    else:
                        break
                body_lines = body_lines[start_index:]
                changelog_entry = f"üìù [{commit_dt.strftime('%d/%m/%y %H:%M')}] {subject}\n"
                if body_lines:
                    for line in body_lines:
                        if line.strip(): 
                            changelog_entry += f" ‚û°Ô∏è {line}\n"
                        else:
                             changelog_entry += "\n"
                changelog_entry += "\n" 
                changelog_text += changelog_entry
            if not os.path.exists(nome_file_locale):
                #self.show_custom_warning("File Editor Mancante", f"‚ö†Ô∏è L'editor locale ({nome_file_locale}) non esiste. Aggiornamento consigliato.")
                return
            local_time = datetime.datetime.utcfromtimestamp(os.path.getmtime(nome_file_locale)).replace(microsecond=0)
            if remote_time.date() > local_time.date():
                win = tk.Toplevel(self, bg=self.COLOR_UPDATE)
                win.title(titolo_popup)
                win.wm_attributes('-topmost', 1)
                label_timer = ttk.Label(win, text="‚è±Ô∏è Chiusura automatica tra 60 secondi", style="Timer.TLabel")
                label_timer.pack(pady=(10, 0))
                msg = (
                    "üÜï √à stato rilevato un possibile aggiornamento per l'Editor.\n\n"
                    f"üì° Ultima versione online: {remote_time.strftime('%d/%m/%Y %H:%M')}\n"
                    f"üñ•Ô∏è Versione attuale locale: {local_time.strftime('%d/%m/%Y %H:%M')}"
                )
                tk.Label(win, text=msg, bg=self.COLOR_UPDATE, wraplength=460, justify=tk.LEFT).pack(padx=20, pady=(10, 0))
                tk.Label(win, text="Storico Modifiche (Changelog):", bg=self.COLOR_UPDATE).pack(pady=(10, 0))
                frame_changelog = ttk.Frame(win)
                frame_changelog.pack(padx=20, pady=(5, 10), fill='both', expand=True)
                scrollbar = ttk.Scrollbar(frame_changelog)
                scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
                text_area = tk.Text(frame_changelog, wrap=tk.WORD, yscrollcommand=scrollbar.set, height=6, width=60, font=("Arial", 9))
                text_area.insert(tk.END, changelog_text.strip())
                text_area.config(state=tk.DISABLED, background="#ADD8E6") 
                text_area.pack(side=tk.LEFT, fill='both', expand=True)
                scrollbar.config(command=text_area.yview)
                tk.Label(win, text="üëâ Vuoi procedere con l'aggiornamento adesso?", bg=self.COLOR_UPDATE).pack(pady=(5, 10))
                frame_bottoni = tk.Frame(win, bg=self.COLOR_UPDATE)
                frame_bottoni.pack(pady=10)
                def aggiorna_timer(secondi_rimasti):
                    if secondi_rimasti > 0:
                        colore = "red" if secondi_rimasti <= 10 else "black"
                        label_timer.config(text=f"‚è±Ô∏è Chiusura automatica tra {secondi_rimasti} secondi")
                        win.after(1000, aggiorna_timer, secondi_rimasti - 1)
                    else:
                        label_timer.config(text="‚è±Ô∏è Chiusura automatica...")
                        win.destroy()
                timeout_id = win.after(60000, win.destroy)
                aggiorna_timer(60)
                def annulla_timeout():
                    win.after_cancel(timeout_id)
                def aggiorna():
                    annulla_timeout()
                    win.destroy()
                    if self.aggiorna(GITHUB_SUPERMARKET, nome_file_locale):
                        self.show_custom_info("Editor Aggiornato", f"L'editor {nome_file_locale} √® stato aggiornato!")
                def chiudi():
                    annulla_timeout()
                    win.destroy()
                ttk.Button(frame_bottoni, text="üîÑ AGGIORNA", command=aggiorna, style="Verde.TButton").pack(side="left", padx=5)
                ttk.Button(frame_bottoni, text="‚ùå CHIUDI", command=chiudi, style="Giallo.TButton").pack(side="left", padx=5)
                win.withdraw()
                win.update_idletasks()
                min_w, min_h = 660, 410
                w = max(win.winfo_width(), min_w)
                h = max(win.winfo_height(), min_h)
                x = self.winfo_rootx() + (self.winfo_width() // 2) - (w // 2)
                y = self.winfo_rooty() + (self.winfo_height() // 2) - (h // 2)
                win.geometry(f"{w}x{h}+{x}+{y}")
                win.deiconify()
                win.grab_set()
                win.transient(self.master)
                win.focus_set()
                win.bind('<Escape>', lambda e: chiudi())
        except requests.exceptions.ConnectionError:
            print(f"üåê Connessione assente o GitHub non raggiungibile per {nome_file_locale}.")
        except requests.exceptions.RequestException as e:
            print(f"‚ö†Ô∏è Errore HTTP o API per {nome_file_locale}: {e}")
        except Exception as e:
            print(f"‚ö†Ô∏è Errore generico durante il controllo aggiornamento per {nome_file_locale}: {e}")

    def check_supermarket_update_manuale(self):
        from datetime import timedelta
        nome_file_locale = NOME_EDITOR_LOCALE
        try:
            url_parts = GITHUB_SUPERMARKET.split('/')
            REPO_OWNER = url_parts[3]
            REPO_NAME = url_parts[4]
            titolo_popup = "üîÑ Aggiornamento Disponibile"
        except IndexError:
            print("‚ö†Ô∏è Errore nel parsing dell'URL GITHUB_SUPERMARKET.")
            return
        except NameError:
            print("‚ö†Ô∏è Errore: Costanti GITHUB_SUPERMARKET o NOME_EDITOR_LOCALE non definite.")
            return
        try:
            api_url = f"https://api.github.com/repos/{REPO_OWNER}/{REPO_NAME}/commits"
            params = {"path": nome_file_locale, "per_page": 1}
            response = requests.get(api_url, params=params, timeout=5)
            response.raise_for_status()
            commits = response.json()
            if not commits: return
            commit_date = commits[0]["commit"]["committer"]["date"]
            remote_time = datetime.datetime.strptime(commit_date, "%Y-%m-%dT%H:%M:%SZ").replace(microsecond=0)
            changelog_text = ""
            for commit in commits:
                date_str = commit["commit"]["committer"]["date"]
                commit_dt = datetime.datetime.strptime(date_str, "%Y-%m-%dT%H:%M:%SZ")
                message = commit["commit"]["message"].strip()
                message = message.replace('\r', '')
                lines = message.split('\n')
                subject = lines[0]
                body_lines = lines[1:]
                start_index = 0
                while start_index < len(body_lines):
                    current_line = body_lines[start_index].strip()
                    if not current_line or current_line == subject.strip():
                        start_index += 1
                    else:
                        break
                body_lines = body_lines[start_index:]
                changelog_entry = f"üìù [{commit_dt.strftime('%d/%m/%y %H:%M')}] {subject}\n"
                if body_lines:
                    for line in body_lines:
                        if line.strip():
                            changelog_entry += f" ‚û°Ô∏è {line}\n"
                        else:
                             changelog_entry += "\n"
                changelog_entry += "\n"
                changelog_text += changelog_entry
            if not os.path.exists(nome_file_locale):
                #self.show_custom_warning("File Editor Mancante", f"‚ö†Ô∏è L'editor locale ({nome_file_locale}) non esiste. Aggiornamento consigliato.")
                return
            local_time = datetime.datetime.utcfromtimestamp(os.path.getmtime(nome_file_locale)).replace(microsecond=0)
            if remote_time.date() > local_time.date():
                win = tk.Toplevel(self, bg=self.COLOR_UPDATE)
                win.title(titolo_popup)
                win.wm_attributes('-topmost', 1)
                label_timer = ttk.Label(win, text="‚è±Ô∏è Chiusura automatica tra 60 secondi", style="Timer.TLabel")
                label_timer.pack(pady=(10, 0))
                msg = (
                    "üÜï √à stato rilevato un possibile aggiornamento per l'Editor.\n\n"
                    f"üì° Ultima versione online: {remote_time.strftime('%d/%m/%Y %H:%M')}\n"
                    f"üñ•Ô∏è Versione attuale locale: {local_time.strftime('%d/%m/%Y %H:%M')}"
                )
                tk.Label(win, bg=self.COLOR_UPDATE, text=msg, wraplength=460, justify=tk.LEFT).pack(padx=20, pady=(10, 0))
                tk.Label(win, text="Storico Modifiche (Changelog):", bg=self.COLOR_UPDATE).pack(pady=(10, 0))
                frame_changelog = ttk.Frame(win)
                frame_changelog.pack(padx=20, pady=(5, 10), fill='both', expand=True)
                scrollbar = ttk.Scrollbar(frame_changelog)
                scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
                text_area = tk.Text(frame_changelog, wrap=tk.WORD, yscrollcommand=scrollbar.set, height=6, width=60, font=("Arial", 9))
                text_area.insert(tk.END, changelog_text.strip())
                text_area.config(state=tk.DISABLED, background="#ADD8E6")
                text_area.pack(side=tk.LEFT, fill='both', expand=True)
                scrollbar.config(command=text_area.yview)
                tk.Label(win, text="üëâ Vuoi procedere con l'aggiornamento adesso?", bg=self.COLOR_UPDATE).pack(pady=(5, 10))
                frame_bottoni = tk.Frame(win, bg=self.COLOR_UPDATE)
                frame_bottoni.pack(pady=10)
                def aggiorna_timer(secondi_rimasti):
                    if secondi_rimasti > 0:
                        colore = "red" if secondi_rimasti <= 10 else "black"
                        label_timer.config(text=f"‚è±Ô∏è Chiusura automatica tra {secondi_rimasti} secondi")
                        win.after(1000, aggiorna_timer, secondi_rimasti - 1)
                    else:
                        label_timer.config(text="‚è±Ô∏è Chiusura automatica...")
                        win.destroy()
                timeout_id = win.after(60000, win.destroy)
                aggiorna_timer(60)
                def annulla_timeout():
                    win.after_cancel(timeout_id)
                def aggiorna():
                    annulla_timeout()
                    win.destroy()
                    if self.aggiorna(GITHUB_SUPERMARKET, nome_file_locale):
                        self.show_custom_info("Editor Aggiornato", f"L'editor {nome_file_locale} √® stato aggiornato!")
                def chiudi():
                    annulla_timeout()
                    win.destroy()
                ttk.Button(frame_bottoni, text="üîÑ AGGIORNA", command=aggiorna, style="Verde.TButton").pack(side="left", padx=5)
                ttk.Button(frame_bottoni, text="‚ùå CHIUDI", command=chiudi, style="Giallo.TButton").pack(side="left", padx=5)
                win.withdraw()
                win.update_idletasks()
                min_w, min_h = 660, 410
                w = max(win.winfo_width(), min_w)
                h = max(win.winfo_height(), min_h)
                x = self.winfo_rootx() + (self.winfo_width() // 2) - (w // 2)
                y = self.winfo_rooty() + (self.winfo_height() // 2) - (h // 2)
                win.geometry(f"{w}x{h}+{x}+{y}")
                win.deiconify()
                win.grab_set()
                win.transient(self.master)
                win.focus_set()
                win.bind('<Escape>', lambda e: chiudi())
            else:
                self.show_custom_info(
                    "Aggiornamento Editor",
                    f"L'editor '{nome_file_locale}' √® gi√† aggiornato.\n"
                    f"Ultima versione locale: {local_time.strftime('%d/%m/%Y %H:%M')}"
                )
        except requests.exceptions.ConnectionError:
            self.show_custom_warning(
                 "Connessione Assente",
                 f"üåê Connessione assente o GitHub non raggiungibile per il controllo di {nome_file_locale}."
            )
        except requests.exceptions.RequestException as e:
            print(f"‚ö†Ô∏è Errore HTTP o API per {nome_file_locale}: {e}")
            self.show_custom_warning(
                 "Errore GitHub",
                 f"‚ö†Ô∏è Errore nel controllo della versione su GitHub per {nome_file_locale}."
            )
        except Exception as e:
            print(f"‚ö†Ô∏è Errore generico durante il controllo aggiornamento per {nome_file_locale}: {e}")

    def _rimuovi_editor_esterno(self):
        try:
            nome_file = NOME_EDITOR_LOCALE
            nome_backup = f"{nome_file}.bak"
            rimossi = []
            if os.path.exists(nome_file):
                try:
                    os.remove(nome_file)
                    rimossi.append(nome_file)
                except PermissionError:
                    self.show_custom_warning(
                        "Errore Permessi", 
                        f"‚ö†Ô∏è Impossibile rimuovere '{nome_file}'. Il file potrebbe essere in uso."
                    )
                    return
                except Exception as e:
                    self.show_custom_warning("Errore Rimozione", f"‚ùå Errore durante la rimozione di '{nome_file}': {e}")
                    return
            if os.path.exists(nome_backup):
                try:
                    os.remove(nome_backup)
                    rimossi.append(nome_backup)
                except Exception as e:
                    print(f"‚ö†Ô∏è Attenzione: Impossibile rimuovere il file di backup '{nome_backup}': {e}")
            if rimossi:
                messaggio_successo = "\n".join(f"‚úÖ Rimosso: {f}" for f in rimossi)
                self.show_custom_info(
                    "Rimozione Editor Completata", 
                    f"I seguenti file sono stati rimossi con successo:\n{messaggio_successo}"
                )
            elif not os.path.exists(nome_file) and not os.path.exists(nome_backup):
                self.show_custom_info(
                    "Rimozione Editor", 
                    "L'editor scontrini e il suo backup non erano presenti."
                )
        except NameError:
            self.show_custom_warning(
                "Errore Configurazione", 
                "‚ö†Ô∏è La costante NOME_EDITOR_LOCALE non √® definita. Impossibile procedere."
            )
        except Exception as e:
            self.show_custom_warning("Errore Sconosciuto", f"üõë Errore fatale: {e}")

    # Forza Installazione Editor Scontrini
    def _scarica_editor_esterno(self):
        url = GITHUB_SUPERMARKET
        filename = NOME_EDITOR_LOCALE
        try:
            response = requests.get(url, stream=True)
            response.raise_for_status()
            with open(filename, 'wb') as file:
                for chunk in response.iter_content(chunk_size=8192):
                    file.write(chunk)
            self.show_custom_info(
                "Download Editor", 
                f"‚úÖ Editor scaricato con successo come '{filename}'."
            )
        except requests.exceptions.RequestException as e:
            self.show_custom_warning(
                "Errore Download", 
                f"‚ùå Impossibile scaricare l'editor. Errore: {e}"
            )

    # Avvia Editor Scontrini
    def _avvia_editor_esterno(self):
        base_dir = os.path.dirname(os.path.abspath(sys.argv[0]))
        script_path = os.path.join(base_dir,"supermarket.pyw") 
        if not os.path.exists(script_path):
            self._scarica_editor_esterno()
            #self.show_custom_warning("Errore File", f"File non trovato. Assicurati che esista in: {script_path}")
            return
        try:
            if sys.platform.startswith('win'):
                comando = [sys.executable.replace('python.exe', 'pythonw.exe'), script_path]
            else:
                comando = ['python3', script_path]
            if hasattr(self, '_popup_spesa_active') and self._popup_spesa_active is not None and self._popup_spesa_active.winfo_exists():
                self._popup_spesa_active.destroy()
            subprocess.run(comando, close_fds=True)
            self.deiconify() 
            self.lift()
            self.focus_force()
        except OSError as e:
            self.show_custom_warning(
                "Errore Esecuzione", 
                f"Impossibile avviare il tool ({comando[0]}). Errore: {e}"
            )

    # Gestisci ripristino focus Blinker
    def _gestisci_ripristino_focus(self, event):
        if event.widget == self: 
            if hasattr(self, 'imp_entry'):
                self.after(0, self.imp_entry.focus_set)
            if ICO_SET_DATE:
                today_date = datetime.datetime.now().strftime("%d-%m-%Y") 
                self.data_spesa_var.set(today_date)
            if hasattr(self, 'ricorrenza_data_inizio'):
                self.ricorrenza_data_inizio.set(today_date)
            if hasattr(self, 'cal'):
                self.goto_today()
        self._reset_inattivita()
                     
    # Gestione Avanzata di Inattivit√† e Minimizzazione (Auto-Lock)                 
    def _attiva_timer_inattivita(self):
        if self._timer_inattivita:
            self.after_cancel(self._timer_inattivita)
        self._timer_inattivita = self.after(self._timeout_inattivita, self._iconizza_finestra)
    def _reset_inattivita(self, cancel_countdown=False): 
        if self._countdown_timer_id and cancel_countdown:
            self.after_cancel(self._countdown_timer_id)
            self._countdown_timer_id = None
            if self._countdown_splash:
                 self._countdown_splash.destroy()
                 self._countdown_splash = None
            self._attiva_timer_inattivita() 
            return 
        if self.state() == "iconic":
            self.deiconify()
            self.after(0, self.imp_entry.focus_set)
        self._attiva_timer_inattivita()
    def _iconizza_finestra(self):
        if self.state() == "iconic":
            self._attiva_timer_inattivita()
            return
        toplevel_active = False
        for widget in self.winfo_children():
            if isinstance(widget, tk.Toplevel) and widget.winfo_ismapped():
                toplevel_active = True
                break
        if toplevel_active:
            self._attiva_timer_inattivita() 
            return
        self._mostra_avviso_countdown()
    def mostra_avviso_iconizzata(self):
        splash = tk.Toplevel(self)
        splash.overrideredirect(True)
        splash.attributes("-topmost", True)
        width, height = 290, 100 
        screen_width = splash.winfo_screenwidth()
        screen_height = splash.winfo_screenheight()
        x = (screen_width // 2) - (width // 2)
        y = (screen_height // 2) - (height // 2)
        splash.geometry(f"{width}x{height}+{x}+{y}")
        bg_color = "#7fc2c7"
        splash.configure(bg=bg_color)
        label = tk.Label(
            splash,
            text = f"üí§ {NAME} v.{VERSION}\n\nFinestra minimizzata per inattivit√†.",
            font=("Arial", 9, "bold"),
            bg=bg_color
        )
        label.pack(expand=True, pady=15)
        splash.update()
        splash.after(3000, splash.destroy)
    def _finalizza_iconizzazione(self):
        if self._countdown_splash:
            self._countdown_splash.destroy()
            self._countdown_splash = None
        self.iconify()
        self.mostra_avviso_iconizzata() 
        self._attiva_timer_inattivita()
    def _mostra_avviso_countdown(self):
        if self._timer_inattivita:
            self.after_cancel(self._timer_inattivita)
            self._timer_inattivita = None
        if self._countdown_splash:
            self._countdown_splash.destroy()
            self._countdown_splash = None
        if self._countdown_timer_id:
            self.after_cancel(self._countdown_timer_id)
            self._countdown_timer_id = None
        splash = tk.Toplevel(self)
        splash.overrideredirect(True)
        splash.attributes("-topmost", True)
        width, height = 290, 100
        screen_width = splash.winfo_screenwidth()
        screen_height = splash.winfo_screenheight()
        x = (screen_width // 2) - (width // 2)
        y = (screen_height // 2) - (height // 2)
        splash.geometry(f"{width}x{height}+{x}+{y}")
        bg_color = "#ffcccc"
        splash.configure(bg=bg_color)
        label = tk.Label(
            splash, 
            text="ATTENZIONE: Avviso di Inattivit√†", 
            font=("Arial", 9, "bold"), 
            bg=bg_color
        ) 
        label.pack(expand=True, pady=30, padx=10)
        splash.update()
        self._countdown_splash = splash
        self._countdown_label = label
        splash.bind("<Motion>", lambda e: self._reset_inattivita(cancel_countdown=True))
        label.bind("<Motion>", lambda e: self._reset_inattivita(cancel_countdown=True))
        self._aggiorna_countdown(self._countdown_delay)
    def _aggiorna_countdown(self, remaining_ms):
        if not self._countdown_splash:
            return
        if remaining_ms <= 0:
            self._finalizza_iconizzazione()
            return
        seconds = remaining_ms // 1000
        self._countdown_label.config(
            text=f"ATTENZIONE: Nessuna attivit√† rilevata.\n\nLa finestra si minimizzer√† tra {seconds} secondi."
        )
        self._countdown_timer_id = self.after(
            1000, 
            lambda: self._aggiorna_countdown(remaining_ms - 1000)
        )
    def _iconizza_finestra_startup(self):
        toplevel_active = False
        for widget in self.winfo_children():
            if isinstance(widget, tk.Toplevel) and widget.winfo_ismapped():
                toplevel_active = True
                break
        if toplevel_active:
            return 
        self.iconify()

    # Analisi e Promemoria Categorie di Spesa Ricorrenti Mancanti Manuale
    def controlla_ricorrenti_manual(self):
        from datetime import datetime, timedelta
        oggi = datetime.today().date()
        def converti_data(d):
            if isinstance(d, str):
                try:
                    return datetime.strptime(d, "%d-%m-%Y").date()
                except:
                    return None
            elif isinstance(d, datetime):
                return d.date()
            return d
        categorie_base = {cat.title() for cat in self.categorie if cat}
        if not categorie_base:
            return
        categorie_mancanti_nel_mese = []
        risultati = {}
        for d, sp in self.spese.items():
            dd = converti_data(d)
            if not dd or dd.year != oggi.year:
                continue
            mese = dd.month
            for voce in sp:
                if len(voce) < 1 or not voce[0].strip():
                    continue
                cat = voce[0].strip().title()
                if mese == oggi.month:
                    risultati.setdefault(cat, set()).add(mese)
        for cat in categorie_base:
            presenze_precedenti = 0
            for d, sp in self.spese.items():
                dd = converti_data(d)
                if not dd or dd.year != oggi.year or dd.month >= oggi.month: 
                    continue
                for voce in sp:
                    if len(voce) > 0 and voce[0].strip().title() == cat:
                        presenze_precedenti += 1
                        break
            is_presente_questo_mese = oggi.month in risultati.get(cat, set())
            if presenze_precedenti >= 2 and not is_presente_questo_mese:
                categorie_mancanti_nel_mese.append(cat)
        if categorie_mancanti_nel_mese:
            elenco_mancanti = "\n".join(categorie_mancanti_nel_mese)
            messaggio = (
                f"‚ö†Ô∏è PROMEMORIA MOVIMENTI RICORRENTI (Fine Mese)!\n\n"
                f"Hai dimenticato qualcosa? Le seguenti categorie di Movimenti, registrati"
                f"abitualmente nei mesi scorsi, non risultano ancora presenti nel mese corrente:\n\n"
                f"{elenco_mancanti}\n\n"
                f"Premi S√¨ per aprire la verifica dettagliata, oppure No per chiudere l'avviso "
            )
            risposta = self.show_custom_askyesno(
                "Promemoria Movimenti Ricorrenti", 
                messaggio
            )
            if risposta:
                self.calcola_mancanti()

    # Analisi e Promemoria Categorie di Spesa Ricorrenti Mancanti Automatico
    def controlla_ricorrenti_a_fine_mese(self):
        if hasattr(self, 'changelog_window') and \
           self.changelog_window is not None and \
           self.changelog_window.winfo_exists():
           self.after(5000, self.controlla_ricorrenti_a_fine_mese) 
           return
        from datetime import datetime, timedelta
        oggi = datetime.today().date()
        prossimo_mese = oggi.replace(day=28) + timedelta(days=4)
        ultimo_giorno_mese = prossimo_mese - timedelta(days=prossimo_mese.day)
        giorni_alla_fine = (ultimo_giorno_mese - oggi).days
        if giorni_alla_fine > SOGLIA_GIORNI_RICORRENTI or giorni_alla_fine < 0:
            return
        if self._last_dismiss_date and self._last_dismiss_date.year == oggi.year and self._last_dismiss_date.month == oggi.month:
            return
        giorno_del_mese = oggi.day
        try:
            giorni_nel_mese = (oggi.replace(day=28) + timedelta(days=4)).day - 3
        except ValueError:
            pass 
        def converti_data(d):
            if isinstance(d, str):
                try:
                    return datetime.strptime(d, "%d-%m-%Y").date()
                except:
                    return None
            elif isinstance(d, datetime):
                return d.date()
            return d
        categorie_base = {cat.title() for cat in self.categorie if cat}
        if not categorie_base:
            return
        categorie_mancanti_nel_mese = []
        risultati = {}
        for d, sp in self.spese.items():
            dd = converti_data(d)
            if not dd or dd.year != oggi.year:
                continue
            mese = dd.month
            for voce in sp:
                if len(voce) < 1 or not voce[0].strip():
                    continue
                cat = voce[0].strip().title()
                if mese == oggi.month:
                    risultati.setdefault(cat, set()).add(mese)
        for cat in categorie_base:
            presenze_precedenti = 0
            for d, sp in self.spese.items():
                dd = converti_data(d)
                if not dd or dd.year != oggi.year or dd.month >= oggi.month: 
                    continue
                for voce in sp:
                    if len(voce) > 0 and voce[0].strip().title() == cat:
                        presenze_precedenti += 1
                        break
            is_presente_questo_mese = oggi.month in risultati.get(cat, set())
            if presenze_precedenti >= 2 and not is_presente_questo_mese:
                categorie_mancanti_nel_mese.append(cat)
        if categorie_mancanti_nel_mese:
            if self.wm_state() == 'iconic':
                self.deiconify()
                self.lift()
            elenco_mancanti = "\n".join(categorie_mancanti_nel_mese)
            messaggio = (
                f"‚ö†Ô∏è PROMEMORIA MOVIMENTI RICORRENTI (Fine Mese)!\n\n"
                f"Hai dimenticato qualcosa? Le seguenti categorie di Movimenti, registrati"
                f"abitualmente nei mesi scorsi, non risultano ancora presenti nel mese corrente:\n\n"
                f"{elenco_mancanti}\n\n"
                f"Premi S√¨ per aprire la verifica dettagliata, oppure No per nascondere l'avviso fino al mese prossimo."
            )
            risposta = self.show_custom_askyesno(
                "Promemoria Movimenti Ricorrenti", 
                messaggio
            )
            if risposta:
                self.calcola_mancanti()
            else:
                self._last_dismiss_date = oggi
                self._salva_dismiss_fm(oggi)

    # Persistenza e Gestione della Data di "Dismiss" Promemoria Ricorrenti
    def _carica_dismiss_fm(self):
        if not os.path.exists(CONTROLLO_F_M):
            return None
        try:
            with open(CONTROLLO_F_M, 'r') as f:
                data = json.load(f)
                data_str = data.get('last_recurring_dismiss')               
                if data_str:
                    return datetime.datetime.strptime(data_str, "%Y-%m-%d").date()
                return None
        except Exception as e:
            print(f"Errore nel caricamento del dismiss ricorrenti: {e}")
            return None
    def _salva_dismiss_fm(self, data_da_salvare):
        try:
            data_str = data_da_salvare.strftime("%Y-%m-%d")
            dati = {'last_recurring_dismiss': data_str}
            dir_path = os.path.dirname(CONTROLLO_F_M)
            if not os.path.exists(dir_path):
                os.makedirs(dir_path)
            with open(CONTROLLO_F_M, 'w') as f:
                json.dump(dati, f, indent=4)
            return True
        except Exception as e:
            errore_messaggio = (
                f"Errore critico durante il salvataggio della data di 'dismiss' "
                f"nel file di controllo ({os.path.basename(CONTROLLO_F_M)}).\n"
                f"L'avviso delle ricorrenti ricomparir√† al prossimo avvio.\n"
                f"Dettagli: {e}"
            )
            if hasattr(self, 'show_custom_error'):
                self.show_custom_warning("‚ö†Ô∏è Errore di Persistenza", errore_messaggio) 
            else:
                print(errore_messaggio)
            return False
            
    # Controllo Versione e Notifica Changelog Tramite GitHub API
    def verifica_e_mostra_changelog(self):
        from datetime import datetime
        import requests
        URL_API = f"https://api.github.com/repos/{REPO_OWNER}/{REPO_NAME}/commits"
        PARAMETRI = {"path": NOME_FILE, "per_page": 1}
        try:
            risposta = requests.get(URL_API, params=PARAMETRI, timeout=5)
            risposta.raise_for_status()
            commits = risposta.json()
            if not commits:
                return
            hash_commit_corrente = commits[0]["sha"]
            hash_visto_precedentemente = self._carica_changelog_hash()
            if hash_commit_corrente != hash_visto_precedentemente:
                self.new_release() 
                self._salva_changelog_hash(hash_commit_corrente)
        except requests.exceptions.RequestException as e:
            print(f"Impossibile controllare gli aggiornamenti su GitHub a causa di un errore di rete: {e}")
        except Exception as e:
            print(f"Errore generico nel controllo aggiornamenti changelog: {e}")
    
    # Recupero e Visualizzazione Dello Storico Modifiche (Changelog) da GitHub
    def new_release(self):
        if self.wm_state() == 'iconic':
            self.deiconify()
            self.lift()
        from datetime import datetime
        api_url = f"https://api.github.com/repos/{REPO_OWNER}/{REPO_NAME}/commits"
        params = {"path": NOME_FILE, "per_page": 1} 
        changelog_text = ""
        try:
            response = requests.get(api_url, params=params, timeout=10)
            response.raise_for_status()
            commits = response.json()
            if not commits:
                self.show_custom_info("Changelog Vuoto", "‚ö†Ô∏è Nessuno storico di commit trovato per questo file.")
                return
            for commit in commits:
                date_str = commit["commit"]["committer"]["date"]
                commit_dt = datetime.strptime(date_str, "%Y-%m-%dT%H:%M:%SZ")
                message = commit["commit"]["message"].strip()
                message = message.replace('\r', '')
                lines = message.split('\n')
                subject = lines[0]
                body_lines = lines[1:]
                start_index = 0
                while start_index < len(body_lines):
                    current_line = body_lines[start_index].strip()
                    if not current_line or current_line == subject.strip():
                        start_index += 1
                    else:
                        break
                body_lines = body_lines[start_index:]
                changelog_entry = f"üìù [{commit_dt.strftime('%d/%m/%y %H:%M')}] {subject}\n"
                if body_lines:
                    for line in body_lines:
                        if line.strip(): 
                            changelog_entry += f" ‚û°Ô∏è {line}\n"
                        else:
                            changelog_entry += "\n"
                changelog_entry += "\n"  
                changelog_text += changelog_entry
            win = tk.Toplevel(self)
            self.changelog_window = win
            win.title(f"üìÑ Storico Modifiche: {NOME_FILE}")
            win.bind('<Escape>', lambda e: win.destroy())
            ttk.Label(win, text=f"Note di Rilascio : v.{VERSION}", font=("Arial", 10, "bold")).pack(pady=(10, 0))
            frame_changelog = ttk.Frame(win)
            frame_changelog.pack(padx=20, pady=(5, 10), fill='both', expand=True)
            scrollbar = ttk.Scrollbar(frame_changelog)
            scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
            text_area = tk.Text(frame_changelog, wrap=tk.WORD, yscrollcommand=scrollbar.set, height=15, width=80, font=("Arial", 9))
            text_area.insert(tk.END, changelog_text.strip())
            text_area.config(state=tk.DISABLED, background="#FFFFE0") 
            text_area.pack(side=tk.LEFT, fill='both', expand=True)
            scrollbar.config(command=text_area.yview)
            ttk.Button(win, text="‚ùå Chiudi", command=win.destroy, style="Giallo.TButton").pack(pady=(0, 10))
            win.withdraw()
            win.update_idletasks()
            min_w, min_h = 660, 410
            w = max(win.winfo_width(), min_w)
            h = max(win.winfo_height(), min_h)
            x = self.winfo_rootx() + (self.winfo_width() // 2) - (w // 2)
            y = self.winfo_rooty() + (self.winfo_height() // 2) - (h // 2)
            win.geometry(f"{w}x{h}+{x}+{y}")
            win.deiconify()
            self.lift()
            win.attributes('-topmost', True)
            win.focus_set()
            win.grab_set()
            win.wait_window()
            self.changelog_window = None
        except requests.exceptions.RequestException as e:
            self.show_custom_warning("Errore Connessione", f"‚ö†Ô∏è Impossibile connettersi a GitHub:\n{e}")
        except Exception as e:
            self.show_custom_warning("Errore", f"‚ùå Errore generico durante la visualizzazione dello storico:\n{e}")
    def _carica_changelog_hash(self):
        if not os.path.exists(CONTROLLO_CHANGELOG):
            return ""
        try:
            with open(CONTROLLO_CHANGELOG, 'r') as f:
                data = json.load(f)
                return data.get('last_seen_hash', "")
        except Exception as e:
            print(f"Errore nel caricamento dell'hash del changelog: {e}")
            return ""
    def _salva_changelog_hash(self, commit_hash):
        try:
            dati = {'last_seen_hash': commit_hash}
            dir_path = os.path.dirname(CONTROLLO_CHANGELOG)
            if not os.path.exists(dir_path):
                os.makedirs(dir_path)
            with open(CONTROLLO_CHANGELOG, 'w') as f:
                json.dump(dati, f, indent=4)
            return True
        except Exception as e:
            print(f"Errore critico durante il salvataggio dell'hash del changelog: {e}")
            return False

    # Gestione Icona Applicazione con Fallback e Download Remoto
    def set_app_icon(window):
        ICON_PATH = os.path.join(DB_DIR, ICON_NAME)
        if os.path.exists(ICON_PATH):
            try:
                icon = tk.PhotoImage(file=ICON_PATH)
                window.iconphoto(True, icon) 
                window.icon_ref = icon
            except tk.TclError as e:
                print(f"Errore: Impossibile impostare l'icona dal file {ICON_PATH}.")
        else:
            print("Icona non trovata in locale. Tentativo di download...")
            try:
                response = requests.get(ICON_URL, timeout=10)
                response.raise_for_status()
                os.makedirs(DB_DIR, exist_ok=True)
                with open(ICON_PATH, 'wb') as f:
                    f.write(response.content)
                icon = tk.PhotoImage(file=ICON_PATH)
                window.iconphoto(True, icon)
                window.icon_ref = icon
                print("Icona scaricata e impostata con successo!")
            except requests.exceptions.RequestException as e:
                print(f"Errore durante il download dell'icona: {e}")
            except tk.TclError:
                print("Errore: L'immagine scaricata non √® un formato PhotoImage valido.")

    # Sistema Completo di Aggiornamento Software (Fetch, Notifica, Download, Riavvio)
    def check_aggiornamento_con_api(self):
        import subprocess, sys, os
        import time
        from datetime import datetime, timedelta
        try:
            if os.path.exists(RIMANDA_FILE):
                with open(RIMANDA_FILE, "r") as f:
                    data = json.load(f)
                    rimanda = datetime.strptime(data.get("rimanda_fino", ""), "%Y-%m-%d")
                    if datetime.today() < rimanda:
                        print(f"‚è≥ Rimandato fino al {rimanda.date()}")
                        return
            api_url = f"https://api.github.com/repos/{REPO_OWNER}/{REPO_NAME}/commits"
            params = {"path": NOME_FILE, "per_page": 1}
            response = requests.get(api_url, params=params, timeout=5)
            response.raise_for_status()
            commits = response.json()
            if not commits:
                return 
            commit_date = commits[0]["commit"]["committer"]["date"]
            remote_time = datetime.strptime(commit_date, "%Y-%m-%dT%H:%M:%SZ").replace(microsecond=0)
            changelog_text = ""
            for commit in commits:
                date_str = commit["commit"]["committer"]["date"]
                commit_dt = datetime.strptime(date_str, "%Y-%m-%dT%H:%M:%SZ")
                message = commit["commit"]["message"].strip()
                message = message.replace('\r', '') 
                lines = message.split('\n')
                subject = lines[0] 
                body_lines = lines[1:] 
                start_index = 0
                while start_index < len(body_lines):
                    current_line = body_lines[start_index].strip()
                    if not current_line or current_line == subject.strip():
                        start_index += 1
                    else:
                        break
                body_lines = body_lines[start_index:]
                changelog_entry = f"üìù [{commit_dt.strftime('%d/%m/%y %H:%M')}] {subject}\n"
                if body_lines:
                    for line in body_lines:
                        if line.strip(): 
                            changelog_entry += f" ‚û°Ô∏è {line}\n"
                        else:
                             changelog_entry += "\n"
                changelog_entry += "\n" 
                changelog_text += changelog_entry
            if not os.path.exists(NOME_FILE):
                if self.state() == 'iconic':
                    self.deiconify()
                    self.lift()
                    self.focus_force()
                self.show_custom_warning(
                    "File mancante", 
                    f"‚ö†Ô∏è File '{NOME_FILE}' non trovato (rinominato o rimosso).\n\n"
                    "Vai in 'Opzioni' -> 'Forza Aggiornamento Software' per ripristinarlo."
                )
                return
            local_time = datetime.utcfromtimestamp(os.path.getmtime(NOME_FILE)).replace(microsecond=0)
            if remote_time.date() > local_time.date():
                if self.state() == 'iconic':
                    self.deiconify()
                    self.lift()
                win = tk.Toplevel(self, bg=self.COLOR_UPDATE)
                win.title("üîÑ Aggiornamento disponibile")
                win.bind('<Escape>', lambda e: win.destroy())
                label_timer = ttk.Label(win, text="‚è±Ô∏è Chiusura automatica tra 60 secondi", style="Timer.TLabel")
                label_timer.pack(pady=(10, 0))
                msg = (
                    "üÜï √à stato rilevato un possibile aggiornamento.\n\n"
                    f"üì° Ultima versione online: {remote_time.strftime('%d/%m/%Y %H:%M')}\n"
                    f"üñ•Ô∏è Versione attuale locale: {local_time.strftime('%d/%m/%Y %H:%M')}"
                )
                tk.Label(win, text=msg, wraplength=460, justify=tk.LEFT, bg=self.COLOR_UPDATE).pack(padx=20, pady=(10, 0))
                tk.Label(win, text="Storico Modifiche (Changelog):", bg=self.COLOR_UPDATE).pack(pady=(10, 0))
                frame_changelog = ttk.Frame(win)
                frame_changelog.pack(padx=20, pady=(5, 10), fill='both', expand=True)
                scrollbar = ttk.Scrollbar(frame_changelog)
                scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
                text_area = tk.Text(frame_changelog, wrap=tk.WORD, yscrollcommand=scrollbar.set, height=6, width=60, font=("Arial", 9))
                text_area.insert(tk.END, changelog_text.strip())
                text_area.config(state=tk.DISABLED, background="#ADD8E6") 
                text_area.pack(side=tk.LEFT, fill='both', expand=True)
                scrollbar.config(command=text_area.yview)
                tk.Label(win, text="üëâ Vuoi procedere con l'aggiornamento adesso?", bg=self.COLOR_UPDATE).pack(pady=(5, 10))
                frame_bottoni = tk.Frame(win, bg=self.COLOR_UPDATE)
                frame_bottoni.pack(pady=10)
                def aggiorna_timer(secondi_rimasti):
                    if secondi_rimasti > 0:
                        colore = "red" if secondi_rimasti <= 10 else "black"
                        label_timer.config(text=f"‚è±Ô∏è Chiusura automatica tra {secondi_rimasti} secondi")
                        win.after(1000, aggiorna_timer, secondi_rimasti - 1)
                    else:
                        label_timer.config(text="‚è±Ô∏è Chiusura automatica...")
                        win.destroy()
                timeout_id = win.after(60000, win.destroy)
                aggiorna_timer(60)
                def annulla_timeout():
                    win.after_cancel(timeout_id)
                def aggiorna():
                    annulla_timeout()
                    url = f"https://raw.githubusercontent.com/{REPO_OWNER}/{REPO_NAME}/main/{NOME_FILE.replace(' ', '%20')}"
                    win.destroy()
                    try:
                        nome_backup = f"{NOME_FILE}.bak"
                        if os.path.exists(NOME_FILE):
                            shutil.copy2(NOME_FILE, nome_backup)
                        urllib.request.urlretrieve(url, NOME_FILE)
                        print(f"Download completato! {NOME_FILE} √® stato aggiornato.")
                        if os.path.exists(RIMANDA_FILE):
                            try:
                                os.remove(RIMANDA_FILE)
                                print("File rimando eliminato dopo aggiornamento.")
                            except Exception as err:
                                print(f"‚ö†Ô∏è Errore durante l'eliminazione del file rimando: {err}")
                        messaggio = "üîÑ Riavvio in corso. File aggiornato! ATTENDERE..."
                        duration_s = 2 
                        width = 350
                        height = 80
                        popup_win = tk.Toplevel(self)
                        popup_win.overrideredirect(True) 
                        popup_win.resizable(False, False)
                        w_root, h_root = self.winfo_width(), self.winfo_height()
                        x_root, y_root = self.winfo_rootx(), self.winfo_rooty()
                        x_pos = (w_root // 2) - (width // 2)
                        y_pos = (h_root // 2) - (height // 2)
                        popup_win.geometry(f"{width}x{height}+{x_root + x_pos}+{y_root + y_pos}")
                        popup_frame = tk.Frame(popup_win, bg="orange", bd=3, relief="raised")
                        popup_frame.pack(expand=True, fill='both')
                        tk.Label(popup_frame, text=messaggio, font=("Arial", 10, "bold"), 
                                 justify="center", padx=10, pady=10, bg="orange", fg="black").pack(expand=True, fill='both')
                        popup_win.lift() 
                        try:
                            popup_win.attributes('-topmost', True) 
                        except:
                            pass
                        self.update() 
                        time.sleep(duration_s)
                        script_path = os.path.abspath(sys.argv[0])
                        args = [sys.executable, script_path] + sys.argv[1:]
                        subprocess.Popen(args, start_new_session=True, close_fds=True)
                        os._exit(0)
                    except Exception as e:
                        if 'shutil' in sys.modules and os.path.exists(nome_backup):
                            shutil.copy2(nome_backup, NOME_FILE)
                            os.remove(nome_backup)
                        self.show_custom_warning("Attenzione", f"‚ùå Aggiornamento fallito durante il download/riavvio:\n{e}")
                        return
                def chiudi():
                    annulla_timeout()
                    win.destroy()
                def rimanda():
                    annulla_timeout()
                    win.destroy()
                    nuova_data = datetime.today() + timedelta(days=15)
                    with open(RIMANDA_FILE, "w") as f:
                        json.dump({"rimanda_fino": nuova_data.strftime("%Y-%m-%d")}, f)
                    print(f"‚è≥ Rimandato fino al {nuova_data.date()}")
                    data_formattata = nuova_data.date().strftime("%d/%m/%Y")
                    self.show_custom_warning("Aggiornamento Rimandato", f"‚è≥ Aggiornamento Rimandato fino al {data_formattata}")
                ttk.Button(frame_bottoni, text="üîÑ AGGIORNA", command=aggiorna, style="Verde.TButton").pack(side="left", padx=5)
                ttk.Button(frame_bottoni, text="‚ùå CHIUDI", command=chiudi, style="Giallo.TButton").pack(side="left", padx=5)
                ttk.Button(frame_bottoni, text="‚è≥ RIMANDA", command=rimanda, style="Arancio.TButton").pack(side="left", padx=5)
                win.withdraw()
                win.update_idletasks()
                min_w, min_h = 660, 410
                w = max(win.winfo_width(), min_w)
                h = max(win.winfo_height(), min_h)
                x = self.winfo_rootx() + (self.winfo_width() // 2) - (w // 2)
                y = self.winfo_rooty() + (self.winfo_height() // 2) - (h // 2)
                win.geometry(f"{w}x{h}+{x}+{y}")
                win.deiconify()
                win.grab_set()
                win.transient(self)
                win.focus_set()
                win.wait_window()
            else:
                self.verifica_e_mostra_changelog()
        except ConnectionError:
            print("üåê Connessione assente o GitHub non raggiungibile.")
        except RequestException as e:
            print(f"‚ö†Ô∏è Errore HTTP o API: {e}")
        except Exception as e:
            print(f"‚ö†Ô∏è Errore generico durante il controllo aggiornamento: {e}")
            
    # Controllo Manuale Forzato degli Aggiornamenti Software
    def forza_check_aggiornamento_con_api(self):
        import time
        from datetime import datetime, timedelta
        import subprocess, sys, os
        if os.path.exists(RIMANDA_FILE):
            try:
                os.remove(RIMANDA_FILE)
                print("File rimando cancellato per la verifica manuale forzata.")
            except Exception as e:
                print(f"‚ö†Ô∏è Errore durante la cancellazione del file rimando: {e}")
        try:
            api_url = f"https://api.github.com/repos/{REPO_OWNER}/{REPO_NAME}/commits"
            params = {"path": NOME_FILE, "per_page": 1}
            response = requests.get(api_url, params=params, timeout=5)
            response.raise_for_status()
            commits = response.json()
            if not commits:
                self.show_custom_warning("Controllo Aggiornamento", "‚ö†Ô∏è Nessun commit trovato. Impossibile verificare lo stato.")
                return 
            commit_date = commits[0]["commit"]["committer"]["date"]
            remote_time = datetime.strptime(commit_date, "%Y-%m-%dT%H:%M:%SZ").replace(microsecond=0)
            changelog_text = ""
            for commit in commits:
                date_str = commit["commit"]["committer"]["date"]
                commit_dt = datetime.strptime(date_str, "%Y-%m-%dT%H:%M:%SZ")
                message = commit["commit"]["message"].strip()
                message = message.replace('\r', '') 
                lines = message.split('\n')
                subject = lines[0] 
                body_lines = lines[1:] 
                start_index = 0
                while start_index < len(body_lines):
                    current_line = body_lines[start_index].strip()
                    if not current_line or current_line == subject.strip():
                        start_index += 1
                    else:
                        break
                body_lines = body_lines[start_index:]
                changelog_entry = f"üìù [{commit_dt.strftime('%d/%m/%y %H:%M')}] {subject}\n"
                if body_lines:
                    for line in body_lines:
                        if line.strip(): 
                            changelog_entry += f" ‚û°Ô∏è {line}\n"
                        else:
                             changelog_entry += "\n"
                changelog_entry += "\n" 
                changelog_text += changelog_entry
            if not os.path.exists(NOME_FILE):
                if self.state() == 'iconic':
                    self.deiconify()
                    self.lift()
                    self.focus_force()
                self.show_custom_warning(
                    "File mancante", 
                    f"‚ö†Ô∏è File '{NOME_FILE}' non trovato (rinominato o rimosso).\n\n"
                    "Vai in 'Opzioni' -> 'Forza Aggiornamento Software' per ripristinarlo."
                )
                return
            local_time = datetime.utcfromtimestamp(os.path.getmtime(NOME_FILE)).replace(microsecond=0)
            if remote_time.date() > local_time.date():
                win = tk.Toplevel(self, bg=self.COLOR_UPDATE)
                win.title("üîÑ Aggiornamento disponibile")
                win.bind('<Escape>', lambda e: win.destroy())
                frame_timer = tk.Frame(win, bg=self.COLOR_UPDATE)
                frame_timer.pack(fill="x", pady=(10, 0))
                label_timer = ttk.Label(frame_timer, text="‚è±Ô∏è Chiusura automatica tra 60 secondi", style="Timer.TLabel")
                label_timer.pack(pady=(10, 0))
                msg = (
                    "üÜï √à stato rilevato un possibile aggiornamento.\n\n"
                    f"üì° Ultima versione online: {remote_time.strftime('%d/%m/%Y %H:%M')}\n"
                    f"üñ•Ô∏è Versione attuale locale: {local_time.strftime('%d/%m/%Y %H:%M')}"
                )
                tk.Label(win, bg=self.COLOR_UPDATE, text=msg, wraplength=460, justify=tk.LEFT).pack(padx=20, pady=(10, 0))
                tk.Label(win, text="Storico Modifiche (Changelog):", bg=self.COLOR_UPDATE).pack(pady=(10, 0))
                frame_changelog = ttk.Frame(win)
                frame_changelog.pack(padx=20, pady=(5, 10), fill='both', expand=True)
                scrollbar = ttk.Scrollbar(frame_changelog)
                scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
                text_area = tk.Text(frame_changelog, wrap=tk.WORD, yscrollcommand=scrollbar.set, height=6, width=60, font=("Arial", 9))
                text_area.insert(tk.END, changelog_text.strip())
                text_area.config(state=tk.DISABLED, background="#ADD8E6") 
                text_area.pack(side=tk.LEFT, fill='both', expand=True)
                scrollbar.config(command=text_area.yview)
                tk.Label(win, text="üëâ Vuoi procedere con l'aggiornamento adesso?", bg=self.COLOR_UPDATE).pack(pady=(5, 10))
                frame_bottoni = tk.Frame(win, bg=self.COLOR_UPDATE)
                frame_bottoni.pack(pady=10)
                def aggiorna_timer(secondi_rimasti):
                    if secondi_rimasti > 0:
                        colore = "red" if secondi_rimasti <= 10 else "black"
                        label_timer.config(text=f"‚è±Ô∏è Chiusura automatica tra {secondi_rimasti} secondi")
                        win.after(1000, aggiorna_timer, secondi_rimasti - 1)
                    else:
                        label_timer.config(text="‚è±Ô∏è Chiusura automatica...")
                        win.destroy()
                timeout_id = win.after(60000, win.destroy)
                aggiorna_timer(60)
                def annulla_timeout():
                    win.after_cancel(timeout_id)
                def aggiorna():
                    annulla_timeout()
                    url = f"https://raw.githubusercontent.com/{REPO_OWNER}/{REPO_NAME}/main/{NOME_FILE.replace(' ', '%20')}"
                    win.destroy()
                    try:
                        nome_backup = f"{NOME_FILE}.bak"
                        if os.path.exists(NOME_FILE):
                            shutil.copy2(NOME_FILE, nome_backup)
                        urllib.request.urlretrieve(url, NOME_FILE)
                        print(f"Download completato! {NOME_FILE} √® stato aggiornato.")
                        if os.path.exists(RIMANDA_FILE):
                            try:
                                os.remove(RIMANDA_FILE)
                                print("File rimando eliminato dopo aggiornamento.")
                            except Exception as err:
                                print(f"‚ö†Ô∏è Errore durante l'eliminazione del file rimando: {err}")
                        messaggio = "üîÑ Riavvio in corso. File aggiornato! ATTENDERE..."
                        duration_s = 2 
                        width = 350
                        height = 80
                        popup_win = tk.Toplevel(self)
                        popup_win.overrideredirect(True) 
                        popup_win.resizable(False, False)
                        w_root, h_root = self.winfo_width(), self.winfo_height()
                        x_root, y_root = self.winfo_rootx(), self.winfo_rooty()
                        x_pos = (w_root // 2) - (width // 2)
                        y_pos = (h_root // 2) - (height // 2)
                        popup_win.geometry(f"{width}x{height}+{x_root + x_pos}+{y_root + y_pos}")
                        popup_frame = tk.Frame(popup_win, bg="orange", bd=3, relief="raised")
                        popup_frame.pack(expand=True, fill='both')
                        tk.Label(popup_frame, text=messaggio, font=("Arial", 10, "bold"), 
                                 justify="center", padx=10, pady=10, bg="orange", fg="black").pack(expand=True, fill='both')
                        popup_win.lift() 
                        try:
                            popup_win.attributes('-topmost', True) 
                        except:
                            pass
                        self.update() 
                        time.sleep(duration_s)
                        script_path = os.path.abspath(sys.argv[0])
                        args = [sys.executable, script_path] + sys.argv[1:]
                        subprocess.Popen(args, start_new_session=True, close_fds=True)
                        os._exit(0)
                    except Exception as e:
                        if 'shutil' in sys.modules and os.path.exists(nome_backup):
                            shutil.copy2(nome_backup, NOME_FILE)
                            os.remove(nome_backup)
                        self.show_custom_warning("Attenzione", f"‚ùå Aggiornamento fallito durante il download/riavvio:\n{e}")
                        return
                def chiudi():
                    annulla_timeout()
                    win.destroy()
                def rimanda():
                    annulla_timeout()
                    win.destroy()
                    nuova_data = datetime.today() + timedelta(days=15)
                    with open(RIMANDA_FILE, "w") as f:
                        json.dump({"rimanda_fino": nuova_data.strftime("%Y-%m-%d")}, f)
                    print(f"‚è≥ Rimandato fino al {nuova_data.date()}")
                    data_formattata = nuova_data.date().strftime("%d/%m/%Y")
                    self.show_custom_warning("Aggiornamento Rimandato", f"‚è≥ Aggiornamento Rimandato fino al {data_formattata}")
                ttk.Button(frame_bottoni, text="üîÑ AGGIORNA", command=aggiorna, style="Verde.TButton").pack(side="left", padx=5)
                ttk.Button(frame_bottoni, text="‚ùå CHIUDI", command=chiudi, style="Giallo.TButton").pack(side="left", padx=5)
                ttk.Button(frame_bottoni, text="‚è≥ RIMANDA", command=rimanda, style="Arancio.TButton").pack(side="left", padx=5)
                win.withdraw()
                win.update_idletasks()
                min_w, min_h = 660, 410
                w = max(win.winfo_width(), min_w)
                h = max(win.winfo_height(), min_h)
                x = self.winfo_rootx() + (self.winfo_width() // 2) - (w // 2)
                y = self.winfo_rooty() + (self.winfo_height() // 2) - (h // 2)
                win.geometry(f"{w}x{h}+{x}+{y}")
                win.deiconify()
                win.grab_set()
                win.transient(self)
                win.focus_set()
                win.wait_window()
            else:
                self.show_custom_warning("Controllo Manuale", "‚úÖ Nessun nuovo aggiornamento software disponibile. Sei gi√† all'ultima versione.")
                return
        except ConnectionError:
            print("üåê Connessione assente o GitHub non raggiungibile.")
        except RequestException as e:
            print(f"‚ö†Ô∏è Errore HTTP o API: {e}")
        except Exception as e:
            print(f"‚ö†Ô∏è Errore generico durante il controllo aggiornamento: {e}")
    
    # Funzione di Ripristino del Software da Backup Locale con Riavvio
    def ripristina_da_backup(self):
        import time
        import subprocess, sys, os
        nome_backup = f"{NOME_FILE}.bak"
        if not os.path.exists(nome_backup):
            self.show_custom_info("Non Riuscito", 
                                  f"‚ùå File di backup ({nome_backup}) non trovato. Impossibile procedere al ripristino.")
            return
        conferma = self.show_custom_askyesno(
            title="Ripristino",
            message=f"Sei sicuro di voler ripristinare il file '{NOME_FILE}' dalla copia di backup?\n\n"
                    f"Questo annuller√† l'ultima modifica/aggiornamento e riavvier√† l'applicazione."
        )
        if not conferma:
            self.show_custom_warning("Annullato", "Ripristino annullato dall'utente.")
            return
        try:
            shutil.copy2(nome_backup, NOME_FILE)
            os.remove(nome_backup)
            self.save_db()
            self._on_close_lock() 
            messaggio = "Riavvio in corso. File aggiornato! ATTENDERE..."
            duration_s = 2
            width = 350
            height = 80
            parent = self
            parent.update_idletasks()
            parent_width = parent.winfo_width()
            parent_height = parent.winfo_height()
            x_pos = (parent_width // 2) - (width // 2)
            y_pos = (parent_height // 2) - (height // 2)
            popup_frame = tk.Frame(parent, bg="orange", bd=3, relief="raised")
            popup_frame.place(x=x_pos, y=y_pos, width=width, height=height)
            popup_frame.lift()
            label = tk.Label(popup_frame, text=messaggio, font=("Arial", 10, "bold"), 
                              justify="center", padx=10, pady=10, bg="orange", fg="black")
            label.pack(expand=True, fill='both')
            parent.update() 
            time.sleep(duration_s)
            script_path = os.path.abspath(sys.argv[0])
            args = [sys.executable, script_path] + sys.argv[1:]
            subprocess.Popen(args, start_new_session=True, close_fds=True)
            os._exit(0)
        except Exception as e:
            self.show_custom_warning("Errore Grave", 
                                     f"üõë Errore critico durante il ripristino del file:\n{e}")

    # Visualizzazione Dettagliata dello Storico Modifiche (Changelog Manuale)
    def visualizza_changelog(self):
        from datetime import datetime
        api_url = f"https://api.github.com/repos/{REPO_OWNER}/{REPO_NAME}/commits"
        params = {"path": NOME_FILE, "per_page": 20} 
        changelog_text = ""
        try:
            response = requests.get(api_url, params=params, timeout=10)
            response.raise_for_status()
            commits = response.json()
            if not commits:
                self.show_custom_info("Changelog Vuoto", "‚ö†Ô∏è Nessuno storico di commit trovato per questo file.")
                return
            for commit in commits:
                date_str = commit["commit"]["committer"]["date"]
                commit_dt = datetime.strptime(date_str, "%Y-%m-%dT%H:%M:%SZ")
                message = commit["commit"]["message"].strip()
                message = message.replace('\r', '')
                lines = message.split('\n')
                subject = lines[0]
                body_lines = lines[1:]
                start_index = 0
                while start_index < len(body_lines):
                    current_line = body_lines[start_index].strip()
                    if not current_line or current_line == subject.strip():
                        start_index += 1
                    else:
                        break
                body_lines = body_lines[start_index:]
                changelog_entry = f"üìù [{commit_dt.strftime('%d/%m/%y %H:%M')}] {subject}\n"
                if body_lines:
                    for line in body_lines:
                        if line.strip(): 
                            changelog_entry += f" ‚û°Ô∏è {line}\n"
                        else:
                            changelog_entry += "\n"
                changelog_entry += "\n"  
                changelog_text += changelog_entry
            win = tk.Toplevel(self, bg=self.COLOR_UPDATE)
            win.title(f"üìÑ Storico Modifiche: {NOME_FILE}")
            win.bind('<Escape>', lambda e: win.destroy())
            tk.Label(win, text="Storico degli ultimi commit da GitHub:", bg=self.COLOR_UPDATE, font=("Arial", 10, "bold")).pack(pady=(10, 0))
            frame_changelog = ttk.Frame(win)
            frame_changelog.pack(padx=20, pady=(5, 10), fill='both', expand=True)
            scrollbar = ttk.Scrollbar(frame_changelog)
            scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
            text_area = tk.Text(frame_changelog, wrap=tk.WORD, yscrollcommand=scrollbar.set, height=15, width=80, font=("Arial", 9))
            text_area.insert(tk.END, changelog_text.strip())
            text_area.config(state=tk.DISABLED, background="#ADD8E6") 
            text_area.pack(side=tk.LEFT, fill='both', expand=True)
            scrollbar.config(command=text_area.yview)
            ttk.Button(win, text="‚ùå Chiudi", command=win.destroy, style="Giallo.TButton").pack(pady=(0, 10))
            win.withdraw()
            win.update_idletasks()
            min_w, min_h = 660, 410
            w = max(win.winfo_width(), min_w)
            h = max(win.winfo_height(), min_h)
            x = self.winfo_rootx() + (self.winfo_width() // 2) - (w // 2)
            y = self.winfo_rooty() + (self.winfo_height() // 2) - (h // 2)
            win.geometry(f"{w}x{h}+{x}+{y}")
            win.deiconify()
            win.transient(self)
            win.focus_set()
            win.wait_window()
        except requests.exceptions.RequestException as e:
            self.show_custom_warning("Errore Connessione", f"‚ö†Ô∏è Impossibile connettersi a GitHub:\n{e}")
        except Exception as e:
            self.show_custom_warning("Errore", f"‚ùå Errore generico durante la visualizzazione dello storico:\n{e}")
                  
    # Creazione e Archiviazione (ZIP/Formato Specifico) Completa             
    def esegui_backup_zip(self):
        from datetime import datetime
        percorso_archivio = ""
        cartella_temp_path = None
        print(f"‚úÖ Tentativo di backup di '{self.current_folder}'...")
        try:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            default_name = f"{self.current_folder}_backup_{timestamp}"
            percorso_completo_output = filedialog.asksaveasfilename(
                title="Scegli dove salvare il file di backup",
                initialdir=os.path.expanduser('~'),
                initialfile=default_name,
                confirmoverwrite=False,
                defaultextension=f".{self.backup_formato}",
                filetypes=[(f"Archivi {self.backup_formato.upper()}", f"*.{self.backup_formato}")]
            )
            if not percorso_completo_output:
                print("‚ùå Backup annullato dall'utente.")
                return ""
            popup = Toplevel(self)
            popup.overrideredirect(True)
            bg_color = self.COLOR_WIDGET_BG
            text_color = self.COLOR_HEADER
            accent_color = self.COLOR_HIGHLIGHT
            popup.configure(bg=bg_color, highlightbackground=accent_color, highlightthickness=2)
            w, h = 380, 120
            x = self.winfo_x() + (self.winfo_width() // 2) - (w // 2)
            y = self.winfo_y() + (self.winfo_height() // 2) - (h // 2)
            popup.geometry(f"{w}x{h}+{x}+{y}")
            popup.grab_set()
            lbl_status = Label(
                popup, 
                text="Inizializzazione backup...", 
                font=("Arial", 10, "bold"),
                bg=bg_color,
                fg=text_color
            )
            lbl_status.pack(pady=(25, 5))
            progress = ttk.Progressbar(
                popup, 
                orient="horizontal", 
                length=320, 
                mode="determinate",
                style="Backup.Horizontal.TProgressbar"
            )
            progress.pack(pady=10)
            def aggiorna_UI(valore, testo):
                progress['value'] = valore
                lbl_status.config(text=testo)
                popup.update()
            aggiorna_UI(15, "Preparazione file temporanei...")
            percorso_output_senza_ext, _ = os.path.splitext(percorso_completo_output)
            cartella_destinazione = os.path.dirname(percorso_output_senza_ext)
            root_dir_compress = os.path.dirname(os.getcwd())
            cartella_sorgente = os.path.join(root_dir_compress, self.current_folder)
            cartella_temp_path = tempfile.mkdtemp()
            cartella_dati_nel_temp_nome = self.current_folder
            cartella_dati_nel_temp_path = os.path.join(cartella_temp_path, cartella_dati_nel_temp_nome)
            aggiorna_UI(40, f"Copia dati: {self.current_folder}...")
            PATTERNS_DA_IGNORARE = ('*.lock', '*-journal', '*.db-wal', '*.tmp')
            shutil.copytree(
                cartella_sorgente,
                cartella_dati_nel_temp_path,
                ignore=shutil.ignore_patterns(*PATTERNS_DA_IGNORARE)
            )
            aggiorna_UI(75, "Compressione archivio finale...")
            os.makedirs(cartella_destinazione, exist_ok=True)
            percorso_archivio = shutil.make_archive(
                base_name=percorso_output_senza_ext,
                format=self.backup_formato,
                root_dir=cartella_temp_path,
                base_dir=cartella_dati_nel_temp_nome
            )
            aggiorna_UI(100, "Operazione completata!")
            popup.after(400, popup.destroy)
            self.show_custom_warning("Backup", f"Salvataggio di '{self.current_folder}' eseguito con successo!")
        except Exception as e:
            if 'popup' in locals():
                popup.destroy()
            print(f"‚ùå ERRORE: {e}")
            self.show_custom_warning("Errore", f"Errore durante il backup:\n{e}")
        finally:
            if cartella_temp_path and os.path.exists(cartella_temp_path):
                shutil.rmtree(cartella_temp_path, ignore_errors=True)
                print("‚úÖ Pulizia file temporanei eseguita.")
        
    # Finestra di Configurazione Avanzata e Gestione delle Preferenze Utente 
    def gestisci_configurazione(self):
        if hasattr(self, 'ferma_scorrimento_automatico'):
            try: self.ferma_scorrimento_automatico()
            except: pass
        if hasattr(self, 'btn_ciclico_carosello'):
            self.btn_ciclico_carosello.configure(variable="") 
            self.btn_ciclico_carosello.state(['!active', '!selected', '!alternate'])
            self.btn_ciclico_carosello.update_idletasks()
        if not self.winfo_exists():
            return
        try:
            with open(CONFIG_FILE, 'r', encoding='utf-8') as f:
                config = json.load(f)
        except (FileNotFoundError, json.JSONDecodeError):
            config = DEFAULT_CONFIG.copy()
        use_wait_window_iniziale = config.get("use_wait_window", DEFAULT_CONFIG.get("use_wait_window", False))
        warn_timeout_ms_iniziale = config.get("warn_timeout_ms", DEFAULT_CONFIG.get("warn_timeout_ms", 20000))
        timeout_sec_iniziale = round(warn_timeout_ms_iniziale / 1000)
        timeout_sec_iniziale = max(5, min(60, timeout_sec_iniziale))
        ico_set_date_iniziale = config.get("ico_set_date", DEFAULT_CONFIG["ico_set_date"])
        recurring_reminder_iniziale = config.get("enable_recurring_reminder", DEFAULT_CONFIG["enable_recurring_reminder"])
        max_backup_iniziale = config.get("max_backup", DEFAULT_CONFIG.get("max_backup", 10))
        max_backup_iniziale = max(1, min(10, max_backup_iniziale))
        soglia_giorni_ricorrenti_iniziale = config.get("soglia_giorni_ricorrenti", DEFAULT_CONFIG.get("soglia_giorni_ricorrenti", 5))
        soglia_giorni_ricorrenti_iniziale = max(1, min(10, soglia_giorni_ricorrenti_iniziale))
        timeout_ms_iniziale = config.get("inactivity_timeout_ms", DEFAULT_CONFIG["inactivity_timeout_ms"])
        timeout_minuti_iniziale = round(timeout_ms_iniziale / 60000)
        timeout_minuti_iniziale = max(5, min(60, timeout_minuti_iniziale))
        anni_da_mantenere_iniziale = config.get("anni_da_mantenere", DEFAULT_CONFIG["anni_da_mantenere"])
        anni_da_mantenere_iniziale = max(2, min(15, anni_da_mantenere_iniziale))
        iconizza_inattivita_iniziale = config.get("iconizza_inattivita", DEFAULT_CONFIG["iconizza_inattivita"])
        smartcat_enabled_iniziale = config.get("smartcat_enabled", DEFAULT_CONFIG.get("smartcat_enabled", True))
        bank_link_iniziale = config.get("bank_link", DEFAULT_CONFIG.get("bank_link", ""))
        thema_iniziale = config.get("thema", DEFAULT_CONFIG.get("thema", "MATERIAL"))
        carosello_enabled_iniziale = config.get("carosello_enabled", DEFAULT_CONFIG.get("carosello_enabled", True))
        carosello_intervallo_iniziale = config.get("carosello_intervallo", DEFAULT_CONFIG.get("carosello_intervallo", 10000))
        carosello_intervallo_sec_iniziale = round(carosello_intervallo_iniziale / 1000)
        carosello_intervallo_sec_iniziale = max(5, min(30, carosello_intervallo_sec_iniziale))
        config_window = Toplevel(self)
        config_window.title("‚öôÔ∏è Configurazione Applicazione")
        config_window.bind('<Escape>', lambda e: config_window.destroy())
        config_window.resizable(False, False)
        self.var_use_wait_window = tk.BooleanVar(value=use_wait_window_iniziale)
        self.var_warn_timeout_sec = tk.DoubleVar(value=timeout_sec_iniziale)
        self.var_ico_set_date = tk.BooleanVar(value=ico_set_date_iniziale)
        self.var_recurring_reminder = tk.BooleanVar(value=recurring_reminder_iniziale)
        self.var_max_backup = tk.IntVar(value=max_backup_iniziale)
        self.var_soglia_ricorrenti = tk.IntVar(value=soglia_giorni_ricorrenti_iniziale)
        self.var_smartcat_enabled = tk.BooleanVar(value=smartcat_enabled_iniziale)
        self.var_auto_login = tk.BooleanVar(value=config.get("enable_auto_login_flow", DEFAULT_CONFIG["enable_auto_login_flow"]))
        self.var_webserver_enabled = tk.BooleanVar(value=config.get("webserver_enabled", DEFAULT_CONFIG["webserver_enabled"]))
        self.var_timeout_minuti = tk.DoubleVar(value=timeout_minuti_iniziale)
        self.var_port = tk.IntVar(value=config.get("webserver_port", DEFAULT_CONFIG["webserver_port"]))
        self.var_bank_link = tk.StringVar(value=bank_link_iniziale)
        self.var_load_geometry = tk.BooleanVar(value=config.get("load_saved_geometry", DEFAULT_CONFIG["load_saved_geometry"]))
        self.var_anni_da_mantenere = tk.IntVar(value=anni_da_mantenere_iniziale)
        self.var_iconizza_inattivita = tk.BooleanVar(value=iconizza_inattivita_iniziale)
        self.var_thema = tk.StringVar(value=thema_iniziale.capitalize())
        self.var_carosello_enabled = tk.BooleanVar(value=carosello_enabled_iniziale)
        self.var_carosello_intervallo_sec = tk.DoubleVar(value=carosello_intervallo_sec_iniziale)
        self.var_cal_tooltips = tk.BooleanVar(value=config.get("cal_tooltips_enabled", False))
        main_frame = ttk.Frame(config_window, padding="10 10 10 5")
        main_frame.pack(fill="both", expand=True)
        main_frame.columnconfigure(0, weight=1)
        main_frame.columnconfigure(1, weight=1)
        main_frame.columnconfigure(2, weight=0)
        warn_timeout_label = ttk.Label(main_frame, text="")
        timeout_label = ttk.Label(main_frame, text="")
        anni_label = ttk.Label(main_frame, text="")
        max_backup_label = ttk.Label(main_frame, text="")
        soglia_ricorrenti_label = ttk.Label(main_frame, text="")
        carosello_intervallo_label = ttk.Label(main_frame, text="")
        def update_warn_timeout_label(value):
            current_sec = int(round(self.var_warn_timeout_sec.get()))
            warn_timeout_label.config(text=f"{current_sec} Secondi")
        def update_timeout_label(value):
            current_minuti = int(round(self.var_timeout_minuti.get()))
            timeout_label.config(text=f"{current_minuti} Minuti")
        def update_anni_label(value):
            current_anni = int(round(self.var_anni_da_mantenere.get()))
            anni_label.config(text=f"{current_anni} Anni")
        def update_max_backup_label(value):
            current_val = int(round(self.var_max_backup.get()))
            max_backup_label.config(text=f"{current_val} Copie")
        def update_soglia_ricorrenti_label(value):
            current_val = int(round(self.var_soglia_ricorrenti.get()))
            soglia_ricorrenti_label.config(text=f"{current_val} Giorni")
        def update_carosello_intervallo_label(value):
            current_sec = int(round(self.var_carosello_intervallo_sec.get()))
            carosello_intervallo_label.config(text=f"{current_sec} Secondi")
        def reset_defaults():
            self.var_auto_login.set(DEFAULT_CONFIG["enable_auto_login_flow"])
            self.var_webserver_enabled.set(DEFAULT_CONFIG["webserver_enabled"])
            self.var_port.set(DEFAULT_CONFIG["webserver_port"])
            self.var_bank_link.set(DEFAULT_CONFIG.get("bank_link", ""))
            self.var_load_geometry.set(DEFAULT_CONFIG["load_saved_geometry"])
            self.var_use_wait_window.set(DEFAULT_CONFIG.get("use_wait_window", False))
            default_timeout_min = round(DEFAULT_CONFIG["inactivity_timeout_ms"] / 60000)
            self.var_timeout_minuti.set(max(5, default_timeout_min))
            update_timeout_label(self.var_timeout_minuti.get())
            self.var_anni_da_mantenere.set(DEFAULT_CONFIG["anni_da_mantenere"])
            update_anni_label(self.var_anni_da_mantenere.get())
            self.var_iconizza_inattivita.set(DEFAULT_CONFIG["iconizza_inattivita"])
            self.var_ico_set_date.set(DEFAULT_CONFIG["ico_set_date"])
            self.var_recurring_reminder.set(DEFAULT_CONFIG.get("enable_recurring_reminder", False))
            self.var_max_backup.set(max(1, min(10, DEFAULT_CONFIG.get("max_backup", 10))))
            update_max_backup_label(self.var_max_backup.get())
            self.var_soglia_ricorrenti.set(max(1, min(10, DEFAULT_CONFIG.get("soglia_giorni_ricorrenti", 5))))
            update_soglia_ricorrenti_label(self.var_soglia_ricorrenti.get())
            self.var_smartcat_enabled.set(DEFAULT_CONFIG.get("smartcat_enabled", True))
            self.var_thema.set(DEFAULT_CONFIG.get("thema", "MATERIAL").capitalize())
            self.var_carosello_enabled.set(DEFAULT_CONFIG.get("carosello_enabled", True))
            default_carosello_sec = round(DEFAULT_CONFIG.get("carosello_intervallo", 10000) / 1000)
            self.var_carosello_intervallo_sec.set(max(5, min(30, default_carosello_sec)))
            update_carosello_intervallo_label(self.var_carosello_intervallo_sec.get())
            self.var_cal_tooltips.set(False)
            self.show_custom_info("Reset", "Impostazioni ripristinate ai valori predefinite. Clicca su Salva per applicare.")
        def chiudi_config():
            config_window.destroy()
        def salva_e_chiudi():
            try:
                anni = self.var_anni_da_mantenere.get()
                if anni < 2 or anni > 15:
                    raise ValueError("Anni da mantenere deve essere tra 2 e 15.")
                max_backup = self.var_max_backup.get()
                if max_backup < 1 or max_backup > 10:
                    raise ValueError("Il numero massimo di backup deve essere tra 1 e 10.")
                soglia_giorni = self.var_soglia_ricorrenti.get()
                if soglia_giorni < 1 or soglia_giorni > 10:
                    raise ValueError("La soglia giorni ricorrenti deve essere tra 1 e 10.")
                timeout_minuti = round(self.var_timeout_minuti.get())
                if timeout_minuti < 5 or timeout_minuti > 60:
                    raise ValueError("Timeout Inattivit√† deve essere tra 5 e 60 minuti.")
                timeout_ms = int(timeout_minuti * 60000)
                warn_timeout_sec = round(self.var_warn_timeout_sec.get())
                if warn_timeout_sec < 5 or warn_timeout_sec > 60:
                    raise ValueError("Timeout Avviso Popup deve essere tra 5 e 60 secondi.")
                warn_timeout_ms = int(warn_timeout_sec * 1000)
                webserver_port = self.var_port.get()
                if webserver_port < 1024 or webserver_port > 65535:
                    raise ValueError("La porta Webserver non √® valida (range 1024-65535).")
                carosello_intervallo_sec = round(self.var_carosello_intervallo_sec.get())
                if carosello_intervallo_sec < 5 or carosello_intervallo_sec > 30:
                    raise ValueError("L'intervallo Carosello deve essere tra 5 e 30 secondi.")
                carosello_intervallo_ms = int(carosello_intervallo_sec * 1000)
                nuova_config = {
                    "enable_auto_login_flow": self.var_auto_login.get(),
                    "webserver_enabled": self.var_webserver_enabled.get(),
                    "inactivity_timeout_ms": timeout_ms,
                    "webserver_port": webserver_port,
                    "bank_link": self.var_bank_link.get(),
                    "load_saved_geometry": self.var_load_geometry.get(),
                    "anni_da_mantenere": anni,
                    "iconizza_inattivita": self.var_iconizza_inattivita.get(),
                    "ico_set_date": self.var_ico_set_date.get(),
                    "enable_recurring_reminder": self.var_recurring_reminder.get(),
                    "max_backup": max_backup,
                    "soglia_giorni_ricorrenti": soglia_giorni,
                    "smartcat_enabled": self.var_smartcat_enabled.get(),
                    "use_wait_window": self.var_use_wait_window.get(),
                    "warn_timeout_ms": warn_timeout_ms,
                    "thema": self.var_thema.get().upper(),
                    "carosello_enabled": self.var_carosello_enabled.get(),
                    "carosello_intervallo": carosello_intervallo_ms,
                    "cal_tooltips_enabled": self.var_cal_tooltips.get(),
                }
                if not os.path.exists(DB_DIR):
                    os.makedirs(DB_DIR)
                with open(CONFIG_FILE, 'w', encoding='utf-8') as f:
                    json.dump(nuova_config, f, indent=4)
                self.suggerimenti_attivi = self.var_smartcat_enabled.get()
                if config_window.winfo_exists():
                    config_window.destroy()
                riavvia_subito = self.show_custom_askyesno(
                    title="Riavvio Necessario",
                    message="Per applicare completamente alcune modifiche\n(es. porta WebServer, timeout, pulizia database, tema)\n√® necessario riavviare l'applicazione.\n\nRiavviare ora?"
                )
                if riavvia_subito:
                    riavvia_app_definitivo()
                else:
                    self.show_custom_warning("Riavvio in Sospeso", "‚ö†Ô∏è Riavvio posticipato. Le modifiche saranno applicate al prossimo avvio manuale.")
            except ValueError as e:
                self.show_custom_info("Errore di Validazione", str(e))
            except Exception as e:
                self.show_custom_info("Errore di Salvataggio", f"Impossibile salvare la configurazione: {e}")
        def riavvia_app_definitivo():
            import subprocess, sys, os
            if self.winfo_exists():
                self.destroy()
            script_path = os.path.abspath(sys.argv[0])
            args = [sys.executable, script_path] + sys.argv[1:]
            subprocess.Popen(args, start_new_session=True, close_fds=True)
            os._exit(0)
        def create_checkbutton(parent, label_text, variable, row):
            check = ttk.Checkbutton(parent, variable=variable, text=label_text)
            check.grid(row=row, column=0, columnspan=2, sticky="w", pady=1, padx=(0, 10))
        def create_entry(parent, label_text, variable, row, width=None):
            label = ttk.Label(parent, text=label_text)
            label.grid(row=row, column=0, sticky="w", pady=1, padx=(0, 10))
            entry = ttk.Entry(parent, textvariable=variable, width=width)
            sticky_val = "ew" if width is None else "w"
            entry.grid(row=row, column=1, columnspan=2, sticky=sticky_val, pady=1, padx=(0, 5))
        def create_combobox(parent, label_text, variable, values, row):
            label = ttk.Label(parent, text=label_text)
            label.grid(row=row, column=0, sticky="w", pady=1, padx=(0, 10))
            combo = ttk.Combobox(
                parent,
                textvariable=variable,
                values=values,
                style="Border.TCombobox",
                state="readonly",
                width=10
            )
            combo.grid(row=row, column=2, sticky="w", pady=1)
        def create_slider_row(parent, label_text, from_val, to_val, variable, command_func, label_widget, row, units=""):
            label = ttk.Label(parent, text=label_text)
            label.grid(row=row, column=0, sticky="w", pady=1)
            slider = ttk.Scale(
                parent,
                from_=from_val,
                to=to_val,
                orient="horizontal",
                length=150, 
                variable=variable,
                command=command_func
            )
            slider.grid(row=row, column=1, pady=1, padx=5, sticky="ew")
            label_widget.grid(row=row, column=2, sticky="w", pady=1)
            command_func(variable.get()) 
        def mostra_help_configurazione():
            fixed_width = 1000
            fixed_height = 550
            help_window = Toplevel(config_window)
            help_window.title("‚ùì Aiuto Dettagliato Configurazione")
            help_window.resizable(False, False)
            help_window.configure(bg="#f0f0f0")
            help_window.transient(config_window)
            help_window.grab_set()
            help_window.focus_set()
            help_window.bind('<Escape>', lambda e: help_window.destroy())
            help_window.withdraw()
            main_container = ttk.Frame(help_window, padding="10")
            main_container.pack(fill="both", expand=True)
            ttk.Label(main_container, text="Manuale d'uso - Opzioni di Configurazione", 
                      font=("Arial", 12, "bold"), foreground="#00529B").pack(pady=(0, 10))
            notebook = ttk.Notebook(main_container)
            notebook.pack(fill="both", expand=True, pady=(0, 10))
            def crea_tab(titolo):
                frame = ttk.Frame(notebook, padding="10")
                notebook.add(frame, text=titolo)
                return frame
            tab1 = crea_tab("ü§ñ Automatismo & Web")
            ttk.Label(tab1, text="‚Ä¢ Flusso Login/Iconizza: Riduce l'app a icona all'avvio.", wraplength=930).pack(anchor="w", pady=2)
            ttk.Label(tab1, text="‚Ä¢ Attiva SmartCat: Suggerimento automatico delle categorie.", wraplength=930).pack(anchor="w", pady=2)
            ttk.Label(tab1, text="‚Ä¢ Web Server: Accesso locale via browser (Richiede riavvio).", wraplength=930).pack(anchor="w", pady=2)
            ttk.Label(tab1, text="‚Ä¢ Porta Web Server: Range consigliato 1024-65535.", wraplength=930).pack(anchor="w", pady=2)
            ttk.Label(tab1, text="‚Ä¢ Link Banca: URL rapido per accesso web banking.", wraplength=930).pack(anchor="w", pady=2)
            tab2 = crea_tab("üñ•Ô∏è Interfaccia & Window")
            tab2_inner = ttk.Frame(tab2, padding="15 5 15 5")
            tab2_inner.pack(fill="both", expand=True)
            ttk.Label(tab2_inner, text="‚Ä¢ Carica Posizione: Ripristina coordinate e dimensioni finestra.", wraplength=900).pack(anchor="w", pady=3)
            ttk.Separator(tab2_inner, orient='horizontal').pack(fill='x', pady=8)
            lbl_tt = ttk.Label(tab2_inner, 
                               text="‚Ä¢ ABILITA TOOLTIPS CALENDARIO (Sperimentale)\nVisualizza un popup con il dettaglio delle spese passando il mouse sopra i giorni.\nConsente una consultazione immediata senza dover generare report separati.", 
                               foreground="#2E86C1", 
                               wraplength=900,
                               justify="left")
            lbl_tt.pack(anchor="w", pady=5)
            ttk.Separator(tab2_inner, orient='horizontal').pack(fill='x', pady=8)
            ttk.Label(tab2_inner, text="‚Ä¢ Aggiorna Data al Ripristino: Imposta data su 'Oggi' alla riapertura.", wraplength=900).pack(anchor="w", pady=3)
            ttk.Label(tab2_inner, text="‚Ä¢ Avvisi Bloccanti: I popup richiedono l'interazione dell'utente.", wraplength=900).pack(anchor="w", pady=3)
            ttk.Label(tab2_inner, text="‚Ä¢ Timer Auto-Chiusura: Secondi di permanenza dei messaggi a schermo.", wraplength=900).pack(anchor="w", pady=3)
            ttk.Label(tab2_inner, text="‚Ä¢ Iconizza per Inattivit√†: Riduce l'app a icona dopo il timeout.", wraplength=900).pack(anchor="w", pady=3)
            ttk.Label(tab2_inner, text="‚Ä¢ Tema UI: Selezione tra modalit√† Chiaro e Material.", wraplength=900).pack(anchor="w", pady=3)
            tab3 = crea_tab("üìä Carosello & Alert")
            ttk.Label(tab3, text="‚Ä¢ Abilita Carosello: Scorrimento statistiche quando inattiva.", wraplength=930).pack(anchor="w", pady=2)
            ttk.Label(tab3, text="‚Ä¢ Intervallo Carosello: Secondi tra un cambio e l'altro (5-30s).", wraplength=930).pack(anchor="w", pady=2)
            ttk.Label(tab3, text="‚Ä¢ Promemoria Mensile: Alert se mancano categorie a fine mese.", wraplength=930).pack(anchor="w", pady=2)
            ttk.Label(tab3, text="‚Ä¢ Soglia Anticipo: Quanti giorni prima della fine mese attivare l'alert.", wraplength=930).pack(anchor="w", pady=2)
            tab4 = crea_tab("üíæ Database & Backup")
            ttk.Label(tab4, text="‚Ä¢ Anni Storico: Periodo di conservazione dati (2-15 anni).", wraplength=930).pack(anchor="w", pady=2)
            ttk.Label(tab4, text="‚Ä¢ Max Copie Backup: Numero di file backup mantenuti (1-10).", wraplength=930).pack(anchor="w", pady=2)
            footer_frame = ttk.Frame(main_container)
            footer_frame.pack(fill="x", side="bottom")
            ttk.Separator(footer_frame, orient='horizontal').pack(fill="x", pady=5)
            ttk.Label(footer_frame, text="Tasto Rapido: Premi [ESC] per chiudere.", font=("Arial", 9, "italic"), foreground="#D35400").pack(side="left")
            ttk.Button(footer_frame, text="‚ùå Chiudi", command=help_window.destroy, style="Giallo.TButton").pack(side="right")
            help_window.update_idletasks()
            c_x = config_window.winfo_rootx() + (config_window.winfo_width() // 2) - (fixed_width // 2)
            c_y = config_window.winfo_rooty() + (config_window.winfo_height() // 2) - (fixed_height // 2)
            help_window.geometry(f"{fixed_width}x{fixed_height}+{c_x}+{c_y}")
            help_window.deiconify()
            
        row_counter = 0
        create_combobox(main_frame, "Tema UI (Chiaro/Materiale):", self.var_thema, ["Chiaro", "Material"], row_counter); row_counter += 1
        ttk.Separator(main_frame, orient='horizontal').grid(row=row_counter, column=0, columnspan=3, sticky="ew", pady=5)
        row_counter += 1
        create_checkbutton(main_frame, "Abilita Flusso Login/Iconizza Automatica:", self.var_auto_login, row_counter); row_counter += 1
        create_checkbutton(main_frame, "Attiva SmartCat (Suggerimento Categorie):", self.var_smartcat_enabled, row_counter); row_counter += 1
        create_checkbutton(main_frame, "Aggiorna Data Movimento al Ripristino Finestra:", self.var_ico_set_date, row_counter); row_counter += 1
        create_checkbutton(main_frame, "Carica Posizione Finestra Salvata:", self.var_load_geometry, row_counter); row_counter += 1
        create_checkbutton(main_frame, "Abilita Tooltips su Calendario (Dettaglio spese):", self.var_cal_tooltips, row_counter); row_counter += 1
        create_checkbutton(main_frame, "Abilita Web Server all'avvio:", self.var_webserver_enabled, row_counter); row_counter += 1
        create_entry(main_frame, "Porta Web Server (8080 default):", self.var_port, row_counter); row_counter += 1
        create_entry(main_frame, "Link Banca (URL rapido):", self.var_bank_link, row_counter); row_counter += 1
        ttk.Separator(main_frame, orient='horizontal').grid(row=row_counter, column=0, columnspan=3, sticky="ew", pady=5)
        row_counter += 1
        create_checkbutton(main_frame, "Avvisi Bloccanti (Richiedono Interazione):", self.var_use_wait_window, row_counter); row_counter += 1
        create_slider_row(
            main_frame,
            "Timer  Auto-Chiusura Avvisi (5-60 secondi):", 
            5, 60, 
            self.var_warn_timeout_sec, 
            update_warn_timeout_label, 
            warn_timeout_label, 
            row_counter
        )
        row_counter += 1
        ttk.Separator(main_frame, orient='horizontal').grid(row=row_counter, column=0, columnspan=3, sticky="ew", pady=5)
        row_counter += 1
        create_checkbutton(main_frame, "Iconizza App in caso di Inattivit√†:", self.var_iconizza_inattivita, row_counter); row_counter += 1
        create_slider_row(
            main_frame,
            "Timeout Inattivit√† (5-60 minuti):", 
            5, 60, 
            self.var_timeout_minuti, 
            update_timeout_label, 
            timeout_label, 
            row_counter
        )
        row_counter += 1
        ttk.Separator(main_frame, orient='horizontal').grid(row=row_counter, column=0, columnspan=3, sticky="ew", pady=5)
        row_counter += 1
        create_checkbutton(main_frame, "Attiva Promemoria Mensile Categorie Mancanti:", self.var_recurring_reminder, row_counter); row_counter += 1
        create_slider_row(
            main_frame,
            "Soglia Giorni Anticipo Promemoria (1-10 giorni):", 
            1, 10, 
            self.var_soglia_ricorrenti, 
            update_soglia_ricorrenti_label, 
            soglia_ricorrenti_label, 
            row_counter
        )
        row_counter += 1
        ttk.Separator(main_frame, orient='horizontal').grid(row=row_counter, column=0, columnspan=3, sticky="ew", pady=5)
        row_counter += 1
        create_checkbutton(main_frame, "Abilita Carosello Statistiche:", self.var_carosello_enabled, row_counter); row_counter += 1
        create_slider_row(
            main_frame,
            "Intervallo Carosello (5-30 secondi):", 
            5, 30, 
            self.var_carosello_intervallo_sec, 
            update_carosello_intervallo_label, 
            carosello_intervallo_label, 
            row_counter
        )
        row_counter += 1
        ttk.Separator(main_frame, orient='horizontal').grid(row=row_counter, column=0, columnspan=3, sticky="ew", pady=5)
        row_counter += 1
        create_slider_row(
            main_frame,
            "Anni di Storico Dati (periodo di conservazione - 2-15 anni):", 
            2, 15, 
            self.var_anni_da_mantenere, 
            update_anni_label, 
            anni_label, 
            row_counter
        )
        row_counter += 1
        create_slider_row(
            main_frame,
            "Max Copie Backup da Mantenere (1-10):", 
            1, 10, 
            self.var_max_backup, 
            update_max_backup_label, 
            max_backup_label, 
            row_counter
        )
        row_counter += 1
        ttk.Separator(main_frame, orient='horizontal').grid(row=row_counter, column=0, columnspan=3, sticky="ew", pady=5)
        row_counter += 1
        button_frame = ttk.Frame(main_frame)
        button_frame.grid(row=row_counter, column=0, columnspan=3, pady=5, sticky="ew")
        button_frame.columnconfigure(0, weight=1)
        button_frame.columnconfigure(1, weight=1)
        button_frame.columnconfigure(2, weight=1)
        button_frame.columnconfigure(3, weight=1)
        save_button = ttk.Button(button_frame, text="üíæ Salva Configurazione", command=salva_e_chiudi, style="Verde.TButton")
        save_button.grid(row=0, column=0, padx=(0, 10), sticky="e")
        defaults_button = ttk.Button(button_frame, text="‚Ü©Ô∏è Defaults", command=reset_defaults, style="Rosso.TButton")
        defaults_button.grid(row=0, column=1, padx=5)
        close_button = ttk.Button(button_frame, text="‚ùå Chiudi", command=chiudi_config, style="Giallo.TButton")
        close_button.grid(row=0, column=2, padx=(10, 0), sticky="w")
        help_button = ttk.Button(button_frame, text="‚ùì", command=mostra_help_configurazione, style="Giallo.TButton", width=3)
        help_button.grid(row=0, column=3, padx=5)
        config_window.protocol("WM_DELETE_WINDOW", chiudi_config)
        config_window.bind_all("<Escape>", chiudi_config)
        row_counter += 1
        config_window.withdraw()
        config_window.minsize(700, 580) 
        config_window.update_idletasks()
        width = config_window.winfo_width()
        height = config_window.winfo_height()
        if width < 700: width = 700
        if height < 580: height = 580 
        screen_w = self.winfo_screenwidth()
        screen_h = self.winfo_screenheight()
        center_x = (screen_w // 2) - (width // 2)
        center_y = (screen_h // 2) - (height // 2)
        config_window.geometry(f"{width}x{height}+{center_x}+{center_y}")
        config_window.deiconify()
        config_window.lift()
        self.wait_window(config_window)

    # Implementazione di Effetti di Lampeggio Ricorsivo per Widget Tkinter
    def start_blinking(self, label):
        if hasattr(label, "_blinking_timer_id"):
            self.after_cancel(label._blinking_timer_id)
        label._is_blinking_on = True 
        label.state(['!disabled']) 
        self._blink_recursive(label)
    def _blink_recursive(self, label):
        try:
            label.winfo_exists()
        except:
            return
        if not hasattr(label, "_is_blinking_on"):
             label._is_blinking_on = True 
        label._is_blinking_on = not label._is_blinking_on
        if label._is_blinking_on:
            label.state(['!disabled'])
        else:
            label.state(['disabled'])
        try:
            interval = self.blinking_interval
            timer_id = self.after(interval, lambda: self._blink_recursive(label))
            label._blinking_timer_id = timer_id
        except Exception:
            print("Errore nel scheduling del timer. Controllare self.blinking_interval.")
            pass
    def stop_blinking(self, label):
        if hasattr(label, "_blinking_timer_id"):
            try:
                self.after_cancel(label._blinking_timer_id)
            except ValueError:
                pass 
            del label._blinking_timer_id
        try:
            label.state(['disabled'])
        except Exception:
            pass
        if hasattr(label, "_is_blinking_on"):
            del label._is_blinking_on
    def toggle_blinking(self, label):
        if hasattr(label, "_blinking_timer_id"):
            self.stop_blinking(label)
        else:
            self.start_blinking(label)      

# Gestione dei Backup Incrementali con Rotazione (Limiti Massimi)
def backup_incrementale(file_path, cartella_backup="backup", max_backup=MAX_BACKUP):
    if not os.path.exists(file_path):
        return
    os.makedirs(cartella_backup, exist_ok=True)
    nome_completo = os.path.basename(file_path)
    data = datetime.datetime.today().strftime("%d-%m-%Y") 
    backup_file_name = f"{data}-{nome_completo}"
    backup_file_path = os.path.join(cartella_backup, backup_file_name)
    shutil.copy2(file_path, backup_file_path)
    stringa_filtro = f"-{nome_completo}"
    files_to_check = [f for f in os.listdir(cartella_backup) if f.endswith(stringa_filtro)]
    if not files_to_check:
        return
    def get_sort_key(filename):
        date_str = filename[:10] 
        return datetime.datetime.strptime(date_str, "%d-%m-%Y")
    files_ordinati = sorted(
        files_to_check,
        key=get_sort_key,
        reverse=True 
    )
    files_da_cancellare = files_ordinati[max_backup:]
    if files_da_cancellare:
        for f in files_da_cancellare:
            os.remove(os.path.join(cartella_backup, f))

# Installazione Automatica e Gestione Condizionale delle Dipendenze Python
def install_tkcalendar():
    package_name = "tkcalendar"
    try:
        from tkcalendar import Calendar, DateEntry
    except ImportError:
        print(f"{package_name} non √® installato. Installazione in corso...")
        subprocess.run([sys.executable, "-m", "pip", "install", package_name], check=True)
        print(f"{package_name} installato con successo!")
        from tkcalendar import Calendar, DateEntry
    return Calendar, DateEntry

def install_genai():
    try:
        from google import genai
        return genai
    except ImportError:
        print("Il modulo 'google-genai' non √® stato trovato. Installazione in corso...")
        try:
            subprocess.run([sys.executable, "-m", "pip", "install", "google-genai"], check=True)
            print("'google-genai' installato con successo.")
            from google import genai
            return genai
        except subprocess.CalledProcessError as e:
            print(f"ERRORE: Installazione di 'google-genai' fallita. Dettagli: {e}")
            sys.exit(1)
        except ImportError:
            print("ERRORE: Impossibile importare 'google-genai' anche dopo l'installazione.")
            sys.exit(1)
genai_client = install_genai()
from google.genai.errors import APIError

def install_requests():
    try:
        import requests
    except ImportError:
        print("requests non trovato. Installazione in corso...")
        subprocess.run([sys.executable, "-m", "pip", "install", "requests"], check=True)
        import requests
    return requests
requests = install_requests()
from requests.exceptions import ConnectionError, RequestException

def install_segno():
    try:
        import segno
    except ImportError:
        print("segno non trovato. Installazione in corso...")
        subprocess.run([sys.executable, "-m", "pip", "install", "segno"], check=True)
        import segno
    return segno
segno = install_segno()

def install_win32_libraries():
    if platform.system() != "Windows":
        print("Sistema operativo non Windows: installazione non necessaria.")
        return None, None, None
    try:
        import win32print # type: ignore
        import win32api   # type: ignore
        import win32con   # type: ignore
    except ImportError:
        print("Moduli win32 non trovati. Installazione di pywin32 in corso...")
        subprocess.run([sys.executable, "-m", "pip", "install", "pywin32"], check=True)
        print("pywin32 installato con successo.")

# Controllo dell'Istanza Unica (Single Instance Check) Tramite Mutex o File Lock
def check_single_instance():
    global _lock_file_handle
    global _mutex_handle
    _lock_file_handle = None 
    _mutex_handle = None
    if sys.platform.startswith("win"):
        import ctypes
        LAST_ERROR_ALREADY_EXISTS = 183
        mutex_name = "Global\\CasaFacileWeb_Mutex_34A5B6C7"
        mutex = ctypes.windll.kernel32.CreateMutexW(None, True, mutex_name)
        if ctypes.windll.kernel32.GetLastError() == LAST_ERROR_ALREADY_EXISTS:
            print("Un'altra istanza √® gi√† in esecuzione! (Windows)")
            show_warning_popup()
            sys.exit(1)
        _mutex_handle = mutex
        print("Avvio riuscito. Acquisito il Mutex (Windows).")
        return
    else:
        import fcntl
        lock_dir = os.path.dirname(os.path.abspath(sys.argv[0]))
        lock_file_path = os.path.join(lock_dir, 'casa_facile.lock')
        try:
            lock_file = open(lock_file_path, 'a')
            fcntl.lockf(lock_file.fileno(), fcntl.LOCK_EX | fcntl.LOCK_NB)
            _lock_file_handle = lock_file
            lock_file.write(f"{os.getpid()}\n") 
            lock_file.flush()
            print("Avvio riuscito. Acquisito il lock (Linux/Unix).")
            return
        except BlockingIOError:
            print("Un'altra istanza √® gi√† in esecuzione! (Linux/Unix)")
            show_warning_popup()
            sys.exit(1)
        except Exception as e:
            print(f"Errore critico durante la creazione del lock: {e}")
            sys.exit(1)

# Visualizzazione Popup di Avviso Istanza Duplicata (Splash Screen Temporaneo)
def show_warning_popup():
    splash = tk.Tk()
    splash.overrideredirect(True)
    width, height = 360, 110
    screen_width = splash.winfo_screenwidth()
    screen_height = splash.winfo_screenheight()
    x = (screen_width // 2) - (width // 2)
    y = (screen_height // 2) - (height // 2)
    splash.geometry(f"{width}x{height}+{x}+{y}")
    splash.configure(bg="white")
    label = tk.Label(
        splash,
        text= f"{NAME}\nApp gi√† in esecuzione!",
        font=("Arial", 12, "bold"),
        fg="white",
        bg="#b22222",
        justify="center"
    )
    label.pack(expand=True, fill="both")  
    splash.after(3000, splash.destroy)
    splash.mainloop()
    return splash

# Lettura e Inizializzazione della Configurazione Globale
def leggi_configurazione_globale():
    final_config = DEFAULT_CONFIG.copy()
    if not os.path.exists(CONFIG_FILE):
        try:
            with open(CONFIG_FILE, 'w') as f:
                json.dump(final_config, f, indent=4)
            print("üíæ Creato file config.json di default.")
            return final_config
        except Exception:
            return final_config
    try:
        with open(CONFIG_FILE, 'r') as f:
            config_data = json.load(f)
            final_config = {**final_config, **config_data}
    except Exception:
        print("‚ö†Ô∏è Errore di lettura config.json. Uso i default.")
    return final_config


if __name__ == "__main__":

    # Soppressione Temporanea degli Errori Standard in Console
    try:
        sys.stderr = open(os.devnull, 'w')
    except Exception:
        pass
    # Manuale degli Argomenti da Riga di Comando (CLI)
    print(f"""
    üìò {NAME} ‚Äî Guida agli argomenti da riga di comando
    
    ‚ñ∂ auto       Avvio automatico con impostazione password:

      ‚Ä¢ auto <password>   ‚Üí usa la password specificata
      ‚Ä¢ auto ""           ‚Üí imposta una password vuota
      ‚Ä¢ auto              ‚Üí usa la password predefinita (es. "return")

    ‚ñ∂ noweb      Avvia senza interfaccia web (disabilita server locale)

    Esempi:
    {NAME}.pyw auto 1234     # imposta password ‚Äú1234‚Äù
    {NAME}.pyw auto ""       # password vuota
    {NAME}.pyw auto          # password automatica (definita da utente)
    {NAME}.pyw noweb         # GUI senza web server
    {NAME}.pyw auto "" noweb # password vuota + niente web

    """)
    
    # Sequenza di Inizializzazione e Controllo di Avvio
    Calendar, DateEntry = install_tkcalendar()
    install_segno()
    install_genai()
    install_requests()
    install_win32_libraries()
    check_single_instance()
    print("Programma avviato.")

    # Inizializzazione Struttura delle Directory e dei File di Sistema
    if not os.path.exists(EXPORT_FILES):
        os.makedirs(EXPORT_FILES)
    if not os.path.exists(DB_DIR):
        os.makedirs(DB_DIR)
    if not os.path.exists(EXP_DB):
        os.makedirs(EXP_DB)
    if not os.path.exists(UTENZE_DB):
        with open(UTENZE_DB, "w") as file:
            file.write("")  
    
    # Caricamento Finale dei Parametri di Configurazione Globali
    app_config_globale = leggi_configurazione_globale()
    AUTO_ICONIZE_STARTUP = app_config_globale.get("enable_auto_login_flow", True)
    ICONIZZA_INATTIVITA = app_config_globale.get("iconizza_inattivita", True)
    TIMEOUT_INATTIVITA_MS = app_config_globale.get("inactivity_timeout_ms", 1200000)
    SALVA_GEOMETRIA_INIZIALE = app_config_globale.get("load_saved_geometry", False)
    ABILITA_WEBSERVER = app_config_globale.get("webserver_enabled", True)
    PORTA = app_config_globale.get("webserver_port", 8080)
    ANNI_DA_MANTENERE = app_config_globale.get("anni_da_mantenere", 10)
    ICO_SET_DATE = app_config_globale.get("ico_set_date", True)
    CHECK_MESE = app_config_globale.get("enable_recurring_reminder", True)
    SOGLIA_GIORNI_RICORRENTI = app_config_globale.get("soglia_giorni_ricorrenti", 5)
    MAX_BACKUP = app_config_globale.get("max_backup", 10)
    SMARTCAT = app_config_globale.get("smartcat_enabled", True)
    USE_WAIT_WINDOW = app_config_globale.get("use_wait_window", False)
    WARN_TIMEOUT = app_config_globale.get("warn_timeout_ms", 20000)
    LINK_BANCA = app_config_globale.get("bank_link", "")
    THEMA = app_config_globale.get("thema", "MATERIAL")
    CAROSELLO = app_config_globale.get("carosello_enabled", True)
    CAROSELLO_INTERVALLO = app_config_globale.get("carosello_intervallo", 10000)
    CAL_TOOLTIPS = app_config_globale.get("cal_tooltips_enabled", False)
    
    # Lancio dell'Applicazione Principale e Ciclo di Eventi (Main Loop)
    app = GestioneSpese()
    app.mainloop()

